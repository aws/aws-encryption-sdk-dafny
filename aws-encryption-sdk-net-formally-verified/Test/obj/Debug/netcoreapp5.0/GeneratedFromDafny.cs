// Dafny program the_program compiled into C#
// To recompile, you will need the libraries
//     System.Runtime.Numerics.dll System.Collections.Immutable.dll
// but the 'dotnet' tool in net5.0 should pick those up automatically.
// Optionally, you may want to include compiler switches like
//     /debug /nowarn:162,164,168,183,219,436,1717,1718

using System;
using System.Numerics;
[assembly: DafnyAssembly.DafnySourceAttribute(@"
// Dafny 3.2.0.30713
// Command Line Options: /out:obj/Debug/netcoreapp5.0/GeneratedFromDafny.cs ../../src/Crypto/AESEncryption.dfy ../../src/Crypto/Datatypes.dfy ../../src/Crypto/Digest.dfy ../../src/Crypto/EncryptionSuites.dfy ../../src/Crypto/HKDF/HKDF.dfy ../../src/Crypto/HKDF/HMAC.dfy ../../src/Crypto/KeyDerivationAlgorithms.dfy ../../src/Crypto/Random.dfy ../../src/Crypto/RSAEncryption.dfy ../../src/Crypto/Signature.dfy ../../src/Generated/Aws.dfy ../../src/Generated/AwsCryptographicMaterialProviders.dfy ../../src/Generated/AwsEncryptionSdk.dfy ../../src/KMS/AmazonKeyManagementService.dfy ../../src/KMS/AwsKmsArnParsing.dfy ../../src/KMS/KMSUtils.dfy ../../src/SDK/AlgorithmSuite.dfy ../../src/SDK/AwsCryptographicMaterialProviders.dfy ../../src/SDK/AwsEncryptionSdk.dfy ../../src/SDK/CMM/DefaultCMM.dfy ../../src/SDK/Deserialize.dfy ../../src/SDK/EncryptDecrypt.dfy ../../src/SDK/EncryptionContext.dfy ../../src/SDK/Keyring/AwsKms/AwsKmsMrkAreUnique.dfy ../../src/SDK/Keyring/AwsKms/AwsKmsMrkAwareSymmetricKeyring.dfy ../../src/SDK/Keyring/AwsKms/AwsKmsMrkMatchForDecrypt.dfy ../../src/SDK/Keyring/AwsKms/Constants.dfy ../../src/SDK/Keyring/Defs.dfy ../../src/SDK/Keyring/RawAESKeyring.dfy ../../src/SDK/Materials.dfy ../../src/SDK/MessageBody.dfy ../../src/SDK/MessageHeader.dfy ../../src/SDK/Serialize.dfy ../../src/StandardLibrary/Actions.dfy ../../src/StandardLibrary/Base64.dfy ../../src/StandardLibrary/Base64Lemmas.dfy ../../src/StandardLibrary/StandardLibrary.dfy ../../src/StandardLibrary/UInt.dfy ../../src/Util/Sets.dfy ../../src/Util/Sorting.dfy ../../src/Util/Streams.dfy ../../src/Util/Time.dfy ../../src/Util/UTF8.dfy ../../test/Crypto/Digest.dfy ../../test/Crypto/Signature.dfy ../../test/hkdf/HKDF.dfy ../../test/SDK/Keyring/RawAESKeyring.dfy ../../test/SDK/MessageHeader.dfy ../../test/SDK/POCEncryptDecrypt.dfy ../../test/SDK/Serialize.dfy ../../test/StandardLibrary/Base64.dfy ../../test/StandardLibrary/StandardLibrary.dfy ../../test/StandardLibrary/UInt.dfy ../../test/Util/Sets.dfy ../../test/Util/Streams.dfy ../../test/Util/TestUtils.dfy ../../test/Util/UTF8.dfy /compile:0 /spillTargetCode:3 /noVerify
// the_program


module {:extern ""AESEncryption""} AESEncryption {

  import EncryptionSuites = EncryptionSuites

  import opened Wrappers = Wrappers

  import opened UInt = StandardLibrary.UInt

  export
    provides AESDecrypt, AESEncrypt, AESDecryptExtern, AESEncryptExtern, EncryptionSuites, Wrappers, UInt, PlaintextDecryptedWithAAD, EncryptionOutputEncryptedWithAAD, CiphertextGeneratedWithPlaintext, EncryptedWithKey, DecryptedWithKey
    reveals EncryptionOutput

  datatype EncryptionOutput = EncryptionOutput(cipherText: seq<uint8>, authTag: seq<uint8>)

  predicate {:axiom} PlaintextDecryptedWithAAD(plaintext: seq<uint8>, aad: seq<uint8>)
    decreases plaintext, aad

  predicate {:axiom} EncryptionOutputEncryptedWithAAD(ciphertext: EncryptionOutput, aad: seq<uint8>)
    decreases ciphertext, aad

  predicate {:axiom} CiphertextGeneratedWithPlaintext(ciphertext: seq<uint8>, plaintext: seq<uint8>)
    decreases ciphertext, plaintext

  predicate {:axiom} EncryptedWithKey(ciphertext: seq<uint8>, key: seq<uint8>)
    decreases ciphertext, key

  predicate {:axiom} DecryptedWithKey(key: seq<uint8>, plaintext: seq<uint8>)
    decreases key, plaintext

  function method EncryptionOutputFromByteSeq(s: seq<uint8>, encAlg: EncryptionSuites.EncryptionSuite): (encArt: EncryptionOutput)
    requires encAlg.Valid()
    requires |s| >= encAlg.tagLen as int
    ensures |encArt.cipherText + encArt.authTag| == |s|
    ensures |encArt.authTag| == encAlg.tagLen as int
    decreases s, encAlg
  {
    EncryptionOutput(s[..|s| - encAlg.tagLen as int], s[|s| - encAlg.tagLen as int..])
  }

  method {:extern ""AESEncryption.AES_GCM"", ""AESEncryptExtern""} AESEncryptExtern(encAlg: EncryptionSuites.EncryptionSuite, iv: seq<uint8>, key: seq<uint8>, msg: seq<uint8>, aad: seq<uint8>)
      returns (res: Result<EncryptionOutput, string>)
    requires encAlg.Valid()
    requires encAlg.alg.AES?
    requires encAlg.alg.mode.GCM?
    requires |iv| == encAlg.ivLen as int
    requires |key| == encAlg.keyLen as int
    ensures res.Success? ==> EncryptionOutputEncryptedWithAAD(res.value, aad)
    ensures res.Success? ==> CiphertextGeneratedWithPlaintext(res.value.cipherText, msg)
    ensures res.Success? ==> EncryptedWithKey(res.value.cipherText, key)
    decreases encAlg, iv, key, msg, aad

  method AESEncrypt(encAlg: EncryptionSuites.EncryptionSuite, iv: seq<uint8>, key: seq<uint8>, msg: seq<uint8>, aad: seq<uint8>)
      returns (res: Result<EncryptionOutput, string>)
    requires encAlg.Valid()
    requires encAlg.alg.AES?
    requires encAlg.alg.mode.GCM?
    requires |iv| == encAlg.ivLen as int
    requires |key| == encAlg.keyLen as int
    ensures res.Success? ==> |res.value.cipherText| == |msg| && |res.value.authTag| == encAlg.tagLen as int
    ensures res.Success? ==> EncryptionOutputEncryptedWithAAD(res.value, aad)
    ensures res.Success? ==> CiphertextGeneratedWithPlaintext(res.value.cipherText, msg)
    ensures res.Success? ==> EncryptedWithKey(res.value.cipherText, key)
    decreases encAlg, iv, key, msg, aad
  {
    res := AESEncryptExtern(encAlg, iv, key, msg, aad);
    if res.Success? && |res.value.cipherText| != |msg| {
      res := Failure(""AESEncrypt did not return cipherText of expected length"");
    }
    if res.Success? && |res.value.authTag| != encAlg.tagLen as int {
      res := Failure(""AESEncryption did not return valid tag"");
    }
  }

  method {:extern ""AESEncryption.AES_GCM"", ""AESDecryptExtern""} AESDecryptExtern(encAlg: EncryptionSuites.EncryptionSuite, key: seq<uint8>, cipherTxt: seq<uint8>, authTag: seq<uint8>, iv: seq<uint8>, aad: seq<uint8>)
      returns (res: Result<seq<uint8>, string>)
    requires encAlg.Valid()
    requires encAlg.alg.AES?
    requires encAlg.alg.mode.GCM?
    requires |key| == encAlg.keyLen as int
    requires |iv| == encAlg.ivLen as int
    requires |authTag| == encAlg.tagLen as int
    ensures res.Success? ==> PlaintextDecryptedWithAAD(res.value, aad)
    ensures res.Success? ==> CiphertextGeneratedWithPlaintext(cipherTxt, res.value)
    ensures res.Success? ==> DecryptedWithKey(key, res.value)
    decreases encAlg, key, cipherTxt, authTag, iv, aad

  method AESDecrypt(encAlg: EncryptionSuites.EncryptionSuite, key: seq<uint8>, cipherTxt: seq<uint8>, authTag: seq<uint8>, iv: seq<uint8>, aad: seq<uint8>)
      returns (res: Result<seq<uint8>, string>)
    requires encAlg.Valid()
    requires encAlg.alg.AES?
    requires encAlg.alg.mode.GCM?
    requires |key| == encAlg.keyLen as int
    requires |iv| == encAlg.ivLen as int
    requires |authTag| == encAlg.tagLen as int
    ensures res.Success? ==> |res.value| == |cipherTxt|
    ensures res.Success? ==> PlaintextDecryptedWithAAD(res.value, aad)
    ensures res.Success? ==> CiphertextGeneratedWithPlaintext(cipherTxt, res.value)
    ensures res.Success? ==> DecryptedWithKey(key, res.value)
    decreases encAlg, key, cipherTxt, authTag, iv, aad
  {
    res := AESDecryptExtern(encAlg, key, cipherTxt, authTag, iv, aad);
    if res.Success? && |cipherTxt| != |res.value| {
      res := Failure(""AESDecrypt did not return plaintext of expected length"");
    }
  }
}

module CryptoDatatypes {
  datatype DigestAlgorithm = SHA_512
}

module Digest {

  import opened Wrappers = Wrappers

  import opened UInt = StandardLibrary.UInt

  import CryptoDatatypes = CryptoDatatypes

  import ExternDigest = ExternDigest
  function method Length(alg: CryptoDatatypes.DigestAlgorithm): nat
    decreases alg
  {
    match alg
    case SHA_512() =>
      64
  }

  method Digest(alg: CryptoDatatypes.DigestAlgorithm, msg: seq<uint8>) returns (res: Result<seq<uint8>, string>)
    ensures res.Success? ==> |res.value| == Length(alg)
    decreases alg, msg
  {
    var result := ExternDigest.Digest(alg, msg);
    if result.Success? && |result.value| != Length(alg) {
      return Failure(""Incorrect length digest from ExternDigest."");
    }
    return result;
  }
}

module {:extern ""ExternDigest""} ExternDigest {

  import opened Wrappers = Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened CryptoDatatypes = CryptoDatatypes
  method {:extern} Digest(alg: CryptoDatatypes.DigestAlgorithm, msg: seq<uint8>) returns (res: Result<seq<uint8>, string>)
    decreases alg, msg
}

module {:extern ""EncryptionSuites""} EncryptionSuites {

  import opened UInt = StandardLibrary.UInt
  datatype EncryptionAlgorithm = AES(mode: AESMode)

  datatype AESMode = GCM

  datatype EncryptionSuite = EncryptionSuite(alg: EncryptionAlgorithm, keyLen: uint8, tagLen: uint8, ivLen: uint8) {
    predicate method Valid()
      decreases this
    {
      match alg
      case AES(mode) =>
        keyLen as int in AES_CIPHER_KEY_LENGTHS &&
        tagLen == AES_TAG_LEN &&
        ivLen == AES_IV_LEN &&
        mode == GCM
    }
  }

  const AES_MAX_KEY_LEN := 32
  const AES_CIPHER_KEY_LENGTHS := {32, 24, 16}
  const AES_TAG_LEN := 16 as uint8
  const AES_IV_LEN := 12 as uint8
  const AES_GCM_128 := EncryptionSuite(AES(GCM), 16, AES_TAG_LEN, AES_IV_LEN)
  const AES_GCM_192 := EncryptionSuite(AES(GCM), 24, AES_TAG_LEN, AES_IV_LEN)
  const AES_GCM_256 := EncryptionSuite(AES(GCM), 32, AES_TAG_LEN, AES_IV_LEN)
}

module HKDF {

  import opened HMAC = HMAC

  import opened KeyDerivationAlgorithms = KeyDerivationAlgorithms

  import opened Wrappers = Wrappers

  import opened UInt = StandardLibrary.UInt
  function method GetHMACDigestFromHKDFAlgorithm(algorithm: HKDFAlgorithms): Digests
    decreases algorithm
  {
    match algorithm
    case HKDF_WITH_SHA_256() =>
      SHA_256
    case HKDF_WITH_SHA_384() =>
      SHA_384
  }

  method Extract(hmac: HMac, salt: seq<uint8>, ikm: seq<uint8>, ghost digest: Digests)
      returns (prk: seq<uint8>)
    requires hmac.GetDigest() == digest
    requires |salt| != 0
    requires |ikm| < INT32_MAX_LIMIT
    modifies hmac
    ensures GetHashLength(hmac.GetDigest()) == |prk|
    ensures hmac.GetKey() == salt
    ensures hmac.GetDigest() == digest
    decreases hmac, salt, ikm, digest
  {
    hmac.Init(salt);
    hmac.Update(ikm);
    assert hmac.GetInputSoFar() == ikm;
    prk := hmac.GetResult();
    return prk;
  }

  predicate T(hmac: HMac, info: seq<uint8>, n: nat, res: seq<uint8>)
    requires 0 <= n < 256
    decreases n
  {
    if n == 0 then
      [] == res
    else
      ghost var nMinusOne: int := n - 1; exists prev1: seq<uint8>, prev2: seq<uint8> :: T(hmac, info, nMinusOne, prev1) && Ti(hmac, info, n, prev2) && prev1 + prev2 == res
  }

  predicate Ti(hmac: HMac, info: seq<uint8>, n: nat, res: seq<uint8>)
    requires 0 <= n < 256
    decreases n, 1
  {
    if n == 0 then
      res == []
    else
      exists prev: seq<uint8> :: PreTi(hmac, info, n, prev) && hmac.HashSignature(prev, res)
  }

  predicate PreTi(hmac: HMac, info: seq<uint8>, n: nat, res: seq<uint8>)
    requires 1 <= n < 256
    decreases n, 0
  {
    ghost var nMinusOne: int := n - 1;
    exists prev: seq<uint8> | Ti(hmac, info, nMinusOne, prev) :: 
      res == prev + info + [n as uint8]
  }

  method Expand(hmac: HMac, prk: seq<uint8>, info: seq<uint8>, expectedLength: int, digest: Digests, ghost salt: seq<uint8>)
      returns (okm: seq<uint8>, ghost okmUnabridged: seq<uint8>)
    requires hmac.GetDigest() == digest
    requires 1 <= expectedLength <= 255 * GetHashLength(hmac.GetDigest())
    requires |salt| != 0
    requires hmac.GetKey() == salt
    requires |info| < INT32_MAX_LIMIT
    requires GetHashLength(hmac.GetDigest()) == |prk|
    modifies hmac
    ensures |okm| == expectedLength
    ensures hmac.GetKey() == prk
    ensures var n: int := (GetHashLength(digest) + expectedLength - 1) / GetHashLength(digest); T(hmac, info, n, okmUnabridged) && (|okmUnabridged| <= expectedLength ==> okm == okmUnabridged) && (expectedLength < |okmUnabridged| ==> okm == okmUnabridged[..expectedLength])
    decreases hmac, prk, info, expectedLength, digest, salt
  {
    var hashLength := GetHashLength(digest);
    var n := (hashLength + expectedLength - 1) / hashLength;
    assert 0 <= n < 256;
    hmac.Init(prk);
    var t_prev := [];
    var t_n := t_prev;
    var i := 1;
    while i <= n
      invariant 1 <= i <= n + 1
      invariant |t_prev| == if i == 1 then 0 else hashLength
      invariant hashLength == |prk|
      invariant |t_n| == (i - 1) * hashLength
      invariant hmac.GetKey() == prk
      invariant hmac.GetDigest() == digest
      invariant hmac.GetInputSoFar() == []
      invariant T(hmac, info, i - 1, t_n)
      invariant Ti(hmac, info, i - 1, t_prev)
      decreases n - i
    {
      hmac.Update(t_prev);
      hmac.Update(info);
      hmac.Update([i as uint8]);
      assert hmac.GetInputSoFar() == t_prev + info + [i as uint8];
      t_prev := hmac.GetResult();
      assert Ti(hmac, info, i, t_prev);
      t_n := t_n + t_prev;
      i := i + 1;
      assert T(hmac, info, i - 1, t_n);
    }
    okm := t_n;
    okmUnabridged := okm;
    assert T(hmac, info, n, okmUnabridged);
    if expectedLength < |okm| {
      okm := okm[..expectedLength];
    }
  }

  method Hkdf(algorithm: HKDFAlgorithms, salt: Option<seq<uint8>>, ikm: seq<uint8>, info: seq<uint8>, L: int)
      returns (okm: seq<uint8>)
    requires 0 <= L <= 255 * GetHashLength(GetHMACDigestFromHKDFAlgorithm(algorithm))
    requires salt.None? || |salt.value| != 0
    requires |info| < INT32_MAX_LIMIT
    requires |ikm| < INT32_MAX_LIMIT
    ensures |okm| == L
    decreases algorithm, salt, ikm, info, L
  {
    if L == 0 {
      return [];
    }
    var digest := GetHMACDigestFromHKDFAlgorithm(algorithm);
    var hmac := new HMac(digest);
    var hashLength := GetHashLength(digest);
    var nonEmptySalt: seq<uint8>;
    match salt {
      case {:split false} None() =>
        nonEmptySalt := StandardLibrary.Fill(0, hashLength);
      case {:split false} Some(s) =>
        nonEmptySalt := s;
    }
    var prk := Extract(hmac, nonEmptySalt, ikm, digest);
    ghost var okmUnabridged;
    okm, okmUnabridged := Expand(hmac, prk, info, L, digest, nonEmptySalt);
  }
}

module {:extern ""HMAC""} HMAC {

  import opened KeyDerivationAlgorithms = KeyDerivationAlgorithms

  import opened StandardLibrary = StandardLibrary

  import opened UInt = StandardLibrary.UInt
  datatype {:extern ""Digests""} Digests = SHA_256 | SHA_384

  class {:extern ""HMac""} HMac {
    function {:extern} GetKey(): seq<uint8>
      reads this
      decreases {this}

    function {:extern} GetDigest(): Digests
      reads this
      decreases {this}

    function {:extern} GetInputSoFar(): seq<uint8>
      reads this
      decreases {this}

    constructor {:extern} (digest: Digests)
      ensures this.GetDigest() == digest
      ensures this.GetInputSoFar() == []
      decreases digest

    method {:extern ""Init""} Init(key: seq<uint8>)
      modifies this
      ensures this.GetKey() == key
      ensures this.GetDigest() == old(this.GetDigest())
      ensures this.GetInputSoFar() == []
      decreases key

    method {:extern ""BlockUpdate""} Update(input: seq<uint8>)
      requires |this.GetKey()| > 0
      requires |input| < INT32_MAX_LIMIT
      modifies this
      ensures this.GetInputSoFar() == old(this.GetInputSoFar()) + input
      ensures this.GetDigest() == old(this.GetDigest())
      ensures this.GetKey() == old(this.GetKey())
      decreases input

    method {:extern ""GetResult""} GetResult() returns (s: seq<uint8>)
      requires |this.GetKey()| > 0
      modifies this
      ensures |s| == GetHashLength(this.GetDigest())
      ensures this.GetInputSoFar() == []
      ensures this.GetDigest() == old(this.GetDigest())
      ensures this.GetKey() == old(this.GetKey())
      ensures this.HashSignature(old(this.GetInputSoFar()), s)

    predicate {:axiom} HashSignature(message: seq<uint8>, s: seq<uint8>)
      decreases message, s
  }

  function method GetHashLength(digest: Digests): int
    decreases digest
  {
    match digest
    case SHA_256() =>
      32
    case SHA_384() =>
      48
  }
}

module {:extern ""KeyDerivationAlgorithms""} KeyDerivationAlgorithms {

  import opened UInt = StandardLibrary.UInt
  datatype KeyDerivationAlgorithm = HKDF_WITH_SHA_384 | HKDF_WITH_SHA_256 | IDENTITY

  type HKDFAlgorithms = a: KeyDerivationAlgorithm
    | a != KeyDerivationAlgorithm.IDENTITY
    witness KeyDerivationAlgorithm.HKDF_WITH_SHA_384

  type IdentityAlgorithm = a: KeyDerivationAlgorithm
    | a == KeyDerivationAlgorithm.IDENTITY
    witness KeyDerivationAlgorithm.IDENTITY
}

module Random {

  export
    provides GenerateBytes, Wrappers, UInt


  import opened Wrappers = Wrappers

  import opened UInt = StandardLibrary.UInt

  import ExternRandom = ExternRandom
  method GenerateBytes(i: int32) returns (res: Result<seq<uint8>, string>)
    requires 0 <= i
    ensures res.Success? ==> |res.value| == i as int
    decreases i
  {
    var result := ExternRandom.GenerateBytes(i);
    if result.Success? && |result.value| != i as int {
      return Failure(""Incorrect length from ExternRandom."");
    }
    return result;
  }
}

module {:extern ""ExternRandom""} ExternRandom {

  import opened Wrappers = Wrappers

  import opened UInt = StandardLibrary.UInt
  method {:extern} GenerateBytes(i: int32) returns (res: Result<seq<uint8>, string>)
    decreases i
}

module {:extern ""RSAEncryption""} RSAEncryption {

  import opened Wrappers = Wrappers

  import opened UInt = StandardLibrary.UInt
  datatype {:extern ""PaddingMode""} PaddingMode = PKCS1 | OAEP_SHA1 | OAEP_SHA256 | OAEP_SHA384 | OAEP_SHA512

  newtype {:nativeType ""int"", ""number""} StrengthBits = x: int
    | 81 <= x < 2147483648
    witness 81

  trait {:termination false} Key {
    ghost var Repr: set<object>
    ghost const strength: StrengthBits
    ghost const padding: PaddingMode
    const pem: seq<uint8>

    predicate Valid()
      reads this, Repr
      ensures Valid() ==> this in Repr
      decreases Repr + {this}
    {
      this in Repr &&
      |pem| > 0 &&
      GetBytes(strength) >= MinStrengthBytes(padding) &&
      PEMGeneratedWithStrength(pem, strength) &&
      PEMGeneratedWithPadding(pem, padding)
    }
  }

  class PrivateKey extends Key {
    constructor (pem: seq<uint8>, ghost strength: StrengthBits, ghost padding: PaddingMode)
      requires |pem| > 0
      requires GetBytes(strength) >= MinStrengthBytes(padding)
      requires PEMGeneratedWithStrength(pem, strength)
      requires PEMGeneratedWithPadding(pem, padding)
      ensures this.pem == pem
      ensures this.strength == strength
      ensures this.padding == padding
      ensures Valid() && fresh(Repr)
      decreases pem, strength, padding
    {
      this.pem := pem;
      this.strength := strength;
      this.padding := padding;
      Repr := {this};
    }
  }

  class PublicKey extends Key {
    constructor (pem: seq<uint8>, ghost strength: StrengthBits, ghost padding: PaddingMode)
      requires |pem| > 0
      requires GetBytes(strength) >= MinStrengthBytes(padding)
      requires PEMGeneratedWithStrength(pem, strength)
      requires PEMGeneratedWithPadding(pem, padding)
      ensures this.pem == pem
      ensures this.strength == strength
      ensures this.padding == padding
      ensures Valid() && fresh(Repr)
      decreases pem, strength, padding
    {
      this.pem := pem;
      this.strength := strength;
      this.padding := padding;
      Repr := {this};
    }
  }

  predicate {:axiom} PEMGeneratedWithStrength(pem: seq<uint8>, strength: StrengthBits)
    decreases pem, strength

  predicate {:axiom} PEMGeneratedWithPadding(pem: seq<uint8>, padding: PaddingMode)
    decreases pem, padding

  const SHA1_HASH_BYTES := 20
  const SHA256_HASH_BYTES := 32
  const SHA384_HASH_BYTES := 48
  const SHA512_HASH_BYTES := 64

  function GetBytes(bits: StrengthBits): nat
    decreases bits
  {
    (bits as nat + 7) / 8
  }

  function MinStrengthBytes(padding: PaddingMode): nat
    decreases padding
  {
    match padding {
      case PKCS1() =>
        11
      case OAEP_SHA1() =>
        2 * SHA1_HASH_BYTES + 2
      case OAEP_SHA256() =>
        2 * SHA256_HASH_BYTES + 2
      case OAEP_SHA384() =>
        2 * SHA384_HASH_BYTES + 2
      case OAEP_SHA512() =>
        2 * SHA512_HASH_BYTES + 2
    }
  }

  function MaxPlaintextBytes(padding: PaddingMode, strength: StrengthBits): nat
    requires GetBytes(strength) >= MinStrengthBytes(padding)
    decreases padding, strength
  {
    match padding {
      case PKCS1() =>
        GetBytes(strength) - 11
      case OAEP_SHA1() =>
        GetBytes(strength) - 2 * SHA1_HASH_BYTES - 2
      case OAEP_SHA256() =>
        GetBytes(strength) - 2 * SHA256_HASH_BYTES - 2
      case OAEP_SHA384() =>
        GetBytes(strength) - 2 * SHA384_HASH_BYTES - 2
      case OAEP_SHA512() =>
        GetBytes(strength) - 2 * SHA512_HASH_BYTES - 2
    }
  }

  method GenerateKeyPair(strength: StrengthBits, padding: PaddingMode)
      returns (publicKey: PublicKey, privateKey: PrivateKey)
    requires GetBytes(strength) >= MinStrengthBytes(padding)
    ensures privateKey.Valid() && fresh(privateKey.Repr)
    ensures privateKey.strength == strength
    ensures privateKey.padding == padding
    ensures publicKey.Valid() && fresh(publicKey.Repr)
    ensures publicKey.strength == strength
    ensures publicKey.padding == padding
    ensures GetBytes(publicKey.strength) >= MinStrengthBytes(publicKey.padding)
    ensures GetBytes(privateKey.strength) >= MinStrengthBytes(privateKey.padding)
    decreases strength, padding
  {
    var pemPublic, pemPrivate := GenerateKeyPairExtern(strength, padding);
    privateKey := new PrivateKey(pemPrivate, strength, padding);
    publicKey := new PublicKey(pemPublic, strength, padding);
  }

  method Decrypt(padding: PaddingMode, privateKey: PrivateKey, cipherText: seq<uint8>)
      returns (res: Result<seq<uint8>, string>)
    requires privateKey.Valid()
    requires 0 < |cipherText|
    requires padding == privateKey.padding
    ensures privateKey.Valid()
    decreases padding, privateKey, cipherText
  {
    res := DecryptExtern(padding, privateKey.pem, cipherText);
  }

  method Encrypt(padding: PaddingMode, publicKey: PublicKey, plaintextData: seq<uint8>)
      returns (res: Result<seq<uint8>, string>)
    requires publicKey.Valid()
    requires GetBytes(publicKey.strength) >= MinStrengthBytes(padding)
    requires 0 < |plaintextData|
    requires padding == publicKey.padding
    ensures publicKey.Valid()
    decreases padding, publicKey, plaintextData
  {
    res := EncryptExtern(padding, publicKey.pem, plaintextData);
  }

  method {:extern ""RSAEncryption.RSA"", ""GenerateKeyPairExtern""} GenerateKeyPairExtern(strength: StrengthBits, padding: PaddingMode)
      returns (publicKey: seq<uint8>, privateKey: seq<uint8>)
    requires GetBytes(strength) >= MinStrengthBytes(padding)
    ensures |publicKey| > 0
    ensures |privateKey| > 0
    ensures PEMGeneratedWithStrength(publicKey, strength)
    ensures PEMGeneratedWithStrength(privateKey, strength)
    ensures PEMGeneratedWithPadding(publicKey, padding)
    ensures PEMGeneratedWithPadding(privateKey, padding)
    decreases strength, padding

  method {:extern ""RSAEncryption.RSA"", ""DecryptExtern""} DecryptExtern(padding: PaddingMode, privateKey: seq<uint8>, cipherText: seq<uint8>)
      returns (res: Result<seq<uint8>, string>)
    requires |privateKey| > 0
    requires |cipherText| > 0
    decreases padding, privateKey, cipherText

  method {:extern ""RSAEncryption.RSA"", ""EncryptExtern""} EncryptExtern(padding: PaddingMode, publicKey: seq<uint8>, plaintextData: seq<uint8>)
      returns (res: Result<seq<uint8>, string>)
    requires |publicKey| > 0
    requires |plaintextData| > 0
    decreases padding, publicKey, plaintextData
}

module {:extern ""Signature""} Signature {

  export
    reveals SignatureKeyPair, ECDSAParams, ECDSAParams.SignatureLength, ECDSAParams.FieldSize
    provides KeyGen, Sign, Verify, IsSigned, Wrappers, UInt


  import opened Wrappers = Wrappers

  import opened UInt = StandardLibrary.UInt
  datatype SignatureKeyPair = SignatureKeyPair(verificationKey: seq<uint8>, signingKey: seq<uint8>)

  datatype ECDSAParams = ECDSA_P384 | ECDSA_P256 {
    function method SignatureLength(): uint16
      decreases this
    {
      match this
      case ECDSA_P256() =>
        71
      case ECDSA_P384() =>
        103
    }

    function method FieldSize(): nat
      decreases this
    {
      match this
      case ECDSA_P256() =>
        assert 1 + (256 + 7) / 8 == 33; 33
      case ECDSA_P384() =>
        assert 1 + (384 + 7) / 8 == 49;
        49
    }
  }

  predicate {:axiom} IsSigned(key: seq<uint8>, msg: seq<uint8>, signature: seq<uint8>)
    decreases key, msg, signature

  method KeyGen(s: ECDSAParams) returns (res: Result<SignatureKeyPair, string>)
    ensures match res { case Success(_mcc#0) => (var sigKeyPair := _mcc#0; |sigKeyPair.verificationKey| == s.FieldSize()) case Failure(_mcc#1) => true }
    decreases s
  {
    var sigKeyPair :- ExternKeyGen(s);
    if |sigKeyPair.verificationKey| == s.FieldSize() {
      return Success(sigKeyPair);
    } else {
      return Failure(""Incorrect verification-key length from ExternKeyGen."");
    }
  }

  method {:extern ""Signature.ECDSA"", ""ExternKeyGen""} ExternKeyGen(s: ECDSAParams) returns (res: Result<SignatureKeyPair, string>)
    decreases s

  method {:extern ""Signature.ECDSA"", ""Sign""} Sign(s: ECDSAParams, key: seq<uint8>, msg: seq<uint8>)
      returns (sig: Result<seq<uint8>, string>)
    ensures sig.Success? ==> IsSigned(key, msg, sig.value)
    decreases s, key, msg

  method {:extern ""Signature.ECDSA"", ""Verify""} Verify(s: ECDSAParams, key: seq<uint8>, msg: seq<uint8>, sig: seq<uint8>)
      returns (res: Result<bool, string>)
    decreases s, key, msg, sig
}

module {:extern ""Dafny.Aws""} Aws {

  module {:extern ""Dafny.Aws.Crypto""} Crypto {

    import opened Wrappers = Wrappers

    import AmazonKeyManagementService = AmazonKeyManagementService

    import opened UInt = StandardLibrary.UInt

    import UTF8 = UTF8

    export
      provides UTF8, UInt, Wrappers, IKeyring.OnDecrypt, ICryptographicMaterialsManager.GetEncryptionMaterials, ICryptographicMaterialsManager.DecryptMaterials, IKeyring.OnEncrypt, IAwsCryptographicMaterialsProviderClient.CreateRawAesKeyring, IAwsCryptographicMaterialsProviderClient.CreateDefaultCryptographicMaterialsManager
      reveals AlgorithmSuiteId, EncryptedDataKey, EncryptedDataKey.Valid, IKeyring, GetEncryptionMaterialsInput, GetEncryptionMaterialsOutput, DecryptMaterialsInput, DecryptMaterialsOutput, ICryptographicMaterialsManager, EncryptionContext, EncryptionMaterials, DecryptionMaterials, ValidEncryptedDataKey, EncryptedDataKeyList, OnEncryptInput, OnEncryptOutput, OnDecryptInput, OnDecryptOutput, OnEncryptInput.Valid, OnDecryptInput.Valid, GetEncryptionMaterialsInput.Valid, DecryptMaterialsInput.Valid, EncryptionMaterials.Valid, CreateRawAesKeyringInput, CreateDefaultCryptographicMaterialsManagerInput, IAwsCryptographicMaterialsProviderClient, AesWrappingAlg, CreateDefaultCryptographicMaterialsManagerInput.Valid, CreateRawAesKeyringInput.Valid

    type KmsKeyId = string

    type KmsKeyIdList = seq<KmsKeyId>

    type GrantToken = string

    type GrantTokenList = seq<GrantToken>

    type Region = string

    type RegionList = seq<Region>

    datatype DiscoveryFilter = DiscoveryFilter(accountId: string, partition: string) {
      predicate Valid()
        decreases this
      {
        true
      }
    }

    datatype GetClientInput = GetClientInput(region: string) {
      predicate Valid()
        decreases this
      {
        true
      }
    }

    trait IKmsClient { }

    trait IClientSupplier {
      method GetClient(input: GetClientInput) returns (res: IKmsClient)
        requires input.Valid()
        decreases input
    }

    type EncryptionContext = map<UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes>

    datatype EncryptedDataKey = EncryptedDataKey(nameonly keyProviderId: UTF8.ValidUTF8Bytes, nameonly keyProviderInfo: seq<uint8>, nameonly ciphertext: seq<uint8>) {
      predicate Valid()
        decreases this
      {
        |keyProviderId| < UINT16_LIMIT &&
        |keyProviderInfo| < UINT16_LIMIT &&
        |ciphertext| < UINT16_LIMIT
      }
    }

    type ValidEncryptedDataKey = i: EncryptedDataKey
      | i.Valid()
      witness *

    type EncryptedDataKeyList = seq<EncryptedDataKey>

    datatype EncryptionMaterials = EncryptionMaterials(nameonly algorithmSuiteId: AlgorithmSuiteId, nameonly encryptionContext: EncryptionContext, nameonly encryptedDataKeys: seq<ValidEncryptedDataKey>, nameonly plaintextDataKey: Option<seq<uint8>>, nameonly signingKey: Option<seq<uint8>>) {
      predicate Valid()
        decreases this
      {
        true
      }
    }

    datatype DecryptionMaterials = DecryptionMaterials(nameonly algorithmSuiteId: AlgorithmSuiteId, nameonly encryptionContext: EncryptionContext, nameonly plaintextDataKey: Option<seq<uint8>>, nameonly verificationKey: Option<seq<uint8>>) {
      predicate Valid()
        decreases this
      {
        true
      }
    }

    datatype CommitmentPolicy = FORBID_ENCRYPT_FORBID_DECRYPT | REQUIRE_ENCRYPT_ALLOW_DECRYPT | REQUIRE_ENCRYPT_REQUIRE_DECRYPT

    datatype AesWrappingAlg = ALG_AES128_GCM_IV12_TAG16 | ALG_AES192_GCM_IV12_TAG16 | ALG_AES256_GCM_IV12_TAG16

    datatype AlgorithmSuiteId = ALG_AES_128_GCM_IV12_TAG16_NO_KDF | ALG_AES_192_GCM_IV12_TAG16_NO_KDF | ALG_AES_256_GCM_IV12_TAG16_NO_KDF | ALG_AES_128_GCM_IV12_TAG16_HKDF_SHA256 | ALG_AES_192_GCM_IV12_TAG16_HKDF_SHA256 | ALG_AES_256_GCM_IV12_TAG16_HKDF_SHA256 | ALG_AES_128_GCM_IV12_TAG16_HKDF_SHA256_ECDSA_P256 | ALG_AES_192_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384 | ALG_AES_256_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384

    datatype PaddingScheme = PKCS1 | OAEP_SHA1_MGF1 | OAEP_SHA256_MGF1 | OAEP_SHA384_MGF1 | OAEP_SHA512_MGF1

    datatype OnEncryptInput = OnEncryptInput(nameonly materials: EncryptionMaterials) {
      predicate Valid()
        decreases this
      {
        true
      }
    }

    datatype OnEncryptOutput = OnEncryptOutput(nameonly materials: EncryptionMaterials) {
      predicate Valid()
        decreases this
      {
        true
      }
    }

    datatype OnDecryptInput = OnDecryptInput(nameonly materials: DecryptionMaterials, nameonly encryptedDataKeys: EncryptedDataKeyList) {
      predicate Valid()
        decreases this
      {
        true
      }
    }

    datatype OnDecryptOutput = OnDecryptOutput(nameonly materials: DecryptionMaterials) {
      predicate Valid()
        decreases this
      {
        true
      }
    }

    trait {:termination false} IKeyring {
      method OnEncrypt(input: OnEncryptInput) returns (res: Result<OnEncryptOutput, string>)
        requires input.Valid()
        decreases input

      method OnDecrypt(input: OnDecryptInput) returns (res: Result<OnDecryptOutput, string>)
        requires input.Valid()
        decreases input
    }

    datatype CacheUsageMetadata = CacheUsageMetadata(messageUsage: int64, byteUsage: int64) {
      predicate Valid()
        decreases this
      {
        true
      }
    }

    datatype EncryptEntry = EncryptEntry(identifier: seq<uint8>, encryptionMaterials: EncryptionMaterials, creationTime: int64, expiryTime: int64, usageMetadata: CacheUsageMetadata) {
      predicate Valid()
        decreases this
      {
        true
      }
    }

    datatype DecryptEntry = DecryptEntry(identifier: seq<uint8>, decryptionMaterials: DecryptionMaterials, creationTime: int64, expiryTime: int64, usageMetadata: CacheUsageMetadata) {
      predicate Valid()
        decreases this
      {
        true
      }
    }

    datatype PutEntryForEncryptInput = PutEntryForEncryptInput(identifier: seq<uint8>, encryptionMaterials: EncryptionMaterials, usageMetadata: CacheUsageMetadata) {
      predicate Valid()
        decreases this
      {
        true
      }
    }

    datatype PutEntryForEncryptOutput = PutEntryForEncryptOutput {
      predicate Valid()
        decreases this
      {
        true
      }
    }

    datatype GetEntryForEncryptInput = GetEntryForEncryptInput(identifier: seq<uint8>) {
      predicate Valid()
        decreases this
      {
        true
      }
    }

    datatype GetEntryForEncryptOutput = GetEntryForEncryptOutput(cacheEntry: EncryptEntry) {
      predicate Valid()
        decreases this
      {
        true
      }
    }

    datatype PutEntryForDecryptInput = PutEntryForDecryptInput(identifier: seq<uint8>, decryptionMaterials: DecryptionMaterials) {
      predicate Valid()
        decreases this
      {
        true
      }
    }

    datatype PutEntryForDecryptOutput = PutEntryForDecryptOutput {
      predicate Valid()
        decreases this
      {
        true
      }
    }

    datatype GetEntryForDecryptInput = GetEntryForDecryptInput(identifier: seq<uint8>) {
      predicate Valid()
        decreases this
      {
        true
      }
    }

    datatype GetEntryForDecryptOutput = GetEntryForDecryptOutput(cacheEntry: DecryptEntry) {
      predicate Valid()
        decreases this
      {
        true
      }
    }

    datatype DeleteEntryInput = DeleteEntryInput(identifier: seq<uint8>) {
      predicate Valid()
        decreases this
      {
        true
      }
    }

    datatype DeleteEntryOutput = DeleteEntryOutput {
      predicate Valid()
        decreases this
      {
        true
      }
    }

    trait ICryptoMaterialsCache {
      method PutEntryForEncrypt(input: PutEntryForEncryptInput) returns (res: PutEntryForEncryptOutput)
        requires input.Valid()
        decreases input

      method GetEntryForEncrypt(input: GetEntryForEncryptInput) returns (res: GetEntryForEncryptOutput)
        requires input.Valid()
        decreases input

      method PutEntryForDecrypt(input: PutEntryForDecryptInput) returns (res: PutEntryForDecryptOutput)
        requires input.Valid()
        decreases input

      method GetEntryForDecrypt(input: GetEntryForDecryptInput) returns (res: GetEntryForDecryptOutput)
        requires input.Valid()
        decreases input

      method DeleteEntry(input: DeleteEntryInput) returns (res: DeleteEntryOutput)
        requires input.Valid()
        decreases input
    }

    datatype GetEncryptionMaterialsInput = GetEncryptionMaterialsInput(nameonly encryptionContext: EncryptionContext, nameonly algorithmSuiteId: Option<AlgorithmSuiteId>, nameonly maxPlaintextLength: Option<int64>) {
      predicate Valid()
        decreases this
      {
        true
      }
    }

    datatype GetEncryptionMaterialsOutput = GetEncryptionMaterialsOutput(nameonly encryptionMaterials: EncryptionMaterials) {
      predicate Valid()
        decreases this
      {
        true
      }
    }

    datatype DecryptMaterialsInput = DecryptMaterialsInput(nameonly algorithmSuiteId: AlgorithmSuiteId, nameonly encryptedDataKeys: EncryptedDataKeyList, nameonly encryptionContext: EncryptionContext) {
      predicate Valid()
        decreases this
      {
        true
      }
    }

    datatype DecryptMaterialsOutput = DecryptMaterialsOutput(nameonly decryptionMaterials: DecryptionMaterials) {
      predicate Valid()
        decreases this
      {
        true
      }
    }

    trait {:termination false} ICryptographicMaterialsManager {
      method GetEncryptionMaterials(input: GetEncryptionMaterialsInput) returns (res: Result<GetEncryptionMaterialsOutput, string>)
        requires input.Valid()
        decreases input

      method DecryptMaterials(input: DecryptMaterialsInput) returns (res: Result<DecryptMaterialsOutput, string>)
        requires input.Valid()
        decreases input
    }

    datatype CreateAwsKmsKeyringInput = CreateAwsKmsKeyringInput(nameonly clientSupplier: IClientSupplier, nameonly generator: Option<KmsKeyId>, nameonly keyIds: Option<KmsKeyIdList>, grantTokens: Option<GrantTokenList>) {
      predicate Valid()
        decreases this
      {
        true
      }
    }

    datatype CreateMrkAwareStrictAwsKmsKeyringInput = CreateMrkAwareStrictAwsKmsKeyringInput(nameonly kmsKeyId: KmsKeyId, nameonly grantTokens: Option<GrantTokenList>, nameonly kmsClient: AmazonKeyManagementService.IAmazonKeyManagementService) {
      predicate Valid()
        decreases this
      {
        true
      }
    }

    datatype CreateMrkAwareStrictMultiKeyringInput = CreateMrkAwareStrictMultiKeyringInput(nameonly generator: Option<KmsKeyId>, nameonly kmsKeyIds: Option<KmsKeyIdList>, nameonly grantTokens: Option<GrantTokenList>, nameonly clientSupplier: IClientSupplier?) {
      predicate Valid()
        decreases this
      {
        true
      }
    }

    datatype CreateMrkAwareDiscoveryAwsKmsKeyringInput = CreateMrkAwareDiscoveryAwsKmsKeyringInput(nameonly kmsClient: AmazonKeyManagementService.IAmazonKeyManagementService, nameonly discoveryFilter: Option<DiscoveryFilter>, nameonly grantTokens: Option<GrantTokenList>) {
      predicate Valid()
        decreases this
      {
        true
      }
    }

    datatype CreateMrkAwareDiscoveryMultiKeyringInput = CreateMrkAwareDiscoveryMultiKeyringInput(nameonly regions: RegionList, nameonly discoveryFilter: Option<DiscoveryFilter>, nameonly grantTokens: Option<GrantTokenList>, nameonly clientSupplier: IClientSupplier?) {
      predicate Valid()
        decreases this
      {
        true
      }
    }

    datatype CreateMultiKeyringInput = CreateMultiKeyringInput(nameonly generator: IKeyring?, nameonly childKeyrings: Option<seq<IKeyring>>) {
      predicate Valid()
        decreases this
      {
        true
      }
    }

    datatype CreateRawAesKeyringInput = CreateRawAesKeyringInput(nameonly keyNamespace: string, nameonly keyName: string, nameonly wrappingKey: seq<uint8>, nameonly wrappingAlg: AesWrappingAlg) {
      predicate Valid()
        decreases this
      {
        true
      }
    }

    datatype CreateRawRsaKeyringInput = CreateRawRsaKeyringInput(nameonly keyNamespace: string, nameonly keyName: string, nameonly paddingScheme: PaddingScheme, nameonly publicKey: Option<seq<uint8>>, nameonly privateKey: Option<seq<uint8>>) {
      predicate Valid()
        decreases this
      {
        true
      }
    }

    datatype CreateDefaultCryptographicMaterialsManagerInput = CreateDefaultCryptographicMaterialsManagerInput(nameonly keyring: IKeyring) {
      predicate Valid()
        decreases this
      {
        true
      }
    }

    datatype CreateCachingCryptographicMaterialsManagerInput = CreateCachingCryptographicMaterialsManagerInput(nameonly cache: ICryptoMaterialsCache, nameonly cacheLimitTtl: int32, nameonly keyring: IKeyring?, nameonly materialsManager: ICryptographicMaterialsManager?, nameonly partitionId: Option<string>, nameonly limitBytes: Option<int64>, nameonly limitMessages: Option<int64>) {
      predicate Valid()
        decreases this
      {
        true
      }
    }

    datatype CreateLocalCryptoMaterialsCacheInput = CreateLocalCryptoMaterialsCacheInput(nameonly entryCapacity: int32, nameonly entryPruningTailSize: Option<int32>) {
      predicate Valid()
        decreases this
      {
        true
      }
    }

    trait {:termination false} IAwsCryptographicMaterialsProviderClient {
      method CreateRawAesKeyring(input: CreateRawAesKeyringInput) returns (res: IKeyring)
        requires input.Valid()
        decreases input

      method CreateDefaultCryptographicMaterialsManager(input: CreateDefaultCryptographicMaterialsManagerInput) returns (res: ICryptographicMaterialsManager)
        requires input.Valid()
        decreases input
    }
  }

  module {:extern ""Dafny.Aws.Esdk""} Esdk {

    import Crypto = Crypto

    import opened UInt = StandardLibrary.UInt

    import opened Wrappers = Wrappers
    datatype EncryptInput = EncryptInput(nameonly plaintext: seq<uint8>, nameonly encryptionContext: Crypto.EncryptionContext, nameonly materialsManager: Crypto.ICryptographicMaterialsManager, nameonly algorithmSuiteId: Option<Crypto.AlgorithmSuiteId>) {
      predicate Valid()
        decreases this
      {
        true
      }
    }

    datatype EncryptOutput = EncryptOutput(nameonly ciphertext: seq<uint8>) {
      predicate Valid()
        decreases this
      {
        true
      }
    }

    datatype DecryptInput = DecryptInput(nameonly ciphertext: seq<uint8>, nameonly materialsManager: Crypto.ICryptographicMaterialsManager) {
      predicate Valid()
        decreases this
      {
        true
      }
    }

    datatype DecryptOutput = DecryptOutput(nameonly plaintext: seq<uint8>) {
      predicate Valid()
        decreases this
      {
        true
      }
    }

    trait {:termination false} IAwsEncryptionSdkClient {
      method Encrypt(input: EncryptInput) returns (res: Result<EncryptOutput, string>)
        requires input.Valid()
        decreases input

      method Decrypt(input: DecryptInput) returns (res: Result<DecryptOutput, string>)
        requires input.Valid()
        decreases input
    }
  }
}

module {:extern ""Amazon.KeyManagementService""} AmazonKeyManagementService {
  class {:extern ""IAmazonKeyManagementService""} IAmazonKeyManagementService { }
}

module AwsKmsArnParsing {

  import opened StandardLibrary = StandardLibrary

  import opened Wrappers = Wrappers

  import opened Seq = Seq

  import UTF8 = UTF8
  datatype AwsResource = AwsResource(resourceType: string, value: string) {
    predicate method Valid()
      decreases this
    {
      true &&
      0 < |value|
    }

    function method ToString(): string
      decreases this
    {
      resourceType + ""/"" + value
    }
  }

  datatype AwsArn = AwsArn(arnLiteral: string, partition: string, service: string, region: string, account: string, resource: AwsResource) {
    predicate method Valid()
      decreases this
    {
      arnLiteral == ""arn"" &&
      0 < |partition| &&
      0 < |service| &&
      0 < |region| &&
      0 < |account| &&
      resource.Valid()
    }

    function method ToString(): string
      requires this.Valid()
      decreases this
    {
      ToArnString(None)
    }

    function method ToArnString(customRegion: Option<string>): string
      requires this.Valid()
      decreases if customRegion.None? then 1 else 0
    {
      match customRegion {
        case None() =>
          ToArnString(Some(region))
        case Some(customRegion) =>
          Join([arnLiteral, partition, service, customRegion, account, resource.ToString()], "":"")
      }
    }
  }

  type AwsKmsArn = a: AwsArn
    | ValidAwsKmsArn(a)
    witness *

  type AwsKmsResource = r: AwsResource
    | ValidAwsKmsResource(r)
    witness *

  datatype AwsKmsIdentifier = AwsKmsArnIdentifier(a: AwsKmsArn) | AwsKmsRawResourceIdentifier(r: AwsKmsResource) {
    function method ToString(): string
      decreases this
    {
      match this {
        case AwsKmsArnIdentifier(a) =>
          a.ToString()
        case AwsKmsRawResourceIdentifier(r) =>
          r.ToString()
      }
    }
  }

  type AwsKmsIdentifierString = s: string
    | ParseAwsKmsIdentifier(s).Success? && UTF8.IsASCIIString(s) && 0 < |s| <= MAX_AWS_KMS_IDENTIFIER_LENGTH
    witness *

  const MAX_AWS_KMS_IDENTIFIER_LENGTH := 2048

  predicate method ValidAwsKmsResource(resource: AwsResource)
    decreases resource
  {
    resource.Valid() &&
    (resource.resourceType == ""key"" || resource.resourceType == ""alias"")
  }

  predicate method ValidAwsKmsArn(arn: AwsArn)
    decreases arn
  {
    arn.Valid() &&
    arn.service == ""kms"" &&
    ValidAwsKmsResource(arn.resource)
  }

  function method ParseAwsKmsRawResources(identifier: string): (result: Result<AwsKmsResource, string>)
    decreases identifier
  {
    var info: seq<seq<char>> := Split(identifier, '/');
    Need(info[0] != ""key"", ""Malformed raw key id: "" + identifier); if |info| == 1 then ParseAwsKmsResources(""key/"" + identifier) else ParseAwsKmsResources(identifier)
  }

  function method ParseAwsKmsResources(identifier: string): (result: Result<AwsKmsResource, string>)
    decreases identifier
  {
    var info: seq<seq<char>> := Split(identifier, '/');
    Need(|info| > 1, ""Malformed resource: "" + identifier); var resourceType: seq<char> := info[0]; var value: seq<char> := Join(info[1..], ""/""); var resource: AwsResource := AwsResource(resourceType, value); Need(ValidAwsKmsResource(resource), ""Malformed resource: "" + identifier); Success(resource)
  }

  lemma /*{:_induction identifier}*/ ParseAwsKmsResourcesCorrect(identifier: string)
    ensures ParseAwsKmsResources(identifier).Success? ==> ghost var info: seq<seq<char>> := Split(identifier, '/'); ghost var r: Result<AwsResource, seq<char>> := ParseAwsKmsResources(identifier); |info| > 1 && Join([r.value.resourceType, r.value.value], ""/"") == identifier
    ensures ParseAwsKmsResources(identifier).Success? ==> ghost var resourceType: seq<char> := Split(identifier, '/')[0]; ""key"" == resourceType || ""alias"" == resourceType
    ensures ParseAwsKmsResources(identifier).Success? ==> ghost var info: seq<seq<char>> := Split(identifier, '/'); |Join(info[1..], ""/"")| > 0
    decreases identifier
  {
  }

  function method ParseAwsKmsArn(identifier: string): (result: Result<AwsKmsArn, string>)
    decreases identifier
  {
    var components: seq<seq<char>> := Split(identifier, ':');
    Need(6 == |components|, ""Malformed arn: "" + identifier); var resource: AwsKmsResource :- ParseAwsKmsResources(components[5]); var arn: AwsArn := AwsArn(components[0], components[1], components[2], components[3], components[4], resource); Need(ValidAwsKmsArn(arn), ""Malformed Arn:"" + identifier); Success(arn)
  }

  lemma /*{:_induction identifier}*/ ParseAwsKmsArnCorrect(identifier: string)
    ensures ParseAwsKmsArn(identifier).Success? ==> ""arn"" <= identifier
    ensures ParseAwsKmsArn(identifier).Success? ==> |Split(identifier, ':')| == 6
    ensures ParseAwsKmsArn(identifier).Success? ==> |Split(identifier, ':')[1]| > 0
    ensures ParseAwsKmsArn(identifier).Success? ==> Split(identifier, ':')[2] == ""kms""
    ensures ParseAwsKmsArn(identifier).Success? ==> |Split(identifier, ':')[3]| > 0
    ensures ParseAwsKmsArn(identifier).Success? ==> |Split(identifier, ':')[4]| > 0
    decreases identifier
  {
  }

  function method ParseAwsKmsIdentifier(identifier: string): (result: Result<AwsKmsIdentifier, string>)
    decreases identifier
  {
    if ""arn:"" <= identifier then
      var arn: AwsKmsArn :- ParseAwsKmsArn(identifier); Success(AwsKmsArnIdentifier(arn))
    else
      var r: AwsKmsResource :- ParseAwsKmsRawResources(identifier); Success(AwsKmsRawResourceIdentifier(r))
  }

  predicate method IsMultiRegionAwsKmsArn(arn: AwsKmsArn)
    decreases arn
  {
    IsMultiRegionAwsKmsResource(arn.resource)
  }

  lemma IsMultiRegionAwsKmsArnCorrectness(arn: AwsKmsArn)
    ensures !IsMultiRegionAwsKmsArn(arn) <== arn.resource.resourceType == ""alias""
    ensures !IsMultiRegionAwsKmsArn(arn) <== arn.resource.resourceType == ""key"" && !(""mrk-"" <= arn.resource.value)
    ensures IsMultiRegionAwsKmsArn(arn) <== arn.resource.resourceType == ""key"" && ""mrk-"" <= arn.resource.value
    decreases arn
  {
  }

  predicate method IsMultiRegionAwsKmsIdentifier(identifier: AwsKmsIdentifier)
    decreases identifier
  {
    match identifier {
      case AwsKmsArnIdentifier(arn) =>
        IsMultiRegionAwsKmsArn(arn)
      case AwsKmsRawResourceIdentifier(r) =>
        IsMultiRegionAwsKmsResource(r)
    }
  }

  lemma IsMultiRegionAwsKmsIdentifierCorrect(s: string)
    ensures ""arn:"" <= s && ParseAwsKmsArn(s).Success? ==> ghost var arn: Result<AwsKmsArn, seq<char>> := ParseAwsKmsArn(s); ghost var arnIdentifier: AwsKmsIdentifier := AwsKmsArnIdentifier(arn.value); IsMultiRegionAwsKmsIdentifier(arnIdentifier) == IsMultiRegionAwsKmsArn(arn.value)
    ensures ""alias/"" <= s && ParseAwsKmsResources(s).Success? ==> ghost var resource: Result<AwsKmsResource, seq<char>> := ParseAwsKmsResources(s); ghost var resourceIdentifier: AwsKmsIdentifier := AwsKmsRawResourceIdentifier(resource.value); !IsMultiRegionAwsKmsIdentifier(resourceIdentifier)
    ensures ""mrk-"" <= s && ParseAwsKmsResources(s).Success? ==> ghost var resource: Result<AwsKmsResource, seq<char>> := ParseAwsKmsResources(s); ghost var resourceIdentifier: AwsKmsIdentifier := AwsKmsRawResourceIdentifier(resource.value); IsMultiRegionAwsKmsIdentifier(resourceIdentifier)
    ensures !(""arn:"" <= s) && !(""alias/"" <= s) && !(""mrk-"" <= s) && ParseAwsKmsIdentifier(s).Success? ==> ghost var resourceIdentifier: Result<AwsKmsIdentifier, string> := ParseAwsKmsIdentifier(s); !IsMultiRegionAwsKmsIdentifier(resourceIdentifier.value)
    decreases s
  {
  }

  predicate method IsMultiRegionAwsKmsResource(resource: AwsKmsResource)
    decreases resource
  {
    resource.resourceType == ""key"" &&
    ""mrk-"" <= resource.value
  }

  function method GetRegion(identifier: AwsKmsIdentifier): (res: Option<string>)
    decreases identifier
  {
    match identifier {
      case AwsKmsArnIdentifier(a) =>
        Some(a.region)
      case AwsKmsRawResourceIdentifier(_v0) =>
        None()
    }
  }
}

module {:extern ""KMSUtils""} KMSUtils {

  import EncryptionContext = EncryptionContext

  import opened AmazonKeyManagementService = AmazonKeyManagementService

  import opened StandardLibrary = StandardLibrary

  import opened Wrappers = Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened AwsKmsArnParsing = AwsKmsArnParsing

  import UTF8 = UTF8
  type CustomerMasterKey = AwsKmsIdentifierString

  type GrantTokens = s: seq<GrantToken>
    | 0 <= |s| <= MAX_GRANT_TOKENS

  type GrantToken = s: string
    | 0 < |s| <= 8192
    witness *

  datatype ResponseMetadata = ResponseMetadata(metadata: map<string, string>, requestID: string)

  type HttpStatusCode = int

  datatype GenerateDataKeyRequest = GenerateDataKeyRequest(encryptionContext: EncryptionContext.Map, grantTokens: seq<GrantToken>, keyID: AwsKmsIdentifierString, numberOfBytes: int32) {
    predicate Valid()
      decreases this
    {
      0 <= |grantTokens| <= MAX_GRANT_TOKENS &&
      0 < numberOfBytes <= 1024
    }
  }

  datatype GenerateDataKeyResponse = GenerateDataKeyResponse(ciphertextBlob: seq<uint8>, keyID: string, plaintext: seq<uint8>) {
    predicate method IsWellFormed()
      decreases this
    {
      |keyID| < UINT16_LIMIT &&
      |ciphertextBlob| < UINT16_LIMIT
    }
  }

  datatype EncryptRequest = EncryptRequest(encryptionContext: EncryptionContext.Map, grantTokens: seq<GrantToken>, keyID: AwsKmsIdentifierString, plaintext: seq<uint8>) {
    predicate Valid()
      decreases this
    {
      0 <= |grantTokens| <= MAX_GRANT_TOKENS
    }
  }

  datatype EncryptResponse = EncryptResponse(ciphertextBlob: seq<uint8>, contentLength: int, httpStatusCode: HttpStatusCode, keyID: string, responseMetadata: ResponseMetadata) {
    predicate method IsWellFormed()
      decreases this
    {
      |keyID| < UINT16_LIMIT &&
      |ciphertextBlob| < UINT16_LIMIT
    }
  }

  datatype DecryptRequest = DecryptRequest(keyId: string, ciphertextBlob: seq<uint8>, encryptionContext: EncryptionContext.Map, grantTokens: seq<GrantToken>) {
    predicate Valid()
      decreases this
    {
      0 <= |grantTokens| <= MAX_GRANT_TOKENS
    }
  }

  datatype DecryptResponse = DecryptResponse(contentLength: int, httpStatusCode: HttpStatusCode, keyID: string, plaintext: seq<uint8>, responseMetadata: ResponseMetadata)

  trait {:extern ""DafnyAWSKMSClientSupplier""} DafnyAWSKMSClientSupplier {
    method GetClient(region: Option<string>) returns (res: Result<IAmazonKeyManagementService, string>)
      decreases region
  }

  class BaseClientSupplier extends DafnyAWSKMSClientSupplier {
    constructor ()
    {
    }

    method GetClient(region: Option<string>) returns (res: Result<IAmazonKeyManagementService, string>)
      decreases region
    {
      var resClient := GetDefaultAWSKMSServiceClientExtern(region);
      return resClient;
    }
  }

  const MAX_GRANT_TOKENS := 10

  method {:extern ""KMSUtils.ClientHelper"", ""GetDefaultAWSKMSServiceClientExtern""} GetDefaultAWSKMSServiceClientExtern(region: Option<string>) returns (res: Result<IAmazonKeyManagementService, string>)
    decreases region

  predicate {:opaque} {:fuel 0, 0} GenerateDataKeyCalledWith(client: IAmazonKeyManagementService, request: GenerateDataKeyRequest)
    decreases client, request
  {
    true
  }

  predicate {:opaque} {:fuel 0, 0} GenerateDataKeyResult(ciphertextBlob: seq<uint8>, plaintext: seq<uint8>)
    decreases ciphertextBlob, plaintext
  {
    true
  }

  predicate {:opaque} {:fuel 0, 0} EncryptCalledWith(client: IAmazonKeyManagementService, request: EncryptRequest)
    decreases client, request
  {
    true
  }

  predicate {:opaque} {:fuel 0, 0} EncryptResult(ciphertextBlob: seq<uint8>)
    decreases ciphertextBlob
  {
    true
  }

  predicate {:opaque} {:fuel 0, 0} DecryptCalledWith(client: IAmazonKeyManagementService, request: DecryptRequest)
    decreases client, request
  {
    true
  }

  predicate {:opaque} {:fuel 0, 0} DecryptResult(keyID: string, plaintext: seq<uint8>)
    decreases keyID, plaintext
  {
    true
  }

  method {:extern ""KMSUtils.ClientHelper"", ""GenerateDataKey""} GenerateDataKey(client: IAmazonKeyManagementService, request: GenerateDataKeyRequest) returns (res: Result<GenerateDataKeyResponse, string>)
    requires request.Valid()
    ensures GenerateDataKeyCalledWith(client, request)
    ensures res.Success? ==> var r: GenerateDataKeyResponse := res.value; GenerateDataKeyResult(r.ciphertextBlob, r.plaintext)
    decreases client, request

  method {:extern ""KMSUtils.ClientHelper"", ""Encrypt""} Encrypt(client: IAmazonKeyManagementService, request: EncryptRequest) returns (res: Result<EncryptResponse, string>)
    requires request.Valid()
    ensures EncryptCalledWith(client, request)
    ensures res.Success? ==> EncryptResult(res.value.ciphertextBlob)
    decreases client, request

  method {:extern ""KMSUtils.ClientHelper"", ""Decrypt""} Decrypt(client: IAmazonKeyManagementService, request: DecryptRequest) returns (res: Result<DecryptResponse, string>)
    requires request.Valid()
    ensures DecryptCalledWith(client, request)
    ensures res.Success? ==> var r: DecryptResponse := res.value; DecryptResult(r.keyID, r.plaintext)
    decreases client, request
}

module {:extern ""AlgorithmSuite""} AlgorithmSuite {

  import opened Wrappers = Wrappers

  import Crypto = Aws.Crypto

  import opened UInt = StandardLibrary.UInt

  import EncryptionSuites = EncryptionSuites

  import S = Signature

  import KeyDerivationAlgorithms = KeyDerivationAlgorithms
  newtype ID = x: uint16
    | x in VALID_IDS
    witness 20
{
    function method EncryptionSuite(): EncryptionSuites.EncryptionSuite
      ensures EncryptionSuite().Valid()
      decreases this
    {
      Suite[this].algorithm
    }

    function method KeyLength(): nat
      decreases this
    {
      Suite[this].algorithm.keyLen as nat
    }

    predicate method ContainsIdentityKDF()
      decreases this
    {
      Suite[this].hkdf == KeyDerivationAlgorithms.IDENTITY
    }

    function method KDFInputKeyLength(): nat
      ensures ContainsIdentityKDF() ==> KDFInputKeyLength() == KeyLength()
      decreases this
    {
      match Suite[this].hkdf
      case HKDF_WITH_SHA_384() =>
        Suite[this].algorithm.keyLen as nat
      case HKDF_WITH_SHA_256() =>
        Suite[this].algorithm.keyLen as nat
      case IDENTITY() =>
        Suite[this].algorithm.keyLen as nat
    }

    function method IVLength(): nat
      decreases this
    {
      Suite[this].algorithm.ivLen as nat
    }

    function method TagLength(): nat
      decreases this
    {
      Suite[this].algorithm.tagLen as nat
    }

    function method SignatureType(): Option<S.ECDSAParams>
      decreases this
    {
      Suite[this].sign
    }

    predicate method ValidPlaintextDataKey(plaintextDataKey: seq<uint8>)
      decreases this, plaintextDataKey
    {
      |plaintextDataKey| == KDFInputKeyLength()
    }
  }

  datatype AlgSuite = AlgSuite(algorithm: EncryptionSuites.EncryptionSuite, hkdf: KeyDerivationAlgorithms.KeyDerivationAlgorithm, sign: Option<S.ECDSAParams>)

  const VALID_IDS: set<uint16> := {888, 838, 532, 376, 326, 276, 120, 70, 20}
  const AES_256_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384: ID := 888
  const AES_192_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384: ID := 838
  const AES_128_GCM_IV12_TAG16_HKDF_SHA256_ECDSA_P256: ID := 532
  const AES_256_GCM_IV12_TAG16_HKDF_SHA256_NO_SIGNATURE_ALG: ID := 376
  const AES_192_GCM_IV12_TAG16_HKDF_SHA256_NO_SIGNATURE_ALG: ID := 326
  const AES_128_GCM_IV12_TAG16_HKDF_SHA256_NO_SIGNATURE_ALG: ID := 276
  const AES_256_GCM_IV12_TAG16_IDENTITY_NO_SIGNATURE_ALG: ID := 120
  const AES_192_GCM_IV12_TAG16_IDENTITY_NO_SIGNATURE_ALG: ID := 70
  const AES_128_GCM_IV12_TAG16_IDENTITY_NO_SIGNATURE_ALG: ID := 20
  const Suite := map[AES_256_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384 := AlgSuite(EncryptionSuites.AES_GCM_256, KeyDerivationAlgorithms.HKDF_WITH_SHA_384, Some(S.ECDSA_P384)), AES_192_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384 := AlgSuite(EncryptionSuites.AES_GCM_192, KeyDerivationAlgorithms.HKDF_WITH_SHA_384, Some(S.ECDSA_P384)), AES_128_GCM_IV12_TAG16_HKDF_SHA256_ECDSA_P256 := AlgSuite(EncryptionSuites.AES_GCM_128, KeyDerivationAlgorithms.HKDF_WITH_SHA_256, Some(S.ECDSA_P256)), AES_256_GCM_IV12_TAG16_HKDF_SHA256_NO_SIGNATURE_ALG := AlgSuite(EncryptionSuites.AES_GCM_256, KeyDerivationAlgorithms.HKDF_WITH_SHA_256, None), AES_192_GCM_IV12_TAG16_HKDF_SHA256_NO_SIGNATURE_ALG := AlgSuite(EncryptionSuites.AES_GCM_192, KeyDerivationAlgorithms.HKDF_WITH_SHA_256, None), AES_128_GCM_IV12_TAG16_HKDF_SHA256_NO_SIGNATURE_ALG := AlgSuite(EncryptionSuites.AES_GCM_128, KeyDerivationAlgorithms.HKDF_WITH_SHA_256, None), AES_256_GCM_IV12_TAG16_IDENTITY_NO_SIGNATURE_ALG := AlgSuite(EncryptionSuites.AES_GCM_256, KeyDerivationAlgorithms.IDENTITY, None), AES_192_GCM_IV12_TAG16_IDENTITY_NO_SIGNATURE_ALG := AlgSuite(EncryptionSuites.AES_GCM_192, KeyDerivationAlgorithms.IDENTITY, None), AES_128_GCM_IV12_TAG16_IDENTITY_NO_SIGNATURE_ALG := AlgSuite(EncryptionSuites.AES_GCM_128, KeyDerivationAlgorithms.IDENTITY, None)]

  function method PolymorphIDToInternalID(input: Crypto.AlgorithmSuiteId): (res: ID)
    decreases input
  {
    if input == Crypto.ALG_AES_128_GCM_IV12_TAG16_NO_KDF then
      AES_128_GCM_IV12_TAG16_IDENTITY_NO_SIGNATURE_ALG
    else if input == Crypto.ALG_AES_192_GCM_IV12_TAG16_NO_KDF then
      AES_192_GCM_IV12_TAG16_IDENTITY_NO_SIGNATURE_ALG
    else if input == Crypto.ALG_AES_256_GCM_IV12_TAG16_NO_KDF then
      AES_256_GCM_IV12_TAG16_IDENTITY_NO_SIGNATURE_ALG
    else if input == Crypto.ALG_AES_128_GCM_IV12_TAG16_HKDF_SHA256 then
      AES_128_GCM_IV12_TAG16_HKDF_SHA256_NO_SIGNATURE_ALG
    else if input == Crypto.ALG_AES_192_GCM_IV12_TAG16_HKDF_SHA256 then
      AES_192_GCM_IV12_TAG16_HKDF_SHA256_NO_SIGNATURE_ALG
    else if input == Crypto.ALG_AES_256_GCM_IV12_TAG16_HKDF_SHA256 then
      AES_256_GCM_IV12_TAG16_HKDF_SHA256_NO_SIGNATURE_ALG
    else if input == Crypto.ALG_AES_128_GCM_IV12_TAG16_HKDF_SHA256_ECDSA_P256 then
      AES_128_GCM_IV12_TAG16_HKDF_SHA256_ECDSA_P256
    else if input == Crypto.ALG_AES_192_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384 then
      AES_192_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384
    else
      AES_256_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384
  }

  function method InternalIDToPolymorphID(input: ID): (res: Crypto.AlgorithmSuiteId)
    decreases input
  {
    if input == AES_128_GCM_IV12_TAG16_IDENTITY_NO_SIGNATURE_ALG then
      Crypto.ALG_AES_128_GCM_IV12_TAG16_NO_KDF
    else if input == AES_192_GCM_IV12_TAG16_IDENTITY_NO_SIGNATURE_ALG then
      Crypto.ALG_AES_192_GCM_IV12_TAG16_NO_KDF
    else if input == AES_256_GCM_IV12_TAG16_IDENTITY_NO_SIGNATURE_ALG then
      Crypto.ALG_AES_256_GCM_IV12_TAG16_NO_KDF
    else if input == AES_128_GCM_IV12_TAG16_HKDF_SHA256_NO_SIGNATURE_ALG then
      Crypto.ALG_AES_128_GCM_IV12_TAG16_HKDF_SHA256
    else if input == AES_192_GCM_IV12_TAG16_HKDF_SHA256_NO_SIGNATURE_ALG then
      Crypto.ALG_AES_192_GCM_IV12_TAG16_HKDF_SHA256
    else if input == AES_256_GCM_IV12_TAG16_HKDF_SHA256_NO_SIGNATURE_ALG then
      Crypto.ALG_AES_256_GCM_IV12_TAG16_HKDF_SHA256
    else if input == AES_128_GCM_IV12_TAG16_HKDF_SHA256_ECDSA_P256 then
      Crypto.ALG_AES_128_GCM_IV12_TAG16_HKDF_SHA256_ECDSA_P256
    else if input == AES_192_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384 then
      Crypto.ALG_AES_192_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384
    else
      Crypto.ALG_AES_256_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384
  }

  lemma SuiteIsComplete(id: ID)
    ensures id in Suite.Keys
    decreases id
  {
  }

  lemma ValidIDsAreSuiteKeys()
    ensures VALID_IDS == set id: ID {:trigger id in Suite.Keys} | id in Suite.Keys :: id as uint16
  {
    forall x: uint16 | x in VALID_IDS
      ensures exists id: ID :: id in Suite.Keys && id as uint16 == x
    {
      assert x as ID in Suite.Keys;
    }
  }
}

module {:extern ""Dafny.Aws.Crypto.AwsCryptographicMaterialProvidersClient""} AwsCryptographicMaterialProviders {

  import opened Wrappers = Wrappers

  import opened StandardLibrary = StandardLibrary

  import opened UInt = StandardLibrary.UInt

  import EncryptionSuites = EncryptionSuites

  import UTF8 = UTF8

  import Crypto = Aws.Crypto

  import DefaultCMMDef = DefaultCMMDef

  import RawAESKeyringDef = RawAESKeyringDef

  import Esdk = Aws.Esdk
  class AwsCryptographicMaterialProvidersClient extends Crypto.IAwsCryptographicMaterialsProviderClient {
    constructor ()
    {
    }

    method CreateRawAesKeyring(input: Crypto.CreateRawAesKeyringInput) returns (res: Crypto.IKeyring)
      requires input.Valid()
      decreases input
    {
      var wrappingAlg: EncryptionSuites.EncryptionSuite;
      if input.wrappingAlg == Crypto.ALG_AES128_GCM_IV12_TAG16 {
        wrappingAlg := EncryptionSuites.AES_GCM_128;
      } else if input.wrappingAlg == Crypto.ALG_AES192_GCM_IV12_TAG16 {
        wrappingAlg := EncryptionSuites.AES_GCM_192;
      } else {
        assert input.wrappingAlg == Crypto.ALG_AES256_GCM_IV12_TAG16;
        wrappingAlg := EncryptionSuites.AES_GCM_256;
      }
      var namespaceRes := UTF8.Encode(input.keyNamespace);
      var namespace;
      if namespaceRes.Success? {
        namespace := namespaceRes.value;
      }
      var nameRes := UTF8.Encode(input.keyName);
      var name;
      if nameRes.Success? {
        name := nameRes.value;
      }
      assert wrappingAlg.Valid();
      expect |namespace| < UINT16_LIMIT, ""expectation violation""
      expect |input.wrappingKey| == 16 || |input.wrappingKey| == 24 || |input.wrappingKey| == 32, ""expectation violation""
      expect |input.wrappingKey| == wrappingAlg.keyLen as int, ""expectation violation""
      return new RawAESKeyringDef.RawAESKeyring(namespace, name, input.wrappingKey, wrappingAlg);
    }

    method CreateDefaultCryptographicMaterialsManager(input: Crypto.CreateDefaultCryptographicMaterialsManagerInput) returns (res: Crypto.ICryptographicMaterialsManager)
      requires input.Valid()
      decreases input
    {
      return new DefaultCMMDef.DefaultCMM.OfKeyring(input.keyring);
    }
  }
}

module {:extern ""Dafny.Aws.Esdk.AwsEncryptionSdkClient""} AwsEncryptionSdk {

  import opened Wrappers = Wrappers

  import opened StandardLibrary = StandardLibrary

  import opened UInt = StandardLibrary.UInt

  import UTF8 = UTF8

  import Crypto = Aws.Crypto

  import Esdk = Aws.Esdk

  import EncryptDecrypt = EncryptDecrypt
  class AwsEncryptionSdkClient extends Esdk.IAwsEncryptionSdkClient {
    constructor ()
    {
    }

    method Encrypt(input: Esdk.EncryptInput) returns (res: Result<Esdk.EncryptOutput, string>)
      requires input.Valid()
      decreases input
    {
      var encryptRequest := EncryptDecrypt.EncryptRequest.WithCMM(input.plaintext, input.materialsManager).SetEncryptionContext(input.encryptionContext);
      var e :- EncryptDecrypt.Encrypt(encryptRequest);
      return Success(Esdk.EncryptOutput(ciphertext := e));
    }

    method Decrypt(input: Esdk.DecryptInput) returns (res: Result<Esdk.DecryptOutput, string>)
      requires input.Valid()
      decreases input
    {
      var decryptRequest := EncryptDecrypt.DecryptRequest.WithCMM(input.ciphertext, input.materialsManager);
      var d :- EncryptDecrypt.Decrypt(decryptRequest);
      return Success(Esdk.DecryptOutput(plaintext := d));
    }
  }
}

module {:extern ""DefaultCMMDef""} DefaultCMMDef {

  import opened Wrappers = Wrappers

  import opened UInt = StandardLibrary.UInt

  import Materials = Materials

  import EncryptionContext = EncryptionContext

  import AlgorithmSuite = AlgorithmSuite

  import Signature = Signature

  import Base64 = Base64

  import MessageHeader = MessageHeader

  import UTF8 = UTF8

  import Deserialize = Deserialize

  import Crypto = Aws.Crypto
  class DefaultCMM extends Crypto.ICryptographicMaterialsManager {
    const keyring: Crypto.IKeyring

    constructor OfKeyring(k: Crypto.IKeyring)
      ensures keyring == k
      decreases k
    {
      keyring := k;
    }

    method GetEncryptionMaterials(input: Crypto.GetEncryptionMaterialsInput) returns (res: Result<Crypto.GetEncryptionMaterialsOutput, string>)
      requires input.Valid()
      ensures res.Success? ==> res.value.encryptionMaterials.plaintextDataKey.Some? && Serializable(res.value.encryptionMaterials)
      ensures Materials.EC_PUBLIC_KEY_FIELD in input.encryptionContext ==> res.Failure?
      ensures res.Success? && (input.algorithmSuiteId.None? || AlgorithmSuite.PolymorphIDToInternalID(input.algorithmSuiteId.value).SignatureType().Some?) ==> Materials.EC_PUBLIC_KEY_FIELD in res.value.encryptionMaterials.encryptionContext
      ensures res.Success? ==> Serializable(res.value.encryptionMaterials)
      ensures res.Success? ==> match input.algorithmSuiteId { case None => AlgorithmSuite.PolymorphIDToInternalID(res.value.encryptionMaterials.algorithmSuiteId) == 888 case Some(_mcc#0) => var id := _mcc#0; res.value.encryptionMaterials.algorithmSuiteId == id }
      decreases input
    {
      var reservedField := Materials.EC_PUBLIC_KEY_FIELD;
      assert reservedField in Materials.RESERVED_KEY_VALUES;
      if reservedField in input.encryptionContext.Keys {
        return Failure(""Reserved Field found in EncryptionContext keys."");
      }
      var id := AlgorithmSuite.AES_256_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384;
      if input.algorithmSuiteId.Some? {
        id := AlgorithmSuite.PolymorphIDToInternalID(input.algorithmSuiteId.value);
      }
      var enc_sk := None;
      var enc_ctx := input.encryptionContext;
      match id.SignatureType() {
        case {:split false} None() =>
        case {:split false} Some(param) =>
          var signatureKeys :- Signature.KeyGen(param);
          enc_sk := Some(signatureKeys.signingKey);
          var enc_vk :- UTF8.Encode(Base64.Encode(signatureKeys.verificationKey));
          enc_ctx := enc_ctx[reservedField := enc_vk];
      }
      var validAAD := EncryptionContext.CheckSerializable(enc_ctx);
      if !validAAD {
        return Failure(""Invalid Encryption Context"");
      }
      assert EncryptionContext.Serializable(enc_ctx);
      var materials := Crypto.EncryptionMaterials(encryptionContext := enc_ctx, algorithmSuiteId := AlgorithmSuite.InternalIDToPolymorphID(id), plaintextDataKey := None(), encryptedDataKeys := [], signingKey := enc_sk);
      assert materials.encryptionContext == enc_ctx;
      var result :- keyring.OnEncrypt(Crypto.OnEncryptInput(materials := materials));
      if result.materials.plaintextDataKey.None? || |result.materials.encryptedDataKeys| == 0 {
        return Failure(""Could not retrieve materials required for encryption"");
      }
      assert result.materials.Valid();
      :- Need(OnEncryptResultValid(input, result), ""Keyring returned an invalid response"");
      return Success(Crypto.GetEncryptionMaterialsOutput(encryptionMaterials := result.materials));
    }

    method DecryptMaterials(input: Crypto.DecryptMaterialsInput) returns (res: Result<Crypto.DecryptMaterialsOutput, string>)
      requires input.Valid()
      ensures res.Success? ==> res.value.decryptionMaterials.plaintextDataKey.Some?
      decreases input
    {
      var vkey := None;
      var algID := AlgorithmSuite.PolymorphIDToInternalID(input.algorithmSuiteId);
      var encCtx := input.encryptionContext;
      if algID.SignatureType().Some? {
        var reservedField := Materials.EC_PUBLIC_KEY_FIELD;
        if reservedField !in encCtx {
          return Failure(""Could not get materials required for decryption."");
        }
        var encodedVKey := encCtx[reservedField];
        var utf8Decoded :- UTF8.Decode(encodedVKey);
        var base64Decoded :- Base64.Decode(utf8Decoded);
        vkey := Some(base64Decoded);
      }
      var materials := Crypto.DecryptionMaterials(encryptionContext := encCtx, algorithmSuiteId := input.algorithmSuiteId, plaintextDataKey := None(), verificationKey := vkey);
      var result :- keyring.OnDecrypt(Crypto.OnDecryptInput(materials := materials, encryptedDataKeys := input.encryptedDataKeys));
      if result.materials.plaintextDataKey.None? {
        return Failure(""Keyring.OnDecrypt failed to decrypt the plaintext data key."");
      }
      return Success(Crypto.DecryptMaterialsOutput(decryptionMaterials := result.materials));
    }

    predicate method OnEncryptResultValid(input: Crypto.GetEncryptionMaterialsInput, result: Crypto.OnEncryptOutput)
      decreases input, result
    {
      result.materials.plaintextDataKey.Some? &&
      Serializable(result.materials) &&
      (input.algorithmSuiteId.None? || AlgorithmSuite.PolymorphIDToInternalID(input.algorithmSuiteId.value).SignatureType().Some? ==>
        Materials.EC_PUBLIC_KEY_FIELD in result.materials.encryptionContext) &&
      match input.algorithmSuiteId { case None => AlgorithmSuite.PolymorphIDToInternalID(result.materials.algorithmSuiteId) == 888 case Some(_mcc#0) => var id := _mcc#0; result.materials.algorithmSuiteId == id }
    }
  }

  predicate method Serializable(mat: Crypto.EncryptionMaterials)
    decreases mat
  {
    |mat.encryptedDataKeys| > 0 &&
    EncryptionContext.Serializable(mat.encryptionContext)
  }
}

module Deserialize {

  export
    provides DeserializeHeader, Materials, Streams, StandardLibrary, Wrappers, UInt, AlgorithmSuite, Msg, InsertNewEntry, UTF8, EncryptionContext
    reveals DeserializeHeaderResult


  import Crypto = Aws.Crypto

  import Msg = MessageHeader

  import AlgorithmSuite = AlgorithmSuite

  import Streams = Streams

  import opened StandardLibrary = StandardLibrary

  import opened Wrappers = Wrappers

  import opened UInt = StandardLibrary.UInt

  import UTF8 = UTF8

  import Materials = Materials

  import EncryptionContext = EncryptionContext
  datatype DeserializeHeaderResult = DeserializeHeaderResult(header: Msg.Header, ghost hbSeq: seq<uint8>)

  method DeserializeHeader(rd: Streams.ByteReader) returns (res: Result<DeserializeHeaderResult, string>)
    requires rd.Valid()
    modifies rd.reader`pos
    ensures rd.Valid()
    ensures match res { case Success(_mcc#0) => (var desres := _mcc#0; desres.header.Valid() && old(rd.reader.pos) <= rd.reader.pos <= |rd.reader.data| && Msg.IsSerializationOfHeaderBody(desres.hbSeq, desres.header.body) && desres.hbSeq + desres.header.auth.iv + desres.header.auth.authenticationTag == rd.reader.data[old(rd.reader.pos) .. rd.reader.pos]) case Failure(_mcc#1) => true }
    decreases rd
  {
    var hb :- DeserializeHeaderBody(rd);
    ghost var hbSeq := rd.reader.data[old(rd.reader.pos) .. rd.reader.pos];
    var auth :- DeserializeHeaderAuthentication(rd, hb.algorithmSuiteID);
    return Success(DeserializeHeaderResult(Msg.Header(hb, auth), hbSeq));
  }

  method DeserializeHeaderBody(rd: Streams.ByteReader) returns (ret: Result<Msg.HeaderBody, string>)
    requires rd.Valid()
    modifies rd.reader`pos
    ensures rd.Valid()
    ensures match ret { case Success(_mcc#0) => (var hb := _mcc#0; hb.Valid() && old(rd.reader.pos) <= rd.reader.pos <= |rd.reader.data| && Msg.IsSerializationOfHeaderBody(rd.reader.data[old(rd.reader.pos) .. rd.reader.pos], hb)) case Failure(_mcc#1) => true }
    decreases rd
  {
    var version :- DeserializeVersion(rd);
    var typ :- DeserializeType(rd);
    var algorithmSuiteID :- DeserializeAlgorithmSuiteID(rd);
    var messageID :- DeserializeMsgID(rd);
    ghost var aadStart := rd.reader.pos;
    var aad :- DeserializeAAD(rd);
    ghost var aadEnd := rd.reader.pos;
    var encryptedDataKeys :- DeserializeEncryptedDataKeys(rd);
    var contentType :- DeserializeContentType(rd);
    ghost var reserveStart := rd.reader.pos;
    var _ :- DeserializeReserved(rd);
    ghost var reserveEnd := rd.reader.pos;
    assert [version as uint8] + [typ as uint8] + UInt16ToSeq(algorithmSuiteID as uint16) + messageID + rd.reader.data[aadStart .. aadEnd] + Msg.EDKsToSeq(encryptedDataKeys) + [Msg.ContentTypeToUInt8(contentType)] + rd.reader.data[reserveStart .. reserveEnd] == rd.reader.data[old(rd.reader.pos) .. rd.reader.pos];
    assert [version as uint8] + [typ as uint8] + UInt16ToSeq(algorithmSuiteID as uint16) + messageID + rd.reader.data[aadStart .. aadEnd] + Msg.EDKsToSeq(encryptedDataKeys) + [Msg.ContentTypeToUInt8(contentType)] + [0, 0, 0, 0] == rd.reader.data[old(rd.reader.pos) .. rd.reader.pos];
    var ivLength :- rd.ReadByte();
    var frameLength :- rd.ReadUInt32();
    assert [version as uint8] + [typ as uint8] + UInt16ToSeq(algorithmSuiteID as uint16) + messageID + rd.reader.data[aadStart .. aadEnd] + Msg.EDKsToSeq(encryptedDataKeys) + [Msg.ContentTypeToUInt8(contentType)] + [0, 0, 0, 0] + [ivLength] + UInt32ToSeq(frameLength) == rd.reader.data[old(rd.reader.pos) .. rd.reader.pos];
    if ivLength as nat != algorithmSuiteID.IVLength() {
      return Failure(""Deserialization Error: Incorrect IV length."");
    }
    if contentType.NonFramed? && frameLength != 0 {
      return Failure(""Deserialization Error: Frame length must be 0 when content type is non-framed."");
    } else if contentType.Framed? && frameLength == 0 {
      return Failure(""Deserialization Error: Frame length must be non-0 when content type is framed."");
    }
    reveal Msg.IsSerializationOfHeaderBody();
    var hb := Msg.HeaderBody(version, typ, algorithmSuiteID, messageID, aad, encryptedDataKeys, contentType, ivLength, frameLength);
    assert Msg.IsSerializationOfHeaderBody(rd.reader.data[old(rd.reader.pos) .. rd.reader.pos], hb) by {
      reveal Msg.IsSerializationOfHeaderBody();
      ghost var s := rd.reader.data[old(rd.reader.pos) .. rd.reader.pos];
      ghost var serializedAAD := rd.reader.data[aadStart .. aadEnd];
      assert EncryptionContext.LinearSeqToMap(serializedAAD, aad);
      assert s[0 .. 1] == [hb.version as uint8];
      assert Msg.IsSerializationOfHeaderBodyAux(s, hb, serializedAAD);
    }
    return Success(hb);
  }

  method DeserializeHeaderAuthentication(rd: Streams.ByteReader, algorithmSuiteID: AlgorithmSuite.ID) returns (ret: Result<Msg.HeaderAuthentication, string>)
    requires rd.Valid()
    requires algorithmSuiteID in AlgorithmSuite.Suite.Keys
    modifies rd.reader`pos
    ensures rd.Valid()
    ensures match ret { case Success(_mcc#0) => (var ha := _mcc#0; var bytesRead := algorithmSuiteID.IVLength() + algorithmSuiteID.TagLength(); var serHa := ha.iv + ha.authenticationTag; |ha.iv| == algorithmSuiteID.IVLength() && |ha.authenticationTag| == algorithmSuiteID.TagLength() && old(rd.reader.pos) + bytesRead == rd.reader.pos && serHa == rd.reader.data[old(rd.reader.pos) .. rd.reader.pos]) case Failure(_mcc#1) => true }
    decreases rd, algorithmSuiteID
  {
    var iv :- rd.ReadBytes(algorithmSuiteID.IVLength());
    var authenticationTag :- rd.ReadBytes(algorithmSuiteID.TagLength());
    return Success(Msg.HeaderAuthentication(iv, authenticationTag));
  }

  method DeserializeVersion(rd: Streams.ByteReader) returns (ret: Result<Msg.Version, string>)
    requires rd.Valid()
    modifies rd.reader`pos
    ensures rd.Valid()
    ensures match ret { case Success(_mcc#0) => (var ver := _mcc#0; var bytesRead := 1; var serVer := [ver as uint8]; old(rd.reader.pos) + bytesRead == rd.reader.pos && serVer == rd.reader.data[old(rd.reader.pos) .. rd.reader.pos]) case Failure(_mcc#1) => true }
    decreases rd
  {
    var version :- rd.ReadByte();
    if version == Msg.VERSION_1 {
      return Success(version);
    } else {
      return Failure(""Deserialization Error: Version not supported."");
    }
  }

  method DeserializeType(rd: Streams.ByteReader) returns (ret: Result<Msg.Type, string>)
    requires rd.Valid()
    modifies rd.reader`pos
    ensures rd.Valid()
    ensures match ret { case Success(_mcc#0) => (var typ := _mcc#0; var bytesRead := 1; var serTyp := [typ as uint8]; old(rd.reader.pos) + bytesRead == rd.reader.pos && serTyp == rd.reader.data[old(rd.reader.pos) .. rd.reader.pos]) case Failure(_mcc#1) => true }
    decreases rd
  {
    var typ :- rd.ReadByte();
    if typ == Msg.TYPE_CUSTOMER_AED {
      return Success(typ);
    } else {
      return Failure(""Deserialization Error: Type not supported."");
    }
  }

  method DeserializeAlgorithmSuiteID(rd: Streams.ByteReader) returns (ret: Result<AlgorithmSuite.ID, string>)
    requires rd.Valid()
    modifies rd.reader`pos
    ensures rd.Valid()
    ensures match ret { case Success(_mcc#0) => (var algID := _mcc#0; var bytesRead := 2; var serAlgID := UInt16ToSeq(algID as uint16); old(rd.reader.pos) + bytesRead == rd.reader.pos && serAlgID == rd.reader.data[old(rd.reader.pos) .. rd.reader.pos]) case Failure(_mcc#1) => true }
    decreases rd
  {
    var algorithmSuiteID :- rd.ReadUInt16();
    if algorithmSuiteID in AlgorithmSuite.VALID_IDS {
      return Success(algorithmSuiteID as AlgorithmSuite.ID);
    } else {
      return Failure(""Deserialization Error: Algorithm suite not supported."");
    }
  }

  method DeserializeMsgID(rd: Streams.ByteReader) returns (ret: Result<Msg.MessageID, string>)
    requires rd.Valid()
    modifies rd.reader`pos
    ensures rd.Valid()
    ensures match ret { case Success(_mcc#0) => (var messageID := _mcc#0; var bytesRead := |messageID|; var sermessageID := messageID; old(rd.reader.pos) + bytesRead == rd.reader.pos && sermessageID == rd.reader.data[old(rd.reader.pos) .. rd.reader.pos]) case Failure(_mcc#1) => true }
    decreases rd
  {
    var msgID: seq<uint8> :- rd.ReadBytes(Msg.MESSAGE_ID_LEN);
    return Success(msgID);
  }

  method DeserializeUTF8(rd: Streams.ByteReader, n: nat) returns (ret: Result<UTF8.ValidUTF8Bytes, string>)
    requires rd.Valid()
    modifies rd.reader`pos
    ensures rd.Valid()
    ensures ret.Success? ==> var expectedRes: Option<UTF8.ValidUTF8Bytes> := EncryptionContext.GetUTF8(rd.reader.data[old(rd.reader.pos)..], n); expectedRes.Some? && expectedRes.value == ret.value
    ensures match ret { case Success(_mcc#0) => (var bytes := _mcc#0; UTF8.ValidUTF8Seq(bytes) && old(rd.reader.pos) + n == rd.reader.pos && bytes == rd.reader.data[old(rd.reader.pos) .. rd.reader.pos]) case Failure(_mcc#1) => true }
    decreases rd, n
  {
    var bytes :- rd.ReadBytes(n);
    if UTF8.ValidUTF8Seq(bytes) {
      var utf8: UTF8.ValidUTF8Bytes := bytes;
      assert bytes == rd.reader.data[old(rd.reader.pos)..][..n];
      return Success(utf8);
    } else {
      return Failure(""Deserialization Error: Not a valid UTF8 string."");
    }
  }

  method DeserializeAAD(rd: Streams.ByteReader) returns (ret: Result<EncryptionContext.Map, string>)
    requires rd.Valid()
    modifies rd.reader`pos
    ensures rd.Valid()
    ensures match ret { case Success(_mcc#0) => (var aad := _mcc#0; EncryptionContext.Serializable(aad) && old(rd.reader.pos) <= rd.reader.pos <= |rd.reader.data| && EncryptionContext.LinearSeqToMap(rd.reader.data[old(rd.reader.pos) .. rd.reader.pos], aad)) case Failure(_mcc#1) => true }
    decreases rd
  {
    reveal EncryptionContext.Serializable();
    var kvPairsLength :- rd.ReadUInt16();
    if kvPairsLength == 0 {
      return Success(map[]);
    } else if kvPairsLength < 2 {
      return Failure(""Deserialization Error: The number of bytes in encryption context exceeds the given length."");
    }
    var totalBytesRead := 0;
    var kvPairsCount :- rd.ReadUInt16();
    totalBytesRead := totalBytesRead + 2;
    if kvPairsCount == 0 {
      return Failure(""Deserialization Error: Key value pairs count is 0."");
    }
    var kvPairs: EncryptionContext.Linear := [];
    var i := 0;
    ghost var startKvPos := rd.reader.pos;
    ghost var unsortedKvPairs: EncryptionContext.Linear := [];
    while i < kvPairsCount
      invariant startKvPos <= rd.reader.pos
      invariant rd.Valid()
      invariant |kvPairs| == i as int
      invariant i <= kvPairsCount
      invariant |kvPairs| == |unsortedKvPairs|
      invariant forall kvPair: (UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes) :: kvPair in kvPairs <==> kvPair in unsortedKvPairs
      invariant totalBytesRead == 2 + EncryptionContext.LinearLength(kvPairs, 0, i as nat) <= kvPairsLength as nat
      invariant totalBytesRead == |rd.reader.data[old(rd.reader.pos) .. rd.reader.pos]| - 2
      invariant EncryptionContext.SerializableLinear(kvPairs)
      invariant EncryptionContext.SerializableUnsortedLinear(unsortedKvPairs)
      invariant rd.reader.data[startKvPos .. rd.reader.pos] == EncryptionContext.LinearToUnorderedSeq(unsortedKvPairs, 0, |unsortedKvPairs|)
      decreases kvPairsCount as int - i as int
    {
      ghost var oldPosPair := rd.reader.pos;
      ghost var oldKvPairs := kvPairs;
      ghost var oldunsortedKvPairs := unsortedKvPairs;
      var keyLength :- rd.ReadUInt16();
      totalBytesRead := totalBytesRead + 2;
      var key :- DeserializeUTF8(rd, keyLength as nat);
      totalBytesRead := totalBytesRead + |key|;
      var valueLength :- rd.ReadUInt16();
      totalBytesRead := totalBytesRead + 2;
      if kvPairsLength as nat < totalBytesRead + valueLength as nat {
        return Failure(""Deserialization Error: The number of bytes in encryption context exceeds the given length."");
      }
      var value :- DeserializeUTF8(rd, valueLength as nat);
      totalBytesRead := totalBytesRead + |value|;
      var opt, insertionPoint := InsertNewEntry(kvPairs, key, value);
      match opt {
        case {:split false} Some(kvPairs_) =>
          EncryptionContext.LinearInsert(kvPairs, insertionPoint, key, value);
          kvPairs := kvPairs_;
          unsortedKvPairs := unsortedKvPairs + [(key, value)];
        case {:split false} None() =>
          return Failure(""Deserialization Error: Duplicate key."");
      }
      i := i + 1;
      assert EncryptionContext.KVPairToSeq((key, value)) == rd.reader.data[oldPosPair .. rd.reader.pos] by {
        assert rd.reader.data[oldPosPair .. rd.reader.pos] == rd.reader.data[oldPosPair .. oldPosPair + 4 + |key| + |value|];
        assert UInt16ToSeq(|key| as uint16) == rd.reader.data[oldPosPair .. oldPosPair + 2];
        assert key == rd.reader.data[oldPosPair + 2 .. oldPosPair + 2 + |key|];
        assert UInt16ToSeq(|value| as uint16) == rd.reader.data[oldPosPair + 2 + |key| .. oldPosPair + 2 + |key| + 2];
        assert value == rd.reader.data[oldPosPair + 4 + |key| .. oldPosPair + 4 + |key| + |value|];
      }
      assert forall p: (UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes) :: p in oldKvPairs || p == (key, value) <==> p in kvPairs;
      assert rd.reader.data[startKvPos .. rd.reader.pos] == EncryptionContext.LinearToUnorderedSeq(unsortedKvPairs, 0, |unsortedKvPairs|) by {
        EncryptionContext.LinearToUnorderedSeqInductiveStep(oldunsortedKvPairs, [(key, value)], 0, |oldunsortedKvPairs|);
        assert EncryptionContext.LinearToUnorderedSeq(unsortedKvPairs, 0, |unsortedKvPairs| - 1) == rd.reader.data[startKvPos .. oldPosPair];
        assert EncryptionContext.KVPairToSeq(unsortedKvPairs[|unsortedKvPairs| - 1]) == rd.reader.data[oldPosPair .. rd.reader.pos];
        assert rd.reader.data[startKvPos .. rd.reader.pos] == rd.reader.data[startKvPos .. oldPosPair] + rd.reader.data[oldPosPair .. rd.reader.pos];
      }
    }
    if kvPairsLength as nat != totalBytesRead {
      return Failure(""Deserialization Error: Bytes actually read differs from bytes supposed to be read."");
    }
    var encryptionContext: map<UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes> := EncryptionContext.LinearToMap(kvPairs);
    var isValid := EncryptionContext.CheckSerializable(encryptionContext);
    if !isValid || |kvPairs| != |encryptionContext| {
      return Failure(""Deserialization Error: Failed to parse encryption context."");
    }
    SerializationIsValid(rd.reader.data[old(rd.reader.pos) .. rd.reader.pos], encryptionContext, unsortedKvPairs, kvPairs);
    return Success(encryptionContext);
  }

  lemma /*{:_induction unsortedKvPairs, kvPairs}*/ SerializationIsValid(sequence: seq<uint8>, resultMap: EncryptionContext.Map, unsortedKvPairs: EncryptionContext.Linear, kvPairs: EncryptionContext.Linear)
    requires |resultMap| == 0 ==> |sequence| == 2
    requires |resultMap| != 0 ==> 4 <= |sequence|
    requires EncryptionContext.Serializable(resultMap)
    requires |resultMap| == |kvPairs| == |unsortedKvPairs|
    requires forall kvPair: (UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes) :: kvPair in kvPairs <==> kvPair in unsortedKvPairs
    requires EncryptionContext.SerializableUnsortedLinear(unsortedKvPairs)
    requires EncryptionContext.SerializableLinear(kvPairs)
    requires (reveal EncryptionContext.Serializable(); EncryptionContext.Serializable(resultMap) && EncryptionContext.SerializableLinear(kvPairs) ==> EncryptionContext.MapToSeq(resultMap) == if |resultMap| == 0 then [] else UInt16ToSeq(|kvPairs| as uint16) + EncryptionContext.LinearToSeq(kvPairs, 0, |kvPairs|))
    requires |sequence[2..]| < UINT16_LIMIT && sequence[..2] == UInt16ToSeq(|sequence[2..]| as uint16)
    requires |resultMap| != 0 ==> sequence[2..][..2] == UInt16ToSeq(|resultMap| as uint16)
    requires |resultMap| != 0 ==> sequence[4..] == EncryptionContext.LinearToUnorderedSeq(unsortedKvPairs, 0, |unsortedKvPairs|)
    ensures EncryptionContext.LinearSeqToMap(sequence, resultMap)
    decreases sequence, resultMap, unsortedKvPairs, kvPairs
  {
    reveal EncryptionContext.Serializable();
    if |resultMap| == 0 {
    } else {
      assert EncryptionContext.LinearSeqToMap(sequence, resultMap) by {
        assert EncryptionContext.SeqToMap(sequence[2..], resultMap) by {
          EncryptionContext.InsertionSortPreservesProperties(unsortedKvPairs);
          EncryptionContext.SortedSequenceIsUnqiue(kvPairs, EncryptionContext.InsertionSort(unsortedKvPairs));
          assert EncryptionContext.SeqToLinearToMap(sequence[2..], resultMap, unsortedKvPairs, kvPairs) by {
            assert 2 <= |sequence[2..]|;
            assert EncryptionContext.SerializableUnsortedLinear(unsortedKvPairs);
            assert EncryptionContext.SerializableLinear(kvPairs);
            assert EncryptionContext.SerializableKVPairs(resultMap);
            assert sequence[2..][..2] == UInt16ToSeq(|resultMap| as uint16);
            assert EncryptionContext.LinearToUnorderedSeq(unsortedKvPairs, 0, |unsortedKvPairs|) == sequence[2..][2..];
            assert kvPairs == EncryptionContext.InsertionSort(unsortedKvPairs);
            assert EncryptionContext.MapToSeq(resultMap) == sequence[2..][..2] + EncryptionContext.LinearToSeq(kvPairs, 0, |kvPairs|);
          }
          assert sequence[..2] == UInt16ToSeq(|sequence[2..]| as uint16);
        }
      }
    }
  }

  method InsertNewEntry(kvPairs: EncryptionContext.Linear, key: UTF8.ValidUTF8Bytes, value: UTF8.ValidUTF8Bytes)
      returns (res: Option<EncryptionContext.Linear>, ghost insertionPoint: nat)
    requires EncryptionContext.LinearSorted(kvPairs)
    requires forall i: int, j: int | 0 <= i < j < |kvPairs| :: kvPairs[i].0 != kvPairs[j].0
    ensures (exists l: (UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes) | l in kvPairs :: key == l.0) <==> res.None?
    ensures match res { case None => (exists i :: 0 <= i < |kvPairs| && kvPairs[i].0 == key) case Some(_mcc#0) => var kvPairs' := _mcc#0; insertionPoint <= |kvPairs| && kvPairs' == kvPairs[..insertionPoint] + [(key, value)] + kvPairs[insertionPoint..] && EncryptionContext.LinearSorted(kvPairs') && forall i, j | 0 <= i < j < |kvPairs'| :: kvPairs'[i].0 != kvPairs'[j].0 }
    decreases kvPairs, key, value
  {
    var n := |kvPairs|;
    while 0 < n && LexicographicLessOrEqual(key, kvPairs[n - 1].0, UInt.UInt8Less)
      invariant 0 <= n <= |kvPairs|
      invariant forall i: int :: n <= i < |kvPairs| ==> LexicographicLessOrEqual(key, kvPairs[i].0, UInt.UInt8Less)
      invariant forall i: int | n < i < |kvPairs| :: kvPairs[i].0 != key
      decreases n - 0
    {
      n := n - 1;
    }
    EncryptionContext.LinearSortedImpliesStrongLinearSorted(kvPairs);
    if kvPairs != [] && LexicographicLessOrEqual(key, kvPairs[|kvPairs| - 1].0, UInt.UInt8Less) && kvPairs[n].0 == key {
      return None, n;
    } else {
      var kvPairs' := kvPairs[..n] + [(key, value)] + kvPairs[n..];
      if 0 < n {
        LexIsTotal(kvPairs'[n - 1].0, kvPairs'[n].0, UInt.UInt8Less);
      }
      return Some(kvPairs'), n;
    }
  }

  method DeserializeEncryptedDataKeys(rd: Streams.ByteReader) returns (ret: Result<Msg.EncryptedDataKeys, string>)
    requires rd.Valid()
    modifies rd.reader`pos
    ensures rd.Valid()
    ensures match ret { case Success(_mcc#0) => (var edks := _mcc#0; edks.Valid() && var n := |Msg.EDKsToSeq(edks)|; old(rd.reader.pos) + n == rd.reader.pos && Msg.EDKsToSeq(edks) == rd.reader.data[old(rd.reader.pos) .. rd.reader.pos]) case Failure(_mcc#1) => true }
    decreases rd
  {
    var edkCount :- rd.ReadUInt16();
    if edkCount == 0 {
      return Failure(""Deserialization Error: Encrypted data key count is 0."");
    }
    assert rd.reader.pos == old(rd.reader.pos) + 2;
    var edkEntries: seq<Crypto.EncryptedDataKey> := [];
    var i := 0;
    while i < edkCount
      invariant old(rd.reader.pos) + 2 <= rd.reader.pos
      invariant rd.Valid()
      invariant i <= edkCount
      invariant |edkEntries| == i as int
      invariant forall i: int :: 0 <= i < |edkEntries| ==> edkEntries[i].Valid()
      invariant Msg.EDKEntriesToSeq(edkEntries, 0, |edkEntries|) == rd.reader.data[old(rd.reader.pos) + 2 .. rd.reader.pos]
      decreases edkCount as int - i as int
    {
      ghost var edkStartPos := rd.reader.pos;
      ghost var providerIdStartPos := edkStartPos;
      var providerIdLength :- rd.ReadUInt16();
      var str :- DeserializeUTF8(rd, providerIdLength as nat);
      var providerId := str;
      assert rd.reader.pos == providerIdStartPos + 2 + |providerId|;
      assert UInt16ToSeq(|providerId| as uint16) + providerId == rd.reader.data[providerIdStartPos .. rd.reader.pos];
      ghost var providerInfoStartPos := rd.reader.pos;
      var providerInfoLength :- rd.ReadUInt16();
      var providerInfo :- rd.ReadBytes(providerInfoLength as nat);
      assert rd.reader.pos == providerInfoStartPos + 2 + |providerInfo|;
      assert UInt16ToSeq(|providerInfo| as uint16) + providerInfo == rd.reader.data[providerInfoStartPos .. rd.reader.pos];
      ghost var ciphertextStartPos := rd.reader.pos;
      var ciphertextLength :- rd.ReadUInt16();
      var ciphertext :- rd.ReadBytes(ciphertextLength as nat);
      assert rd.reader.pos == ciphertextStartPos + 2 + |ciphertext|;
      assert UInt16ToSeq(|ciphertext| as uint16) + ciphertext == rd.reader.data[ciphertextStartPos .. rd.reader.pos];
      edkEntries := edkEntries + [Crypto.EncryptedDataKey(keyProviderId := providerId, keyProviderInfo := providerInfo, ciphertext := ciphertext)];
      i := i + 1;
      assert edkStartPos + 2 + |providerId| + 2 + |providerInfo| + 2 + |ciphertext| == rd.reader.pos;
      assert Msg.EDKEntriesToSeq(edkEntries, 0, |edkEntries|) == rd.reader.data[old(rd.reader.pos) + 2 .. rd.reader.pos] by {
        assert UInt16ToSeq(|providerId| as uint16) + providerId == rd.reader.data[edkStartPos .. edkStartPos + 2 + |providerId|];
        assert UInt16ToSeq(|providerInfo| as uint16) + providerInfo == rd.reader.data[edkStartPos + 2 + |providerId| .. edkStartPos + 2 + |providerId| + 2 + |providerInfo|];
        assert Msg.EDKEntryToSeq(Crypto.EncryptedDataKey(keyProviderId := providerId, keyProviderInfo := providerInfo, ciphertext := ciphertext)) == rd.reader.data[edkStartPos .. rd.reader.pos];
        Msg.EDKEntriesToSeqInductiveStep(edkEntries[..|edkEntries| - 1], [Crypto.EncryptedDataKey(keyProviderId := providerId, keyProviderInfo := providerInfo, ciphertext := ciphertext)], 0, |edkEntries[..|edkEntries| - 1]|);
      }
    }
    assert |edkEntries| == edkCount as int;
    var edks := Msg.EncryptedDataKeys(edkEntries);
    return Success(edks);
  }

  method DeserializeContentType(rd: Streams.ByteReader) returns (ret: Result<Msg.ContentType, string>)
    requires rd.Valid()
    modifies rd.reader`pos
    ensures rd.Valid()
    ensures match ret { case Success(_mcc#0) => (var contentType := _mcc#0; old(rd.reader.pos) + 1 == rd.reader.pos && [Msg.ContentTypeToUInt8(contentType)] == rd.reader.data[old(rd.reader.pos) .. rd.reader.pos]) case Failure(_mcc#1) => true }
    decreases rd
  {
    var byte :- rd.ReadByte();
    match Msg.UInt8ToContentType(byte)
    case {:split false} None() =>
      return Failure(""Deserialization Error: Content type not supported."");
    case {:split false} Some(contentType) =>
      return Success(contentType);
  }

  method DeserializeReserved(rd: Streams.ByteReader) returns (ret: Result<seq<uint8>, string>)
    requires rd.Valid()
    modifies rd.reader`pos
    ensures rd.Valid()
    ensures match ret { case Success(_mcc#0) => (var contnetType := _mcc#0; old(rd.reader.pos) + 4 == rd.reader.pos && Msg.Reserved == rd.reader.data[old(rd.reader.pos) .. rd.reader.pos]) case Failure(_mcc#1) => true }
    decreases rd
  {
    var reserved :- rd.ReadBytes(4);
    if reserved == Msg.Reserved {
      return Success(reserved);
    } else {
      return Failure(""Deserialization Error: Reserved fields must be 0."");
    }
  }
}

module {:extern ""EncryptDecrypt""} EncryptDecrypt {

  import opened Wrappers = Wrappers

  import opened StandardLibrary = StandardLibrary

  import opened UInt = StandardLibrary.UInt

  import Crypto = Aws.Crypto

  import EncryptionContext = EncryptionContext

  import AlgorithmSuite = AlgorithmSuite

  import AESEncryption = AESEncryption

  import DefaultCMMDef = DefaultCMMDef

  import Deserialize = Deserialize

  import HKDF = HKDF

  import KeyDerivationAlgorithms = KeyDerivationAlgorithms

  import Materials = Materials

  import Msg = MessageHeader

  import MessageBody = MessageBody

  import Random = Random

  import Serialize = Serialize

  import Signature = Signature

  import Streams = Streams
  datatype EncryptRequest = EncryptRequest(plaintext: seq<uint8>, cmm: Crypto.ICryptographicMaterialsManager?, keyring: Crypto.IKeyring?, plaintextLength: nat, encryptionContext: EncryptionContext.Map, algorithmSuiteID: Option<uint16>, frameLength: Option<uint32>) {
    static function method WithCMM(plaintext: seq<uint8>, cmm: Crypto.ICryptographicMaterialsManager): EncryptRequest
      decreases plaintext, cmm
    {
      EncryptRequest(plaintext, cmm, null, |plaintext|, map[], None, None)
    }

    static function method WithKeyring(plaintext: seq<uint8>, keyring: Crypto.IKeyring): EncryptRequest
      decreases plaintext, keyring
    {
      EncryptRequest(plaintext, null, keyring, |plaintext|, map[], None, None)
    }

    function method SetEncryptionContext(encryptionContext: EncryptionContext.Map): EncryptRequest
      decreases this, encryptionContext
    {
      this.(encryptionContext := encryptionContext)
    }

    function method SetAlgorithmSuiteID(algorithmSuiteID: uint16): EncryptRequest
      decreases this, algorithmSuiteID
    {
      this.(algorithmSuiteID := Some(algorithmSuiteID))
    }

    function method SetFrameLength(frameLength: uint32): EncryptRequest
      decreases this, frameLength
    {
      this.(frameLength := Some(frameLength))
    }
  }

  datatype DecryptRequest = DecryptRequest(message: seq<uint8>, cmm: Crypto.ICryptographicMaterialsManager?, keyring: Crypto.IKeyring?) {
    static function method WithCMM(message: seq<uint8>, cmm: Crypto.ICryptographicMaterialsManager): DecryptRequest
      decreases message, cmm
    {
      DecryptRequest(message, cmm, null)
    }

    static function method WithKeyring(message: seq<uint8>, keyring: Crypto.IKeyring): DecryptRequest
      decreases message, keyring
    {
      DecryptRequest(message, null, keyring)
    }
  }

  datatype DecryptResultWithVerificationInfo = DecryptResultWithVerificationInfo(plaintext: seq<uint8>, ghost header: Msg.Header, ghost hbSeq: seq<uint8>, ghost frames: seq<MessageBody.Frame>, ghost signature: Option<seq<uint8>>)

  const DEFAULT_FRAME_LENGTH: uint32 := 4096

  function SerializeMessageWithSignature(headerBody: Msg.HeaderBody, headerAuthentication: Msg.HeaderAuthentication, frames: seq<MessageBody.Frame>, signature: seq<uint8>): (message: seq<uint8>)
    requires forall frame: MessageBody.Frame | frame in frames :: frame.Valid()
    requires headerBody.Valid()
    requires |signature| < UINT16_LIMIT
    decreases headerBody, headerAuthentication, frames, signature
  {
    ghost var serializedSignature: seq<uint8> := UInt16ToSeq(|signature| as uint16) + signature;
    SerializeMessageWithoutSignature(headerBody, headerAuthentication, frames) + serializedSignature
  }

  function SerializeMessageWithoutSignature(headerBody: Msg.HeaderBody, headerAuthentication: Msg.HeaderAuthentication, frames: seq<MessageBody.Frame>): (message: seq<uint8>)
    requires forall frame: MessageBody.Frame | frame in frames :: frame.Valid()
    requires headerBody.Valid()
    decreases headerBody, headerAuthentication, frames
  {
    ghost var serializedHeaderBody: seq<uint8> := (reveal Msg.HeaderBodyToSeq(); Msg.HeaderBodyToSeq(headerBody));
    ghost var serializedHeaderAuthentication: seq<uint8> := headerAuthentication.iv + headerAuthentication.authenticationTag;
    ghost var serializedFrames: seq<uint8> := MessageBody.FramesToSequence(frames);
    serializedHeaderBody + serializedHeaderAuthentication + serializedFrames
  }

  predicate ValidHeaderBodyForRequest(headerBody: Msg.HeaderBody, request: EncryptRequest)
    decreases headerBody, request
  {
    headerBody.Valid() &&
    headerBody.version == Msg.VERSION_1 &&
    headerBody.typ == Msg.TYPE_CUSTOMER_AED &&
    headerBody.contentType == Msg.ContentType.Framed &&
    headerBody.frameLength == if request.frameLength.Some? then request.frameLength.value else DEFAULT_FRAME_LENGTH
  }

  predicate ValidHeaderAuthenticationForRequest(headerAuthentication: Msg.HeaderAuthentication, headerBody: Msg.HeaderBody)
    requires headerBody.Valid()
    decreases headerAuthentication, headerBody
  {
    ghost var serializedHeaderBody: seq<uint8> := (reveal Msg.HeaderBodyToSeq(); Msg.HeaderBodyToSeq(headerBody));
    headerAuthentication.iv == seq(headerBody.algorithmSuiteID.IVLength(), (_: int) => 0) &&
    Msg.HeaderAuthenticationMatchesHeaderBody(headerAuthentication, headerBody) &&
    exists encryptionOutput: AESEncryption.EncryptionOutput, cipherkey: seq<uint8> | IsDerivedKey(cipherkey) :: 
      AESEncryption.EncryptedWithKey(encryptionOutput.cipherText, cipherkey)
  }

  predicate ValidFramesForRequest(frames: seq<MessageBody.Frame>, request: EncryptRequest, headerBody: Msg.HeaderBody)
    decreases frames, request, headerBody
  {
    (forall frame: MessageBody.Frame | frame in frames :: 
      frame.Valid()) &&
    MessageBody.FramesEncryptPlaintext(frames, request.plaintext) &&
    (forall frame: MessageBody.Frame | frame in frames :: 
      |frame.iv| == headerBody.algorithmSuiteID.IVLength()) &&
    exists cipherkey: seq<uint8> | IsDerivedKey(cipherkey) :: 
      forall frame: MessageBody.Frame | frame in frames :: 
        AESEncryption.EncryptedWithKey(frame.encContent, cipherkey)
  }

  predicate ValidSignatureForRequest(signature: seq<uint8>, headerBody: Msg.HeaderBody, headerAuthentication: Msg.HeaderAuthentication, frames: seq<MessageBody.Frame>)
    requires forall frame: MessageBody.Frame | frame in frames :: frame.Valid()
    requires headerBody.Valid()
    decreases signature, headerBody, headerAuthentication, frames
  {
    ghost var serializedMessage: seq<uint8> := SerializeMessageWithoutSignature(headerBody, headerAuthentication, frames);
    |signature| < UINT16_LIMIT &&
    exists material: Crypto.EncryptionMaterials | material.signingKey.Some? :: 
      Signature.IsSigned(material.signingKey.value, serializedMessage, signature)
  }

  method Encrypt(request: EncryptRequest) returns (res: Result<seq<uint8>, string>)
    ensures request.cmm == null && request.keyring == null ==> res.Failure?
    ensures request.cmm != null && request.keyring != null ==> res.Failure?
    ensures request.algorithmSuiteID.Some? && request.algorithmSuiteID.value !in AlgorithmSuite.VALID_IDS ==> res.Failure?
    ensures request.frameLength.Some? && request.frameLength.value == 0 ==> res.Failure?
    ensures match res { case Success(_mcc#0) => (var encryptedSequence := _mcc#0; exists headerBody, headerAuthentication, frames :: ValidHeaderBodyForRequest(headerBody, request) && ValidHeaderAuthenticationForRequest(headerAuthentication, headerBody) && ValidFramesForRequest(frames, request, headerBody) && match headerBody.algorithmSuiteID.SignatureType() { case Some(_v1) => (exists signature | ValidSignatureForRequest(signature, headerBody, headerAuthentication, frames) :: encryptedSequence == SerializeMessageWithSignature(headerBody, headerAuthentication, frames, signature)) case None => encryptedSequence == SerializeMessageWithoutSignature(headerBody, headerAuthentication, frames) }) case Failure(_mcc#1) => var e := _mcc#1; true }
    decreases request
  {
    if request.cmm != null && request.keyring != null {
      return Failure(""EncryptRequest.keyring OR EncryptRequest.cmm must be set (not both)."");
    } else if request.cmm == null && request.keyring == null {
      return Failure(""EncryptRequest.cmm and EncryptRequest.keyring cannot both be null."");
    } else if request.algorithmSuiteID.Some? && request.algorithmSuiteID.value !in AlgorithmSuite.VALID_IDS {
      return Failure(""Invalid algorithmSuiteID."");
    } else if request.frameLength.Some? && request.frameLength.value == 0 {
      return Failure(""Request frameLength must be > 0"");
    }
    var cmm: Crypto.ICryptographicMaterialsManager;
    if request.keyring == null {
      cmm := request.cmm;
    } else {
      cmm := new DefaultCMMDef.DefaultCMM.OfKeyring(request.keyring);
    }
    var frameLength := if request.frameLength.Some? then request.frameLength.value else DEFAULT_FRAME_LENGTH;
    var algorithmSuiteID := if request.algorithmSuiteID.Some? then Some(AlgorithmSuite.InternalIDToPolymorphID(request.algorithmSuiteID.value as AlgorithmSuite.ID)) else None;
    expect request.plaintextLength < INT64_MAX_LIMIT, ""expectation violation""
    var encMatRequest := Crypto.GetEncryptionMaterialsInput(encryptionContext := request.encryptionContext, algorithmSuiteId := algorithmSuiteID, maxPlaintextLength := Option.Some(request.plaintextLength as int64));
    var output :- cmm.GetEncryptionMaterials(encMatRequest);
    var encMat := output.encryptionMaterials;
    expect encMat.plaintextDataKey.Some?, ""expectation violation""
    expect algorithmSuiteID.None? || (request.algorithmSuiteID.value as AlgorithmSuite.ID).SignatureType().Some? ==> Materials.EC_PUBLIC_KEY_FIELD in encMat.encryptionContext, ""expectation violation""
    expect DefaultCMMDef.Serializable(encMat), ""expectation violation""
    expect match request.algorithmSuiteID { case None => AlgorithmSuite.PolymorphIDToInternalID(encMat.algorithmSuiteId) == 888 as AlgorithmSuite.ID case Some(_mcc#3) => var id := _mcc#3; AlgorithmSuite.PolymorphIDToInternalID(encMat.algorithmSuiteId) == id as AlgorithmSuite.ID }, ""expectation violation""
    expect |encMat.plaintextDataKey.value| == AlgorithmSuite.PolymorphIDToInternalID(encMat.algorithmSuiteId).KDFInputKeyLength(), ""expectation violation""
    if UINT16_LIMIT <= |encMat.encryptedDataKeys| {
      return Failure(""Number of EDKs exceeds the allowed maximum."");
    }
    var messageID: Msg.MessageID :- Random.GenerateBytes(Msg.MESSAGE_ID_LEN as int32);
    var derivedDataKey := DeriveKey(encMat.plaintextDataKey.value, AlgorithmSuite.PolymorphIDToInternalID(encMat.algorithmSuiteId), messageID);
    var headerBody := Msg.HeaderBody(Msg.VERSION_1, Msg.TYPE_CUSTOMER_AED, AlgorithmSuite.PolymorphIDToInternalID(encMat.algorithmSuiteId), messageID, encMat.encryptionContext, Msg.EncryptedDataKeys(encMat.encryptedDataKeys), Msg.ContentType.Framed, AlgorithmSuite.PolymorphIDToInternalID(encMat.algorithmSuiteId).IVLength() as uint8, frameLength);
    assert ValidHeaderBodyForRequest(headerBody, request);
    ghost var serializedHeaderBody := (reveal Msg.HeaderBodyToSeq(); Msg.HeaderBodyToSeq(headerBody));
    var wr := new Streams.ByteWriter();
    var _ :- Serialize.SerializeHeaderBody(wr, headerBody);
    var unauthenticatedHeader := wr.GetDataWritten();
    assert unauthenticatedHeader == serializedHeaderBody;
    var iv: seq<uint8> := seq(AlgorithmSuite.PolymorphIDToInternalID(encMat.algorithmSuiteId).IVLength(), (_: int) => 0);
    var encryptionOutput :- AESEncryption.AESEncryptExtern(AlgorithmSuite.PolymorphIDToInternalID(encMat.algorithmSuiteId).EncryptionSuite(), iv, derivedDataKey, [], unauthenticatedHeader);
    var headerAuthentication := Msg.HeaderAuthentication(iv, encryptionOutput.authTag);
    assert ValidHeaderAuthenticationForRequest(headerAuthentication, headerBody) by {
      assert headerAuthentication.iv == seq(headerBody.algorithmSuiteID.IVLength(), (_: int) => 0);
      assert Msg.HeaderAuthenticationMatchesHeaderBody(headerAuthentication, headerBody);
      assert IsDerivedKey(derivedDataKey) && AESEncryption.EncryptedWithKey(encryptionOutput.cipherText, derivedDataKey);
    }
    ghost var serializedHeaderAuthentication := headerAuthentication.iv + headerAuthentication.authenticationTag;
    var _ :- Serialize.SerializeHeaderAuthentication(wr, headerAuthentication, AlgorithmSuite.PolymorphIDToInternalID(encMat.algorithmSuiteId));
    assert wr.GetDataWritten() == serializedHeaderBody + serializedHeaderAuthentication;
    var seqWithGhostFrames :- MessageBody.EncryptMessageBody(request.plaintext, frameLength as int, messageID, derivedDataKey, AlgorithmSuite.PolymorphIDToInternalID(encMat.algorithmSuiteId));
    var body := seqWithGhostFrames.sequence;
    ghost var frames := seqWithGhostFrames.frames;
    assert ValidFramesForRequest(frames, request, headerBody) && body == MessageBody.FramesToSequence(frames) by {
      assert forall frame: MessageBody.Frame | frame in frames :: frame.Valid();
      assert MessageBody.FramesEncryptPlaintext(frames, request.plaintext);
      assert forall frame: MessageBody.Frame | frame in frames :: |frame.iv| == headerBody.algorithmSuiteID.IVLength();
      assert IsDerivedKey(derivedDataKey);
      assert forall frame: MessageBody.Frame | frame in frames :: AESEncryption.EncryptedWithKey(frame.encContent, derivedDataKey);
    }
    var msg := wr.GetDataWritten() + body;
    if AlgorithmSuite.PolymorphIDToInternalID(encMat.algorithmSuiteId).SignatureType().Some? {
      var ecdsaParams := AlgorithmSuite.PolymorphIDToInternalID(encMat.algorithmSuiteId).SignatureType().value;
      expect encMat.signingKey.Some?, ""expectation violation""
      var bytes :- Signature.Sign(ecdsaParams, encMat.signingKey.value, msg);
      if |bytes| != ecdsaParams.SignatureLength() as int {
        return Failure(""Malformed response from Sign()."");
      }
      var signature := UInt16ToSeq(|bytes| as uint16) + bytes;
      assert ValidSignatureForRequest(bytes, headerBody, headerAuthentication, frames) by {
        assert |signature| < UINT16_LIMIT;
        assert Signature.IsSigned(encMat.signingKey.value, msg, bytes);
      }
      msg := msg + signature;
      assert headerBody.algorithmSuiteID.SignatureType().Some?;
      assert msg == SerializeMessageWithSignature(headerBody, headerAuthentication, frames, bytes);
      return Success(msg);
    } else {
      assert msg == SerializeMessageWithoutSignature(headerBody, headerAuthentication, frames);
      return Success(msg);
    }
  }

  method DeriveKey(plaintextDataKey: seq<uint8>, algorithmSuiteID: AlgorithmSuite.ID, messageID: Msg.MessageID)
      returns (derivedDataKey: seq<uint8>)
    requires |plaintextDataKey| == algorithmSuiteID.KDFInputKeyLength()
    ensures |derivedDataKey| == algorithmSuiteID.KeyLength()
    ensures IsDerivedKey(derivedDataKey)
    decreases plaintextDataKey, algorithmSuiteID, messageID
  {
    var algorithm := AlgorithmSuite.Suite[algorithmSuiteID].hkdf;
    if algorithm == KeyDerivationAlgorithms.IDENTITY {
      assert IsDerivedKey(plaintextDataKey) by {
        reveal IsDerivedKey();
      }
      return plaintextDataKey;
    }
    var infoSeq := UInt16ToSeq(algorithmSuiteID as uint16) + messageID;
    var len := algorithmSuiteID.KeyLength();
    var derivedKey := HKDF.Hkdf(algorithm, None, plaintextDataKey, infoSeq, len);
    assert IsDerivedKey(derivedKey) by {
      reveal IsDerivedKey();
    }
    return derivedKey;
  }

  predicate {:opaque} {:fuel 0, 0} IsDerivedKey(derivedDataKey: seq<uint8>)
    decreases derivedDataKey
  {
    true
  }

  method Decrypt(request: DecryptRequest) returns (res: Result<seq<uint8>, string>)
    ensures request.cmm == null && request.keyring == null ==> res.Failure?
    ensures request.cmm != null && request.keyring != null ==> res.Failure?
    decreases request
  {
    var decryptWithVerificationInfo :- DecryptWithVerificationInfo(request);
    return Success(decryptWithVerificationInfo.plaintext);
  }

  method DecryptWithVerificationInfo(request: DecryptRequest) returns (res: Result<DecryptResultWithVerificationInfo, string>)
    ensures request.cmm == null && request.keyring == null ==> res.Failure?
    ensures request.cmm != null && request.keyring != null ==> res.Failure?
    ensures match res { case Success(_mcc#0) => (var d := _mcc#0; d.header.body.Valid() && Msg.IsSerializationOfHeaderBody(d.hbSeq, d.header.body) && (d.header.body.contentType.Framed? ==> (forall frame: MessageBody.Frame | frame in d.frames :: frame.Valid()) && MessageBody.FramesEncryptPlaintext(d.frames, d.plaintext) && match d.signature { case Some(_v6) => |d.signature.value| < UINT16_LIMIT && request.message == d.hbSeq + d.header.auth.iv + d.header.auth.authenticationTag + MessageBody.FramesToSequence(d.frames) + UInt16ToSeq(|d.signature.value| as uint16) + d.signature.value case None => request.message == d.hbSeq + d.header.auth.iv + d.header.auth.authenticationTag + MessageBody.FramesToSequence(d.frames) })) case Failure(_mcc#1) => var e := _mcc#1; true }
    decreases request
  {
    if request.cmm != null && request.keyring != null {
      return Failure(""DecryptRequest.keyring OR DecryptRequest.cmm must be set (not both)."");
    } else if request.cmm == null && request.keyring == null {
      return Failure(""DecryptRequest.cmm and DecryptRequest.keyring cannot both be null."");
    }
    var cmm: Crypto.ICryptographicMaterialsManager;
    if request.keyring == null {
      cmm := request.cmm;
    } else {
      cmm := new DefaultCMMDef.DefaultCMM.OfKeyring(request.keyring);
    }
    var rd := new Streams.ByteReader(request.message);
    var deserializeHeaderResult :- Deserialize.DeserializeHeader(rd);
    var header := deserializeHeaderResult.header;
    if header.body.contentType.Framed? {
      assert HeaderBySequence(header, deserializeHeaderResult.hbSeq, rd.reader.data[..rd.reader.pos]) by {
        reveal HeaderBySequence();
        assert header.body.contentType.Framed?;
        assert header.body.Valid();
        assert Msg.IsSerializationOfHeaderBody(deserializeHeaderResult.hbSeq, header.body);
        assert rd.reader.data[..rd.reader.pos] == deserializeHeaderResult.hbSeq + header.auth.iv + header.auth.authenticationTag;
      }
      assert DataIsFramed(request.message) by {
        assert 0 <= rd.reader.pos <= |request.message|;
        assert rd.reader.data[..rd.reader.pos] == request.message[..rd.reader.pos];
        assert HeaderBySequence(header, deserializeHeaderResult.hbSeq, request.message[..rd.reader.pos]);
      }
    }
    var decMatRequest := Crypto.DecryptMaterialsInput(algorithmSuiteId := AlgorithmSuite.InternalIDToPolymorphID(header.body.algorithmSuiteID), encryptedDataKeys := header.body.encryptedDataKeys.entries, encryptionContext := header.body.aad);
    var output :- cmm.DecryptMaterials(decMatRequest);
    var decMat := output.decryptionMaterials;
    expect decMat.plaintextDataKey.Some?, ""expectation violation""
    expect |decMat.plaintextDataKey.value| == AlgorithmSuite.PolymorphIDToInternalID(decMat.algorithmSuiteId).KDFInputKeyLength(), ""expectation violation""
    var decryptionKey := DeriveKey(decMat.plaintextDataKey.value, AlgorithmSuite.PolymorphIDToInternalID(decMat.algorithmSuiteId), header.body.messageID);
    ghost var endHeaderPos := rd.reader.pos;
    var plaintext;
    match header.body.contentType {
      case {:split false} NonFramed() =>
        plaintext :- MessageBody.DecryptNonFramedMessageBody(rd, AlgorithmSuite.PolymorphIDToInternalID(decMat.algorithmSuiteId), decryptionKey, header.body.messageID);
      case {:split false} Framed() =>
        plaintext :- MessageBody.DecryptFramedMessageBody(rd, AlgorithmSuite.PolymorphIDToInternalID(decMat.algorithmSuiteId), decryptionKey, header.body.frameLength as int, header.body.messageID);
    }
    assert header.body.contentType.Framed? ==> exists frames: seq<MessageBody.Frame> | |frames| < UINT32_LIMIT && (forall frame: MessageBody.Frame | frame in frames :: frame.Valid()) && MessageBody.FramesToSequence(frames) == rd.reader.data[endHeaderPos .. rd.reader.pos] :: true && MessageBody.FramesEncryptPlaintext(frames, plaintext);
    ghost var frames: seq<MessageBody.Frame> :| header.body.contentType.Framed? ==> |frames| < UINT32_LIMIT && (forall frame: MessageBody.Frame | frame in frames :: frame.Valid()) && MessageBody.FramesToSequence(frames) == rd.reader.data[endHeaderPos .. rd.reader.pos] && MessageBody.FramesEncryptPlaintext(frames, plaintext);
    if header.body.contentType.Framed? {
      assert FramesBySequence(frames, rd.reader.data[endHeaderPos .. rd.reader.pos]) by {
        reveal FramesBySequence();
        assert |frames| < UINT32_LIMIT;
        assert forall frame: MessageBody.Frame | frame in frames :: frame.Valid();
        assert rd.reader.data[endHeaderPos .. rd.reader.pos] == MessageBody.FramesToSequence(frames);
      }
      assert HeaderBySequence(header, deserializeHeaderResult.hbSeq, rd.reader.data[..endHeaderPos]) by {
        assert endHeaderPos == |deserializeHeaderResult.hbSeq| + |header.auth.iv + header.auth.authenticationTag|;
        assert HeaderBySequence(header, deserializeHeaderResult.hbSeq, rd.reader.data[..endHeaderPos]);
      }
      assert FramesBySequence(frames, rd.reader.data[endHeaderPos .. rd.reader.pos]);
    }
    ghost var signature: Option<seq<uint8>> := None;
    ghost var endFramePos := rd.reader.pos;
    assert header.body.contentType.Framed? ==> 0 <= endHeaderPos <= endFramePos <= |request.message|;
    if AlgorithmSuite.PolymorphIDToInternalID(decMat.algorithmSuiteId).SignatureType().Some? {
      var verifyResult, locSig := VerifySignature(rd, decMat);
      signature := Some(locSig);
      if verifyResult.Failure? {
        return Failure(verifyResult.error);
      }
      assert SignatureBySequence(signature.value, rd.reader.data[endFramePos .. rd.reader.pos]);
    }
    var isDone := rd.IsDoneReading();
    if !isDone {
      return Failure(""message contains additional bytes at end"");
    }
    if header.body.contentType.Framed? {
      if AlgorithmSuite.PolymorphIDToInternalID(decMat.algorithmSuiteId).SignatureType().Some? {
        assert signature.Some?;
        assert SignatureBySequence(signature.value, rd.reader.data[endFramePos .. rd.reader.pos]);
        assert HeaderBySequence(header, deserializeHeaderResult.hbSeq, request.message[..endHeaderPos]) && FramesBySequence(frames, request.message[endHeaderPos .. endFramePos]) && SignatureBySequence(signature.value, request.message[endFramePos..]) by {
          assert 0 <= endHeaderPos <= endFramePos <= |request.message|;
          assert SignatureBySequence(signature.value, request.message[endFramePos..]) by {
            assert header.body.contentType.Framed? ==> SignatureBySequence(signature.value, rd.reader.data[endFramePos .. rd.reader.pos]);
            assert rd.reader.data[endFramePos .. rd.reader.pos] == request.message[endFramePos..] by {
              calc {
                rd.reader.data[endFramePos .. rd.reader.pos];
              ==
                {
                  UpperBoundRemv(rd.reader.data, endFramePos);
                  assert rd.reader.pos == |rd.reader.data|;
                }
                rd.reader.data[endFramePos..];
              ==
                {
                  assert rd.reader.data == request.message;
                }
                request.message[endFramePos..];
              }
            }
            assert SignatureBySequence(signature.value, rd.reader.data[endFramePos .. rd.reader.pos]);
          }
        }
        HBandMBwithSigMatchSequence(header, deserializeHeaderResult.hbSeq, frames, signature.value, request.message);
      } else {
        assert signature.None?;
        assert 0 <= endHeaderPos <= |request.message| by {
          assert request.message == rd.reader.data;
        }
        assert HeaderBySequence(header, deserializeHeaderResult.hbSeq, request.message[..endHeaderPos]) && FramesBySequence(frames, request.message[endHeaderPos..]) by {
          assert HeaderBySequence(header, deserializeHeaderResult.hbSeq, rd.reader.data[..endHeaderPos]) && FramesBySequence(frames, rd.reader.data[endHeaderPos .. rd.reader.pos]);
          assert rd.reader.data[endHeaderPos .. rd.reader.pos] == request.message[endHeaderPos..] by {
            calc {
              rd.reader.data[endHeaderPos .. rd.reader.pos];
            ==
              {
                UpperBoundRemv(rd.reader.data, endHeaderPos);
              }
              rd.reader.data[endHeaderPos..];
            ==
              {
                assert rd.reader.data == request.message;
              }
              request.message[endHeaderPos..];
            }
          }
        }
        assert 0 <= endHeaderPos <= |request.message|;
        HBandMBMatchSequence(header, deserializeHeaderResult.hbSeq, frames, request.message);
      }
    }
    var decryptResultWithVerificationInfo := DecryptResultWithVerificationInfo(plaintext, header, deserializeHeaderResult.hbSeq, frames, signature);
    return Success(decryptResultWithVerificationInfo);
  }

  method VerifySignature(rd: Streams.ByteReader, decMat: Crypto.DecryptionMaterials)
      returns (res: Result<(), string>, ghost signature: seq<uint8>)
    requires rd.Valid()
    modifies rd.reader`pos
    ensures rd.Valid()
    ensures match res { case Success(_mcc#0) => 2 <= old(rd.reader.pos) + 2 <= rd.reader.pos && SignatureBySequence(signature, rd.reader.data[old(rd.reader.pos) .. rd.reader.pos]) case Failure(_mcc#1) => true }
    decreases rd, decMat
  {
    expect AlgorithmSuite.PolymorphIDToInternalID(decMat.algorithmSuiteId).SignatureType().Some?, ""expectation violation""
    var ecdsaParams := AlgorithmSuite.PolymorphIDToInternalID(decMat.algorithmSuiteId).SignatureType().value;
    var usedCapacity := rd.GetSizeRead();
    assert usedCapacity == rd.reader.pos;
    var msg := rd.reader.data[..usedCapacity];
    var signatureLengthResult := rd.ReadUInt16();
    if signatureLengthResult.Failure? {
      return Failure(signatureLengthResult.error), [];
    }
    var sigResult := rd.ReadBytes(signatureLengthResult.value as nat);
    if sigResult.Failure? {
      return Failure(sigResult.error), [];
    }
    expect decMat.verificationKey.Some?, ""expectation violation""
    var signatureVerifiedResult := Signature.Verify(ecdsaParams, decMat.verificationKey.value, msg, sigResult.value);
    if signatureVerifiedResult.Failure? {
      return Failure(signatureVerifiedResult.error), [];
    }
    if !signatureVerifiedResult.value {
      return Failure(""signature not verified""), [];
    }
    assert SignatureBySequence(sigResult.value, rd.reader.data[old(rd.reader.pos) .. rd.reader.pos]) by {
      reveal SignatureBySequence();
    }
    return Success(()), sigResult.value;
  }

  predicate {:opaque} {:fuel 0, 0} HeaderBySequence(header: Msg.Header, hbSeq: seq<uint8>, sequence: seq<uint8>)
    decreases header, hbSeq, sequence
  {
    header.body.contentType.Framed? &&
    header.body.Valid() &&
    Msg.IsSerializationOfHeaderBody(hbSeq, header.body) &&
    sequence == hbSeq + header.auth.iv + header.auth.authenticationTag
  }

  predicate {:opaque} {:fuel 0, 0} FramesBySequence(frames: seq<MessageBody.Frame>, sequence: seq<uint8>)
    decreases frames, sequence
  {
    |frames| < UINT32_LIMIT &&
    (forall frame: MessageBody.Frame | frame in frames :: 
      frame.Valid()) &&
    sequence == MessageBody.FramesToSequence(frames)
  }

  predicate {:opaque} {:fuel 0, 0} SignatureBySequence(signature: seq<uint8>, sequence: seq<uint8>)
    decreases signature, sequence
  {
    |signature| < UINT16_LIMIT &&
    sequence == UInt16ToSeq(|signature| as uint16) + signature
  }

  lemma /*{:_induction frames}*/ HBandMBMatchSequence(header: Msg.Header, hbSeq: seq<uint8>, frames: seq<MessageBody.Frame>, message: seq<uint8>)
    requires forall frame: MessageBody.Frame | frame in frames :: frame.Valid()
    requires |message| >= |hbSeq| + |header.auth.iv + header.auth.authenticationTag|
    requires exists headerLength: int | 0 <= headerLength <= |message| :: HeaderBySequence(header, hbSeq, message[..headerLength]) && FramesBySequence(frames, message[headerLength..])
    ensures message == hbSeq + header.auth.iv + header.auth.authenticationTag + MessageBody.FramesToSequence(frames)
    decreases header, hbSeq, frames, message
  {
    reveal HeaderBySequence(), FramesBySequence();
  }

  lemma /*{:_induction frames}*/ HBandMBwithSigMatchSequence(header: Msg.Header, hbSeq: seq<uint8>, frames: seq<MessageBody.Frame>, signature: seq<uint8>, message: seq<uint8>)
    requires forall frame: MessageBody.Frame | frame in frames :: frame.Valid()
    requires |message| >= |hbSeq| + |header.auth.iv + header.auth.authenticationTag| + |MessageBody.FramesToSequence(frames)|
    requires exists headerLength: int, frameLength: int | 0 <= headerLength <= frameLength < |message| :: HeaderBySequence(header, hbSeq, message[..headerLength]) && FramesBySequence(frames, message[headerLength .. frameLength]) && SignatureBySequence(signature, message[frameLength..])
    ensures |signature| < UINT16_LIMIT && message == hbSeq + header.auth.iv + header.auth.authenticationTag + MessageBody.FramesToSequence(frames) + UInt16ToSeq(|signature| as uint16) + signature
    decreases header, hbSeq, frames, signature, message
  {
    reveal HeaderBySequence(), FramesBySequence(), SignatureBySequence();
  }

  lemma UpperBoundRemv(sequence: seq<uint8>, lo: int)
    requires 0 <= lo <= |sequence|
    ensures sequence[lo .. |sequence|] == sequence[lo..]
    decreases sequence, lo
  {
  }

  predicate DataIsFramed(sequence: seq<uint8>)
    decreases sequence
  {
    exists i: int, header: Msg.Header, hbSeq: seq<uint8> | 0 <= i <= |sequence| :: 
      HeaderBySequence(header, hbSeq, sequence[..i])
  }
}

module {:extern ""EncryptionContext""} EncryptionContext {

  import opened StandardLibrary = StandardLibrary

  import opened Wrappers = Wrappers

  import opened UInt = StandardLibrary.UInt

  import UTF8 = UTF8

  import Sets = Sets
  type Map = map<UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes>

  type Linear = seq<(UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes)>

  predicate method {:opaque} {:fuel 0, 0} Serializable(encryptionContext: Map)
    decreases encryptionContext
  {
    SerializableKVPairs(encryptionContext) &&
    Length(encryptionContext) < UINT16_LIMIT
  }

  predicate method SerializableKVPairs(encryptionContext: Map)
    decreases encryptionContext
  {
    |encryptionContext| < UINT16_LIMIT &&
    forall key: UTF8.ValidUTF8Bytes :: 
      key in encryptionContext.Keys ==>
        SerializableKVPair((key, encryptionContext[key]))
  }

  predicate method SerializableKVPair(kvPair: (UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes))
    decreases kvPair
  {
    |kvPair.0| < UINT16_LIMIT &&
    |kvPair.1| < UINT16_LIMIT &&
    UTF8.ValidUTF8Seq(kvPair.0) &&
    UTF8.ValidUTF8Seq(kvPair.1)
  }

  predicate SerializableUnsortedLinear(linear: Linear)
    decreases linear
  {
    |linear| < UINT16_LIMIT &&
    (forall i: int :: 
      0 <= i < |linear| ==>
        SerializableKVPair(linear[i])) &&
    LinearIsUnique(linear)
  }

  predicate SerializableLinear(linear: Linear)
    decreases linear
  {
    LinearSorted(linear) &&
    SerializableUnsortedLinear(linear)
  }

  predicate LinearIsUnique(linear: Linear)
    decreases linear
  {
    forall i: int, j: int | 0 <= i < j < |linear| :: 
      linear[i].0 != linear[j].0
  }

  function method Length(encryptionContext: Map): nat
    decreases encryptionContext
  {
    if |encryptionContext| == 0 then
      0
    else
      var keys: seq<UTF8.ValidUTF8Bytes> := SetToOrderedSequence(encryptionContext.Keys, UInt.UInt8Less); var kvPairs: seq<(UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes)> := seq(|keys|, (i: int) requires 0 <= i < |keys| => (keys[i], encryptionContext[keys[i]])); 2 + LinearLength(kvPairs, 0, |kvPairs|)
  }

  function method LinearLength(kvPairs: Linear, lo: nat, hi: nat): nat
    requires lo <= hi <= |kvPairs|
    decreases kvPairs, lo, hi
  {
    if lo == hi then
      0
    else
      LinearLength(kvPairs, lo, hi - 1) + 2 + |kvPairs[hi - 1].0| + 2 + |kvPairs[hi - 1].1|
  }

  method {:extern ""LinearToMap""} LinearToMap(kvPairs: Linear) returns (res: Map)
    ensures (reveal Serializable(); Serializable(res) && SerializableLinear(kvPairs) ==> MapToSeq(res) == if |res| == 0 then [] else UInt16ToSeq(|kvPairs| as uint16) + LinearToSeq(kvPairs, 0, |kvPairs|))
    decreases kvPairs

  lemma /*{:_induction kvPairs, lo, mid, hi}*/ LinearSplit(kvPairs: Linear, lo: nat, mid: nat, hi: nat)
    requires lo <= mid <= hi <= |kvPairs|
    ensures LinearLength(kvPairs, lo, hi) == LinearLength(kvPairs, lo, mid) + LinearLength(kvPairs, mid, hi)
    decreases kvPairs, lo, mid, hi
  {
  }

  lemma /*{:_induction kvPairs, more}*/ LinearPrefix(kvPairs: Linear, more: Linear)
    ensures LinearLength(kvPairs + more, 0, |kvPairs|) == LinearLength(kvPairs, 0, |kvPairs|)
    decreases kvPairs, more
  {
    ghost var n := |kvPairs|;
    if n == 0 {
    } else {
      ghost var last := kvPairs[n - 1];
      calc {
        LinearLength(kvPairs + more, 0, n);
      ==
        LinearLength(kvPairs + more, 0, n - 1) + 4 + |last.0| + |last.1|;
      ==
        {
          assert kvPairs + more == kvPairs[..n - 1] + ([last] + more);
        }
        LinearLength(kvPairs[..n - 1] + ([last] + more), 0, n - 1) + 4 + |last.0| + |last.1|;
      ==
        {
          LinearPrefix(kvPairs[..n - 1], [last] + more);
        }
        LinearLength(kvPairs[..n - 1], 0, n - 1) + 4 + |last.0| + |last.1|;
      ==
        {
          LinearPrefix(kvPairs[..n - 1], [last] + more);
        }
        LinearLength(kvPairs[..n - 1] + [last], 0, n - 1) + 4 + |last.0| + |last.1|;
      ==
        {
          assert kvPairs[..n - 1] + [last] == kvPairs;
        }
        LinearLength(kvPairs, 0, n - 1) + 4 + |last.0| + |last.1|;
      ==
        LinearLength(kvPairs, 0, n);
      }
    }
  }

  lemma /*{:_induction kvPairs}*/ LinearExtend(kvPairs: Linear, key: UTF8.ValidUTF8Bytes, value: UTF8.ValidUTF8Bytes)
    ensures LinearLength(kvPairs + [(key, value)], 0, |kvPairs| + 1) == LinearLength(kvPairs, 0, |kvPairs|) + 4 + |key| + |value|
    decreases kvPairs, key, value
  {
    LinearPrefix(kvPairs, [(key, value)]);
  }

  lemma /*{:_induction kvPairs}*/ LinearInsert(kvPairs: Linear, insertionPoint: nat, key: UTF8.ValidUTF8Bytes, value: UTF8.ValidUTF8Bytes)
    requires insertionPoint <= |kvPairs|
    ensures ghost var kvPairs': seq<(UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes)> := kvPairs[..insertionPoint] + [(key, value)] + kvPairs[insertionPoint..]; LinearLength(kvPairs', 0, |kvPairs'|) == LinearLength(kvPairs, 0, |kvPairs|) + 4 + |key| + |value|
    decreases |kvPairs|
  {
    ghost var kvPairs' := kvPairs[..insertionPoint] + [(key, value)] + kvPairs[insertionPoint..];
    if |kvPairs| == insertionPoint {
      assert kvPairs' == kvPairs + [(key, value)];
      LinearExtend(kvPairs, key, value);
    } else {
      ghost var m := |kvPairs| - 1;
      var (d0, d1) := kvPairs[m];

      ghost var a, b, c, d := kvPairs[..insertionPoint], [(key, value)], kvPairs[insertionPoint .. m], [(d0, d1)];
      assert kvPairs == a + c + d;
      assert kvPairs' == a + b + c + d;
      ghost var ac := a + c;
      ghost var abc := a + b + c;
      calc {
        LinearLength(kvPairs', 0, |kvPairs'|);
        LinearLength(abc + [(d0, d1)], 0, |abc| + 1);
      ==
        {
          LinearExtend(abc, d0, d1);
        }
        LinearLength(abc, 0, |abc|) + 4 + |d0| + |d1|;
      ==
        {
          LinearInsert(ac, insertionPoint, key, value);
        }
        LinearLength(ac, 0, |ac|) + 4 + |key| + |value| + 4 + |d0| + |d1|;
      ==
        {
          LinearExtend(ac, d0, d1);
        }
        LinearLength(kvPairs, 0, |kvPairs|) + 4 + |key| + |value|;
      }
    }
  }

  method ComputeLength(encryptionContext: Map) returns (res: nat)
    ensures res as nat == Length(encryptionContext)
    decreases encryptionContext
  {
    reveal Serializable();
    if |encryptionContext| == 0 {
      return 0;
    }
    var keys: seq<UTF8.ValidUTF8Bytes> := Sets.ComputeSetToOrderedSequence(encryptionContext.Keys, UInt.UInt8Less);
    var kvPairs := seq(|keys|, (i: int) requires 0 <= i < |keys| => (keys[i], encryptionContext[keys[i]]));
    var len := 2;
    var i := 0;
    while i < |kvPairs|
      invariant i <= |kvPairs|
      invariant 2 + LinearLength(kvPairs, 0, i as int) == len as int
      decreases |kvPairs| - i
    {
      var kvPair := kvPairs[i];
      len := len + 4 + |kvPair.0| + |kvPair.1|;
      LinearSplit(kvPairs, 0, i + 1, |kvPairs| as int);
      i := i + 1;
    }
    assert len == 2 + LinearLength(kvPairs, 0, |kvPairs|);
    assert len == Length(encryptionContext);
    return len;
  }

  method CheckSerializable(encryptionContext: Map) returns (res: bool)
    ensures res == Serializable(encryptionContext)
    decreases encryptionContext
  {
    reveal Serializable();
    if |encryptionContext| == 0 {
      return true;
    } else if |encryptionContext| >= UINT16_LIMIT {
      return false;
    }
    var keys: seq<UTF8.ValidUTF8Bytes> := Sets.ComputeSetToOrderedSequence<uint8>(encryptionContext.Keys, UInt.UInt8Less);
    var kvPairs := seq(|keys|, (i: int) requires 0 <= i < |keys| => (keys[i], encryptionContext[keys[i]]));
    assert forall i: int :: 0 <= i < |keys| ==> kvPairs[i] == (keys[i], encryptionContext[keys[i]]);
    var kvPairsLen := 2;
    var i := 0;
    while i < |kvPairs|
      invariant i <= |kvPairs|
      invariant forall k: int :: 0 <= k < i ==> SerializableKVPair(kvPairs[k])
      invariant 2 + LinearLength(kvPairs, 0, i as int) == kvPairsLen as int < UINT16_LIMIT
      decreases |kvPairs| - i
    {
      var kvPair := kvPairs[i];
      kvPairsLen := kvPairsLen + 4 + |kvPair.0| + |kvPair.1|;
      LinearSplit(kvPairs, 0, i as int + 1, |kvPairs| as int);
      if !(|kvPair.0| < UINT16_LIMIT && |kvPair.1| < UINT16_LIMIT) {
        assert kvPair.0 in encryptionContext.Keys;
        return false;
      } else if kvPairsLen >= UINT16_LIMIT {
        return false;
      }
      assert forall k: int :: 0 <= k < i ==> SerializableKVPair(kvPairs[k]);
      assert kvPairsLen < UINT16_LIMIT;
      i := i + 1;
    }
    return true;
  }

  predicate LinearSortedUpTo(a: Linear, n: nat)
    requires n <= |a|
    decreases a, n
  {
    forall j: int :: 
      0 < j < n ==>
        LexicographicLessOrEqual(a[j - 1].0, a[j].0, UInt.UInt8Less)
  }

  predicate LinearSorted(kvPairs: Linear)
    decreases kvPairs
  {
    LinearSortedUpTo(kvPairs, |kvPairs|)
  }

  predicate StrongLinearSorted(kvPairs: Linear)
    decreases kvPairs
  {
    forall i: int, j: int | 0 <= i < j < |kvPairs| :: 
      LexicographicLessOrEqual(kvPairs[i].0, kvPairs[j].0, UInt.UInt8Less)
  }

  lemma LinearSortedImpliesStrongLinearSorted(ls: Linear)
    requires LinearSorted(ls)
    ensures StrongLinearSorted(ls)
    decreases ls
  {
    if |ls| <= 1 {
    } else {
      forall i: int, j: int | 0 <= i < j < |ls|
        ensures LexicographicLessOrEqual(ls[i].0, ls[j].0, UInt.UInt8Less)
      {
        LinearSortedImpliesStrongLinearSorted(ls[1..]);
        if i == 0 && 2 <= |ls| {
          LexIsReflexive(ls[1].0, UInt.UInt8Less);
          LexIsTransitive(ls[i].0, ls[1].0, ls[j].0, UInt.UInt8Less);
          assert LexicographicLessOrEqual(ls[i].0, ls[j].0, UInt.UInt8Less);
        } else {
          assert LexicographicLessOrEqual(ls[i].0, ls[j].0, UInt.UInt8Less);
        }
      }
    }
  }

  lemma SortedSequenceIsUnqiue(xs: Linear, ys: Linear)
    requires LinearSorted(xs) && LinearIsUnique(xs)
    requires LinearSorted(ys) && LinearIsUnique(ys)
    requires forall p: (UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes) :: p in xs <==> p in ys
    ensures xs == ys
    decreases xs, ys
  {
    LinearSortedImpliesStrongLinearSorted(xs);
    LinearSortedImpliesStrongLinearSorted(ys);
    if xs != [] && ys != [] {
      assert xs[0] == ys[0] by {
        if xs[0] != ys[0] {
          assert forall p: (UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes) | p in xs[1..] :: LexicographicLessOrEqual(xs[0].0, p.0, UInt.UInt8Less);
          assert xs[0] in ys[1..] by {
            assert xs[0] != ys[0] && !(xs[0] in ys[1..]) ==> xs[0] !in ys;
          }
          assert forall p: (UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes) | p in ys[1..] :: LexicographicLessOrEqual(ys[0].0, p.0, UInt.UInt8Less);
          assert ys[0] in xs[1..] by {
            assert ys[0] != xs[0] && !(ys[0] in xs[1..]) ==> ys[0] !in xs;
          }
          assert LexicographicLessOrEqual(ys[0].0, xs[0].0, UInt.UInt8Less);
          assert LexicographicLessOrEqual(xs[0].0, ys[0].0, UInt.UInt8Less);
          assert false;
        }
      }
      assert forall p: (UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes) :: p in xs[1..] <==> p in ys[1..] by {
        if exists p: (UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes) :: p in xs[1..] && !(p in ys[1..]) {
          ghost var p :| p in xs[1..] && !(p in ys[1..]);
          assert p != ys[0];
          assert p in xs && !(p in ys);
          assert false;
        } else {
          if exists p: (UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes) :: p in ys[1..] && !(p in xs[1..]) {
            ghost var p :| p in ys[1..] && !(p in xs[1..]);
            assert p != xs[0];
            assert p in xs && !(p in ys);
            assert false;
          }
        }
      }
      SortedSequenceIsUnqiue(xs[1..], ys[1..]);
    } else {
      if xs == [] && ys != [] {
        assert ys[0] in xs;
        assert false;
      }
      if ys == [] && xs != [] {
        assert xs[0] in ys;
        assert false;
      }
    }
  }

  predicate LinearSeqToMap(sequence: seq<uint8>, resultMap: Map)
    decreases sequence, resultMap
  {
    if 2 <= |sequence| && |sequence[2..]| < UINT16_LIMIT then
      sequence[..2] == UInt16ToSeq(|sequence[2..]| as uint16) &&
      SeqToMap(sequence[2..], resultMap)
    else
      false
  }

  predicate SeqToMap(sequence: seq<uint8>, resultMap: Map)
    decreases sequence, resultMap
  {
    if 2 <= |sequence| then
      exists unsortedKvPairs: Linear :: 
        SeqToLinearToMap(sequence, resultMap, unsortedKvPairs, InsertionSort(unsortedKvPairs))
    else
      |resultMap| == 0
  }

  predicate SeqToLinearToMap(sequence: seq<uint8>, resultMap: Map, unsortedKvPairs: Linear, sortedKvPairs: Linear)
    decreases sequence, resultMap, unsortedKvPairs, sortedKvPairs
  {
    2 <= |sequence| &&
    SerializableUnsortedLinear(unsortedKvPairs) &&
    SerializableLinear(sortedKvPairs) &&
    SerializableKVPairs(resultMap) &&
    sequence[..2] == UInt16ToSeq(|resultMap| as uint16) &&
    LinearToUnorderedSeq(unsortedKvPairs, 0, |unsortedKvPairs|) == sequence[2..] &&
    sortedKvPairs == InsertionSort(unsortedKvPairs) &&
    MapToSeq(resultMap) == sequence[..2] + LinearToSeq(sortedKvPairs, 0, |sortedKvPairs|)
  }

  lemma MapToLinearIsDualLinearSeqToMap(resultMap: Map)
    requires Serializable(resultMap)
    ensures LinearSeqToMap(MapToLinear(resultMap), resultMap)
    decreases resultMap
  {
    reveal Serializable();
    LengthCorrect(resultMap);
    MapToSeqIsDualSeqToMap(resultMap);
  }

  function LinearToUnorderedSeq(kvPairs: Linear, lo: nat, hi: nat): seq<uint8>
    requires SerializableUnsortedLinear(kvPairs)
    requires lo <= hi <= |kvPairs|
    decreases kvPairs, lo, hi
  {
    if lo == hi then
      []
    else
      LinearToUnorderedSeq(kvPairs, lo, hi - 1) + KVPairToSeq(kvPairs[hi - 1])
  }

  lemma /*{:_induction kvHead, kvTail, lo, hi}*/ LinearToUnorderedSeqInductiveStep(kvHead: Linear, kvTail: Linear, lo: nat, hi: nat)
    requires SerializableUnsortedLinear(kvHead + kvTail)
    requires lo <= hi <= |kvHead|
    ensures SerializableUnsortedLinear(kvHead)
    ensures LinearToUnorderedSeq(kvHead + kvTail, lo, hi) == LinearToUnorderedSeq(kvHead, lo, hi)
    decreases kvHead, kvTail, lo, hi
  {
    assert SerializableUnsortedLinear(kvHead) by {
      assert |kvHead| < UINT16_LIMIT;
      assert forall i: int :: 0 <= i < |kvHead| ==> SerializableKVPair(kvHead[i]) by {
        assert forall pair: (UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes) :: pair in kvHead ==> pair in kvHead + kvTail;
        assert (exists pair: (UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes) :: pair in kvHead && !SerializableKVPair(pair)) ==> exists pair: (UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes) :: pair in kvHead + kvTail && !SerializableKVPair(pair);
      }
      assert LinearIsUnique(kvHead) by {
        ghost var kvPairs := kvHead + kvTail;
        assert forall i: int | 0 <= i < |kvHead| :: kvHead[i] == kvPairs[i];
        assert (exists i: int, j: int | 0 <= i < j < |kvHead| :: kvHead[i] == kvHead[j]) ==> exists i: int, j: int | 0 <= i < j < |kvPairs| :: kvPairs[i] == kvPairs[j];
      }
    }
  }

  lemma MapToSeqIsDualSeqToMap(resultMap: Map)
    requires SerializableKVPairs(resultMap)
    ensures SeqToMap(MapToSeq(resultMap), resultMap)
    decreases resultMap
  {
    ghost var sequenceComplete := MapToSeq(resultMap);
    if sequenceComplete != [] {
      ghost var sequence := sequenceComplete[2..];
      ghost var kvPairs :| (forall i: int :: 0 <= i < |kvPairs| ==> SerializableKVPair(kvPairs[i])) && |kvPairs| < UINT16_LIMIT && LinearSorted(kvPairs) && LinearIsUnique(kvPairs) && LinearToSeq(kvPairs, 0, |kvPairs|) == sequence && sequenceComplete[..2] == UInt16ToSeq(|kvPairs| as uint16);
      InsertionSortPreservesProperties(kvPairs);
      SortedSequenceIsUnqiue(kvPairs, InsertionSort(kvPairs));
      SortedLinearIsFixpointAADDuality(kvPairs);
    } else {
    }
  }

  lemma /*{:_induction linear}*/ SortedLinearIsFixpointAADDuality(linear: Linear)
    requires forall p: (UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes) | p in linear :: SerializableKVPair(p)
    requires |linear| < UINT16_LIMIT
    requires LinearIsUnique(linear)
    requires LinearSorted(linear)
    ensures forall hi: int | 0 <= hi <= |linear| :: LinearToUnorderedSeq(linear, 0, hi) == LinearToSeq(linear, 0, hi)
    decreases linear
  {
    SortedLinearIsFixpointAADDualityAux(linear, |linear|);
  }

  lemma /*{:_induction linear}*/ SortedLinearIsFixpointAADDualityAux(linear: Linear, lim: nat)
    requires forall p: (UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes) | p in linear :: SerializableKVPair(p)
    requires |linear| < UINT16_LIMIT
    requires LinearIsUnique(linear)
    requires LinearSorted(linear)
    requires lim <= |linear|
    ensures forall hi: int | 0 <= hi <= lim :: LinearToUnorderedSeq(linear, 0, hi) == LinearToSeq(linear, 0, hi)
    decreases linear, lim
  {
    if lim == 0 {
      assert LinearToUnorderedSeq(linear, 0, 0) == LinearToSeq(linear, 0, 0);
    } else {
      SortedLinearIsFixpointAADDualityAux(linear, lim - 1);
      assert LinearToUnorderedSeq(linear, 0, lim) == LinearToSeq(linear, 0, lim);
    }
  }

  lemma /*{:_induction ps}*/ InsertionSortPreservesProperties(ps: Linear)
    requires LinearIsUnique(ps)
    requires forall l: (UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes) | l in ps :: SerializableKVPair(l)
    ensures LinearIsUnique(InsertionSort(ps))
    ensures forall l: (UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes) | l in InsertionSort(ps) :: SerializableKVPair(l)
    ensures |InsertionSort(ps)| == |ps|
    decreases ps
  {
    if ps == [] {
    } else {
      ghost var ls := InsertionSort(ps[1..]);
      forall j: int | 0 <= j < |ls|
        ensures ps[0].0 != ls[j].0
      {
        assert ps[0].0 == ls[j].0 ==> ls[j] in ps[1..];
        assert ps[0].0 == ls[j].0 ==> false;
      }
      InsertPairPreservesProperties(ps[0], ls);
    }
  }

  lemma /*{:_induction p, ps}*/ InsertPairPreservesProperties(p: (UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes), ps: Linear)
    requires LinearSorted(ps)
    requires LinearIsUnique(ps)
    requires forall j: int | 0 <= j < |ps| :: p.0 != ps[j].0
    requires forall l: (UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes) | l in ps :: SerializableKVPair(l)
    requires SerializableKVPair(p)
    ensures LinearIsUnique(InsertPair(p, ps))
    ensures forall l: (UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes) | l in InsertPair(p, ps) :: SerializableKVPair(l)
    ensures |InsertPair(p, ps)| == |ps| + 1
    decreases p, ps
  {
    if ps == [] || LexicographicLessOrEqual(p.0, ps[0].0, UInt.UInt8Less) {
    } else {
      assert LinearIsUnique([ps[0]] + InsertPair(p, ps[1..])) by {
        ghost var ls := InsertPair(p, ps[1..]);
        ghost var l := ps[0];
        assert !LinearIsUnique([l] + ls) ==> exists m: (UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes) | m in ls :: m.0 == l.0;
      }
    }
  }

  function MapToSeq(kvPairs: Map): seq<uint8>
    requires SerializableKVPairs(kvPairs)
    decreases kvPairs
  {
    ghost var n: int := |kvPairs|;
    if n == 0 then
      []
    else
      ghost var keys: seq<UTF8.ValidUTF8Bytes> := SetToOrderedSequence<uint8>(kvPairs.Keys, UInt.UInt8Less); ghost var kvPairsSeq: seq<(UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes)> := seq(|keys|, (i: int) requires 0 <= i < |keys| => (keys[i], kvPairs[keys[i]])); UInt16ToSeq(n as uint16) + LinearToSeq(kvPairsSeq, 0, |kvPairsSeq|)
  }

  function LinearToSeq(kvPairs: Linear, lo: nat, hi: nat): seq<uint8>
    requires SerializableLinear(kvPairs)
    requires lo <= hi <= |kvPairs|
    decreases kvPairs, lo, hi
  {
    if lo == hi then
      []
    else
      LinearToSeq(kvPairs, lo, hi - 1) + KVPairToSeq(kvPairs[hi - 1])
  }

  function MapToLinear(kvPairs: Map): seq<uint8>
    requires Serializable(kvPairs)
    decreases kvPairs
  {
    reveal Serializable();
    UInt16ToSeq(Length(kvPairs) as uint16) + MapToSeq(kvPairs)
  }

  function KVPairToSeq(kvPair: (UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes)): seq<uint8>
    requires SerializableKVPair(kvPair)
    decreases kvPair
  {
    UInt16ToSeq(|kvPair.0| as uint16) + kvPair.0 + UInt16ToSeq(|kvPair.1| as uint16) + kvPair.1
  }

  function InsertionSort(linear: Linear): Linear
    ensures ghost var linearSorted: Linear := InsertionSort(linear); (forall p: (UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes) :: p in linear <==> p in linearSorted) && LinearSorted(linearSorted)
    decreases linear
  {
    if linear == [] then
      []
    else
      InsertPair(linear[0], InsertionSort(linear[1..]))
  }

  function InsertPair(p: (UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes), ps: Linear): Linear
    requires LinearSorted(ps)
    ensures ghost var ls: Linear := InsertPair(p, ps); LinearSorted(ls) && forall l: (UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes) :: l in ps || l == p <==> l in ls
    decreases p, ps
  {
    if ps == [] || LexicographicLessOrEqual(p.0, ps[0].0, UInt.UInt8Less) then
      [p] + ps
    else
      LexIsTotal(p.0, ps[0].0, UInt.UInt8Less); [ps[0]] + InsertPair(p, ps[1..])
  }

  function GetUTF8(sequence: seq<uint8>, length: nat): (res: Option<UTF8.ValidUTF8Bytes>)
    ensures |sequence| >= length && UTF8.ValidUTF8Seq(sequence[..length]) <==> res.Some?
    ensures res.Some? ==> sequence[..length] == res.value
    decreases sequence, length
  {
    if |sequence| >= length then
      ghost var utfSeq: seq<uint8> := sequence[..length];
      if UTF8.ValidUTF8Seq(utfSeq) then
        ghost var utf: UTF8.ValidUTF8Bytes := utfSeq;
        Some(utf)
      else
        None
    else
      None
  }

  lemma DualOfUTF8(utf: UTF8.ValidUTF8Bytes, remainder: seq<uint8>)
    requires |utf| < UINT16_LIMIT && UTF8.ValidUTF8Seq(utf)
    ensures ghost var serializedUtf: seq<uint8> := UInt16ToSeq(|utf| as uint16) + utf + remainder; GetUTF8(serializedUtf[2..], |utf|) == Some(utf)
    decreases utf, remainder
  {
    ghost var serializedUtf := UInt16ToSeq(|utf| as uint16) + utf + remainder;
    assert serializedUtf[2..][..|utf|] == utf;
    ghost var serial := serializedUtf[2..];
    ghost var deserializedUTF := GetUTF8(serial, |utf|);
    assert deserializedUTF.Some? by {
      assert serial[..|utf|] == utf;
      assert |serial| >= |utf| && UTF8.ValidUTF8Seq(serial[..|utf|]);
    }
    assert deserializedUTF.value == serial[..|utf|];
  }

  lemma LengthCorrect(encryptionContext: Map)
    requires Serializable(encryptionContext)
    ensures |MapToLinear(encryptionContext)| == 2 + Length(encryptionContext)
    decreases encryptionContext
  {
    reveal Serializable();
    ghost var keys: seq<UTF8.ValidUTF8Bytes> := SetToOrderedSequence(encryptionContext.Keys, UInt.UInt8Less);
    ghost var kvPairs := seq(|keys|, (i: int) requires 0 <= i < |keys| => (keys[i], encryptionContext[keys[i]]));
    LinearLengthCorrect(kvPairs, 0, |kvPairs|);
  }

  lemma /*{:_induction encryptionContext, lo, hi}*/ LinearLengthCorrect(encryptionContext: Linear, lo: nat, hi: nat)
    requires forall i: int :: 0 <= i < |encryptionContext| ==> SerializableKVPair(encryptionContext[i])
    requires lo <= hi <= |encryptionContext|
    requires |encryptionContext| < UINT16_LIMIT
    requires LinearSorted(encryptionContext)
    requires LinearIsUnique(encryptionContext)
    ensures |LinearToSeq(encryptionContext, lo, hi)| == LinearLength(encryptionContext, lo, hi)
    decreases encryptionContext, lo, hi
  {
  }
}

module AwsKmsMrkAreUnique {

  import opened StandardLibrary = StandardLibrary

  import opened Wrappers = Wrappers

  import opened Seq = Seq

  import opened AwsKmsArnParsing = AwsKmsArnParsing
  function method AwsKmsMrkAreUnique(identifiers: seq<AwsKmsIdentifier>): (result: Result<(), string>)
    decreases identifiers
  {
    var mrks: seq<AwsKmsIdentifier> := Seq.Filter(IsMultiRegionAwsKmsIdentifier, identifiers);
    if |mrks| == 0 then
      Success(())
    else
      var mrkKeyIds: seq<string> := Seq.Map(GetKeyId, mrks); var setMrks: set<seq<char>> := ToSet(mrkKeyIds); if |mrkKeyIds| == |setMrks| then Success(()) else var duplicateMrkIds: set<seq<char>> := set x: seq<char> {:trigger multiset(mrkKeyIds)[x]} {:trigger x in mrkKeyIds} | x in mrkKeyIds && multiset(mrkKeyIds)[x] >= 1; var isDuplicate: AwsKmsIdentifier -> bool := (identifier: AwsKmsIdentifier) => GetKeyId(identifier) in duplicateMrkIds; var identifierToString: AwsKmsIdentifier -> string := (i: AwsKmsIdentifier) => i.ToString(); var duplicateIdentifiers: seq<AwsKmsIdentifier> := Seq.Filter(isDuplicate, identifiers); var duplicates: seq<string> := Seq.Map(identifierToString, duplicateIdentifiers); Need(|duplicates| > 0, ""Impossible""); Failure(""Related multi-Region keys: "" + Join(duplicates, "","") + ""are not allowed."")
  }

  function method GetKeyId(identifier: AwsKmsIdentifier): (result: string)
    decreases identifier
  {
    match identifier {
      case AwsKmsArnIdentifier(a) =>
        a.resource.value
      case AwsKmsRawResourceIdentifier(i) =>
        i.value
    }
  }

  lemma /*{:_induction identifiers}*/ AwsKmsMrkAreUniqueCorrect(identifiers: seq<AwsKmsIdentifier>)
    ensures |Seq.Filter(IsMultiRegionAwsKmsIdentifier, identifiers)| == 0 ==> AwsKmsMrkAreUnique(identifiers).Success?
    ensures ghost var mrks: seq<AwsKmsIdentifier> := Seq.Filter(IsMultiRegionAwsKmsIdentifier, identifiers); ghost var ids: seq<string> := Seq.Map(GetKeyId, mrks); |mrks| > 0 && Seq.HasNoDuplicates(ids) ==> AwsKmsMrkAreUnique(identifiers).Success?
    ensures ghost var mrks: seq<AwsKmsIdentifier> := Seq.Filter(IsMultiRegionAwsKmsIdentifier, identifiers); ghost var ids: seq<string> := Seq.Map(GetKeyId, mrks); |mrks| > 0 && !Seq.HasNoDuplicates(ids) ==> AwsKmsMrkAreUnique(identifiers).Failure?
    decreases identifiers
  {
    ghost var mrks := Seq.Filter(IsMultiRegionAwsKmsIdentifier, identifiers);
    ghost var ids := Seq.Map(GetKeyId, mrks);
    if Seq.HasNoDuplicates(ids) {
      LemmaCardinalityOfSetNoDuplicates(ids);
    }
    if |ToSet(ids)| == |ids| {
      LemmaNoDuplicatesCardinalityOfSet(ids);
    }
  }
}

module {:extern ""AwsKmsMrkAwareSymmetricKeyringDef""} AwsKmsMrkAwareSymmetricKeyringDef {

  import opened StandardLibrary = StandardLibrary

  import opened Wrappers = Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened AwsKmsArnParsing = AwsKmsArnParsing

  import opened AmazonKeyManagementService = AmazonKeyManagementService

  import opened Seq = Seq

  import opened Actions = Actions

  import opened Constants = Constants

  import opened M = AwsKmsMrkMatchForDecrypt

  import opened KeyringDefs = KeyringDefs

  import Materials = Materials

  import opened KMSUtils = KMSUtils

  import UTF8 = UTF8
  class AwsKmsMrkAwareSymmetricKeyring extends Keyring {
    const client: IAmazonKeyManagementService
    const awsKmsKey: AwsKmsIdentifierString
    const awsKmsArn: AwsKmsIdentifier
    const grantTokens: KMSUtils.GrantTokens

    constructor (client: IAmazonKeyManagementService, awsKmsKey: string, grantTokens: GrantTokens)
      requires ParseAwsKmsIdentifier(awsKmsKey).Success?
      requires UTF8.IsASCIIString(awsKmsKey)
      requires 0 < |awsKmsKey| <= MAX_AWS_KMS_IDENTIFIER_LENGTH
      ensures Valid()
      ensures fresh(Repr - {this})
      ensures this.client == client && this.awsKmsKey == awsKmsKey && this.grantTokens == grantTokens
      decreases client, awsKmsKey, grantTokens
    {
      var parsedAwsKmsId := ParseAwsKmsIdentifier(awsKmsKey);
      this.client := client;
      this.awsKmsKey := awsKmsKey;
      this.awsKmsArn := parsedAwsKmsId.value;
      this.grantTokens := grantTokens;
      Repr := {this};
    }

    predicate Valid()
      reads this, Repr
      ensures Valid() ==> this in Repr
      decreases Repr + {this}
    {
      true &&
      this in Repr
    }

    method OnEncrypt(materials: Materials.ValidEncryptionMaterials) returns (res: Result<Materials.ValidEncryptionMaterials, string>)
      requires Valid()
      ensures Valid()
      ensures OnEncryptPure(materials, res)
      ensures true && materials.plaintextDataKey.None? ==> GenerateDataKeyCalledWith(client, GenerateDataKeyRequest(materials.encryptionContext, grantTokens, awsKmsKey, materials.algorithmSuiteID.KDFInputKeyLength() as int32))
      ensures materials.plaintextDataKey.None? && res.Success? ==> res.value.plaintextDataKey.Some? && |res.value.encryptedDataKeys| == |materials.encryptedDataKeys| + 1 && materials.algorithmSuiteID.ValidPlaintextDataKey(res.value.plaintextDataKey.value) && GenerateDataKeyResult(Last(res.value.encryptedDataKeys).ciphertext, res.value.plaintextDataKey.value)
      ensures true && materials.plaintextDataKey.Some? ==> true && EncryptCalledWith(client, EncryptRequest(materials.encryptionContext, grantTokens, awsKmsKey, materials.plaintextDataKey.value))
      ensures materials.plaintextDataKey.Some? && res.Success? ==> |res.value.encryptedDataKeys| == |materials.encryptedDataKeys| + 1 && EncryptResult(Last(res.value.encryptedDataKeys).ciphertext)
      decreases materials
    {
      if materials.plaintextDataKey.None? {
        var generatorRequest := GenerateDataKeyRequest(materials.encryptionContext, grantTokens, awsKmsKey, materials.algorithmSuiteID.KDFInputKeyLength() as int32);
        var maybeGenerateResponse := GenerateDataKey(client, generatorRequest);
        if maybeGenerateResponse.Failure? {
          return Failure(maybeGenerateResponse.error);
        }
        var generateResponse := maybeGenerateResponse.value;
        :- Need(generateResponse.IsWellFormed(), ""Invalid response from KMS GenerateDataKey"");
        :- Need(ParseAwsKmsIdentifier(generateResponse.keyID).Success?, ""Invalid response from KMS GenerateDataKey:: Invalid Key Id"");
        :- Need(materials.algorithmSuiteID.ValidPlaintextDataKey(generateResponse.plaintext), ""Invalid response from AWS KMS GenerateDataKey: Invalid data key"");
        var providerInfo :- UTF8.Encode(generateResponse.keyID);
        :- Need(|providerInfo| < UINT16_LIMIT, ""AWS KMS Key ID too long."");
        var edk := Materials.EncryptedDataKey(PROVIDER_ID, providerInfo, generateResponse.ciphertextBlob);
        var plaintextDataKey := generateResponse.plaintext;
        var result := materials.WithKeys(Some(plaintextDataKey), [edk]);
        return Success(result);
      } else {
        var encryptRequest := KMSUtils.EncryptRequest(materials.encryptionContext, grantTokens, awsKmsKey, materials.plaintextDataKey.value);
        var maybeEncryptResponse := KMSUtils.Encrypt(client, encryptRequest);
        if maybeEncryptResponse.Failure? {
          return Failure(maybeEncryptResponse.error);
        }
        var encryptResponse := maybeEncryptResponse.value;
        :- Need(encryptResponse.IsWellFormed(), ""Invalid response from KMS Encrypt"");
        :- Need(ParseAwsKmsIdentifier(encryptResponse.keyID).Success?, ""Invalid response from AWS KMS Encrypt:: Invalid Key Id"");
        var providerInfo :- UTF8.Encode(encryptResponse.keyID);
        :- Need(|providerInfo| < UINT16_LIMIT, ""AWS KMS Key ID too long."");
        var edk := Materials.EncryptedDataKey(PROVIDER_ID, providerInfo, encryptResponse.ciphertextBlob);
        var result := materials.WithKeys(materials.plaintextDataKey, [edk]);
        return Success(result);
      }
    }

    method OnDecrypt(materials: Materials.ValidDecryptionMaterials, encryptedDataKeys: seq<Materials.EncryptedDataKey>) returns (res: Result<Materials.ValidDecryptionMaterials, string>)
      requires Valid()
      ensures Valid()
      ensures OnDecryptPure(materials, res)
      ensures materials.plaintextDataKey.Some? ==> res.Success? && res.value == materials
      ensures materials.plaintextDataKey.None? && res.Success? ==> res.value.plaintextDataKey.Some? && exists edk: Materials.EncryptedDataKey | edk in encryptedDataKeys :: edk.providerID == PROVIDER_ID && DecryptCalledWith(client, DecryptRequest(awsKmsKey, edk.ciphertext, materials.encryptionContext, grantTokens)) && DecryptResult(awsKmsKey, res.value.plaintextDataKey.value) && materials.algorithmSuiteID.ValidPlaintextDataKey(res.value.plaintextDataKey.value)
      decreases materials, encryptedDataKeys
    {
      if materials.plaintextDataKey.Some? {
        return Success(materials);
      }
      var filter := new OnDecryptEncryptedDataKeyFilter(awsKmsArn);
      var edksToAttempt :- FilterWithResult(filter, encryptedDataKeys);
      var decryptClosure := new DecryptSingleEncryptedDataKey(materials, client, awsKmsKey, grantTokens);
      var outcome := ReduceToSuccess(decryptClosure, edksToAttempt);
      return match outcome { case Success(_mcc#0) => (var mat := _mcc#0; assert exists edk | edk in edksToAttempt :: edk in encryptedDataKeys && filter.Ensures(edk, Success(true)) && decryptClosure.Ensures(edk, Success(mat)) && DecryptCalledWith(client, DecryptRequest(awsKmsKey, edk.ciphertext, materials.encryptionContext, grantTokens)) && DecryptResult(awsKmsKey, mat.plaintextDataKey.value); Success(mat)) case Failure(_mcc#1) => var errors := _mcc#1; if |errors| == 0 then Failure(""Unable to decrypt data key: No Encrypted Data Keys found to match."") else var concatString := (s, a) => a + ""\n"" + s; var error := Seq.FoldRight(concatString, errors, ""Unable to decrypt data key:\n""); Failure(error) };
    }
  }

  class OnDecryptEncryptedDataKeyFilter extends ActionWithResult<Materials.EncryptedDataKey, bool, string> {
    const awsKmsKey: AwsKmsIdentifier

    constructor (awsKmsKey: AwsKmsIdentifier)
      decreases awsKmsKey
    {
      this.awsKmsKey := awsKmsKey;
    }

    predicate Ensures(edk: Materials.EncryptedDataKey, res: Result<bool, string>)
      decreases edk, res
    {
      true &&
      (res.Success? &&
      res.value ==>
        edk.providerID == PROVIDER_ID)
    }

    method Invoke(edk: Materials.EncryptedDataKey) returns (res: Result<bool, string>)
      ensures Ensures(edk, res)
      decreases edk
    {
      if edk.providerID != PROVIDER_ID {
        return Success(false);
      }
      if !UTF8.ValidUTF8Seq(edk.providerInfo) {
        return Failure(""Invalid AWS KMS encoding, provider info is not UTF8."");
      }
      var keyId :- UTF8.Decode(edk.providerInfo);
      var arn :- ParseAwsKmsArn(keyId);
      return Success(AwsKmsMrkMatchForDecrypt(awsKmsKey, AwsKmsArnIdentifier(arn)));
    }
  }

  class DecryptSingleEncryptedDataKey extends ActionWithResult<Materials.EncryptedDataKey, Materials.CompleteDecryptionMaterials, string> {
    const materials: Materials.PendingDecryptionMaterials
    const client: IAmazonKeyManagementService
    const awsKmsKey: AwsKmsIdentifierString
    const grantTokens: KMSUtils.GrantTokens

    constructor (materials: Materials.PendingDecryptionMaterials, client: IAmazonKeyManagementService, awsKmsKey: AwsKmsIdentifierString, grantTokens: KMSUtils.GrantTokens)
      ensures this.materials == materials && this.client == client && this.awsKmsKey == awsKmsKey && this.grantTokens == grantTokens
      decreases materials, client, awsKmsKey, grantTokens
    {
      this.materials := materials;
      this.client := client;
      this.awsKmsKey := awsKmsKey;
      this.grantTokens := grantTokens;
    }

    predicate Ensures(edk: Materials.EncryptedDataKey, res: Result<Materials.CompleteDecryptionMaterials, string>)
      decreases edk, res
    {
      res.Success? ==>
        res.value.Valid() &&
        OnDecryptPure(materials, res) &&
        DecryptCalledWith(client, DecryptRequest(awsKmsKey, edk.ciphertext, materials.encryptionContext, grantTokens)) &&
        DecryptResult(awsKmsKey, res.value.plaintextDataKey.value)
    }

    method Invoke(edk: Materials.EncryptedDataKey) returns (res: Result<Materials.CompleteDecryptionMaterials, string>)
      ensures Ensures(edk, res)
      decreases edk
    {
      var decryptRequest := KMSUtils.DecryptRequest(awsKmsKey, edk.ciphertext, materials.encryptionContext, grantTokens);
      var decryptResponse :- KMSUtils.Decrypt(client, decryptRequest);
      :- Need(decryptResponse.keyID == awsKmsKey && materials.algorithmSuiteID.ValidPlaintextDataKey(decryptResponse.plaintext), ""Invalid response from KMS Decrypt"");
      var result := materials.WithPlaintextDataKey(decryptResponse.plaintext);
      return Success(result);
    }
  }
}

module AwsKmsMrkMatchForDecrypt {

  import opened StandardLibrary = StandardLibrary

  import opened Wrappers = Wrappers

  import opened Seq = Seq

  import opened AwsKmsArnParsing = AwsKmsArnParsing
  predicate method AwsKmsMrkMatchForDecrypt(configuredAwsKmsIdentifier: AwsKmsIdentifier, messageAwsKmsIdentifer: AwsKmsIdentifier)
    decreases configuredAwsKmsIdentifier, messageAwsKmsIdentifer
  {
    if configuredAwsKmsIdentifier == messageAwsKmsIdentifer then
      true
    else
      match (messageAwsKmsIdentifer, configuredAwsKmsIdentifier) { case _#Make2(_mcc#0, _mcc#1) => match _mcc#0 { case AwsKmsArnIdentifier(_mcc#2) => match _mcc#1 { case AwsKmsArnIdentifier(_mcc#4) => (var messageAwsKmsArn := _mcc#4; var configuredAwsKmsArn := _mcc#2; if !IsMultiRegionAwsKmsArn(configuredAwsKmsArn) || !IsMultiRegionAwsKmsArn(messageAwsKmsArn) then false else messageAwsKmsArn.partition == configuredAwsKmsArn.partition && messageAwsKmsArn.service == configuredAwsKmsArn.service && messageAwsKmsArn.account == configuredAwsKmsArn.account && messageAwsKmsArn.resource == configuredAwsKmsArn.resource) case AwsKmsRawResourceIdentifier(_mcc#6) => false } case AwsKmsRawResourceIdentifier(_mcc#8) => false } }
  }

  lemma AwsKmsMrkMatchForDecryptCorrect(config: string, message: string)
    ensures ghost var c: Result<AwsKmsIdentifier, string> := ParseAwsKmsIdentifier(config); ghost var m: Result<AwsKmsIdentifier, string> := ParseAwsKmsIdentifier(message); config == message && c.Success? && m.Success? ==> AwsKmsMrkMatchForDecrypt(c.value, m.value)
    ensures ghost var c: Result<AwsKmsArn, seq<char>> := ParseAwsKmsArn(config); ghost var m: Result<AwsKmsArn, seq<char>> := ParseAwsKmsArn(message); config != message && c.Success? && m.Success? && IsMultiRegionAwsKmsArn(c.value) != IsMultiRegionAwsKmsArn(m.value) ==> !AwsKmsMrkMatchForDecrypt(AwsKmsArnIdentifier(c.value), AwsKmsArnIdentifier(m.value))
    ensures ghost var c: Result<AwsArn, seq<char>> := ParseAwsKmsArn(config); ghost var m: Result<AwsArn, seq<char>> := ParseAwsKmsArn(message); c.Success? && m.Success? && IsMultiRegionAwsKmsArn(c.value) && IsMultiRegionAwsKmsArn(m.value) ==> AwsKmsMrkMatchForDecrypt(AwsKmsArnIdentifier(c.value), AwsKmsArnIdentifier(m.value)) == (m.value.partition == c.value.partition && m.value.service == c.value.service && m.value.account == c.value.account && m.value.resource == c.value.resource)
    decreases config, message
  {
  }
}

module Constants {

  import UTF8 = UTF8
  const PROVIDER_ID: UTF8.ValidUTF8Bytes := var s: seq<uint8> := [97, 119, 115, 45, 107, 109, 115]; assert UTF8.ValidUTF8Range(s, 0, 7); s
}

module {:extern ""KeyringDefs""} KeyringDefs {

  import opened Wrappers = Wrappers

  import opened UInt = StandardLibrary.UInt

  import Materials = Materials

  import AlgorithmSuite = AlgorithmSuite
  trait {:termination false} Keyring {
    ghost var Repr: set<object>

    predicate Valid()
      reads this, Repr
      ensures Valid() ==> this in Repr
      decreases Repr + {this}

    method OnEncrypt(materials: Materials.ValidEncryptionMaterials) returns (res: Result<Materials.ValidEncryptionMaterials, string>)
      requires Valid()
      ensures Valid()
      ensures OnEncryptPure(materials, res)
      decreases materials

    method OnDecrypt(materials: Materials.ValidDecryptionMaterials, encryptedDataKeys: seq<Materials.EncryptedDataKey>) returns (res: Result<Materials.ValidDecryptionMaterials, string>)
      requires Valid()
      ensures Valid()
      ensures OnDecryptPure(materials, res)
      decreases materials, encryptedDataKeys
  }

  predicate OnEncryptPure(materials: Materials.ValidEncryptionMaterials, res: Result<Materials.ValidEncryptionMaterials, string>)
    decreases materials, res
  {
    res.Success? ==>
      materials.encryptionContext == res.value.encryptionContext &&
      materials.algorithmSuiteID == res.value.algorithmSuiteID &&
      materials.encryptedDataKeys <= res.value.encryptedDataKeys &&
      materials.signingKey == res.value.signingKey &&
      (materials.plaintextDataKey.Some? ==>
        res.value.plaintextDataKey == materials.plaintextDataKey)
  }

  predicate OnDecryptPure(materials: Materials.ValidDecryptionMaterials, res: Result<Materials.ValidDecryptionMaterials, string>)
    decreases materials, res
  {
    (res.Success? &&
    materials.plaintextDataKey.Some? ==>
      true &&
      materials == res.value) &&
    (res.Success? &&
    materials.plaintextDataKey.None? ==>
      materials.encryptionContext == res.value.encryptionContext &&
      materials.algorithmSuiteID == res.value.algorithmSuiteID &&
      materials.verificationKey == res.value.verificationKey &&
      res.value.plaintextDataKey.Some?)
  }
}

module {:extern ""RawAESKeyringDef""} RawAESKeyringDef {

  import opened StandardLibrary = StandardLibrary

  import opened Wrappers = Wrappers

  import Crypto = Aws.Crypto

  import opened UInt = StandardLibrary.UInt

  import EncryptionSuites = EncryptionSuites

  import AlgorithmSuite = AlgorithmSuite

  import Random = Random

  import AESEncryption = AESEncryption

  import Mat = Materials

  import MessageHeader = MessageHeader

  import UTF8 = UTF8

  import EncryptionContext = EncryptionContext

  import Serialize = Serialize

  import Streams = Streams
  class RawAESKeyring extends Crypto.IKeyring {
    const keyNamespace: UTF8.ValidUTF8Bytes
    const keyName: UTF8.ValidUTF8Bytes
    const wrappingKey: seq<uint8>
    const wrappingAlgorithm: EncryptionSuites.EncryptionSuite

    predicate method Valid()
    {
      |wrappingKey| == wrappingAlgorithm.keyLen as int &&
      wrappingAlgorithm in VALID_ALGORITHMS &&
      wrappingAlgorithm.Valid() &&
      |keyNamespace| < UINT16_LIMIT
    }

    predicate method ValidEncryptionMaterials(mat: Crypto.EncryptionMaterials)
      decreases mat
    {
      (AlgorithmSuite.PolymorphIDToInternalID(mat.algorithmSuiteId).SignatureType().Some? ==>
        mat.signingKey.Some?) &&
      (mat.plaintextDataKey.Some? ==>
        AlgorithmSuite.PolymorphIDToInternalID(mat.algorithmSuiteId).ValidPlaintextDataKey(mat.plaintextDataKey.value)) &&
      (mat.plaintextDataKey.None? ==>
        |mat.encryptedDataKeys| == 0)
    }

    constructor (namespace: UTF8.ValidUTF8Bytes, name: UTF8.ValidUTF8Bytes, key: seq<uint8>, wrappingAlg: EncryptionSuites.EncryptionSuite)
      requires |namespace| < UINT16_LIMIT
      requires wrappingAlg in VALID_ALGORITHMS
      requires wrappingAlg.Valid()
      requires |key| == 16 || |key| == 24 || |key| == 32
      requires |key| == wrappingAlg.keyLen as int
      ensures keyNamespace == namespace
      ensures keyName == name
      ensures wrappingKey == key
      ensures wrappingAlgorithm == wrappingAlg
      decreases namespace, name, key, wrappingAlg
    {
      keyNamespace := namespace;
      keyName := name;
      wrappingKey := key;
      wrappingAlgorithm := wrappingAlg;
    }

    function method SerializeProviderInfo(iv: seq<uint8>): seq<uint8>
      requires Valid()
      requires |iv| == wrappingAlgorithm.ivLen as int
      decreases iv
    {
      keyName + [0, 0, 0, wrappingAlgorithm.tagLen * 8] + [0, 0, 0, wrappingAlgorithm.ivLen] + iv
    }

    method OnEncrypt(input: Crypto.OnEncryptInput) returns (res: Result<Crypto.OnEncryptOutput, string>)
      ensures res.Success? ==> input.materials.encryptionContext == res.value.materials.encryptionContext && input.materials.algorithmSuiteId == res.value.materials.algorithmSuiteId && (input.materials.plaintextDataKey.Some? ==> res.value.materials.plaintextDataKey == input.materials.plaintextDataKey) && input.materials.encryptedDataKeys <= res.value.materials.encryptedDataKeys && input.materials.signingKey == res.value.materials.signingKey
      ensures res.Success? ==> true && var encCtxSerializable: bool := (reveal EncryptionContext.Serializable(); EncryptionContext.Serializable(input.materials.encryptionContext)); |res.value.materials.encryptedDataKeys| == |input.materials.encryptedDataKeys| + 1 && encCtxSerializable && wrappingAlgorithm.tagLen as nat <= |res.value.materials.encryptedDataKeys[|input.materials.encryptedDataKeys|].ciphertext| && var encOutput: AESEncryption.EncryptionOutput := DeserializeEDKCiphertext(res.value.materials.encryptedDataKeys[|input.materials.encryptedDataKeys|].ciphertext, wrappingAlgorithm.tagLen as nat); true && AESEncryption.EncryptionOutputEncryptedWithAAD(encOutput, EncryptionContext.MapToSeq(input.materials.encryptionContext))
      ensures res.Success? ==> |res.value.materials.encryptedDataKeys| == |input.materials.encryptedDataKeys| + 1 && res.value.materials.encryptedDataKeys[|input.materials.encryptedDataKeys|].keyProviderId == keyNamespace && ValidProviderInfo(res.value.materials.encryptedDataKeys[|input.materials.encryptedDataKeys|].keyProviderInfo)
      ensures !EncryptionContext.Serializable(input.materials.encryptionContext) ==> res.Failure?
      decreases input
    {
      :- Need(Valid(), ""Keyring in invalid state"");
      :- Need(ValidEncryptionMaterials(input.materials), ""input encryption materials invalid"");
      reveal EncryptionContext.Serializable();
      var valid := EncryptionContext.CheckSerializable(input.materials.encryptionContext);
      if !valid {
        return Failure(""Unable to serialize encryption context"");
      }
      var materialsWithDataKey := input.materials;
      if materialsWithDataKey.plaintextDataKey.None? {
        var k :- Random.GenerateBytes(AlgorithmSuite.PolymorphIDToInternalID(input.materials.algorithmSuiteId).KeyLength() as int32);
        materialsWithDataKey := Crypto.EncryptionMaterials(encryptionContext := materialsWithDataKey.encryptionContext, algorithmSuiteId := materialsWithDataKey.algorithmSuiteId, signingKey := materialsWithDataKey.signingKey, plaintextDataKey := Some(k), encryptedDataKeys := []);
      }
      var iv :- Random.GenerateBytes(wrappingAlgorithm.ivLen as int32);
      var providerInfo := SerializeProviderInfo(iv);
      var wr := new Streams.ByteWriter();
      var _ :- Serialize.SerializeKVPairs(wr, input.materials.encryptionContext);
      var aad := wr.GetDataWritten();
      assert aad == EncryptionContext.MapToSeq(input.materials.encryptionContext);
      var encryptResult :- AESEncryption.AESEncrypt(wrappingAlgorithm, iv, wrappingKey, materialsWithDataKey.plaintextDataKey.value, aad);
      var encryptedKey := SerializeEDKCiphertext(encryptResult);
      if UINT16_LIMIT <= |providerInfo| {
        return Failure(""Serialized provider info too long."");
      }
      if UINT16_LIMIT <= |encryptedKey| {
        return Failure(""Encrypted data key too long."");
      }
      var edk: Crypto.ValidEncryptedDataKey := Crypto.EncryptedDataKey(keyProviderId := keyNamespace, keyProviderInfo := providerInfo, ciphertext := encryptedKey);
      var edks: seq<Crypto.ValidEncryptedDataKey> := materialsWithDataKey.encryptedDataKeys + [edk];
      var r := Crypto.EncryptionMaterials(encryptionContext := materialsWithDataKey.encryptionContext, algorithmSuiteId := materialsWithDataKey.algorithmSuiteId, signingKey := materialsWithDataKey.signingKey, plaintextDataKey := materialsWithDataKey.plaintextDataKey, encryptedDataKeys := edks);
      assert materialsWithDataKey.encryptedDataKeys == input.materials.encryptedDataKeys;
      assert |edks| == |materialsWithDataKey.encryptedDataKeys| + 1;
      assert r.encryptedDataKeys == edks;
      assert |r.encryptedDataKeys| == |edks|;
      assert |r.encryptedDataKeys| >= |input.materials.encryptedDataKeys|;
      res := Success(Crypto.OnEncryptOutput(materials := r));
    }

    method OnDecrypt(input: Crypto.OnDecryptInput) returns (res: Result<Crypto.OnDecryptOutput, string>)
      ensures Valid() && |input.encryptedDataKeys| == 0 ==> res.Success? && input.materials == res.value.materials
      ensures Valid() && input.materials.plaintextDataKey.Some? ==> res.Success? && input.materials == res.value.materials
      ensures res.Success? ==> input.materials.encryptionContext == res.value.materials.encryptionContext && input.materials.algorithmSuiteId == res.value.materials.algorithmSuiteId && (input.materials.plaintextDataKey.Some? ==> res.value.materials.plaintextDataKey == input.materials.plaintextDataKey) && res.value.materials.verificationKey == input.materials.verificationKey
      ensures res.Success? && input.materials.plaintextDataKey.None? && res.value.materials.plaintextDataKey.Some? ==> var encCtxSerializable: bool := (reveal EncryptionContext.Serializable(); EncryptionContext.Serializable(input.materials.encryptionContext)); encCtxSerializable && AESEncryption.PlaintextDecryptedWithAAD(res.value.materials.plaintextDataKey.value, EncryptionContext.MapToSeq(input.materials.encryptionContext))
      ensures input.materials.plaintextDataKey.None? && !EncryptionContext.Serializable(input.materials.encryptionContext) && (exists i: int :: 0 <= i < |input.encryptedDataKeys| && ShouldDecryptEDK(input.encryptedDataKeys[i])) ==> res.Failure?
      decreases input
    {
      :- Need(Valid(), ""Keyring in invalid state"");
      if input.materials.plaintextDataKey.Some? {
        return Success(Crypto.OnDecryptOutput(materials := input.materials));
      }
      var i := 0;
      while i < |input.encryptedDataKeys|
        invariant forall prevIndex: int :: 0 <= prevIndex < i ==> prevIndex < |input.encryptedDataKeys| && !ShouldDecryptEDK(input.encryptedDataKeys[prevIndex])
        decreases |input.encryptedDataKeys| - i
      {
        if ShouldDecryptEDK(input.encryptedDataKeys[i]) {
          reveal EncryptionContext.Serializable();
          var valid := EncryptionContext.CheckSerializable(input.materials.encryptionContext);
          if !valid {
            return Failure(""Unable to serialize encryption context"");
          }
          var wr := new Streams.ByteWriter();
          var _ :- Serialize.SerializeKVPairs(wr, input.materials.encryptionContext);
          var aad := wr.GetDataWritten();
          assert aad == EncryptionContext.MapToSeq(input.materials.encryptionContext);
          var iv := GetIvFromProvInfo(input.encryptedDataKeys[i].keyProviderInfo);
          var encryptionOutput := DeserializeEDKCiphertext(input.encryptedDataKeys[i].ciphertext, wrappingAlgorithm.tagLen as nat);
          var ptKey :- AESEncryption.AESDecrypt(wrappingAlgorithm, wrappingKey, encryptionOutput.cipherText, encryptionOutput.authTag, iv, aad);
          if AlgorithmSuite.PolymorphIDToInternalID(input.materials.algorithmSuiteId).ValidPlaintextDataKey(ptKey) {
            var r := Crypto.DecryptionMaterials(encryptionContext := input.materials.encryptionContext, algorithmSuiteId := input.materials.algorithmSuiteId, verificationKey := input.materials.verificationKey, plaintextDataKey := Some(ptKey));
            return Success(Crypto.OnDecryptOutput(materials := r));
          } else {
            return Failure(""Decryption failed: bad datakey length."");
          }
        }
        i := i + 1;
      }
      return Success(Crypto.OnDecryptOutput(materials := input.materials));
    }

    predicate method ShouldDecryptEDK(edk: Crypto.EncryptedDataKey)
      decreases edk
    {
      edk.keyProviderId == keyNamespace &&
      ValidProviderInfo(edk.keyProviderInfo) &&
      wrappingAlgorithm.tagLen as int <= |edk.ciphertext|
    }

    predicate method ValidProviderInfo(info: seq<uint8>)
      decreases info
    {
      |info| == |keyName| + AUTH_TAG_LEN_LEN + IV_LEN_LEN + wrappingAlgorithm.ivLen as int &&
      info[0 .. |keyName|] == keyName &&
      SeqToUInt32(info[|keyName| .. |keyName| + AUTH_TAG_LEN_LEN]) == 128 &&
      SeqToUInt32(info[|keyName| .. |keyName| + AUTH_TAG_LEN_LEN]) == wrappingAlgorithm.tagLen as uint32 * 8 &&
      SeqToUInt32(info[|keyName| + AUTH_TAG_LEN_LEN .. |keyName| + AUTH_TAG_LEN_LEN + IV_LEN_LEN]) == wrappingAlgorithm.ivLen as uint32 &&
      SeqToUInt32(info[|keyName| + AUTH_TAG_LEN_LEN .. |keyName| + AUTH_TAG_LEN_LEN + IV_LEN_LEN]) == 12
    }

    function method GetIvFromProvInfo(info: seq<uint8>): seq<uint8>
      requires ValidProviderInfo(info)
      decreases info
    {
      info[|keyName| + AUTH_TAG_LEN_LEN + IV_LEN_LEN..]
    }
  }

  const AUTH_TAG_LEN_LEN := 4
  const IV_LEN_LEN := 4
  const VALID_ALGORITHMS := {EncryptionSuites.AES_GCM_128, EncryptionSuites.AES_GCM_192, EncryptionSuites.AES_GCM_256}

  function method DeserializeEDKCiphertext(ciphertext: seq<uint8>, tagLen: nat): (encOutput: AESEncryption.EncryptionOutput)
    requires tagLen <= |ciphertext|
    ensures |encOutput.authTag| == tagLen
    decreases ciphertext, tagLen
  {
    var encryptedKeyLength: int := |ciphertext| - tagLen as int;
    AESEncryption.EncryptionOutput(ciphertext[..encryptedKeyLength], ciphertext[encryptedKeyLength..])
  }

  function method SerializeEDKCiphertext(encOutput: AESEncryption.EncryptionOutput): (ciphertext: seq<uint8>)
    decreases encOutput
  {
    encOutput.cipherText + encOutput.authTag
  }

  lemma EDKSerializeDeserialize(encOutput: AESEncryption.EncryptionOutput)
    ensures DeserializeEDKCiphertext(SerializeEDKCiphertext(encOutput), |encOutput.authTag|) == encOutput
    decreases encOutput
  {
  }

  lemma EDKDeserializeSerialze(ciphertext: seq<uint8>, tagLen: nat)
    requires tagLen <= |ciphertext|
    ensures SerializeEDKCiphertext(DeserializeEDKCiphertext(ciphertext, tagLen)) == ciphertext
    decreases ciphertext, tagLen
  {
  }
}

module {:extern ""Materials""} Materials {

  import opened StandardLibrary = StandardLibrary

  import opened Wrappers = Wrappers

  import opened UInt = StandardLibrary.UInt

  import UTF8 = UTF8

  import AlgorithmSuite = AlgorithmSuite

  import EncryptionContext = EncryptionContext
  datatype EncryptedDataKey = EncryptedDataKey(providerID: UTF8.ValidUTF8Bytes, providerInfo: seq<uint8>, ciphertext: seq<uint8>) {
    predicate Valid()
      decreases this
    {
      |providerID| < UINT16_LIMIT &&
      |providerInfo| < UINT16_LIMIT &&
      |ciphertext| < UINT16_LIMIT
    }

    static function method ValidWitness(): EncryptedDataKey
    {
      EncryptedDataKey([], [], [])
    }
  }

  type ValidEncryptedDataKey = i: EncryptedDataKey
    | i.Valid()
    witness EncryptedDataKey.ValidWitness()

  datatype EncryptionMaterials = EncryptionMaterials(encryptionContext: EncryptionContext.Map, algorithmSuiteID: AlgorithmSuite.ID, plaintextDataKey: Option<seq<uint8>>, encryptedDataKeys: seq<ValidEncryptedDataKey>, signingKey: Option<seq<uint8>>) {
    predicate Valid()
      decreases this
    {
      (algorithmSuiteID.SignatureType().Some? ==>
        signingKey.Some?) &&
      (plaintextDataKey.Some? ==>
        algorithmSuiteID.ValidPlaintextDataKey(plaintextDataKey.value)) &&
      (plaintextDataKey.None? ==>
        |encryptedDataKeys| == 0)
    }

    predicate Empty()
      decreases this
    {
      plaintextDataKey.None? &&
      |encryptedDataKeys| == 0 &&
      (algorithmSuiteID.SignatureType().Some? ==>
        signingKey.Some?)
    }

    predicate Useable()
      decreases this
    {
      plaintextDataKey.Some? &&
      algorithmSuiteID.ValidPlaintextDataKey(plaintextDataKey.value) &&
      |encryptedDataKeys| > 0 &&
      (algorithmSuiteID.SignatureType().Some? ==>
        signingKey.Some?)
    }

    predicate Serializable()
      decreases this
    {
      |encryptedDataKeys| > 0 &&
      EncryptionContext.Serializable(encryptionContext)
    }

    static function method ValidWitness(): EncryptionMaterials
    {
      EncryptionMaterials(map[], AlgorithmSuite.AES_256_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384, None, [], Some(seq(32, (i: int) => 0)))
    }

    static function method WithoutDataKeys(encryptionContext: EncryptionContext.Map, algorithmSuiteID: AlgorithmSuite.ID, signingKey: Option<seq<uint8>>): ValidEncryptionMaterials
      requires algorithmSuiteID.SignatureType().Some? ==> signingKey.Some?
      decreases encryptionContext, algorithmSuiteID, signingKey
    {
      var m: EncryptionMaterials := EncryptionMaterials(encryptionContext, algorithmSuiteID, None, [], signingKey);
      assert m.Valid();
      m
    }

    function method WithKeys(newPlaintextDataKey: Option<seq<uint8>>, newEncryptedDataKeys: seq<ValidEncryptedDataKey>): (res: ValidEncryptionMaterials)
      requires Valid()
      requires this.plaintextDataKey.Some? ==> newPlaintextDataKey == this.plaintextDataKey
      requires newPlaintextDataKey.Some? ==> this.algorithmSuiteID.ValidPlaintextDataKey(newPlaintextDataKey.value)
      requires newPlaintextDataKey.None? ==> |newEncryptedDataKeys| == 0
      ensures this.encryptionContext == res.encryptionContext
      ensures this.algorithmSuiteID == res.algorithmSuiteID
      ensures newPlaintextDataKey == res.plaintextDataKey
      ensures this.encryptedDataKeys + newEncryptedDataKeys == res.encryptedDataKeys
      ensures this.signingKey == res.signingKey
      decreases this, newPlaintextDataKey, newEncryptedDataKeys
    {
      var r: EncryptionMaterials := this.(plaintextDataKey := newPlaintextDataKey, encryptedDataKeys := encryptedDataKeys + newEncryptedDataKeys);
      assert r.Valid();
      r
    }
  }

  type ValidEncryptionMaterials = i: EncryptionMaterials
    | i.Valid()
    witness EncryptionMaterials.ValidWitness()

  type EmptyEncryptionMaterials = i: EncryptionMaterials
    | i.Empty()
    witness *

  type UseableEncryptionMaterials = i: EncryptionMaterials
    | i.Useable()
    witness *

  datatype DecryptionMaterials = DecryptionMaterials(algorithmSuiteID: AlgorithmSuite.ID, encryptionContext: EncryptionContext.Map, plaintextDataKey: Option<seq<uint8>>, verificationKey: Option<seq<uint8>>) {
    predicate Valid()
      decreases this
    {
      (plaintextDataKey.Some? ==>
        algorithmSuiteID.ValidPlaintextDataKey(plaintextDataKey.value)) &&
      (algorithmSuiteID.SignatureType().Some? ==>
        verificationKey.Some?)
    }

    predicate Pending()
      decreases this
    {
      plaintextDataKey.None? &&
      (algorithmSuiteID.SignatureType().Some? ==>
        verificationKey.Some?)
    }

    predicate Complete()
      decreases this
    {
      plaintextDataKey.Some? &&
      algorithmSuiteID.ValidPlaintextDataKey(plaintextDataKey.value) &&
      (algorithmSuiteID.SignatureType().Some? ==>
        verificationKey.Some?)
    }

    static function method ValidWitness(): DecryptionMaterials
    {
      DecryptionMaterials(AlgorithmSuite.AES_256_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384, map[], Some(seq(32, (i: int) => 0)), Some(seq(32, (i: int) => 0)))
    }

    static function method WithoutPlaintextDataKey(encryptionContext: EncryptionContext.Map, algorithmSuiteID: AlgorithmSuite.ID, verificationKey: Option<seq<uint8>>): ValidDecryptionMaterials
      requires algorithmSuiteID.SignatureType().Some? ==> verificationKey.Some?
      decreases encryptionContext, algorithmSuiteID, verificationKey
    {
      var m: DecryptionMaterials := DecryptionMaterials(algorithmSuiteID, encryptionContext, None, verificationKey);
      assert m.Valid();
      m
    }

    function method WithPlaintextDataKey(plaintextDataKey: seq<uint8>): (res: ValidDecryptionMaterials)
      requires Valid()
      requires this.plaintextDataKey.None?
      requires algorithmSuiteID.ValidPlaintextDataKey(plaintextDataKey)
      ensures this.encryptionContext == res.encryptionContext
      ensures this.algorithmSuiteID == res.algorithmSuiteID
      ensures res.plaintextDataKey.Some?
      ensures this.verificationKey == res.verificationKey
      decreases this, plaintextDataKey
    {
      var m: DecryptionMaterials := this.(plaintextDataKey := Some(plaintextDataKey));
      assert m.Valid();
      m
    }
  }

  type PendingDecryptionMaterials = i: DecryptionMaterials
    | i.Pending()
    witness *

  type CompleteDecryptionMaterials = i: DecryptionMaterials
    | i.Complete()
    witness *

  type ValidDecryptionMaterials = i: DecryptionMaterials
    | i.Valid()
    witness DecryptionMaterials.ValidWitness()

  datatype EncryptionMaterialsRequest = EncryptionMaterialsRequest(encryptionContext: EncryptionContext.Map, algorithmSuiteID: Option<AlgorithmSuite.ID>, plaintextLength: Option<nat>)

  datatype DecryptionMaterialsRequest = DecryptionMaterialsRequest(algorithmSuiteID: AlgorithmSuite.ID, encryptedDataKeys: seq<ValidEncryptedDataKey>, encryptionContext: EncryptionContext.Map) {
    predicate Valid()
      decreases this
    {
      |encryptedDataKeys| > 0
    }

    static function method ValidWitness(): DecryptionMaterialsRequest
    {
      DecryptionMaterialsRequest(AlgorithmSuite.AES_256_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384, [EncryptedDataKey.ValidWitness()], map[])
    }
  }

  type ValidDecryptionMaterialsRequest = i: DecryptionMaterialsRequest
    | i.Valid()
    witness DecryptionMaterialsRequest.ValidWitness()

  const EC_PUBLIC_KEY_FIELD: UTF8.ValidUTF8Bytes := var s: seq<uint8> := [97, 119, 115, 45, 99, 114, 121, 112, 116, 111, 45, 112, 117, 98, 108, 105, 99, 45, 107, 101, 121]; assert UTF8.ValidUTF8Range(s, 0, 21); s
  const RESERVED_KEY_VALUES := {EC_PUBLIC_KEY_FIELD}
}

module MessageBody {

  export
    provides EncryptMessageBody, DecryptFramedMessageBody, DecryptNonFramedMessageBody, Wrappers, UInt, Msg, AlgorithmSuite, Materials, Streams, FramesToSequence, FrameToSequence, ValidFrames, FramesEncryptPlaintext, AESEncryption, DecryptedWithKey
    reveals Frame, Frame.Valid, SeqWithGhostFrames


  import opened Wrappers = Wrappers

  import opened UInt = StandardLibrary.UInt

  import AlgorithmSuite = AlgorithmSuite

  import Msg = MessageHeader

  import AESEncryption = AESEncryption

  import Materials = Materials

  import Streams = Streams

  import EncryptionSuites = EncryptionSuites

  import UTF8 = UTF8
  datatype BodyAADContent = AADRegularFrame | AADFinalFrame | AADSingleBlock

  datatype Frame = RegularFrame(seqNum: uint32, iv: seq<uint8>, encContent: seq<uint8>, authTag: seq<uint8>) | FinalFrame(seqNum: uint32, iv: seq<uint8>, encContent: seq<uint8>, authTag: seq<uint8>) {
    predicate Valid()
      decreases this
    {
      |encContent| < UINT32_LIMIT
    }
  }

  datatype SeqWithGhostFrames = SeqWithGhostFrames(sequence: seq<uint8>, ghost frames: seq<Frame>)

  datatype FrameWithGhostSeq = FrameWithGhostSeq(frame: Frame, ghost sequence: seq<uint8>)

  predicate ValidFrames(frames: seq<Frame>)
    decreases frames
  {
    0 < |frames| < UINT32_LIMIT &&
    forall i: int | 0 <= i < |frames| :: 
      ghost var frame: Frame := frames[i]; frame.Valid() && (if i == |frames| - 1 then frame.FinalFrame? else frame.RegularFrame?) && frame.seqNum as int == i + START_SEQUENCE_NUMBER as int && forall j: int | i < j < |frames| :: frame.iv != frames[j].iv
  }

  const BODY_AAD_CONTENT_REGULAR_FRAME: string := ""AWSKMSEncryptionClient Frame""
  const BODY_AAD_CONTENT_FINAL_FRAME: string := ""AWSKMSEncryptionClient Final Frame""
  const BODY_AAD_CONTENT_SINGLE_BLOCK: string := ""AWSKMSEncryptionClient Single Block""

  function method BodyAADContentTypeString(bc: BodyAADContent): string
    decreases bc
  {
    match bc
    case AADRegularFrame() =>
      BODY_AAD_CONTENT_REGULAR_FRAME
    case AADFinalFrame() =>
      BODY_AAD_CONTENT_FINAL_FRAME
    case AADSingleBlock() =>
      BODY_AAD_CONTENT_SINGLE_BLOCK
  }

  const START_SEQUENCE_NUMBER: uint32 := 1
  const ENDFRAME_SEQUENCE_NUMBER: uint32 := 4294967295
  const NONFRAMED_SEQUENCE_NUMBER: uint32 := 1

  function method IVSeq(algorithmSuiteID: AlgorithmSuite.ID, sequenceNumber: uint32): seq<uint8>
    decreases algorithmSuiteID, sequenceNumber
  {
    seq(algorithmSuiteID.IVLength() - 4, (_: int) => 0) + UInt32ToSeq(sequenceNumber)
  }

  lemma IVSeqDistinct(algorithmSuiteID: AlgorithmSuite.ID, m: uint32, n: uint32)
    requires m != n
    ensures IVSeq(algorithmSuiteID, m) != IVSeq(algorithmSuiteID, n)
    decreases algorithmSuiteID, m, n
  {
    ghost var paddingLength := algorithmSuiteID.IVLength() - 4;
    assert IVSeq(algorithmSuiteID, m)[paddingLength..] == UInt32ToSeq(m);
    assert IVSeq(algorithmSuiteID, n)[paddingLength..] == UInt32ToSeq(n);
    UInt32SeqSerializeDeserialize(m);
    UInt32SeqSerializeDeserialize(n);
  }

  function FramesToSequence(frames: seq<Frame>): seq<uint8>
    requires forall frame: Frame | frame in frames :: frame.Valid()
    decreases frames
  {
    if frames == [] then
      []
    else
      FramesToSequence(frames[..|frames| - 1]) + FrameToSequence(frames[|frames| - 1])
  }

  lemma /*{:_induction frames}*/ ExtendFramesToSequence(frames: seq<Frame>, frame: Frame)
    requires |frames| < UINT32_LIMIT - 1
    requires forall frame: Frame | frame in frames :: frame.Valid()
    requires frame.Valid()
    ensures FramesToSequence(frames + [frame]) == FramesToSequence(frames) + FrameToSequence(frame)
    decreases frames, frame
  {
  }

  function FrameToSequence(frame: Frame): (res: seq<uint8>)
    requires frame.Valid()
    ensures match frame { case RegularFrame(_mcc#0, _mcc#1, _mcc#2, _mcc#3) => (var authTag: seq<uint8> := _mcc#3; var encContent: seq<uint8> := _mcc#2; var iv: seq<uint8> := _mcc#1; 4 + |iv| + |encContent| + |authTag| == |res|) case FinalFrame(_mcc#4, _mcc#5, _mcc#6, _mcc#7) => var authTag: seq<uint8> := _mcc#7; var encContent: seq<uint8> := _mcc#6; var iv: seq<uint8> := _mcc#5; var seqNum: uint32 := _mcc#4; 4 + 4 + |iv| + 4 + |encContent| + |authTag| == |res| }
    decreases frame
  {
    match frame
    case RegularFrame(seqNum, iv, encContent, authTag) =>
      var seqNumSeq := UInt32ToSeq(seqNum);
      seqNumSeq + iv + encContent + authTag
    case FinalFrame(seqNum, iv, encContent, authTag) =>
      var seqNumEndSeq := UInt32ToSeq(ENDFRAME_SEQUENCE_NUMBER);
      var seqNumSeq := UInt32ToSeq(seqNum);
      var encContentLengthSeq := UInt32ToSeq(|encContent| as uint32);
      seqNumEndSeq + seqNumSeq + iv + encContentLengthSeq + encContent + authTag
  }

  predicate FramesEncryptPlaintext(frames: seq<Frame>, plaintext: seq<uint8>)
    decreases frames, plaintext
  {
    exists plaintextSeg: seq<seq<uint8>> :: 
      FramesEncryptPlaintextSegments(frames, plaintextSeg) &&
      SumPlaintextSegments(plaintextSeg) == plaintext
  }

  predicate FramesEncryptPlaintextSegments(frames: seq<Frame>, plaintextSeg: seq<seq<uint8>>)
    decreases frames, plaintextSeg
  {
    if |frames| != |plaintextSeg| then
      false
    else if frames == [] then
      true
    else
      FramesEncryptPlaintextSegments(frames[..|frames| - 1], plaintextSeg[..|frames| - 1]) && AESEncryption.CiphertextGeneratedWithPlaintext(frames[|frames| - 1].encContent, plaintextSeg[|frames| - 1])
  }

  lemma /*{:_induction frames, plaintextSeg}*/ ExtendFramesEncryptPlaintextSegments(frames: seq<Frame>, plaintextSeg: seq<seq<uint8>>, frame: Frame, plaintextFrame: seq<uint8>)
    requires FramesEncryptPlaintextSegments(frames, plaintextSeg)
    requires AESEncryption.CiphertextGeneratedWithPlaintext(frame.encContent, plaintextFrame)
    ensures FramesEncryptPlaintextSegments(frames + [frame], plaintextSeg + [plaintextFrame])
    decreases frames, plaintextSeg, frame, plaintextFrame
  {
  }

  function SumPlaintextSegments(plaintextSeg: seq<seq<uint8>>): seq<uint8>
    decreases plaintextSeg
  {
    if plaintextSeg == [] then
      []
    else
      SumPlaintextSegments(plaintextSeg[..|plaintextSeg| - 1]) + plaintextSeg[|plaintextSeg| - 1]
  }

  lemma /*{:_induction plaintextSeg}*/ ExtendSumPlaintextSegments(plaintextSeg: seq<seq<uint8>>, plaintextFrame: seq<uint8>)
    ensures SumPlaintextSegments(plaintextSeg + [plaintextFrame]) == SumPlaintextSegments(plaintextSeg) + plaintextFrame
    decreases plaintextSeg, plaintextFrame
  {
  }

  method EncryptMessageBody(plaintext: seq<uint8>, frameLength: int, messageID: Msg.MessageID, key: seq<uint8>, algorithmSuiteID: AlgorithmSuite.ID)
      returns (result: Result<SeqWithGhostFrames, string>)
    requires |key| == algorithmSuiteID.KeyLength()
    requires 0 < frameLength < UINT32_LIMIT
    ensures match result { case Success(_mcc#0) => (var seqWithGhostFrames := _mcc#0; var frames := seqWithGhostFrames.frames; ValidFrames(frames) && (forall frame | frame in frames :: frame.Valid()) && (forall frame: Frame | frame in frames :: |frame.iv| == algorithmSuiteID.IVLength()) && FramesToSequence(frames) == seqWithGhostFrames.sequence && FramesEncryptPlaintext(frames, plaintext) && forall frame: Frame | frame in frames :: AESEncryption.EncryptedWithKey(frame.encContent, key)) case Failure(_mcc#1) => var e := _mcc#1; true }
    decreases plaintext, frameLength, messageID, key, algorithmSuiteID
  {
    var body := [];
    var n: int, sequenceNumber := 0, START_SEQUENCE_NUMBER;
    ghost var frames: seq<Frame> := [];
    ghost var plaintextSeg := [];
    while n + frameLength < |plaintext|
      invariant |plaintext| != 0 ==> 0 <= n < |plaintext|
      invariant |plaintext| == 0 ==> 0 == n
      invariant START_SEQUENCE_NUMBER <= sequenceNumber <= ENDFRAME_SEQUENCE_NUMBER
      invariant |frames| == (sequenceNumber - START_SEQUENCE_NUMBER) as int
      invariant forall i: int | 0 <= i < |frames| :: var frame: Frame := frames[i]; frame.Valid() && frame.RegularFrame? && frame.seqNum as int == i + START_SEQUENCE_NUMBER as int
      invariant forall i: int | 0 <= i < |frames| :: frames[i].iv == IVSeq(algorithmSuiteID, frames[i].seqNum)
      invariant FramesToSequence(frames) == body
      invariant FramesEncryptPlaintextSegments(frames, plaintextSeg)
      invariant SumPlaintextSegments(plaintextSeg) == plaintext[..n]
      invariant forall frame: Frame | frame in frames :: AESEncryption.EncryptedWithKey(frame.encContent, key)
      decreases |plaintext| - (n + frameLength)
    {
      if sequenceNumber == ENDFRAME_SEQUENCE_NUMBER {
        return Failure(""too many frames"");
      }
      var plaintextFrame := plaintext[n .. n + frameLength];
      var regularFrame, frame := EncryptRegularFrame(algorithmSuiteID, key, frameLength, messageID, plaintextFrame, sequenceNumber);
      if regularFrame.IsFailure() {
        return regularFrame.PropagateFailure();
      }
      assert frame.iv == IVSeq(algorithmSuiteID, sequenceNumber);
      ExtendFramesToSequence(frames, frame);
      ExtendFramesEncryptPlaintextSegments(frames, plaintextSeg, frame, plaintextFrame);
      ExtendSumPlaintextSegments(plaintextSeg, plaintextFrame);
      frames := frames + [frame];
      body := body + regularFrame.Extract();
      plaintextSeg := plaintextSeg + [plaintextFrame];
      n, sequenceNumber := n + frameLength, sequenceNumber + 1;
      assert SumPlaintextSegments(plaintextSeg) == plaintext[..n];
    }
    var finalFrameResult, finalFrame := EncryptFinalFrame(algorithmSuiteID, key, frameLength, messageID, plaintext[n..], sequenceNumber);
    if finalFrameResult.IsFailure() {
      return finalFrameResult.PropagateFailure();
    }
    var finalFrameSequence := finalFrameResult.Extract();
    assert finalFrame.iv == IVSeq(algorithmSuiteID, sequenceNumber);
    ExtendFramesToSequence(frames, finalFrame);
    ExtendFramesEncryptPlaintextSegments(frames, plaintextSeg, finalFrame, plaintext[n..]);
    ExtendSumPlaintextSegments(plaintextSeg, plaintext[n..]);
    frames := frames + [finalFrame];
    body := body + finalFrameSequence;
    plaintextSeg := plaintextSeg + [plaintext[n..]];
    assert ValidFrames(frames) by {
      forall i: int, j: int | 0 <= i < j < |frames|
        ensures frames[i].iv != frames[j].iv
      {
        assert frames[i].seqNum as int == i + START_SEQUENCE_NUMBER as int;
        assert frames[j].seqNum as int == j + START_SEQUENCE_NUMBER as int;
        assert frames[i].iv == IVSeq(algorithmSuiteID, frames[i].seqNum);
        assert frames[j].iv == IVSeq(algorithmSuiteID, frames[j].seqNum);
        IVSeqDistinct(algorithmSuiteID, frames[i].seqNum, frames[j].seqNum);
      }
    }
    result := Success(SeqWithGhostFrames(body, frames));
  }

  method EncryptRegularFrame(algorithmSuiteID: AlgorithmSuite.ID, key: seq<uint8>, ghost frameLength: int, messageID: Msg.MessageID, plaintext: seq<uint8>, sequenceNumber: uint32)
      returns (res: Result<seq<uint8>, string>, ghost regFrame: Frame)
    requires |key| == algorithmSuiteID.KeyLength()
    requires 0 < frameLength < UINT32_LIMIT && START_SEQUENCE_NUMBER <= sequenceNumber <= ENDFRAME_SEQUENCE_NUMBER
    requires |plaintext| < UINT32_LIMIT
    requires |plaintext| == frameLength && sequenceNumber != ENDFRAME_SEQUENCE_NUMBER
    requires 4 <= algorithmSuiteID.IVLength()
    ensures match res { case Success(_mcc#0) => (var resultSuccess := _mcc#0; 4 + algorithmSuiteID.IVLength() + algorithmSuiteID.TagLength() + frameLength == |resultSuccess| && var iv := IVSeq(algorithmSuiteID, sequenceNumber); var encContent := resultSuccess[4 + algorithmSuiteID.IVLength() .. 4 + algorithmSuiteID.IVLength() + frameLength]; var authTag := resultSuccess[4 + algorithmSuiteID.IVLength() + frameLength..]; var frame := RegularFrame(sequenceNumber, iv, encContent, authTag); frame == regFrame && FrameToSequence(regFrame) == resultSuccess && AESEncryption.CiphertextGeneratedWithPlaintext(frame.encContent, plaintext) && AESEncryption.EncryptedWithKey(frame.encContent, key)) case Failure(_mcc#1) => var e := _mcc#1; true }
    decreases algorithmSuiteID, key, frameLength, messageID, plaintext, sequenceNumber
  {
    var seqNumSeq := UInt32ToSeq(sequenceNumber);
    var unauthenticatedFrame := seqNumSeq;
    var iv := IVSeq(algorithmSuiteID, sequenceNumber);
    var aad := BodyAAD(messageID, AADRegularFrame, sequenceNumber, |plaintext| as uint64);
    var encryptionOutputResult := AESEncryption.AESEncrypt(algorithmSuiteID.EncryptionSuite(), iv, key, plaintext, aad);
    if encryptionOutputResult.IsFailure() {
      res := encryptionOutputResult.PropagateFailure();
      regFrame := RegularFrame(0, [], [], []);
      return;
    }
    var encryptionOutput := encryptionOutputResult.Extract();
    ghost var frame := RegularFrame(sequenceNumber, iv, encryptionOutput.cipherText, encryptionOutput.authTag);
    SeqWithUInt32Suffix(iv, sequenceNumber as nat);
    unauthenticatedFrame := unauthenticatedFrame + iv;
    unauthenticatedFrame := unauthenticatedFrame + encryptionOutput.cipherText + encryptionOutput.authTag;
    return Success(unauthenticatedFrame), frame;
  }

  method EncryptFinalFrame(algorithmSuiteID: AlgorithmSuite.ID, key: seq<uint8>, frameLength: int, messageID: Msg.MessageID, plaintext: seq<uint8>, sequenceNumber: uint32)
      returns (res: Result<seq<uint8>, string>, ghost finalFrame: Frame)
    requires |key| == algorithmSuiteID.KeyLength()
    requires START_SEQUENCE_NUMBER <= sequenceNumber <= ENDFRAME_SEQUENCE_NUMBER
    requires 0 <= |plaintext| < UINT32_LIMIT
    requires 0 < frameLength < UINT32_LIMIT
    requires |plaintext| <= frameLength
    requires 4 <= algorithmSuiteID.IVLength()
    ensures match res { case Success(_mcc#0) => (var resultSuccess := _mcc#0; 4 + 4 + algorithmSuiteID.IVLength() + 4 + algorithmSuiteID.TagLength() <= |resultSuccess| <= 4 + 4 + algorithmSuiteID.IVLength() + 4 + algorithmSuiteID.TagLength() + frameLength && var contentLength: uint32 := SeqToUInt32(resultSuccess[4 + 4 + algorithmSuiteID.IVLength() .. 4 + 4 + algorithmSuiteID.IVLength() + 4]); |resultSuccess| == 4 + 4 + algorithmSuiteID.IVLength() + 4 + contentLength as int + algorithmSuiteID.TagLength() && resultSuccess[..4] == UInt32ToSeq(ENDFRAME_SEQUENCE_NUMBER) && |plaintext| == SeqToUInt32(resultSuccess[4 + 4 + algorithmSuiteID.IVLength() .. 4 + 4 + algorithmSuiteID.IVLength() + 4]) as int && var iv := IVSeq(algorithmSuiteID, sequenceNumber); var encContent := resultSuccess[4 + 4 + algorithmSuiteID.IVLength() + 4..][..|plaintext|]; var authTag := resultSuccess[4 + 4 + algorithmSuiteID.IVLength() + 4 + |plaintext|..]; var frame := FinalFrame(sequenceNumber, iv, encContent, authTag); FrameToSequence(frame) == resultSuccess && finalFrame == frame && AESEncryption.CiphertextGeneratedWithPlaintext(frame.encContent, plaintext) && AESEncryption.EncryptedWithKey(frame.encContent, key)) case Failure(_mcc#1) => var e := _mcc#1; true }
    decreases algorithmSuiteID, key, frameLength, messageID, plaintext, sequenceNumber
  {
    var unauthenticatedFrame := UInt32ToSeq(ENDFRAME_SEQUENCE_NUMBER);
    var seqNumSeq := UInt32ToSeq(sequenceNumber);
    unauthenticatedFrame := unauthenticatedFrame + seqNumSeq;
    var iv := IVSeq(algorithmSuiteID, sequenceNumber);
    SeqWithUInt32Suffix(iv, sequenceNumber as nat);
    unauthenticatedFrame := unauthenticatedFrame + iv;
    unauthenticatedFrame := unauthenticatedFrame + UInt32ToSeq(|plaintext| as uint32);
    var aad := BodyAAD(messageID, AADFinalFrame, sequenceNumber, |plaintext| as uint64);
    var encryptionOutputResult := AESEncryption.AESEncrypt(algorithmSuiteID.EncryptionSuite(), iv, key, plaintext, aad);
    if encryptionOutputResult.IsFailure() {
      res := encryptionOutputResult.PropagateFailure();
      finalFrame := RegularFrame(0, [], [], []);
      return;
    }
    var encryptionOutput := encryptionOutputResult.Extract();
    unauthenticatedFrame := unauthenticatedFrame + encryptionOutput.cipherText + encryptionOutput.authTag;
    assert |plaintext| == |encryptionOutput.cipherText|;
    ghost var frame := FinalFrame(sequenceNumber, iv, encryptionOutput.cipherText, encryptionOutput.authTag);
    finalFrame := frame;
    assert FrameToSequence(frame) == unauthenticatedFrame;
    assert |plaintext| == SeqToUInt32(unauthenticatedFrame[4 + 4 + algorithmSuiteID.IVLength() .. 4 + 4 + algorithmSuiteID.IVLength() + 4]) as int;
    assert |unauthenticatedFrame| == 4 + 4 + algorithmSuiteID.IVLength() + 4 + |plaintext| + algorithmSuiteID.TagLength();
    assert unauthenticatedFrame[4 + 4 + algorithmSuiteID.IVLength() + 4..][..|plaintext|] == encryptionOutput.cipherText;
    return Success(unauthenticatedFrame), finalFrame;
  }

  method DecryptFramedMessageBody(rd: Streams.ByteReader, algorithmSuiteID: AlgorithmSuite.ID, key: seq<uint8>, frameLength: int, messageID: Msg.MessageID)
      returns (res: Result<seq<uint8>, string>)
    requires rd.Valid()
    requires |key| == algorithmSuiteID.KeyLength()
    requires 0 < frameLength < UINT32_LIMIT
    modifies rd.reader`pos
    ensures rd.Valid()
    ensures res.Success? ==> DecryptedWithKey(key, res.value)
    ensures match res { case Success(_mcc#0) => (var plaintext := _mcc#0; old(rd.reader.pos) <= rd.reader.pos <= |rd.reader.data| && exists frames: seq<Frame> | |frames| < UINT32_LIMIT && (forall frame | frame in frames :: frame.Valid()) && FramesToSequence(frames) == rd.reader.data[old(rd.reader.pos) .. rd.reader.pos] :: true && FramesEncryptPlaintext(frames, plaintext)) case Failure(_mcc#1) => true }
    decreases rd, algorithmSuiteID, key, frameLength, messageID
  {
    var plaintext := [];
    var n: uint32 := 1;
    ghost var frames: seq<Frame> := [];
    ghost var plaintextSeg: seq<seq<uint8>> := [];
    while true
      invariant rd.Valid()
      invariant n as int - 1 == |frames|
      invariant n <= ENDFRAME_SEQUENCE_NUMBER
      invariant forall frame: Frame | frame in frames :: frame.Valid()
      invariant old(rd.reader.pos) <= rd.reader.pos <= |rd.reader.data|
      invariant FramesToSequence(frames) == rd.reader.data[old(rd.reader.pos) .. rd.reader.pos]
      invariant rd.Valid()
      invariant FramesEncryptPlaintextSegments(frames, plaintextSeg)
      invariant SumPlaintextSegments(plaintextSeg) == plaintext
      invariant DecryptedSegmentsWithKey(key, plaintextSeg)
      invariant plaintext == SumPlaintextSegments(plaintextSeg)
      decreases ENDFRAME_SEQUENCE_NUMBER - n
    {
      var frameWithGhostSeq :- DecryptFrame(rd, algorithmSuiteID, key, frameLength, messageID, n);
      assert |frameWithGhostSeq.sequence| < UINT32_LIMIT;
      var decryptedFrame := frameWithGhostSeq.frame;
      ghost var ciphertext := frameWithGhostSeq.sequence;
      assert |ciphertext| < UINT32_LIMIT;
      ghost var encryptedFrame := if decryptedFrame.FinalFrame? then FinalFrame(decryptedFrame.seqNum, decryptedFrame.iv, ciphertext, decryptedFrame.authTag) else RegularFrame(decryptedFrame.seqNum, decryptedFrame.iv, ciphertext, decryptedFrame.authTag);
      assert encryptedFrame.Valid();
      frames := frames + [encryptedFrame];
      var (decryptedFramePlaintext, final) := (decryptedFrame.encContent, decryptedFrame.FinalFrame?);

      plaintext := plaintext + decryptedFramePlaintext;
      plaintextSeg := plaintextSeg + [decryptedFramePlaintext];
      if final {
        assert FramesEncryptPlaintextSegments(frames, plaintextSeg);
        assert SumPlaintextSegments(plaintextSeg) == plaintext;
        break;
      }
      n := n + 1;
    }
    assert |frames| < UINT32_LIMIT;
    assert forall frame: Frame | frame in frames :: frame.Valid();
    assert FramesToSequence(frames) == rd.reader.data[old(rd.reader.pos) .. rd.reader.pos];
    return Success(plaintext);
  }

  method DecryptFrame(rd: Streams.ByteReader, algorithmSuiteID: AlgorithmSuite.ID, key: seq<uint8>, frameLength: int, messageID: Msg.MessageID, expectedSequenceNumber: uint32)
      returns (res: Result<FrameWithGhostSeq, string>)
    requires rd.Valid()
    requires |key| == algorithmSuiteID.KeyLength()
    requires 0 < frameLength < UINT32_LIMIT
    modifies rd.reader`pos
    ensures rd.Valid()
    ensures match res { case Success(_mcc#0) => (var frameWithGhostSeq := _mcc#0; expectedSequenceNumber == ENDFRAME_SEQUENCE_NUMBER ==> frameWithGhostSeq.frame.FinalFrame?) case Failure(_mcc#1) => true }
    ensures res.Success? ==> |res.value.sequence| < UINT32_LIMIT
    ensures match res { case Success(_mcc#2) => (var frameWithGhostSeq := _mcc#2; true && var decryptedFrame := frameWithGhostSeq.frame; var ciphertext := frameWithGhostSeq.sequence; var final := decryptedFrame.FinalFrame?; decryptedFrame.Valid() && old(rd.reader.pos) < rd.reader.pos <= |rd.reader.data| && AESEncryption.CiphertextGeneratedWithPlaintext(ciphertext, decryptedFrame.encContent) && AESEncryption.DecryptedWithKey(key, decryptedFrame.encContent) && var encryptedFrame := if decryptedFrame.FinalFrame? then FinalFrame(decryptedFrame.seqNum, decryptedFrame.iv, ciphertext, decryptedFrame.authTag) else RegularFrame(decryptedFrame.seqNum, decryptedFrame.iv, ciphertext, decryptedFrame.authTag); rd.reader.data[old(rd.reader.pos) .. rd.reader.pos] == FrameToSequence(encryptedFrame) && AESEncryption.CiphertextGeneratedWithPlaintext(encryptedFrame.encContent, decryptedFrame.encContent)) case Failure(_mcc#3) => true }
    decreases rd, algorithmSuiteID, key, frameLength, messageID, expectedSequenceNumber
  {
    var final := false;
    var sequenceNumber :- rd.ReadUInt32();
    ghost var frameSerialization := UInt32ToSeq(sequenceNumber);
    assert rd.reader.data[old(rd.reader.pos) .. rd.reader.pos] == frameSerialization;
    if sequenceNumber == ENDFRAME_SEQUENCE_NUMBER {
      final := true;
      sequenceNumber :- rd.ReadUInt32();
      frameSerialization := frameSerialization + UInt32ToSeq(sequenceNumber);
      assert rd.reader.data[old(rd.reader.pos) .. rd.reader.pos] == frameSerialization;
    }
    if sequenceNumber != expectedSequenceNumber {
      return Failure(""unexpected frame sequence number"");
    }
    var iv :- rd.ReadBytes(algorithmSuiteID.IVLength());
    frameSerialization := frameSerialization + iv;
    assert rd.reader.data[old(rd.reader.pos) .. rd.reader.pos] == frameSerialization;
    var len := frameLength as uint32;
    if final {
      len :- rd.ReadUInt32();
      if len > frameLength as uint32 {
        return Failure(""Final frame too long"");
      }
      frameSerialization := frameSerialization + UInt32ToSeq(len);
    }
    var aad := BodyAAD(messageID, if final then AADFinalFrame else AADRegularFrame, sequenceNumber, len as uint64);
    var ciphertext :- rd.ReadBytes(len as nat);
    frameSerialization := frameSerialization + ciphertext;
    assert rd.reader.data[old(rd.reader.pos) .. rd.reader.pos] == frameSerialization;
    var authTag :- rd.ReadBytes(algorithmSuiteID.TagLength());
    frameSerialization := frameSerialization + authTag;
    assert rd.reader.data[old(rd.reader.pos) .. rd.reader.pos] == frameSerialization;
    var plaintext :- Decrypt(ciphertext, authTag, algorithmSuiteID, iv, key, aad);
    assert AESEncryption.CiphertextGeneratedWithPlaintext(ciphertext, plaintext);
    assert rd.reader.data[old(rd.reader.pos) .. rd.reader.pos] == frameSerialization;
    var frame := if final then FinalFrame(sequenceNumber, iv, plaintext, authTag) else RegularFrame(sequenceNumber, iv, plaintext, authTag);
    ghost var encryptedFrame := if final then FinalFrame(sequenceNumber, iv, ciphertext, authTag) else RegularFrame(sequenceNumber, iv, ciphertext, authTag);
    assert frameSerialization == FrameToSequence(encryptedFrame);
    assert !final ==> frameSerialization[..4] == rd.reader.data[old(rd.reader.pos)..][..4];
    assert !final ==> frameSerialization[4..][..algorithmSuiteID.IVLength()] == rd.reader.data[old(rd.reader.pos)..][4..][..algorithmSuiteID.IVLength()];
    assert !final ==> frameSerialization[4 + algorithmSuiteID.IVLength()..][..frameLength] == rd.reader.data[old(rd.reader.pos)..][4 + algorithmSuiteID.IVLength()..][..frameLength];
    assert !final ==> frameSerialization[4 + frameLength + algorithmSuiteID.IVLength()..] == rd.reader.data[old(rd.reader.pos)..][4 + frameLength + algorithmSuiteID.IVLength()..][..algorithmSuiteID.TagLength()];
    assert rd.reader.data[old(rd.reader.pos) .. rd.reader.pos] == frameSerialization;
    assert old(rd.reader.pos) < rd.reader.pos <= |rd.reader.data|;
    return Success(FrameWithGhostSeq(frame, ciphertext));
  }

  method BodyAAD(messageID: seq<uint8>, bc: BodyAADContent, sequenceNumber: uint32, length: uint64)
      returns (aad: seq<uint8>)
    decreases messageID, bc, sequenceNumber, length
  {
    var contentAAD := UTF8.Encode(BodyAADContentTypeString(bc));
    aad := messageID + contentAAD.value + UInt32ToSeq(sequenceNumber) + UInt64ToSeq(length);
  }

  method Decrypt(ciphertext: seq<uint8>, authTag: seq<uint8>, algorithmSuiteID: AlgorithmSuite.ID, iv: seq<uint8>, key: seq<uint8>, aad: seq<uint8>)
      returns (res: Result<seq<uint8>, string>)
    requires |iv| == algorithmSuiteID.IVLength()
    requires |key| == algorithmSuiteID.KeyLength()
    requires |authTag| == algorithmSuiteID.TagLength()
    ensures res.Success? ==> AESEncryption.CiphertextGeneratedWithPlaintext(ciphertext, res.value)
    ensures res.Success? ==> |ciphertext| == |res.value|
    ensures res.Success? ==> AESEncryption.DecryptedWithKey(key, res.value)
    decreases ciphertext, authTag, algorithmSuiteID, iv, key, aad
  {
    var encAlg := algorithmSuiteID.EncryptionSuite();
    res := AESEncryption.AESDecrypt(encAlg, key, ciphertext, authTag, iv, aad);
    assert res.Success? ==> AESEncryption.DecryptedWithKey(key, res.value);
  }

  predicate DecryptedWithKey(key: seq<uint8>, plaintext: seq<uint8>)
    decreases key, plaintext
  {
    if AESEncryption.DecryptedWithKey(key, plaintext) then
      true
    else
      exists plaintextSeg: seq<seq<uint8>> | SumPlaintextSegments(plaintextSeg) == plaintext :: DecryptedSegmentsWithKey(key, plaintextSeg)
  }

  predicate DecryptedSegmentsWithKey(key: seq<uint8>, plaintextSeg: seq<seq<uint8>>)
    decreases key, plaintextSeg
  {
    if plaintextSeg == [] then
      true
    else
      DecryptedSegmentsWithKey(key, plaintextSeg[..|plaintextSeg| - 1]) && AESEncryption.DecryptedWithKey(key, plaintextSeg[|plaintextSeg| - 1])
  }

  method DecryptNonFramedMessageBody(rd: Streams.ByteReader, algorithmSuiteID: AlgorithmSuite.ID, key: seq<uint8>, messageID: Msg.MessageID)
      returns (res: Result<seq<uint8>, string>)
    requires rd.Valid()
    requires |key| == algorithmSuiteID.KeyLength()
    modifies rd.reader`pos
    ensures rd.Valid()
    decreases rd, algorithmSuiteID, key, messageID
  {
    var iv :- rd.ReadBytes(algorithmSuiteID.IVLength());
    var contentLength :- rd.ReadUInt64();
    var ciphertext :- rd.ReadBytes(contentLength as nat);
    var authTag :- rd.ReadBytes(algorithmSuiteID.TagLength());
    var aad := BodyAAD(messageID, AADSingleBlock, NONFRAMED_SEQUENCE_NUMBER, contentLength);
    var plaintext :- Decrypt(ciphertext, authTag, algorithmSuiteID, iv, key, aad);
    return Success(plaintext);
  }
}

module {:extern ""MessageHeader""} MessageHeader {

  import Crypto = Aws.Crypto

  import AlgorithmSuite = AlgorithmSuite

  import Sets = Sets

  import opened Wrappers = Wrappers

  import opened UInt = StandardLibrary.UInt

  import EncryptionContext = EncryptionContext

  import Materials = Materials

  import UTF8 = UTF8

  import AESEncryption = AESEncryption
  datatype Header = Header(body: HeaderBody, auth: HeaderAuthentication) {
    predicate Valid()
      decreases this
    {
      body.Valid() &&
      |auth.iv| == body.algorithmSuiteID.IVLength() &&
      |auth.authenticationTag| == body.algorithmSuiteID.TagLength()
    }
  }

  type Version = x: uint8
    | x == VERSION_1
    witness VERSION_1

  type Type = x: uint8
    | x == TYPE_CUSTOMER_AED
    witness TYPE_CUSTOMER_AED

  type MessageID = x: seq<uint8>
    | |x| == MESSAGE_ID_LEN
    witness [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]

  datatype ContentType = NonFramed | Framed

  datatype EncryptedDataKeys = EncryptedDataKeys(entries: seq<Crypto.EncryptedDataKey>) {
    predicate Valid()
      decreases this
    {
      0 < |entries| < UINT16_LIMIT &&
      forall i: int :: 
        0 <= i < |entries| ==>
          entries[i].Valid()
    }
  }

  datatype HeaderBody = HeaderBody(version: Version, typ: Type, algorithmSuiteID: AlgorithmSuite.ID, messageID: MessageID, aad: EncryptionContext.Map, encryptedDataKeys: EncryptedDataKeys, contentType: ContentType, ivLength: uint8, frameLength: uint32) {
    predicate Valid()
      decreases this
    {
      EncryptionContext.Serializable(aad) &&
      encryptedDataKeys.Valid() &&
      algorithmSuiteID.IVLength() == ivLength as nat &&
      ValidFrameLength(frameLength, contentType)
    }
  }

  datatype HeaderAuthentication = HeaderAuthentication(iv: seq<uint8>, authenticationTag: seq<uint8>)

  const VERSION_1: uint8 := 1
  const TYPE_CUSTOMER_AED: uint8 := 128
  const MESSAGE_ID_LEN := 16
  const Reserved: seq<uint8> := [0, 0, 0, 0]

  function method ContentTypeToUInt8(contentType: ContentType): uint8
    decreases contentType
  {
    match contentType
    case NonFramed() =>
      1
    case Framed() =>
      2
  }

  function method UInt8ToContentType(x: uint8): Option<ContentType>
    decreases x
  {
    if x == 1 then
      Some(NonFramed)
    else if x == 2 then
      Some(Framed)
    else
      None
  }

  lemma ContentTypeConversionsCorrect(contentType: ContentType, x: uint8)
    ensures UInt8ToContentType(ContentTypeToUInt8(contentType)) == Some(contentType)
    ensures ghost var opt: Option<ContentType> := UInt8ToContentType(x); opt == None || ContentTypeToUInt8(opt.value) == x
    decreases contentType, x
  {
  }

  predicate HeaderAuthenticationMatchesHeaderBody(headerAuthentication: HeaderAuthentication, headerBody: HeaderBody)
    requires headerBody.Valid()
    decreases headerAuthentication, headerBody
  {
    ghost var serializedHeaderBody: seq<uint8> := (reveal HeaderBodyToSeq(); HeaderBodyToSeq(headerBody));
    headerAuthentication.iv == seq(headerBody.algorithmSuiteID.IVLength(), (_: int) => 0) &&
    exists encryptionOutput: EncryptionOutput | AESEncryption.EncryptionOutputEncryptedWithAAD(encryptionOutput, serializedHeaderBody) && AESEncryption.CiphertextGeneratedWithPlaintext(encryptionOutput.cipherText, []) :: 
      encryptionOutput.authTag == headerAuthentication.authenticationTag
  }

  predicate ValidFrameLength(frameLength: uint32, contentType: ContentType)
    decreases frameLength, contentType
  {
    match contentType
    case NonFramed() =>
      frameLength == 0
    case Framed() =>
      frameLength != 0
  }

  function {:opaque} {:fuel 0, 0} HeaderBodyToSeq(hb: HeaderBody): seq<uint8>
    requires hb.Valid()
    decreases hb
  {
    [hb.version as uint8] + [hb.typ as uint8] + UInt16ToSeq(hb.algorithmSuiteID as uint16) + hb.messageID + EncryptionContext.MapToLinear(hb.aad) + EDKsToSeq(hb.encryptedDataKeys) + [ContentTypeToUInt8(hb.contentType)] + Reserved + [hb.ivLength] + UInt32ToSeq(hb.frameLength)
  }

  function EDKsToSeq(encryptedDataKeys: EncryptedDataKeys): seq<uint8>
    requires encryptedDataKeys.Valid()
    decreases encryptedDataKeys
  {
    ghost var n: int := |encryptedDataKeys.entries|;
    UInt16ToSeq(n as uint16) + EDKEntriesToSeq(encryptedDataKeys.entries, 0, n)
  }

  function EDKEntriesToSeq(entries: seq<Crypto.EncryptedDataKey>, lo: nat, hi: nat): seq<uint8>
    requires forall i: int :: 0 <= i < |entries| ==> entries[i].Valid()
    requires lo <= hi <= |entries|
    decreases entries, lo, hi
  {
    if lo == hi then
      []
    else
      EDKEntriesToSeq(entries, lo, hi - 1) + EDKEntryToSeq(entries[hi - 1])
  }

  lemma /*{:_induction entriesHead, entriesTail, lo, hi}*/ EDKEntriesToSeqInductiveStep(entriesHead: seq<Crypto.EncryptedDataKey>, entriesTail: seq<Crypto.EncryptedDataKey>, lo: nat, hi: nat)
    requires ghost var entries: seq<Crypto.EncryptedDataKey> := entriesHead + entriesTail; forall i: int :: 0 <= i < |entries| ==> entries[i].Valid()
    requires lo <= hi <= |entriesHead|
    ensures forall i: int :: 0 <= i < |entriesHead| ==> entriesHead[i].Valid()
    ensures ghost var entries: seq<Crypto.EncryptedDataKey> := entriesHead + entriesTail; EDKEntriesToSeq(entriesHead + entriesTail, lo, hi) == EDKEntriesToSeq(entriesHead, lo, hi)
    decreases entriesHead, entriesTail, lo, hi
  {
    assert forall i: int :: 0 <= i < |entriesHead| ==> entriesHead[i].Valid() by {
      if !forall i: int :: 0 <= i < |entriesHead| ==> entriesHead[i].Valid() {
        ghost var entry :| entry in entriesHead && !entry.Valid();
        assert entry in entriesHead + entriesTail;
        assert false;
      }
    }
  }

  function method EDKEntryToSeq(edk: Crypto.EncryptedDataKey): seq<uint8>
    requires edk.Valid()
    decreases edk
  {
    UInt16ToSeq(|edk.keyProviderId| as uint16) + edk.keyProviderId + UInt16ToSeq(|edk.keyProviderInfo| as uint16) + edk.keyProviderInfo + UInt16ToSeq(|edk.ciphertext| as uint16) + edk.ciphertext
  }

  predicate {:opaque} {:fuel 0, 0} IsSerializationOfHeaderBody(sequence: seq<uint8>, hb: HeaderBody)
    requires hb.Valid()
    decreases sequence, hb
  {
    exists serializedAAD: seq<uint8> | EncryptionContext.LinearSeqToMap(serializedAAD, hb.aad) :: 
      IsSerializationOfHeaderBodyAux(sequence, hb, serializedAAD)
  }

  predicate IsSerializationOfHeaderBodyAux(sequence: seq<uint8>, hb: HeaderBody, serializedAAD: seq<uint8>)
    requires hb.Valid() && EncryptionContext.LinearSeqToMap(serializedAAD, hb.aad)
    decreases sequence, hb, serializedAAD
  {
    sequence == [hb.version as uint8] + [hb.typ as uint8] + UInt16ToSeq(hb.algorithmSuiteID as uint16) + hb.messageID + serializedAAD + EDKsToSeq(hb.encryptedDataKeys) + [ContentTypeToUInt8(hb.contentType)] + Reserved + [hb.ivLength] + UInt32ToSeq(hb.frameLength)
  }

  lemma IsSerializationOfHeaderBodyDuality(hb: HeaderBody)
    requires hb.Valid()
    ensures IsSerializationOfHeaderBody(HeaderBodyToSeq(hb), hb)
    decreases hb
  {
    reveal HeaderBodyToSeq(), IsSerializationOfHeaderBody();
    EncryptionContext.MapToLinearIsDualLinearSeqToMap(hb.aad);
  }
}

module Serialize {

  import Msg = MessageHeader

  import EncryptionContext = EncryptionContext

  import AlgorithmSuite = AlgorithmSuite

  import Streams = Streams

  import opened StandardLibrary = StandardLibrary

  import opened Wrappers = Wrappers

  import opened UInt = StandardLibrary.UInt

  import UTF8 = UTF8

  import Sets = Sets
  method SerializeHeaderBody(wr: Streams.ByteWriter, hb: Msg.HeaderBody) returns (ret: Result<nat, string>)
    requires wr.Valid() && hb.Valid()
    modifies wr.writer`data
    ensures wr.Valid()
    ensures match ret { case Success(_mcc#0) => (var totalWritten := _mcc#0; var serHb := (reveal Msg.HeaderBodyToSeq(); Msg.HeaderBodyToSeq(hb)); var initLen := old(wr.GetSizeWritten()); totalWritten == |serHb| && initLen + totalWritten == wr.GetSizeWritten() && serHb == wr.GetDataWritten()[initLen .. initLen + totalWritten]) case Failure(_mcc#1) => var e := _mcc#1; true }
    decreases wr, hb
  {
    var totalWritten := 0;
    var len := wr.WriteByte(hb.version as uint8);
    totalWritten := totalWritten + len;
    len := wr.WriteByte(hb.typ as uint8);
    totalWritten := totalWritten + len;
    len := wr.WriteUInt16(hb.algorithmSuiteID as uint16);
    totalWritten := totalWritten + len;
    len := wr.WriteBytes(hb.messageID);
    totalWritten := totalWritten + len;
    len :- SerializeAAD(wr, hb.aad);
    totalWritten := totalWritten + len;
    len := SerializeEDKs(wr, hb.encryptedDataKeys);
    totalWritten := totalWritten + len;
    var contentType := Msg.ContentTypeToUInt8(hb.contentType);
    len := wr.WriteByte(contentType);
    totalWritten := totalWritten + len;
    len := wr.WriteBytes(Msg.Reserved);
    totalWritten := totalWritten + len;
    len := wr.WriteByte(hb.ivLength);
    totalWritten := totalWritten + len;
    len := wr.WriteUInt32(hb.frameLength);
    totalWritten := totalWritten + len;
    reveal Msg.HeaderBodyToSeq();
    return Success(totalWritten);
  }

  method SerializeHeaderAuthentication(wr: Streams.ByteWriter, ha: Msg.HeaderAuthentication, ghost algorithmSuiteID: AlgorithmSuite.ID)
      returns (ret: Result<nat, string>)
    requires wr.Valid()
    modifies wr.writer`data
    ensures wr.Valid()
    ensures match ret { case Success(_mcc#0) => (var totalWritten := _mcc#0; var serHa := ha.iv + ha.authenticationTag; var initLen := old(wr.GetSizeWritten()); initLen + totalWritten == wr.GetSizeWritten() && serHa == wr.GetDataWritten()[initLen .. initLen + totalWritten] && totalWritten == |serHa| && old(wr.GetDataWritten()) + serHa == wr.GetDataWritten()) case Failure(_mcc#1) => var e := _mcc#1; true }
    decreases wr, ha, algorithmSuiteID
  {
    var m := wr.WriteBytes(ha.iv);
    var n := wr.WriteBytes(ha.authenticationTag);
    return Success(m + n);
  }

  method SerializeAAD(wr: Streams.ByteWriter, kvPairs: EncryptionContext.Map) returns (ret: Result<nat, string>)
    requires wr.Valid() && EncryptionContext.Serializable(kvPairs)
    modifies wr.writer`data
    ensures wr.Valid() && EncryptionContext.Serializable(kvPairs)
    ensures match ret { case Success(_mcc#0) => (var totalWritten := _mcc#0; var serAAD := EncryptionContext.MapToLinear(kvPairs); var initLen := old(wr.GetSizeWritten()); totalWritten == |serAAD| && initLen + totalWritten == wr.GetSizeWritten() && wr.GetDataWritten() == old(wr.GetDataWritten()) + serAAD) case Failure(_mcc#1) => var e := _mcc#1; true }
    decreases wr, kvPairs
  {
    reveal EncryptionContext.Serializable();
    var totalWritten := 0;
    var kvPairsLength := EncryptionContext.ComputeLength(kvPairs);
    var len := wr.WriteUInt16(kvPairsLength as uint16);
    totalWritten := totalWritten + len;
    len :- SerializeKVPairs(wr, kvPairs);
    totalWritten := totalWritten + len;
    return Success(totalWritten);
  }

  method SerializeKVPairs(wr: Streams.ByteWriter, encryptionContext: EncryptionContext.Map) returns (ret: Result<nat, string>)
    requires wr.Valid() && EncryptionContext.SerializableKVPairs(encryptionContext)
    modifies wr.writer`data
    ensures wr.Valid() && EncryptionContext.SerializableKVPairs(encryptionContext)
    ensures match ret { case Success(_mcc#0) => (var newlyWritten := _mcc#0; var serAAD := EncryptionContext.MapToSeq(encryptionContext); newlyWritten == |serAAD| && wr.GetSizeWritten() == old(wr.GetSizeWritten()) + newlyWritten && wr.GetDataWritten() == old(wr.GetDataWritten()) + serAAD) case Failure(_mcc#1) => var e := _mcc#1; true }
    decreases wr, encryptionContext
  {
    var newlyWritten := 0;
    if |encryptionContext| == 0 {
      return Success(newlyWritten);
    }
    var len := wr.WriteUInt16(|encryptionContext| as uint16);
    newlyWritten := newlyWritten + len;
    var keys: seq<UTF8.ValidUTF8Bytes> := Sets.ComputeSetToOrderedSequence(encryptionContext.Keys, UInt.UInt8Less);
    ghost var kvPairs := seq(|keys|, (i: int) requires 0 <= i < |keys| => (keys[i], encryptionContext[keys[i]]));
    ghost var n := |keys|;
    ghost var writtenBeforeLoop := wr.GetDataWritten();
    assert writtenBeforeLoop == old(wr.GetDataWritten()) + UInt16ToSeq(n as uint16);
    var j := 0;
    while j < |keys|
      invariant j <= n == |keys|
      invariant wr.GetDataWritten() == writtenBeforeLoop + EncryptionContext.LinearToSeq(kvPairs, 0, j)
      invariant wr.GetSizeWritten() == old(wr.GetSizeWritten()) + newlyWritten
      decreases |keys| - j
    {
      len :- SerializeKVPair(wr, keys[j], encryptionContext[keys[j]]);
      newlyWritten := newlyWritten + len;
      assert wr.GetSizeWritten() == old(wr.GetSizeWritten()) + newlyWritten;
      calc {
        wr.GetDataWritten();
      ==
        writtenBeforeLoop + EncryptionContext.LinearToSeq(kvPairs, 0, j) + EncryptionContext.KVPairToSeq(kvPairs[j]);
      ==
        writtenBeforeLoop + (EncryptionContext.LinearToSeq(kvPairs, 0, j) + EncryptionContext.KVPairToSeq(kvPairs[j]));
      ==
        {
          assert EncryptionContext.LinearToSeq(kvPairs, 0, j) + EncryptionContext.KVPairToSeq(kvPairs[j]) == EncryptionContext.LinearToSeq(kvPairs, 0, j + 1);
        }
        writtenBeforeLoop + EncryptionContext.LinearToSeq(kvPairs, 0, j + 1);
      }
      j := j + 1;
    }
    return Success(newlyWritten);
  }

  method SerializeKVPair(wr: Streams.ByteWriter, k: UTF8.ValidUTF8Bytes, v: UTF8.ValidUTF8Bytes)
      returns (ret: Result<nat, string>)
    requires wr.Valid() && EncryptionContext.SerializableKVPair((k, v))
    modifies wr.writer`data
    ensures wr.Valid()
    ensures match ret { case Success(_mcc#0) => (var newlyWritten := _mcc#0; var serKV := EncryptionContext.KVPairToSeq((k, v)); newlyWritten == |serKV| && wr.GetSizeWritten() == old(wr.GetSizeWritten()) + newlyWritten && wr.GetDataWritten() == old(wr.GetDataWritten()) + serKV) case Failure(_mcc#1) => var e := _mcc#1; true }
    decreases wr, k, v
  {
    ghost var previouslyWritten := wr.GetDataWritten();
    var newlyWritten := 0;
    var len := wr.WriteUInt16(|k| as uint16);
    newlyWritten := newlyWritten + len;
    len := wr.WriteBytes(k);
    newlyWritten := newlyWritten + len;
    len := wr.WriteUInt16(|v| as uint16);
    newlyWritten := newlyWritten + len;
    len := wr.WriteBytes(v);
    newlyWritten := newlyWritten + len;
    calc {
      wr.GetDataWritten();
    ==
      previouslyWritten + UInt16ToSeq(|k| as uint16) + k + UInt16ToSeq(|v| as uint16) + v;
    ==
      previouslyWritten + (UInt16ToSeq(|k| as uint16) + k + UInt16ToSeq(|v| as uint16) + v);
    ==
      previouslyWritten + EncryptionContext.KVPairToSeq((k, v));
    }
    return Success(newlyWritten);
  }

  method SerializeEDKs(wr: Streams.ByteWriter, encryptedDataKeys: Msg.EncryptedDataKeys) returns (ret: nat)
    requires wr.Valid() && encryptedDataKeys.Valid()
    modifies wr.writer`data
    ensures wr.Valid() && encryptedDataKeys.Valid()
    ensures ret == |Msg.EDKsToSeq(encryptedDataKeys)|
    ensures old(wr.GetSizeWritten()) + ret == wr.GetSizeWritten()
    ensures wr.GetDataWritten() == old(wr.GetDataWritten()) + Msg.EDKsToSeq(encryptedDataKeys)
    decreases wr, encryptedDataKeys
  {
    var totalWritten := 0;
    var len := wr.WriteUInt16(|encryptedDataKeys.entries| as uint16);
    totalWritten := totalWritten + len;
    var j := 0;
    ghost var n := |encryptedDataKeys.entries|;
    while j < |encryptedDataKeys.entries|
      invariant j <= n == |encryptedDataKeys.entries|
      invariant wr.GetDataWritten() == old(wr.GetDataWritten()) + UInt16ToSeq(n as uint16) + Msg.EDKEntriesToSeq(encryptedDataKeys.entries, 0, j)
      invariant totalWritten == 2 + |Msg.EDKEntriesToSeq(encryptedDataKeys.entries, 0, j)|
      decreases |encryptedDataKeys.entries| - j
    {
      var entry := encryptedDataKeys.entries[j];
      len := wr.WriteUInt16(|entry.keyProviderId| as uint16);
      totalWritten := totalWritten + len;
      len := wr.WriteBytes(entry.keyProviderId);
      totalWritten := totalWritten + len;
      len := wr.WriteUInt16(|entry.keyProviderInfo| as uint16);
      totalWritten := totalWritten + len;
      len := wr.WriteBytes(entry.keyProviderInfo);
      totalWritten := totalWritten + len;
      len := wr.WriteUInt16(|entry.ciphertext| as uint16);
      totalWritten := totalWritten + len;
      len := wr.WriteBytes(entry.ciphertext);
      totalWritten := totalWritten + len;
      j := j + 1;
    }
    return totalWritten;
  }
}

module Actions {

  import opened Wrappers = Wrappers
  trait {:termination false} Action<A, R> {
    method Invoke(a: A) returns (r: R)
      ensures Ensures(a, r)

    predicate Ensures(a: A, r: R)
  }

  trait {:termination false} ActionWithResult<A, R, E> extends Action<A, Result<R, E>> {
    method Invoke(a: A) returns (res: Result<R, E>)
      ensures Ensures(a, res)
  }

  method Map<A, R>(action: Action<A, R>, s: seq<A>) returns (res: seq<R>)
    ensures |s| == |res|
    ensures forall i: int :: true && 0 <= i < |s| ==> action.Ensures(s[i], res[i])
    decreases action, s
  {
    var rs := [];
    for i: int := 0 to |s|
      invariant |s[..i]| == |rs|
      invariant forall j: int :: true && 0 <= j < i ==> action.Ensures(s[j], rs[j])
    {
      var r := action.Invoke(s[i]);
      rs := rs + [r];
    }
    return rs;
  }

  method MapWithResult<A, R(0), E>(action: ActionWithResult<A, R, E>, s: seq<A>) returns (res: Result<seq<R>, E>)
    ensures res.Success? ==> |s| == |res.value|
    ensures res.Success? ==> forall i: int :: true && 0 <= i < |s| ==> action.Ensures(s[i], Success(res.value[i]))
    decreases action, s
  {
    var rs := [];
    for i: int := 0 to |s|
      invariant |s[..i]| == |rs|
      invariant forall j: int :: true && 0 <= j < i ==> action.Ensures(s[j], Success(rs[j]))
    {
      var r :- action.Invoke(s[i]);
      rs := rs + [r];
    }
    return Success(rs);
  }

  method Filter<A>(action: Action<A, bool>, s: seq<A>) returns (res: seq<A>)
    ensures |s| >= |res|
    ensures forall j: A :: j in res ==> j in s && action.Ensures(j, true)
    decreases action, s
  {
    var rs := [];
    for i: int := 0 to |s|
      invariant |s[..i]| >= |rs|
      invariant forall j: A :: j in rs ==> j in s && action.Ensures(j, true)
    {
      var r := action.Invoke(s[i]);
      if r {
        rs := rs + [s[i]];
      }
    }
    return rs;
  }

  method FilterWithResult<A, E>(action: ActionWithResult<A, bool, E>, s: seq<A>) returns (res: Result<seq<A>, E>)
    ensures res.Success? ==> |s| >= |res.value| && forall j: A :: j in res.value ==> j in s && action.Ensures(j, Success(true))
    decreases action, s
  {
    var rs := [];
    for i: int := 0 to |s|
      invariant |s[..i]| >= |rs|
      invariant forall j: A :: j in rs ==> j in s && action.Ensures(j, Success(true))
    {
      var r :- action.Invoke(s[i]);
      if r {
        rs := rs + [s[i]];
      }
    }
    return Success(rs);
  }

  method ReduceToSuccess<A, B, E>(action: ActionWithResult<A, B, E>, s: seq<A>) returns (res: Result<B, seq<E>>)
    ensures res.Success? ==> exists a: A | a in s :: action.Ensures(a, Success(res.value))
    decreases action, s
  {
    var errors := [];
    for i: int := 0 to |s| {
      var attempt := action.Invoke(s[i]);
      if attempt.Success? {
        return Success(attempt.value);
      } else {
        errors := errors + [attempt.error];
      }
    }
    return Failure(errors);
  }
}

module Base64 {

  import opened Wrappers = Wrappers

  import opened UInt = StandardLibrary.UInt
  newtype index = x: int
    | 0 <= x < 64

  newtype uint24 = x: int
    | 0 <= x < 16777216

  predicate method IsBase64Char(c: char)
    decreases c
  {
    c == '+' || c == '/' || '0' <= c <= '9' || 'A' <= c <= 'Z' || 'a' <= c <= 'z'
  }

  predicate method IsUnpaddedBase64String(s: string)
    decreases s
  {
    |s| % 4 == 0 &&
    forall k: char :: 
      k in s ==>
        IsBase64Char(k)
  }

  function method IndexToChar(i: index): (c: char)
    ensures IsBase64Char(c)
    decreases i
  {
    if i == 63 then
      '/'
    else if i == 62 then
      '+'
    else if 52 <= i <= 61 then
      (i - 4) as char
    else if 26 <= i <= 51 then
      i as char + 71 as char
    else
      i as char + 65 as char
  }

  function method CharToIndex(c: char): (i: index)
    requires IsBase64Char(c)
    ensures IndexToChar(i) == c
    decreases c
  {
    if c == '/' then
      63
    else if c == '+' then
      62
    else if '0' <= c <= '9' then
      (c + 4 as char) as index
    else if 'a' <= c <= 'z' then
      (c - 71 as char) as index
    else
      (c - 65 as char) as index
  }

  lemma CharToIndexToChar(x: char)
    requires IsBase64Char(x)
    ensures IndexToChar(CharToIndex(x)) == x
    decreases x
  {
  }

  lemma IndexToCharToIndex(x: index)
    ensures CharToIndex(IndexToChar(x)) == x
    decreases x
  {
  }

  function method UInt24ToSeq(x: uint24): (ret: seq<uint8>)
    ensures |ret| == 3
    ensures ret[0] as uint24 * 65536 + ret[1] as uint24 * 256 + ret[2] as uint24 == x
    decreases x
  {
    var b0: uint8 := (x / 65536) as uint8;
    var x0: uint24 := x - b0 as uint24 * 65536;
    var b1: uint8 := (x0 / 256) as uint8;
    var b2: uint8 := (x0 % 256) as uint8;
    [b0, b1, b2]
  }

  function method SeqToUInt24(s: seq<uint8>): (x: uint24)
    requires |s| == 3
    ensures UInt24ToSeq(x) == s
    decreases s
  {
    s[0] as uint24 * 65536 + s[1] as uint24 * 256 + s[2] as uint24
  }

  lemma UInt24ToSeqToUInt24(x: uint24)
    ensures SeqToUInt24(UInt24ToSeq(x)) == x
    decreases x
  {
  }

  lemma SeqToUInt24ToSeq(s: seq<uint8>)
    requires |s| == 3
    ensures UInt24ToSeq(SeqToUInt24(s)) == s
    decreases s
  {
  }

  function method UInt24ToIndexSeq(x: uint24): (ret: seq<index>)
    ensures |ret| == 4
    ensures ret[0] as uint24 * 262144 + ret[1] as uint24 * 4096 + ret[2] as uint24 * 64 + ret[3] as uint24 == x
    decreases x
  {
    var b0: index := (x / 262144) as index;
    var x0: uint24 := x - b0 as uint24 * 262144;
    var b1: index := (x0 / 4096) as index;
    var x1: uint24 := x0 - b1 as uint24 * 4096;
    var b2: index := (x1 / 64) as index;
    var b3: index := (x1 % 64) as index;
    [b0, b1, b2, b3]
  }

  function method IndexSeqToUInt24(s: seq<index>): (x: uint24)
    requires |s| == 4
    ensures UInt24ToIndexSeq(x) == s
    decreases s
  {
    s[0] as uint24 * 262144 + s[1] as uint24 * 4096 + s[2] as uint24 * 64 + s[3] as uint24
  }

  lemma UInt24ToIndexSeqToUInt24(x: uint24)
    ensures IndexSeqToUInt24(UInt24ToIndexSeq(x)) == x
    decreases x
  {
  }

  lemma IndexSeqToUInt24ToIndexSeq(s: seq<index>)
    requires |s| == 4
    ensures UInt24ToIndexSeq(IndexSeqToUInt24(s)) == s
    decreases s
  {
  }

  function method DecodeBlock(s: seq<index>): (ret: seq<uint8>)
    requires |s| == 4
    ensures |ret| == 3
    ensures UInt24ToIndexSeq(SeqToUInt24(ret)) == s
    decreases s
  {
    UInt24ToSeq(IndexSeqToUInt24(s))
  }

  function method EncodeBlock(s: seq<uint8>): (ret: seq<index>)
    requires |s| == 3
    ensures |ret| == 4
    ensures UInt24ToSeq(IndexSeqToUInt24(ret)) == s
    ensures DecodeBlock(ret) == s
    decreases s
  {
    UInt24ToIndexSeq(SeqToUInt24(s))
  }

  lemma EncodeDecodeBlock(s: seq<uint8>)
    requires |s| == 3
    ensures DecodeBlock(EncodeBlock(s)) == s
    decreases s
  {
  }

  lemma DecodeEncodeBlock(s: seq<index>)
    requires |s| == 4
    ensures EncodeBlock(DecodeBlock(s)) == s
    decreases s
  {
  }

  function method DecodeRecursively(s: seq<index>): (b: seq<uint8>)
    requires |s| % 4 == 0
    ensures |b| == |s| / 4 * 3
    ensures |b| % 3 == 0
    ensures |b| == 0 ==> |s| == 0
    ensures |b| != 0 ==> EncodeBlock(b[..3]) == s[..4]
    decreases |s|
  {
    if |s| == 0 then
      []
    else
      DecodeBlock(s[..4]) + DecodeRecursively(s[4..])
  }

  function method EncodeRecursively(b: seq<uint8>): (s: seq<index>)
    requires |b| % 3 == 0
    ensures |s| == |b| / 3 * 4
    ensures |s| % 4 == 0
    ensures DecodeRecursively(s) == b
    decreases b
  {
    if |b| == 0 then
      []
    else
      EncodeBlock(b[..3]) + EncodeRecursively(b[3..])
  }

  lemma /*{:_induction s}*/ DecodeEncodeRecursively(s: seq<index>)
    requires |s| % 4 == 0
    ensures EncodeRecursively(DecodeRecursively(s)) == s
    decreases s
  {
  }

  lemma /*{:_induction b}*/ EncodeDecodeRecursively(b: seq<uint8>)
    requires |b| % 3 == 0
    ensures DecodeRecursively(EncodeRecursively(b)) == b
    decreases b
  {
  }

  function method FromCharsToIndices(s: seq<char>): (b: seq<index>)
    requires forall k: char :: k in s ==> IsBase64Char(k)
    ensures |b| == |s|
    ensures forall k: int :: 0 <= k < |b| ==> IndexToChar(b[k]) == s[k]
    decreases s
  {
    seq(|s|, (i: int) requires 0 <= i < |s| => CharToIndex(s[i]))
  }

  function method FromIndicesToChars(b: seq<index>): (s: seq<char>)
    ensures forall k: char :: k in s ==> IsBase64Char(k)
    ensures |s| == |b|
    ensures forall k: int :: 0 <= k < |s| ==> CharToIndex(s[k]) == b[k]
    ensures FromCharsToIndices(s) == b
    decreases b
  {
    seq(|b|, (i: int) requires 0 <= i < |b| => IndexToChar(b[i]))
  }

  lemma FromCharsToIndicesToChars(s: seq<char>)
    requires forall k: char :: k in s ==> IsBase64Char(k)
    ensures FromIndicesToChars(FromCharsToIndices(s)) == s
    decreases s
  {
  }

  lemma FromIndicesToCharsToIndices(b: seq<index>)
    ensures FromCharsToIndices(FromIndicesToChars(b)) == b
    decreases b
  {
  }

  function method DecodeUnpadded(s: seq<char>): (b: seq<uint8>)
    requires IsUnpaddedBase64String(s)
    ensures |b| == |s| / 4 * 3
    ensures |b| % 3 == 0
    decreases s
  {
    DecodeRecursively(FromCharsToIndices(s))
  }

  function method EncodeUnpadded(b: seq<uint8>): (s: seq<char>)
    requires |b| % 3 == 0
    ensures IsUnpaddedBase64String(s)
    ensures |s| == |b| / 3 * 4
    ensures DecodeUnpadded(s) == b
    decreases b
  {
    FromIndicesToChars(EncodeRecursively(b))
  }

  lemma EncodeDecodeUnpadded(b: seq<uint8>)
    requires |b| % 3 == 0
    ensures DecodeUnpadded(EncodeUnpadded(b)) == b
    decreases b
  {
  }

  lemma DecodeEncodeUnpadded(s: seq<char>)
    requires |s| % 4 == 0
    requires IsUnpaddedBase64String(s)
    ensures EncodeUnpadded(DecodeUnpadded(s)) == s
    decreases s
  {
    ghost var fromCharsToIndicesS := FromCharsToIndices(s);
    calc {
      EncodeUnpadded(DecodeUnpadded(s));
    ==
      EncodeUnpadded(DecodeRecursively(FromCharsToIndices(s)));
    ==
      EncodeUnpadded(DecodeRecursively(fromCharsToIndicesS));
    ==
      assert |fromCharsToIndicesS| % 4 == 0; assert |DecodeRecursively(fromCharsToIndicesS)| % 3 == 0; FromIndicesToChars(EncodeRecursively(DecodeRecursively(fromCharsToIndicesS)));
    ==
      {
        DecodeEncodeRecursively(fromCharsToIndicesS);
      }
      FromIndicesToChars(fromCharsToIndicesS);
    ==
      FromIndicesToChars(FromCharsToIndices(s));
    ==
      {
        FromCharsToIndicesToChars(s);
      }
      s;
    }
  }

  predicate method Is1Padding(s: seq<char>)
    decreases s
  {
    |s| == 4 &&
    IsBase64Char(s[0]) &&
    IsBase64Char(s[1]) &&
    IsBase64Char(s[2]) &&
    CharToIndex(s[2]) % 4 == 0 &&
    s[3] == '='
  }

  function method Decode1Padding(s: seq<char>): (b: seq<uint8>)
    requires Is1Padding(s)
    ensures |b| == 2
    decreases s
  {
    var d: seq<uint8> := DecodeBlock([CharToIndex(s[0]), CharToIndex(s[1]), CharToIndex(s[2]), 0]);
    [d[0], d[1]]
  }

  function method Encode1Padding(b: seq<uint8>): (s: seq<char>)
    requires |b| == 2
    ensures Is1Padding(s)
    ensures Decode1Padding(s) == b
    decreases b
  {
    var e: seq<index> := EncodeBlock([b[0], b[1], 0]);
    [IndexToChar(e[0]), IndexToChar(e[1]), IndexToChar(e[2]), '=']
  }

  lemma DecodeEncode1Padding(s: seq<char>)
    requires Is1Padding(s)
    ensures Encode1Padding(Decode1Padding(s)) == s
    decreases s
  {
  }

  lemma EncodeDecode1Padding(b: seq<uint8>)
    requires |b| == 2
    ensures Decode1Padding(Encode1Padding(b)) == b
    decreases b
  {
  }

  predicate method Is2Padding(s: seq<char>)
    decreases s
  {
    |s| == 4 &&
    IsBase64Char(s[0]) &&
    IsBase64Char(s[1]) &&
    CharToIndex(s[1]) % 16 == 0 &&
    s[2] == '=' &&
    s[3] == '='
  }

  function method Decode2Padding(s: seq<char>): (b: seq<uint8>)
    requires Is2Padding(s)
    ensures |b| == 1
    decreases s
  {
    var d: seq<uint8> := DecodeBlock([CharToIndex(s[0]), CharToIndex(s[1]), 0, 0]);
    [d[0]]
  }

  function method Encode2Padding(b: seq<uint8>): (s: seq<char>)
    requires |b| == 1
    ensures Is2Padding(s)
    ensures Decode2Padding(s) == b
    decreases b
  {
    var e: seq<index> := EncodeBlock([b[0], 0, 0]);
    [IndexToChar(e[0]), IndexToChar(e[1]), '=', '=']
  }

  lemma DecodeEncode2Padding(s: seq<char>)
    requires Is2Padding(s)
    ensures Encode2Padding(Decode2Padding(s)) == s
    decreases s
  {
  }

  lemma EncodeDecode2Padding(b: seq<uint8>)
    requires |b| == 1
    ensures Decode2Padding(Encode2Padding(b)) == b
    decreases b
  {
  }

  predicate method IsBase64String(s: string)
    decreases s
  {
    var finalBlockStart: int := |s| - 4;
    |s| % 4 == 0 &&
    (IsUnpaddedBase64String(s) || (IsUnpaddedBase64String(s[..finalBlockStart]) && (Is1Padding(s[finalBlockStart..]) || Is2Padding(s[finalBlockStart..]))))
  }

  function method DecodeValid(s: seq<char>): (b: seq<uint8>)
    requires IsBase64String(s)
    decreases s
  {
    if s == [] then
      []
    else
      var finalBlockStart: int := |s| - 4; var prefix: seq<char>, suffix: seq<char> := s[..finalBlockStart], s[finalBlockStart..]; if Is1Padding(suffix) then DecodeUnpadded(prefix) + Decode1Padding(suffix) else if Is2Padding(suffix) then DecodeUnpadded(prefix) + Decode2Padding(suffix) else DecodeUnpadded(s)
  }

  lemma AboutDecodeValid(s: seq<char>, b: seq<uint8>)
    requires IsBase64String(s) && b == DecodeValid(s)
    ensures 4 <= |s| ==> ghost var finalBlockStart: int := |s| - 4; ghost var prefix: seq<char>, suffix: seq<char> := s[..finalBlockStart], s[finalBlockStart..]; (Is1Padding(suffix) ==> |b| % 3 == 2) && (Is2Padding(suffix) ==> |b| % 3 == 1) && (!Is1Padding(suffix) && !Is2Padding(suffix) ==> |b| % 3 == 0)
    decreases s, b
  {
    if 4 <= |s| {
      ghost var finalBlockStart := |s| - 4;
      ghost var prefix, suffix := s[..finalBlockStart], s[finalBlockStart..];
      if s == [] {
      } else if Is1Padding(suffix) {
        assert !Is2Padding(suffix);
        ghost var x, y := DecodeUnpadded(prefix), Decode1Padding(suffix);
        assert b == x + y;
        assert |x| == |x| / 3 * 3 && |y| == 2;
        Mod3(|x| / 3, |y|, |b|);
      } else if Is2Padding(suffix) {
        ghost var x, y := DecodeUnpadded(prefix), Decode2Padding(suffix);
        assert b == x + y;
        assert |x| == |x| / 3 * 3 && |y| == 1;
        Mod3(|x| / 3, |y|, |b|);
      } else {
        assert b == DecodeUnpadded(s);
      }
    }
  }

  lemma Mod3(x: nat, k: nat, n: nat)
    requires 0 <= k < 3 && n == 3 * x + k
    ensures n % 3 == k
    decreases x, k, n
  {
  }

  function method Decode(s: seq<char>): (b: Result<seq<uint8>, string>)
    ensures IsBase64String(s) ==> b.Success?
    ensures !IsBase64String(s) ==> b.Failure?
    decreases s
  {
    if IsBase64String(s) then
      Success(DecodeValid(s))
    else
      Failure(""The encoding is malformed"")
  }

  predicate StringIs7Bit(s: string)
    decreases s
  {
    forall i: int :: 
      0 <= i < |s| ==>
        s[i] < 128 as char
  }

  function method Encode(b: seq<uint8>): (s: seq<char>)
    ensures StringIs7Bit(s)
    ensures |s| % 4 == 0
    ensures IsBase64String(s)
    decreases b
  {
    if |b| % 3 == 0 then
      EncodeUnpadded(b)
    else if |b| % 3 == 1 then
      EncodeUnpadded(b[..|b| - 1]) + Encode2Padding(b[|b| - 1..])
    else
      EncodeUnpadded(b[..|b| - 2]) + Encode1Padding(b[|b| - 2..])
  }

  lemma EncodeLengthExact(b: seq<uint8>)
    ensures ghost var s: seq<char> := Encode(b); (|b| % 3 == 0 ==> |s| == |b| / 3 * 4) && (|b| % 3 != 0 ==> |s| == |b| / 3 * 4 + 4)
    decreases b
  {
    ghost var s := Encode(b);
    if |b| % 3 == 0 {
      assert s == EncodeUnpadded(b);
      assert |s| == |b| / 3 * 4;
    } else if |b| % 3 == 1 {
      assert s == EncodeUnpadded(b[..|b| - 1]) + Encode2Padding(b[|b| - 1..]);
      calc {
        |s|;
      ==
        |EncodeUnpadded(b[..|b| - 1])| + |Encode2Padding(b[|b| - 1..])|;
      ==
        {
          assert |Encode2Padding(b[|b| - 1..])| == 4;
        }
        |EncodeUnpadded(b[..|b| - 1])| + 4;
      ==
        {
          assert |EncodeUnpadded(b[..|b| - 1])| == |b[..|b| - 1]| / 3 * 4;
        }
        |b[..|b| - 1]| / 3 * 4 + 4;
      ==
        {
          assert |b[..|b| - 1]| == |b| - 1;
        }
        (|b| - 1) / 3 * 4 + 4;
      ==
        {
          assert (|b| - 1) / 3 == |b| / 3;
        }
        |b| / 3 * 4 + 4;
      }
    } else {
      assert s == EncodeUnpadded(b[..|b| - 2]) + Encode1Padding(b[|b| - 2..]);
      calc {
        |s|;
      ==
        |EncodeUnpadded(b[..|b| - 2])| + |Encode1Padding(b[|b| - 2..])|;
      ==
        {
          assert |Encode1Padding(b[|b| - 2..])| == 4;
        }
        |EncodeUnpadded(b[..|b| - 2])| + 4;
      ==
        {
          assert |EncodeUnpadded(b[..|b| - 2])| == |b[..|b| - 2]| / 3 * 4;
        }
        |b[..|b| - 2]| / 3 * 4 + 4;
      ==
        {
          assert |b[..|b| - 2]| == |b| - 2;
        }
        (|b| - 2) / 3 * 4 + 4;
      ==
        {
          assert (|b| - 2) / 3 == |b| / 3;
        }
        |b| / 3 * 4 + 4;
      }
      assert ghost var s: seq<char> := Encode(b); (|b| % 3 == 0 ==> |s| == |b| / 3 * 4) && (|b| % 3 != 0 ==> |s| == |b| / 3 * 4 + 4);
    }
  }

  lemma EncodeLengthBound(b: seq<uint8>)
    ensures ghost var s: seq<char> := Encode(b); |s| <= |b| / 3 * 4 + 4
    decreases b
  {
    EncodeLengthExact(b);
  }
}

module Base64Lemmas {

  import opened StandardLibrary = StandardLibrary

  import opened Wrappers = Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened Base64 = Base64
  lemma DecodeValidEncodeEmpty(s: seq<char>)
    requires s == []
    ensures Encode(DecodeValid(s)) == s
    decreases s
  {
  }

  lemma DecodeValidEncodeUnpadded(s: seq<char>)
    requires IsBase64String(s)
    requires |s| >= 4
    requires !Is1Padding(s[|s| - 4..])
    requires !Is2Padding(s[|s| - 4..])
    ensures Encode(DecodeValid(s)) == s
    decreases s
  {
    calc {
      Encode(DecodeValid(s));
    ==
      Encode(DecodeUnpadded(s));
    ==
      EncodeUnpadded(DecodeUnpadded(s));
    ==
      {
        DecodeEncodeUnpadded(s);
      }
      s;
    }
  }

  lemma DecodeValidUnpaddedPartialFrom1PaddedSeq(s: seq<char>)
    requires IsBase64String(s)
    requires |s| >= 4
    requires Is1Padding(s[|s| - 4..])
    ensures DecodeValid(s)[..|DecodeValid(s)| - 2] == DecodeUnpadded(s[..|s| - 4])
    decreases s
  {
  }

  lemma DecodeValid1PaddedPartialFrom1PaddedSeq(s: seq<char>)
    requires IsBase64String(s)
    requires |s| >= 4
    requires Is1Padding(s[|s| - 4..])
    ensures DecodeValid(s)[|DecodeValid(s)| - 2..] == Decode1Padding(s[|s| - 4..])
    decreases s
  {
  }

  lemma DecodeValidEncode1Padding(s: seq<char>)
    requires IsBase64String(s)
    requires |s| >= 4
    requires Is1Padding(s[|s| - 4..])
    ensures Encode(DecodeValid(s)) == s
    decreases s
  {
    calc {
      Encode(DecodeValid(s));
    ==
      assert |DecodeValid(s)| % 3 == 2; EncodeUnpadded(DecodeValid(s)[..|DecodeValid(s)| - 2]) + Encode1Padding(DecodeValid(s)[|DecodeValid(s)| - 2..]);
    ==
      {
        DecodeValidUnpaddedPartialFrom1PaddedSeq(s);
      }
      EncodeUnpadded(DecodeUnpadded(s[..|s| - 4])) + Encode1Padding(DecodeValid(s)[|DecodeValid(s)| - 2..]);
    ==
      {
        DecodeEncodeUnpadded(s[..|s| - 4]);
      }
      s[..|s| - 4] + Encode1Padding(DecodeValid(s)[|DecodeValid(s)| - 2..]);
    ==
      {
        DecodeValid1PaddedPartialFrom1PaddedSeq(s);
      }
      s[..|s| - 4] + Encode1Padding(Decode1Padding(s[|s| - 4..]));
    ==
      {
        DecodeEncode1Padding(s[|s| - 4..]);
      }
      s[..|s| - 4] + s[|s| - 4..];
    ==
      {
        SeqPartsMakeWhole(s, |s| - 4);
      }
      s;
    }
  }

  lemma DecodeValidUnpaddedPartialFrom2PaddedSeq(s: seq<char>)
    requires IsBase64String(s)
    requires |s| >= 4
    requires Is2Padding(s[|s| - 4..])
    ensures DecodeValid(s)[..|DecodeValid(s)| - 1] == DecodeUnpadded(s[..|s| - 4])
    decreases s
  {
  }

  lemma DecodeValid2PaddedPartialFrom2PaddedSeq(s: seq<char>)
    requires IsBase64String(s)
    requires |s| >= 4
    requires Is2Padding(s[|s| - 4..])
    ensures DecodeValid(s)[|DecodeValid(s)| - 1..] == Decode2Padding(s[|s| - 4..])
    decreases s
  {
  }

  lemma DecodeValidEncode2Padding(s: seq<char>)
    requires IsBase64String(s)
    requires |s| >= 4
    requires Is2Padding(s[|s| - 4..])
    ensures Encode(DecodeValid(s)) == s
    decreases s
  {
    calc {
      Encode(DecodeValid(s));
    ==
      assert |DecodeValid(s)| % 3 == 1; EncodeUnpadded(DecodeValid(s)[..|DecodeValid(s)| - 1]) + Encode2Padding(DecodeValid(s)[|DecodeValid(s)| - 1..]);
    ==
      {
        DecodeValidUnpaddedPartialFrom2PaddedSeq(s);
      }
      EncodeUnpadded(DecodeUnpadded(s[..|s| - 4])) + Encode2Padding(DecodeValid(s)[|DecodeValid(s)| - 1..]);
    ==
      {
        DecodeEncodeUnpadded(s[..|s| - 4]);
      }
      s[..|s| - 4] + Encode2Padding(DecodeValid(s)[|DecodeValid(s)| - 1..]);
    ==
      {
        DecodeValid2PaddedPartialFrom2PaddedSeq(s);
      }
      s[..|s| - 4] + Encode2Padding(Decode2Padding(s[|s| - 4..]));
    ==
      {
        DecodeEncode2Padding(s[|s| - 4..]);
      }
      s[..|s| - 4] + s[|s| - 4..];
    ==
      {
        SeqPartsMakeWhole(s, |s| - 4);
      }
      s;
    }
  }

  lemma DecodeValidEncode(s: seq<char>)
    requires IsBase64String(s)
    ensures Encode(DecodeValid(s)) == s
    decreases s
  {
    if s == [] {
      calc {
        Encode(DecodeValid(s));
      ==
        {
          DecodeValidEncodeEmpty(s);
        }
        s;
      }
    } else if |s| >= 4 && Is1Padding(s[|s| - 4..]) {
      calc {
        Encode(DecodeValid(s));
      ==
        {
          DecodeValidEncode1Padding(s);
        }
        s;
      }
    } else if |s| >= 4 && Is2Padding(s[|s| - 4..]) {
      calc {
        Encode(DecodeValid(s));
      ==
        {
          DecodeValidEncode2Padding(s);
        }
        s;
      }
    } else {
      calc {
        Encode(DecodeValid(s));
      ==
        {
          DecodeValidEncodeUnpadded(s);
        }
        s;
      }
    }
  }

  lemma EncodeDecodeValid(b: seq<uint8>)
    ensures DecodeValid(Encode(b)) == b
    decreases b
  {
  }

  lemma DecodeEncode(s: seq<char>)
    requires IsBase64String(s)
    ensures Encode(Decode(s).value) == s
    decreases s
  {
    calc {
      Encode(Decode(s).value);
    ==
      {
        DecodeValidEncode(s);
      }
      s;
    }
  }

  lemma EncodeDecode(b: seq<uint8>)
    ensures Decode(Encode(b)) == Success(b)
    decreases b
  {
    calc {
      Decode(Encode(b));
    ==
      {
        assert IsBase64String(Encode(b));
      }
      Success(DecodeValid(Encode(b)));
    ==
      {
        EncodeDecodeValid(b);
      }
      Success(b);
    }
  }
}

module StandardLibrary {

  import opened Wrappers = Wrappers

  import opened U = UInt
  function method {:tailrecursion} Join<T>(ss: seq<seq<T>>, joiner: seq<T>): (s: seq<T>)
    requires 0 < |ss|
    decreases ss, joiner
  {
    if |ss| == 1 then
      ss[0]
    else
      ss[0] + joiner + Join(ss[1..], joiner)
  }

  function method {:tailrecursion} Split<T(==)>(s: seq<T>, delim: T): (res: seq<seq<T>>)
    ensures delim !in s ==> res == [s]
    ensures s == [] ==> res == [[]]
    ensures 0 < |res|
    ensures forall i: int :: 0 <= i < |res| ==> delim !in res[i]
    ensures Join(res, [delim]) == s
    decreases |s|
  {
    var i: Option<nat> := FindIndexMatching(s, delim, 0);
    if i.Some? then
      [s[..i.value]] + Split(s[i.value + 1..], delim)
    else
      [s]
  }

  lemma /*{:_induction s}*/ WillSplitOnDelim<T>(s: seq<T>, delim: T, prefix: seq<T>)
    requires |prefix| < |s|
    requires forall i: int :: 0 <= i < |prefix| ==> prefix[i] == s[i]
    requires delim !in prefix && s[|prefix|] == delim
    ensures Split(s, delim) == [prefix] + Split(s[|prefix| + 1..], delim)
    decreases s, prefix
  {
    calc {
      Split(s, delim);
    ==
      ghost var i: Option<nat> := FindIndexMatching(s, delim, 0); if i.Some? then [s[..i.value]] + Split(s[i.value + 1..], delim) else [s];
    ==
      {
        FindIndexMatchingLocatesElem(s, delim, 0, |prefix|);
        assert FindIndexMatching(s, delim, 0).Some?;
      }
      [s[..|prefix|]] + Split(s[|prefix| + 1..], delim);
    ==
      {
        assert s[..|prefix|] == prefix;
      }
      [prefix] + Split(s[|prefix| + 1..], delim);
    }
  }

  lemma /*{:_induction s}*/ WillNotSplitWithOutDelim<T>(s: seq<T>, delim: T)
    requires delim !in s
    ensures Split(s, delim) == [s]
    decreases s
  {
    calc {
      Split(s, delim);
    ==
      ghost var i: Option<nat> := FindIndexMatching(s, delim, 0); if i.Some? then [s[..i.value]] + Split(s[i.value + 1..], delim) else [s];
    ==
      {
        FindIndexMatchingLocatesElem(s, delim, 0, |s|);
      }
      [s];
    }
  }

  lemma FindIndexMatchingLocatesElem<T>(s: seq<T>, c: T, start: nat, elemIndex: nat)
    requires start <= elemIndex <= |s|
    requires forall i: int :: start <= i < elemIndex ==> s[i] != c
    requires elemIndex == |s| || s[elemIndex] == c
    ensures FindIndexMatching(s, c, start) == if elemIndex == |s| then None else Some(elemIndex)
    decreases elemIndex - start
  {
  }

  function method FindIndexMatching<T(==)>(s: seq<T>, c: T, i: nat): (index: Option<nat>)
    requires i <= |s|
    ensures index.Some? ==> i <= index.value < |s| && s[index.value] == c && c !in s[i .. index.value]
    ensures index.None? ==> c !in s[i..]
    decreases |s| - i
  {
    FindIndex(s, (x: T) => x == c, i)
  }

  function method {:tailrecursion} FindIndex<T>(s: seq<T>, f: T -> bool, i: nat): (index: Option<nat>)
    requires i <= |s|
    ensures index.Some? ==> i <= index.value < |s| && f(s[index.value]) && forall j: int :: i <= j < index.value ==> !f(s[j])
    ensures index.None? ==> forall j: int :: i <= j < |s| ==> !f(s[j])
    decreases |s| - i
  {
    if i == |s| then
      None
    else if f(s[i]) then
      Some(i)
    else
      FindIndex(s, f, i + 1)
  }

  function method {:tailrecursion} Filter<T>(s: seq<T>, f: T -> bool): (res: seq<T>)
    ensures forall i: int :: 0 <= i < |s| && f(s[i]) ==> s[i] in res
    ensures forall i: int :: 0 <= i < |res| ==> res[i] in s && f(res[i])
    ensures |res| <= |s|
    decreases s
  {
    if |s| == 0 then
      []
    else if f(s[0]) then
      [s[0]] + Filter(s[1..], f)
    else
      Filter(s[1..], f)
  }

  lemma /*{:_induction s, s', f}*/ FilterIsDistributive<T>(s: seq<T>, s': seq<T>, f: T -> bool)
    ensures Filter(s + s', f) == Filter(s, f) + Filter(s', f)
    decreases s, s'
  {
    if s == [] {
      assert s + s' == s';
    } else {
      ghost var S := s + s';
      ghost var s1 := s[1..];
      calc {
        Filter(S, f);
      ==
        if f(S[0]) then [S[0]] + Filter(S[1..], f) else Filter(S[1..], f);
      ==
        {
          assert S[0] == s[0] && S[1..] == s1 + s';
        }
        if f(s[0]) then [s[0]] + Filter(s1 + s', f) else Filter(s1 + s', f);
      ==
        {
          FilterIsDistributive(s1, s', f);
        }
        if f(s[0]) then [s[0]] + (Filter(s1, f) + Filter(s', f)) else Filter(s1, f) + Filter(s', f);
      ==
        if f(s[0]) then [s[0]] + Filter(s1, f) + Filter(s', f) else Filter(s1, f) + Filter(s', f);
      ==
        (if f(s[0]) then [s[0]] + Filter(s1, f) else Filter(s1, f)) + Filter(s', f);
      ==
        Filter(s, f) + Filter(s', f);
      }
    }
  }

  function method Min(a: int, b: int): int
    decreases a, b
  {
    if a < b then
      a
    else
      b
  }

  function method Fill<T>(value: T, n: nat): seq<T>
    ensures |Fill(value, n)| == n
    ensures forall i: int :: 0 <= i < n ==> Fill(value, n)[i] == value
    decreases n
  {
    seq(n, (_: int) => value)
  }

  method SeqToArray<T>(s: seq<T>) returns (a: array<T>)
    ensures fresh(a)
    ensures a.Length == |s|
    ensures forall i: int :: 0 <= i < |s| ==> a[i] == s[i]
    decreases s
  {
    a := new T[|s|] ((i: int) requires 0 <= i < |s| => s[i]);
  }

  lemma SeqPartsMakeWhole<T>(s: seq<T>, i: nat)
    requires 0 <= i <= |s|
    ensures s[..i] + s[i..] == s
    decreases s, i
  {
  }

  predicate method LexicographicLessOrEqual<T(==)>(a: seq<T>, b: seq<T>, less: (T, T) -> bool)
    decreases a, b
  {
    exists k: int :: 
      0 <= k <= |a| &&
      LexicographicLessOrEqualAux(a, b, less, k)
  }

  predicate method LexicographicLessOrEqualAux<T(==)>(a: seq<T>, b: seq<T>, less: (T, T) -> bool, lengthOfCommonPrefix: nat)
    requires 0 <= lengthOfCommonPrefix <= |a|
    decreases a, b, lengthOfCommonPrefix
  {
    lengthOfCommonPrefix <= |b| &&
    (forall i: int :: 
      0 <= i < lengthOfCommonPrefix ==>
        a[i] == b[i]) &&
    (lengthOfCommonPrefix == |a| || (lengthOfCommonPrefix < |b| && less(a[lengthOfCommonPrefix], b[lengthOfCommonPrefix])))
  }

  predicate Trichotomous<T(!new)>(less: (T, T) -> bool)
  {
    (forall x: T, y: T :: 
      less(x, y) || x == y || less(y, x)) &&
    (forall x: T, y: T :: 
      less(x, y) &&
      less(y, x) ==>
        false) &&
    forall x: T, y: T :: 
      less(x, y) ==>
        x != y
  }

  predicate Transitive<T(!new)>(R: (T, T) -> bool)
  {
    forall x: T, y: T, z: T :: 
      R(x, y) &&
      R(y, z) ==>
        R(x, z)
  }

  lemma UInt8LessIsTrichotomousTransitive()
    ensures Trichotomous(UInt8Less)
    ensures Transitive(UInt8Less)
  {
  }

  lemma LexIsReflexive<T>(a: seq<T>, less: (T, T) -> bool)
    ensures LexicographicLessOrEqual(a, a, less)
    decreases a
  {
    assert LexicographicLessOrEqualAux(a, a, less, |a|);
  }

  lemma LexIsAntisymmetric<T>(a: seq<T>, b: seq<T>, less: (T, T) -> bool)
    requires Trich: Trichotomous(less)
    requires LexicographicLessOrEqual(a, b, less)
    requires LexicographicLessOrEqual(b, a, less)
    ensures a == b
    decreases a, b
  {
    assert LessIrreflexive: forall x: T, y: T :: less(x, y) ==> x != y by {
      reveal Trich;
    }
    assert ASymmetric: forall x: T, y: T :: less(x, y) && less(y, x) ==> false by {
      reveal Trich;
    }
    ghost var k0 :| 0 <= k0 <= |a| && LexicographicLessOrEqualAux(a, b, less, k0);
    ghost var k1 :| 0 <= k1 <= |b| && LexicographicLessOrEqualAux(b, a, less, k1);
    ghost var max := if k0 < k1 then k1 else k0;
    assert max <= |a| && max <= |b|;
    assert SameUntilMax: forall i: int :: 0 <= i < max ==> a[i] == b[i];
    assert AA: k0 == |a| || (k0 < |b| && less(a[k0], b[k0]));
    assert BB: k1 == |b| || (k1 < |a| && less(b[k1], a[k1]));
    calc {
      true;
    ==>
      {
        reveal AA, BB;
      }
      (k0 == |a| || (k0 < |b| && less(a[k0], b[k0]))) &&
      (k1 == |b| || (k1 < |a| && less(b[k1], a[k1])));
    ==
      (k0 == |a| && k1 == |b|) || (k0 == |a| && k1 < |a| && less(b[k1], a[k1])) || (k0 < |b| && less(a[k0], b[k0]) && k1 == |b|) || (k0 < |b| && less(a[k0], b[k0]) && k1 < |a| && less(b[k1], a[k1]));
    ==
      {
        reveal LessIrreflexive, SameUntilMax;
      }
      (k0 == |a| && k1 == |b|) || (k0 < |b| && less(a[k0], b[k0]) && k1 < |a| && less(b[k1], a[k1]));
    ==>
      {
        reveal LessIrreflexive, SameUntilMax;
        assert max <= k0 && max <= k1;
      }
      (k0 == |a| && k1 == |b|) || (k0 < |b| && less(a[k0], b[k0]) && k1 < |a| && less(b[k1], a[k1]) && k0 == k1 == max);
    ==
      {
        reveal ASymmetric;
      }
      k0 == |a| &&
      k1 == |b|;
    ==>
      {
        assert |a| == k0 <= max && |b| == k1 <= max ==> k0 == k1;
      }
      max == |a| == |b|;
    ==>
      {
        reveal SameUntilMax;
      }
      a == b;
    }
  }

  lemma LexIsTransitive<T>(a: seq<T>, b: seq<T>, c: seq<T>, less: (T, T) -> bool)
    requires Transitive(less)
    requires LexicographicLessOrEqual(a, b, less)
    requires LexicographicLessOrEqual(b, c, less)
    ensures LexicographicLessOrEqual(a, c, less)
    decreases a, b, c
  {
    ghost var k0 :| 0 <= k0 <= |a| && LexicographicLessOrEqualAux(a, b, less, k0);
    ghost var k1 :| 0 <= k1 <= |b| && LexicographicLessOrEqualAux(b, c, less, k1);
    ghost var k := if k0 < k1 then k0 else k1;
    assert LexicographicLessOrEqualAux(a, c, less, k);
  }

  lemma LexIsTotal<T>(a: seq<T>, b: seq<T>, less: (T, T) -> bool)
    requires Trich: Trichotomous(less)
    ensures LexicographicLessOrEqual(a, b, less) || LexicographicLessOrEqual(b, a, less)
    decreases a, b
  {
    ghost var m := 0;
    while m < |a| && m < |b| && a[m] == b[m]
      invariant m <= |a| && m <= |b|
      invariant forall i: int :: 0 <= i < m ==> a[i] == b[i]
      decreases |a| - m, if m < |a| then |b| - m else 0 - 1
    {
      m := m + 1;
    }
    if m == |a| == |b| {
      assert a == b;
      LexIsReflexive(a, less);
    } else if m == |a| < |b| {
      assert LexicographicLessOrEqualAux(a, b, less, m);
    } else if m == |b| < |a| {
      assert LexicographicLessOrEqualAux(b, a, less, m);
    } else {
      assert m < |a| && m < |b|;
      reveal Trich;
      if
      case less(a[m], b[m]) =>
        assert LexicographicLessOrEqualAux(a, b, less, m);
      case less(b[m], a[m]) =>
        assert LexicographicLessOrEqualAux(b, a, less, m);
    }
  }

  function method {:tailrecursion} SetToOrderedSequence<T(==,!new)>(s: set<seq<T>>, less: (T, T) -> bool): (q: seq<seq<T>>)
    requires Trichotomous(less) && Transitive(less)
    ensures |s| == |q|
    ensures forall i: int :: 0 <= i < |q| ==> q[i] in s
    ensures forall k: seq<T> :: k in s ==> k in q
    ensures forall i: int :: 0 < i < |q| ==> LexicographicLessOrEqual(q[i - 1], q[i], less)
    ensures forall i: int, j: int | 0 <= i < j < |q| :: q[i] != q[j]
    decreases s
  {
    if s == {} then
      []
    else
      ThereIsAMinimum(s, less); assert forall a: seq<T>, b: seq<T> :: IsMinimum(a, s, less) && IsMinimum(b, s, less) ==> a == b by {
    forall a: seq<T>, b: seq<T> | IsMinimum(a, s, less) && IsMinimum(b, s, less) {
      MinimumIsUnique(a, b, s, less);
    }
  } var a: seq<T> :| a in s && IsMinimum(a, s, less); [a] + SetToOrderedSequence(s - {a}, less)
  }

  predicate method IsMinimum<T(==)>(a: seq<T>, s: set<seq<T>>, less: (T, T) -> bool)
    decreases a, s
  {
    a in s &&
    forall z: seq<T> :: 
      z in s ==>
        LexicographicLessOrEqual(a, z, less)
  }

  lemma ThereIsAMinimum<T>(s: set<seq<T>>, less: (T, T) -> bool)
    requires s != {}
    requires Trichotomous(less) && Transitive(less)
    ensures exists a: seq<T> :: IsMinimum(a, s, less)
    decreases s
  {
    ghost var a := FindMinimum(s, less);
  }

  lemma MinimumIsUnique<T>(a: seq<T>, b: seq<T>, s: set<seq<T>>, less: (T, T) -> bool)
    requires IsMinimum(a, s, less) && IsMinimum(b, s, less)
    requires Trichotomous(less)
    ensures a == b
    decreases a, b, s
  {
    LexIsAntisymmetric(a, b, less);
  }

  lemma FindMinimum<T>(s: set<seq<T>>, less: (T, T) -> bool) returns (a: seq<T>)
    requires s != {}
    requires Trichotomous(less) && Transitive(less)
    ensures IsMinimum(a, s, less)
    decreases s
  {
    a :| a in s;
    if s == {a} {
      LexIsReflexive(a, less);
    } else {
      ghost var s' := s - {a};
      assert forall x: seq<T> :: x in s <==> x == a || x in s';
      ghost var a' := FindMinimum(s', less);
      if LexicographicLessOrEqual(a', a, less) {
        a := a';
      } else {
        assert LexicographicLessOrEqual(a, a', less) by {
          LexIsTotal(a, a', less);
        }
        forall z: seq<T> | z in s
          ensures LexicographicLessOrEqual(a, z, less)
        {
          if z == a {
            LexIsReflexive(a, less);
          } else {
            calc {
              true;
            ==
              z in s';
            ==>
              LexicographicLessOrEqual(a', z, less);
            ==>
              {
                LexIsTransitive(a, a', z, less);
              }
              LexicographicLessOrEqual(a, z, less);
            }
          }
        }
      }
    }
  }

  module UInt {
    newtype uint8 = x: int
      | 0 <= x < 256

    newtype uint16 = x: int
      | 0 <= x < 65536

    newtype uint32 = x: int
      | 0 <= x < 4294967296

    newtype uint64 = x: int
      | 0 <= x < 18446744073709551616

    newtype int32 = x: int
      | -2147483648 <= x < 2147483648

    newtype int64 = x: int
      | -9223372036854775808 <= x < 9223372036854775808

    const UINT16_LIMIT := 65536
    const UINT32_LIMIT := 4294967296
    const INT32_MAX_LIMIT := 2147483648
    const INT64_MAX_LIMIT := 9223372036854775808

    predicate method UInt8Less(a: uint8, b: uint8)
      decreases a, b
    {
      a < b
    }

    function method UInt16ToSeq(x: uint16): (ret: seq<uint8>)
      ensures |ret| == 2
      ensures 256 * ret[0] as uint16 + ret[1] as uint16 == x
      decreases x
    {
      var b0: uint8 := (x / 256) as uint8;
      var b1: uint8 := (x % 256) as uint8;
      [b0, b1]
    }

    function method SeqToUInt16(s: seq<uint8>): (x: uint16)
      requires |s| == 2
      ensures UInt16ToSeq(x) == s
      decreases s
    {
      var x0: uint16 := s[0] as uint16 * 256;
      x0 + s[1] as uint16
    }

    lemma UInt16SeqSerializeDeserialize(x: uint16)
      ensures SeqToUInt16(UInt16ToSeq(x)) == x
      decreases x
    {
    }

    lemma UInt16SeqDeserializeSerialize(s: seq<uint8>)
      requires |s| == 2
      ensures UInt16ToSeq(SeqToUInt16(s)) == s
      decreases s
    {
    }

    function method UInt32ToSeq(x: uint32): (ret: seq<uint8>)
      ensures |ret| == 4
      ensures 16777216 * ret[0] as uint32 + 65536 * ret[1] as uint32 + 256 * ret[2] as uint32 + ret[3] as uint32 == x
      decreases x
    {
      var b0: uint8 := (x / 16777216) as uint8;
      var x0: uint32 := x - b0 as uint32 * 16777216;
      var b1: uint8 := (x0 / 65536) as uint8;
      var x1: uint32 := x0 - b1 as uint32 * 65536;
      var b2: uint8 := (x1 / 256) as uint8;
      var b3: uint8 := (x1 % 256) as uint8;
      [b0, b1, b2, b3]
    }

    function method SeqToUInt32(s: seq<uint8>): (x: uint32)
      requires |s| == 4
      ensures UInt32ToSeq(x) == s
      decreases s
    {
      var x0: uint32 := s[0] as uint32 * 16777216;
      var x1: uint32 := x0 + s[1] as uint32 * 65536;
      var x2: uint32 := x1 + s[2] as uint32 * 256;
      x2 + s[3] as uint32
    }

    lemma UInt32SeqSerializeDeserialize(x: uint32)
      ensures SeqToUInt32(UInt32ToSeq(x)) == x
      decreases x
    {
    }

    lemma UInt32SeqDeserializeSerialize(s: seq<uint8>)
      requires |s| == 4
      ensures UInt32ToSeq(SeqToUInt32(s)) == s
      decreases s
    {
    }

    function method UInt64ToSeq(x: uint64): (ret: seq<uint8>)
      ensures |ret| == 8
      ensures 72057594037927936 * ret[0] as uint64 + 281474976710656 * ret[1] as uint64 + 1099511627776 * ret[2] as uint64 + 4294967296 * ret[3] as uint64 + 16777216 * ret[4] as uint64 + 65536 * ret[5] as uint64 + 256 * ret[6] as uint64 + ret[7] as uint64 == x
      decreases x
    {
      var b0: uint8 := (x / 72057594037927936) as uint8;
      var x0: uint64 := x - b0 as uint64 * 72057594037927936;
      var b1: uint8 := (x0 / 281474976710656) as uint8;
      var x1: uint64 := x0 - b1 as uint64 * 281474976710656;
      var b2: uint8 := (x1 / 1099511627776) as uint8;
      var x2: uint64 := x1 - b2 as uint64 * 1099511627776;
      var b3: uint8 := (x2 / 4294967296) as uint8;
      var x3: uint64 := x2 - b3 as uint64 * 4294967296;
      var b4: uint8 := (x3 / 16777216) as uint8;
      var x4: uint64 := x3 - b4 as uint64 * 16777216;
      var b5: uint8 := (x4 / 65536) as uint8;
      var x5: uint64 := x4 - b5 as uint64 * 65536;
      var b6: uint8 := (x5 / 256) as uint8;
      var b7: uint8 := (x5 % 256) as uint8;
      [b0, b1, b2, b3, b4, b5, b6, b7]
    }

    function method SeqToUInt64(s: seq<uint8>): (x: uint64)
      requires |s| == 8
      ensures UInt64ToSeq(x) == s
      decreases s
    {
      var x0: uint64 := s[0] as uint64 * 72057594037927936;
      var x1: uint64 := x0 + s[1] as uint64 * 281474976710656;
      var x2: uint64 := x1 + s[2] as uint64 * 1099511627776;
      var x3: uint64 := x2 + s[3] as uint64 * 4294967296;
      var x4: uint64 := x3 + s[4] as uint64 * 16777216;
      var x5: uint64 := x4 + s[5] as uint64 * 65536;
      var x6: uint64 := x5 + s[6] as uint64 * 256;
      var x: uint64 := x6 + s[7] as uint64;
      UInt64SeqSerialize(x, s);
      x
    }

    lemma UInt64SeqSerialize(x: uint64, s: seq<uint8>)
      requires |s| == 8
      requires 72057594037927936 * s[0] as uint64 + 281474976710656 * s[1] as uint64 + 1099511627776 * s[2] as uint64 + 4294967296 * s[3] as uint64 + 16777216 * s[4] as uint64 + 65536 * s[5] as uint64 + 256 * s[6] as uint64 + s[7] as uint64 == x
      ensures UInt64ToSeq(x) == s
      decreases x, s
    {
      calc {
        UInt64ToSeq(x);
      ==
        UInt64ToSeq(s[0] as uint64 * 72057594037927936 + s[1] as uint64 * 281474976710656 + s[2] as uint64 * 1099511627776 + s[3] as uint64 * 4294967296 + s[4] as uint64 * 16777216 + s[5] as uint64 * 65536 + s[6] as uint64 * 256 + s[7] as uint64);
      ==
        ghost var b0: uint8 := ((s[0] as uint64 * 72057594037927936 + s[1] as uint64 * 281474976710656 + s[2] as uint64 * 1099511627776 + s[3] as uint64 * 4294967296 + s[4] as uint64 * 16777216 + s[5] as uint64 * 65536 + s[6] as uint64 * 256 + s[7] as uint64) / 72057594037927936) as uint8; assert b0 == s[0]; ghost var x0: uint64 := s[0] as uint64 * 72057594037927936 + s[1] as uint64 * 281474976710656 + s[2] as uint64 * 1099511627776 + s[3] as uint64 * 4294967296 + s[4] as uint64 * 16777216 + s[5] as uint64 * 65536 + s[6] as uint64 * 256 + s[7] as uint64 - b0 as uint64 * 72057594037927936; assert x0 == s[1] as uint64 * 281474976710656 + s[2] as uint64 * 1099511627776 + s[3] as uint64 * 4294967296 + s[4] as uint64 * 16777216 + s[5] as uint64 * 65536 + s[6] as uint64 * 256 + s[7] as uint64; ghost var b1: uint8 := (x0 / 281474976710656) as uint8; assert b1 == s[1]; ghost var x1: uint64 := x0 - b1 as uint64 * 281474976710656; assert x1 == s[2] as uint64 * 1099511627776 + s[3] as uint64 * 4294967296 + s[4] as uint64 * 16777216 + s[5] as uint64 * 65536 + s[6] as uint64 * 256 + s[7] as uint64; ghost var b2: uint8 := (x1 / 1099511627776) as uint8; assert b2 == s[2]; ghost var x2: uint64 := x1 - b2 as uint64 * 1099511627776; assert x2 == s[3] as uint64 * 4294967296 + s[4] as uint64 * 16777216 + s[5] as uint64 * 65536 + s[6] as uint64 * 256 + s[7] as uint64; ghost var b3: uint8 := (x2 / 4294967296) as uint8; assert b3 == s[3]; ghost var x3: uint64 := x2 - b3 as uint64 * 4294967296; assert x3 == s[4] as uint64 * 16777216 + s[5] as uint64 * 65536 + s[6] as uint64 * 256 + s[7] as uint64; ghost var b4: uint8 := (x3 / 16777216) as uint8; assert b4 == s[4]; ghost var x4: uint64 := x3 - b4 as uint64 * 16777216; assert x4 == s[5] as uint64 * 65536 + s[6] as uint64 * 256 + s[7] as uint64; ghost var b5: uint8 := (x4 / 65536) as uint8; assert b5 == s[5]; ghost var x5: uint64 := x4 - b5 as uint64 * 65536; assert x5 == s[6] as uint64 * 256 + s[7] as uint64; ghost var b6: uint8 := (x5 / 256) as uint8; assert b6 == s[6]; ghost var b7: uint8 := (x5 % 256) as uint8; assert b7 == s[7]; [b0, b1, b2, b3, b4, b5, b6, b7];
      ==
        [s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7]];
      ==
        s;
      }
    }

    lemma UInt64SeqSerializeDeserialize(x: uint64)
      ensures SeqToUInt64(UInt64ToSeq(x)) == x
      decreases x
    {
    }

    lemma UInt64SeqDeserializeSerialize(s: seq<uint8>)
      requires |s| == 8
      ensures UInt64ToSeq(SeqToUInt64(s)) == s
      decreases s
    {
    }

    function SeqToNat(s: seq<uint8>): nat
      decreases s
    {
      if s == [] then
        0
      else
        ghost var finalIndex: int := |s| - 1; SeqToNat(s[..finalIndex]) * 256 + s[finalIndex] as nat
    }

    lemma /*{:_induction s}*/ SeqToNatZeroPrefix(s: seq<uint8>)
      ensures SeqToNat(s) == SeqToNat([0] + s)
      decreases s
    {
      if s == [] {
      } else {
        ghost var s' := [0] + s;
        ghost var sLength := |s|;
        ghost var sFinalIndex := sLength - 1;
        calc {
          SeqToNat(s);
        ==
          SeqToNat(s[..sFinalIndex]) * 256 + s[sFinalIndex] as nat;
        ==
          SeqToNat([0] + s[..sFinalIndex]) * 256 + s[sFinalIndex] as nat;
        ==
          {
            assert s'[..sLength] == [0] + s[..sFinalIndex] && s'[sLength] == s[sFinalIndex];
          }
          SeqToNat(s'[..sLength]) * 256 + s'[sLength] as nat;
        ==
          SeqToNat(s');
        ==
          SeqToNat([0] + s);
        }
      }
    }

    lemma /*{:_induction s}*/ SeqWithUInt32Suffix(s: seq<uint8>, n: nat)
      requires n < UINT32_LIMIT
      requires 4 <= |s|
      requires ghost var suffixStartIndex: int := |s| - 4; s[suffixStartIndex..] == UInt32ToSeq(n as uint32) && forall i: int :: 0 <= i < suffixStartIndex ==> s[i] == 0
      ensures SeqToNat(s) == n
      decreases s, n
    {
      if |s| == 4 {
        calc {
          SeqToNat(s);
        ==
          SeqToNat(s[..3]) * 256 + s[3] as nat;
        ==
          {
            assert s[..3][..2] == s[..2] && s[..3][2] == s[2];
          }
          (SeqToNat(s[..2]) * 256 + s[2] as nat) * 256 + s[3] as nat;
        ==
          {
            assert s[..2][..1] == s[..1] && s[..2][1] == s[1];
          }
          ((SeqToNat(s[..1]) * 256 + s[1] as nat) * 256 + s[2] as nat) * 256 + s[3] as nat;
        ==
          {
            assert s[..1][..0] == s[..0] && s[..1][0] == s[0];
          }
          (((SeqToNat(s[..0]) * 256 + s[0] as nat) * 256 + s[1] as nat) * 256 + s[2] as nat) * 256 + s[3] as nat;
        ==
          n;
        }
      } else {
        assert s == [0] + s[1..];
        SeqToNatZeroPrefix(s[1..]);
        SeqWithUInt32Suffix(s[1..], n);
      }
    }
  }
}

module {:extern ""Sets""} Sets {

  import opened StandardLibrary = StandardLibrary
  method {:extern ""SetToOrderedSequence""} ComputeSetToOrderedSequence<T(==)>(s: set<seq<T>>, less: (T, T) -> bool) returns (res: seq<seq<T>>)
    requires Trichotomous(less) && Transitive(less)
    ensures res == SetToOrderedSequence(s, less)
    decreases s
}

module Sorting {

  export
    reveals Reflexive, AntiSymmetric, Connected, TotalOrdering, LexicographicByteSeqBelow, LexicographicByteSeqBelowAux
    provides AboutLexicographicByteSeqBelow, SelectionSort, StandardLibrary, UInt


  import StandardLibrary = StandardLibrary

  import opened UInt = StandardLibrary.UInt
  predicate Reflexive<T(!new)>(R: (T, T) -> bool)
  {
    forall x: T :: 
      R(x, x)
  }

  predicate AntiSymmetric<T(!new)>(R: (T, T) -> bool)
  {
    forall x: T, y: T :: 
      R(x, y) &&
      R(y, x) ==>
        x == y
  }

  predicate Connected<T(!new)>(R: (T, T) -> bool)
  {
    forall x: T, y: T :: 
      R(x, y) || R(y, x)
  }

  predicate TotalOrdering<T(!new)>(R: (T, T) -> bool)
  {
    Reflexive(R) &&
    AntiSymmetric(R) &&
    StandardLibrary.Transitive(R) &&
    Connected(R)
  }

  predicate method LexicographicByteSeqBelow(x: seq<uint8>, y: seq<uint8>)
    decreases x, y
  {
    LexicographicByteSeqBelowAux(x, y, 0)
  }

  predicate method LexicographicByteSeqBelowAux(x: seq<uint8>, y: seq<uint8>, n: nat)
    requires n <= |x| && n <= |y|
    decreases |x| - n
  {
    n == |x| || (n != |y| && x[n] < y[n]) || (n != |y| && x[n] == y[n] && LexicographicByteSeqBelowAux(x, y, n + 1))
  }

  lemma AboutLexicographicByteSeqBelow()
    ensures TotalOrdering(LexicographicByteSeqBelow)
  {
    assert Reflexive(LexicographicByteSeqBelow) by {
      forall x: seq<uint8>, n: int | 0 <= n <= |x| {
        AboutLexicographicByteSeqBelowAux_Reflexive(x, n);
      }
    }
    assert AntiSymmetric(LexicographicByteSeqBelow) by {
      forall x: seq<uint8>, y: seq<uint8>, n: nat | n <= |x| && n <= |y| && x[..n] == y[..n] && LexicographicByteSeqBelowAux(x, y, n) && LexicographicByteSeqBelowAux(y, x, n) {
        AboutLexicographicByteSeqBelowAux_AntiSymmetric(x, y, n);
      }
    }
    assert StandardLibrary.Transitive(LexicographicByteSeqBelow) by {
      forall x: seq<uint8>, y: seq<uint8>, z: seq<uint8>, n: nat | n <= |x| && n <= |y| && n <= |z| && LexicographicByteSeqBelowAux(x, y, n) && LexicographicByteSeqBelowAux(y, z, n) {
        AboutLexicographicByteSeqBelowAux_Transitive(x, y, z, n);
      }
    }
    assert Connected(LexicographicByteSeqBelow) by {
      forall x: seq<uint8>, y: seq<uint8>, n: nat | n <= |x| && n <= |y| {
        AboutLexicographicByteSeqBelowAux_Connected(x, y, n);
      }
    }
  }

  lemma /*{:_induction x, n}*/ AboutLexicographicByteSeqBelowAux_Reflexive(x: seq<uint8>, n: nat)
    requires n <= |x|
    ensures LexicographicByteSeqBelowAux(x, x, n)
    decreases |x| - n
  {
  }

  lemma /*{:_induction x, y, n}*/ AboutLexicographicByteSeqBelowAux_AntiSymmetric(x: seq<uint8>, y: seq<uint8>, n: nat)
    requires n <= |x| && n <= |y|
    requires x[..n] == y[..n]
    requires LexicographicByteSeqBelowAux(x, y, n) && LexicographicByteSeqBelowAux(y, x, n)
    ensures x == y
    decreases |x| - n
  {
  }

  lemma /*{:_induction x, y, z, n}*/ AboutLexicographicByteSeqBelowAux_Transitive(x: seq<uint8>, y: seq<uint8>, z: seq<uint8>, n: nat)
    requires n <= |x| && n <= |y| && n <= |z|
    requires LexicographicByteSeqBelowAux(x, y, n) && LexicographicByteSeqBelowAux(y, z, n)
    ensures LexicographicByteSeqBelowAux(x, z, n)
    decreases |x| - n
  {
  }

  lemma /*{:_induction x, y, n}*/ AboutLexicographicByteSeqBelowAux_Connected(x: seq<uint8>, y: seq<uint8>, n: nat)
    requires n <= |x| && n <= |y|
    ensures LexicographicByteSeqBelowAux(x, y, n) || LexicographicByteSeqBelowAux(y, x, n)
    decreases |x| - n
  {
  }

  method SelectionSort<Data>(a: array<Data>, below: (Data, Data) -> bool)
    requires StandardLibrary.Transitive(below)
    requires Connected(below)
    modifies a
    ensures multiset(a[..]) == old(multiset(a[..]))
    ensures forall i: int, j: int :: 0 <= i < j < a.Length ==> below(a[i], a[j])
    decreases a
  {
    var m := 0;
    while m < a.Length
      invariant 0 <= m <= a.Length
      invariant multiset(a[..]) == old(multiset(a[..]))
      invariant forall i: int, j: int :: 0 <= i < j < m ==> below(a[i], a[j])
      invariant forall i: int, j: int :: 0 <= i < m <= j < a.Length ==> below(a[i], a[j])
      decreases a.Length - m
    {
      var mindex, n := m, m + 1;
      while n < a.Length
        invariant m <= mindex < n <= a.Length
        invariant forall i: int :: m <= i < n ==> below(a[mindex], a[i])
        decreases a.Length - n
      {
        if !below(a[mindex], a[n]) {
          mindex := n;
        }
        n := n + 1;
      }
      a[m], a[mindex] := a[mindex], a[m];
      m := m + 1;
    }
  }
}

module Streams {

  import opened Wrappers = Wrappers

  import opened UInt = StandardLibrary.UInt
  class SeqReader<T> {
    ghost var Repr: set<object>
    const data: seq<T>
    var pos: nat

    predicate Valid()
      reads this, Repr
      ensures Valid() ==> this in Repr
      decreases Repr + {this}
    {
      this in Repr &&
      pos <= |data|
    }

    constructor (s: seq<T>)
      ensures pos == 0
      ensures data[..] == s
      ensures Valid() && fresh(Repr)
      decreases s
    {
      data := s;
      pos := 0;
      Repr := {this};
    }

    method ReadElements(n: nat) returns (elems: seq<T>)
      requires Valid()
      requires n + pos <= |data|
      modifies `pos
      ensures n == 0 ==> elems == []
      ensures n > 0 ==> elems == data[old(pos)..][..n]
      ensures pos == old(pos) + n
      ensures data == old(data)
      ensures Valid()
      decreases n
    {
      elems := data[pos..][..n];
      pos := pos + n;
      return elems;
    }

    method ReadExact(n: nat) returns (res: Result<seq<T>, string>)
      requires Valid()
      modifies `pos
      ensures n + old(pos) <= |data| <==> res.Success?
      ensures res.Success? ==> |res.value| == n
      ensures res.Success? ==> pos == old(pos) + n
      ensures res.Success? ==> res.value == data[old(pos) .. old(pos) + n]
      ensures res.Failure? ==> n > |data| - pos
      ensures res.Failure? ==> pos == old(pos)
      ensures data == old(data)
      ensures Valid()
      decreases n
    {
      if n > |data| - pos {
        return Failure(""IO Error: Not enough elements left on stream."");
      } else {
        var elements := ReadElements(n);
        return Success(elements);
      }
    }
  }

  class ByteReader {
    ghost var Repr: set<object>
    const reader: SeqReader<uint8>

    predicate Valid()
      reads this, Repr
      ensures Valid() ==> this in Repr
      decreases Repr + {this}
    {
      this in Repr &&
      reader in Repr &&
      reader.Repr <= Repr &&
      this !in reader.Repr &&
      reader.Valid()
    }

    constructor (s: seq<uint8>)
      ensures reader.data == s
      ensures reader.pos == 0
      ensures Valid() && fresh(Repr)
      decreases s
    {
      var mr := new SeqReader<uint8>(s);
      reader := mr;
      Repr := {this} + mr.Repr;
    }

    method ReadByte() returns (res: Result<uint8, string>)
      requires Valid()
      modifies reader`pos
      ensures res.Failure? ==> |reader.data| - reader.pos < 1
      ensures res.Failure? ==> unchanged(reader)
      ensures res.Success? ==> reader.pos == old(reader.pos) + 1
      ensures old(reader.pos) + 1 <= |old(reader.data)| <==> res.Success?
      ensures res.Success? ==> res.value == reader.data[old(reader.pos)]
      ensures reader.data == old(reader.data)
      ensures Valid()
    {
      var bytes :- reader.ReadExact(1);
      assert |bytes| == 1;
      return Success(bytes[0]);
    }

    method ReadBytes(n: nat) returns (res: Result<seq<uint8>, string>)
      requires Valid()
      modifies reader`pos
      ensures res.Failure? ==> |reader.data| - reader.pos < n
      ensures res.Failure? ==> unchanged(reader)
      ensures res.Success? ==> |res.value| == n
      ensures res.Success? && |res.value| == 0 ==> unchanged(reader)
      ensures res.Success? ==> reader.pos == old(reader.pos) + n
      ensures old(reader.pos) + n <= |old(reader.data)| <==> res.Success?
      ensures res.Success? ==> res.value == reader.data[old(reader.pos) .. old(reader.pos) + n]
      ensures reader.data == old(reader.data)
      ensures Valid()
      decreases n
    {
      var bytes :- reader.ReadExact(n);
      assert |bytes| == n;
      return Success(bytes);
    }

    method ReadUInt16() returns (res: Result<uint16, string>)
      requires Valid()
      modifies reader`pos
      ensures res.Failure? ==> |reader.data| - reader.pos < 2
      ensures res.Failure? ==> unchanged(reader)
      ensures res.Success? ==> reader.pos == old(reader.pos) + 2
      ensures old(reader.pos) + 2 <= |old(reader.data)| <==> res.Success?
      ensures res.Success? ==> res.value == SeqToUInt16(reader.data[old(reader.pos) .. old(reader.pos) + 2])
      ensures reader.data == old(reader.data)
      ensures Valid()
    {
      var bytes :- reader.ReadExact(2);
      assert |bytes| == 2;
      var n := SeqToUInt16(bytes);
      return Success(n);
    }

    method ReadUInt32() returns (res: Result<uint32, string>)
      requires Valid()
      modifies reader`pos
      ensures res.Failure? ==> unchanged(reader)
      ensures res.Success? ==> reader.pos == old(reader.pos) + 4
      ensures old(reader.pos) + 4 <= |old(reader.data)| <==> res.Success?
      ensures res.Success? ==> res.value == SeqToUInt32(reader.data[old(reader.pos) .. old(reader.pos) + 4])
      ensures reader.data == old(reader.data)
      ensures Valid()
    {
      var bytes :- reader.ReadExact(4);
      assert |bytes| == 4;
      var n := SeqToUInt32(bytes);
      return Success(n);
    }

    method ReadUInt64() returns (res: Result<uint64, string>)
      requires Valid()
      modifies reader`pos
      ensures res.Failure? ==> |reader.data| - reader.pos < 8
      ensures res.Failure? ==> unchanged(reader)
      ensures res.Success? ==> reader.pos == old(reader.pos) + 8
      ensures old(reader.pos) + 8 <= |old(reader.data)| <==> res.Success?
      ensures res.Success? ==> res.value == SeqToUInt64(reader.data[old(reader.pos) .. old(reader.pos) + 8])
      ensures reader.data == old(reader.data)
      ensures Valid()
    {
      var bytes :- reader.ReadExact(8);
      assert |bytes| == 8;
      var n := SeqToUInt64(bytes);
      return Success(n);
    }

    method IsDoneReading() returns (b: bool)
      requires Valid()
      ensures (b && |reader.data| - reader.pos == 0) || (!b && |reader.data| - reader.pos > 0)
      ensures Valid()
    {
      return |reader.data| == reader.pos;
    }

    method GetSizeRead() returns (n: nat)
      requires Valid()
      ensures n == reader.pos
      ensures Valid()
    {
      return reader.pos;
    }
  }

  class SeqWriter<T> {
    ghost var Repr: set<object>
    var data: seq<T>

    predicate Valid()
      reads this, Repr
      ensures Valid() ==> this in Repr
      decreases Repr + {this}
    {
      this in Repr
    }

    constructor ()
      ensures data == []
      ensures Valid() && fresh(Repr)
    {
      data := [];
      Repr := {this};
    }

    method WriteElements(elems: seq<T>) returns (n: nat)
      requires Valid()
      modifies `data
      ensures n == |data| - |old(data)| == |elems|
      ensures |elems| == 0 ==> data == old(data)
      ensures |elems| > 0 ==> data == old(data) + elems
      ensures elems == data[|data| - |elems|..]
      ensures Valid()
      decreases elems
    {
      data := data + elems;
      return |elems|;
    }
  }

  class ByteWriter {
    ghost var Repr: set<object>
    const writer: SeqWriter<uint8>

    predicate Valid()
      reads this, Repr
      ensures Valid() ==> this in Repr
      decreases Repr + {this}
    {
      this in Repr &&
      writer in Repr &&
      writer.Repr <= Repr &&
      this !in writer.Repr &&
      writer.Valid()
    }

    constructor ()
      ensures writer.data == []
      ensures Valid() && fresh(Repr)
    {
      var mw := new SeqWriter<uint8>();
      writer := mw;
      Repr := {this} + mw.Repr;
    }

    method WriteByte(n: uint8) returns (r: nat)
      requires Valid()
      modifies writer`data
      ensures !unchanged(writer`data)
      ensures writer.data == old(writer.data) + [n]
      ensures r == 1
      ensures Valid()
      decreases n
    {
      r := writer.WriteElements([n]);
    }

    method WriteBytes(s: seq<uint8>) returns (r: nat)
      requires Valid()
      modifies writer`data
      ensures |s| == 0 ==> unchanged(writer)
      ensures |s| > 0 ==> !unchanged(writer`data)
      ensures writer.data == old(writer.data) + s
      ensures r == |s|
      ensures Valid()
      decreases s
    {
      r := writer.WriteElements(s);
    }

    method WriteUInt16(n: uint16) returns (r: nat)
      requires Valid()
      modifies writer`data
      ensures !unchanged(writer`data)
      ensures writer.data == old(writer.data) + UInt16ToSeq(n)
      ensures r == 2
      ensures Valid()
      decreases n
    {
      r := writer.WriteElements(UInt16ToSeq(n));
    }

    method WriteUInt32(n: uint32) returns (r: nat)
      requires Valid()
      modifies writer`data
      ensures !unchanged(writer`data)
      ensures writer.data == old(writer.data) + UInt32ToSeq(n)
      ensures r == 4
      ensures Valid()
      decreases n
    {
      r := writer.WriteElements(UInt32ToSeq(n));
    }

    function method GetDataWritten(): (s: seq<uint8>)
      requires Valid()
      reads Repr
      ensures s == writer.data
      ensures Valid()
      decreases Repr
    {
      writer.data
    }

    function method GetSizeWritten(): (n: nat)
      requires Valid()
      reads Repr
      ensures n == |writer.data|
      ensures Valid()
      decreases Repr
    {
      |writer.data|
    }
  }
}

module Time {

  import opened StandardLibrary = StandardLibrary

  import opened UInt = StandardLibrary.UInt
  method {:extern ""TimeUtil.Time"", ""CurrentRelativeTime""} GetCurrent() returns (seconds: uint64)
}

module {:extern ""UTF8""} UTF8 {

  import opened Wrappers = Wrappers

  import opened UInt = StandardLibrary.UInt
  type ValidUTF8Bytes = i: seq<uint8>
    | ValidUTF8Seq(i)
    witness []

  method {:extern ""Encode""} Encode(s: string) returns (res: Result<ValidUTF8Bytes, string>)
    ensures IsASCIIString(s) ==> res.Success? && |res.value| == |s|
    decreases s

  method {:extern ""Decode""} Decode(b: ValidUTF8Bytes) returns (res: Result<string, string>)
    decreases b

  predicate method IsASCIIString(s: string)
    decreases s
  {
    forall i: int :: 
      0 <= i < |s| ==>
        s[i] as int < 128
  }

  predicate method Uses1Byte(s: seq<uint8>)
    requires |s| >= 1
    decreases s
  {
    0 <= s[0] <= 127
  }

  predicate method Uses2Bytes(s: seq<uint8>)
    requires |s| >= 2
    decreases s
  {
    194 <= s[0] <= 223 &&
    128 <= s[1] <= 191
  }

  predicate method Uses3Bytes(s: seq<uint8>)
    requires |s| >= 3
    decreases s
  {
    (s[0] == 224 && 160 <= s[1] <= 191 && 128 <= s[2] <= 191) || (225 <= s[0] <= 236 && 128 <= s[1] <= 191 && 128 <= s[2] <= 191) || (s[0] == 237 && 128 <= s[1] <= 159 && 128 <= s[2] <= 191) || (238 <= s[0] <= 239 && 128 <= s[1] <= 191 && 128 <= s[2] <= 191)
  }

  predicate method Uses4Bytes(s: seq<uint8>)
    requires |s| >= 4
    decreases s
  {
    (s[0] == 240 && 144 <= s[1] <= 191 && 128 <= s[2] <= 191 && 128 <= s[3] <= 191) || (241 <= s[0] <= 243 && 128 <= s[1] <= 191 && 128 <= s[2] <= 191 && 128 <= s[3] <= 191) || (s[0] == 244 && 128 <= s[1] <= 143 && 128 <= s[2] <= 191 && 128 <= s[3] <= 191)
  }

  predicate method ValidUTF8Range(a: seq<uint8>, lo: nat, hi: nat)
    requires lo <= hi <= |a|
    decreases hi - lo
  {
    if lo == hi then
      true
    else
      var r: seq<uint8> := a[lo .. hi]; if Uses1Byte(r) then ValidUTF8Range(a, lo + 1, hi) else if 2 <= |r| && Uses2Bytes(r) then ValidUTF8Range(a, lo + 2, hi) else if 3 <= |r| && Uses3Bytes(r) then ValidUTF8Range(a, lo + 3, hi) else 4 <= |r| && Uses4Bytes(r) && ValidUTF8Range(a, lo + 4, hi)
  }

  lemma /*{:_induction a, b, c, lo, hi}*/ ValidUTF8Embed(a: seq<uint8>, b: seq<uint8>, c: seq<uint8>, lo: nat, hi: nat)
    requires lo <= hi <= |b|
    ensures ValidUTF8Range(b, lo, hi) == ValidUTF8Range(a + b + c, |a| + lo, |a| + hi)
    decreases hi - lo
  {
    if lo == hi {
    } else {
      ghost var r := b[lo .. hi];
      ghost var r' := (a + b + c)[|a| + lo .. |a| + hi];
      assert r == r';
      if Uses1Byte(r) {
        ValidUTF8Embed(a, b, c, lo + 1, hi);
      } else if 2 <= |r| && Uses2Bytes(r) {
        ValidUTF8Embed(a, b, c, lo + 2, hi);
      } else if 3 <= |r| && Uses3Bytes(r) {
        ValidUTF8Embed(a, b, c, lo + 3, hi);
      } else if 4 <= |r| && Uses4Bytes(r) {
        ValidUTF8Embed(a, b, c, lo + 4, hi);
      }
    }
  }

  predicate method ValidUTF8Seq(s: seq<uint8>)
    decreases s
  {
    ValidUTF8Range(s, 0, |s|)
  }

  lemma ValidUTF8Concat(s: seq<uint8>, t: seq<uint8>)
    requires ValidUTF8Seq(s) && ValidUTF8Seq(t)
    ensures ValidUTF8Seq(s + t)
    decreases s, t
  {
    ghost var lo := 0;
    while lo < |s|
      invariant lo <= |s|
      invariant ValidUTF8Range(s, lo, |s|)
      invariant ValidUTF8Range(s + t, 0, |s + t|) == ValidUTF8Range(s + t, lo, |s + t|)
      decreases |s| - lo
    {
      ghost var r := (s + t)[lo..];
      if Uses1Byte(r) {
        lo := lo + 1;
      } else if 2 <= |r| && Uses2Bytes(r) {
        lo := lo + 2;
      } else if 3 <= |r| && Uses3Bytes(r) {
        lo := lo + 3;
      } else if 4 <= |r| && Uses4Bytes(r) {
        lo := lo + 4;
      } else {
        assert false;
      }
    }
    calc {
      ValidUTF8Seq(s + t);
    ==
      ValidUTF8Range(s + t, 0, |s + t|);
    ==
      ValidUTF8Range(s + t, lo, |s + t|);
    ==
      {
        assert s + t == s + t + [] && lo == |s| && |s + t| == |s| + |t|;
      }
      ValidUTF8Range(s + t + [], |s|, |s| + |t|);
    ==
      {
        ValidUTF8Embed(s, t, [], 0, |t|);
      }
      ValidUTF8Range(t, 0, |t|);
    ==
      ValidUTF8Seq(t);
    ==
      true;
    }
  }
}

module TestDigest {

  import CryptoDatatypes = CryptoDatatypes

  import Digest = Digest

  module Helpers {

    import CryptoDatatypes = CryptoDatatypes

    import Digest = Digest

    import opened StandardLibrary = StandardLibrary

    import opened UInt = StandardLibrary.UInt
    method ToInt(bytes: seq<uint8>) returns (n: nat)
      decreases bytes
    {
      n := 0;
      var i := 0;
      while i < |bytes|
        decreases |bytes| - i
      {
        n := 256 * n + bytes[i] as int;
        i := i + 1;
      }
    }

    method TestDigest(s: string, alg: CryptoDatatypes.DigestAlgorithm, expected: nat)
      decreases s, alg, expected
    {
      expect forall i: int :: 0 <= i < |s| ==> 'a' <= s[i] <= 'z', ""expectation violation""
      var msg := seq(|s|, (i: int) requires 0 <= i < |s| && 'a' <= s[i] <= 'z' => s[i] as uint8);
      var digest :- Digest.Digest(alg, msg);
      expect |digest| == Digest.Length(alg), ""expectation violation""
      var actual := ToInt(digest);
      expect actual == expected, ""expectation violation""
    }
  }
  method {:test} DigestTestVectors()
  {
    var s := ""abc"";
    Helpers.TestDigest(s, CryptoDatatypes.SHA_512, 11610554759577678887058616627522426787358414133166247019097754655123425531747192578669846860198531688061507751898313498051436198428987376028989280584770719);
    s := """";
    Helpers.TestDigest(s, CryptoDatatypes.SHA_512, 10868450558671247443152026947160338505683745266658651051718065983487878962987857602829315249215796444208488632888003673539585986066311769564391053988452926);
    s := ""abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu"";
    Helpers.TestDigest(s, CryptoDatatypes.SHA_512, 7467751150072304710748607053756525574443640673541183129594735496433453152253989885323496399866777464427478124519714519652484878749913622135027995536779529);
  }
}

module TestSignature {

  import Signature = Signature

  module Helpers {

    import Signature = Signature

    import UTF8 = UTF8

    import opened Wrappers = Wrappers

    import opened UInt = StandardLibrary.UInt
    method RequireGoodKeyLengths(s: Signature.ECDSAParams, sigKeyPair: Signature.SignatureKeyPair)
      decreases s, sigKeyPair
    {
      expect |sigKeyPair.verificationKey| == s.FieldSize(), ""expectation violation""
    }

    method YCompression(s: Signature.ECDSAParams, fieldSize: nat)
      decreases s, fieldSize
    {
      var res :- Signature.KeyGen(s);
      RequireGoodKeyLengths(s, res);
      var public, secret := res.verificationKey, res.signingKey;
      expect 0 < |secret|, ""expectation violation""
      expect |public| == 1 + (fieldSize + 7) / 8, ""expectation violation""
      expect public[0] == 2 || public[0] == 3, ""expectation violation""
    }

    method VerifyMessage(params: Signature.ECDSAParams)
      decreases params
    {
      var message :- UTF8.Encode(""Hello, World!"");
      var keys :- Signature.KeyGen(params);
      RequireGoodKeyLengths(params, keys);
      var signature :- Signature.Sign(params, keys.signingKey, message);
      var shouldBeTrue :- Signature.Verify(params, keys.verificationKey, message, signature);
      expect shouldBeTrue, ""expectation violation""
      var shouldBeFalse :- Signature.Verify(params, keys.verificationKey, message + [1], signature);
      expect !shouldBeFalse, ""expectation violation""
    }
  }
  method {:test} YCompression384()
  {
    Helpers.YCompression(Signature.ECDSA_P384, 384);
  }

  method {:test} YCompression256()
  {
    Helpers.YCompression(Signature.ECDSA_P256, 256);
  }

  method {:test} VerifyMessage384()
  {
    Helpers.VerifyMessage(Signature.ECDSA_P384);
  }

  method {:test} VerifyMessage256()
  {
    Helpers.VerifyMessage(Signature.ECDSA_P256);
  }
}

module {:extern ""TestHKDF""} TestHKDF {

  import opened Wrappers = Wrappers

  import opened HKDF = HKDF

  import opened KeyDerivationAlgorithms = KeyDerivationAlgorithms
  method {:test} Test0()
  {
    var tv_ikm := new [] [11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11];
    var tv_salt := new [] [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];
    var tv_info := new [] [240, 241, 242, 243, 244, 245, 246, 247, 248, 249];
    var tv_okm_desired := new [] [60, 178, 95, 37, 250, 172, 213, 122, 144, 67, 79, 100, 208, 54, 47, 42, 45, 45, 10, 144, 207, 26, 90, 76, 93, 176, 45, 86, 236, 196, 197, 191, 52, 0, 114, 8, 213, 184, 135, 24, 88, 101];
    var okm := Hkdf(HKDF_WITH_SHA_256, Some(tv_salt[..]), tv_ikm[..], tv_info[..], 42);
    expect tv_okm_desired[..] == okm, ""expectation violation""
  }

  method {:test} Test1()
  {
    var tv_ikm := new [] [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79];
    var tv_salt := new [] [96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 130, 86, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175];
    var tv_info := new [] [176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255];
    var tv_okm_desired := new [] [86, 160, 84, 52, 29, 13, 71, 250, 11, 73, 208, 29, 1, 53, 45, 194, 17, 12, 253, 117, 16, 251, 6, 124, 155, 90, 233, 105, 148, 86, 41, 99, 67, 199, 253, 213, 169, 254, 226, 104, 215, 158, 234, 250, 134, 60, 241, 23, 88, 218, 24, 176, 71, 136, 160, 210, 197, 159, 59, 3, 66, 163, 130, 46, 215, 166, 223, 241, 108, 59, 97, 59, 88, 158, 207, 15, 113, 11, 223, 43, 21, 57];
    var okm := Hkdf(HKDF_WITH_SHA_256, Some(tv_salt[..]), tv_ikm[..], tv_info[..], 82);
    expect tv_okm_desired[..] == okm, ""expectation violation""
  }

  method {:test} Test2()
  {
    var tv_salt := None;
    var tv_ikm := new [] [11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11];
    var tv_info := [];
    var tv_okm_desired := new [] [141, 164, 231, 117, 165, 99, 193, 143, 113, 95, 128, 42, 6, 60, 90, 49, 184, 161, 31, 92, 94, 225, 135, 158, 195, 69, 78, 95, 60, 115, 141, 45, 157, 32, 19, 149, 250, 164, 182, 26, 150, 200];
    var okm := Hkdf(HKDF_WITH_SHA_256, tv_salt, tv_ikm[..], tv_info[..], 42);
    expect tv_okm_desired[..] == okm, ""expectation violation""
  }

  method {:test} Test3()
  {
    var tv_salt := new [] [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];
    var tv_ikm := new [] [11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11];
    var tv_info := new [] [240, 241, 242, 243, 244, 245, 246, 247, 248, 249];
    var tv_okm_desired := new [] [155, 80, 151, 168, 96, 56, 184, 5, 48, 144, 118, 164, 75, 58, 159, 56, 6, 62, 37, 181, 22, 220, 191, 54, 159, 57, 76, 250, 180, 54, 133, 247, 72, 182, 69, 119, 99, 228, 240, 32, 79, 197];
    var okm := Hkdf(HKDF_WITH_SHA_384, Some(tv_salt[..]), tv_ikm[..], tv_info[..], 42);
    expect tv_okm_desired[..] == okm, ""expectation violation""
  }

  method {:test} Test4()
  {
    var tv_salt := new [] [96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175];
    var tv_ikm := new [] [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79];
    var tv_info := new [] [176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255];
    var tv_okm_desired := new [] [72, 76, 160, 82, 184, 204, 114, 79, 209, 196, 236, 100, 213, 123, 78, 129, 140, 126, 37, 168, 224, 244, 86, 158, 215, 42, 106, 5, 254, 6, 73, 238, 191, 105, 248, 213, 200, 50, 133, 107, 244, 228, 251, 193, 121, 103, 213, 73, 117, 50, 74, 148, 152, 127, 127, 65, 131, 88, 23, 216, 153, 79, 219, 214, 244, 192, 156, 85, 0, 220, 162, 74, 86, 34, 47, 234, 83, 216, 150, 122, 139, 46];
    var okm := Hkdf(HKDF_WITH_SHA_384, Some(tv_salt[..]), tv_ikm[..], tv_info[..], 82);
    expect tv_okm_desired[..] == okm, ""expectation violation""
  }

  method {:test} Test5()
  {
    var tv_salt := None;
    var tv_ikm := new [] [11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11];
    var tv_info := [];
    var tv_okm_desired := new [] [200, 201, 110, 113, 15, 137, 176, 215, 153, 11, 202, 104, 188, 222, 200, 207, 133, 64, 98, 229, 76, 115, 167, 171, 199, 67, 250, 222, 155, 36, 45, 170, 204, 28, 234, 86, 112, 65, 91, 82, 132, 156];
    var okm := Hkdf(HKDF_WITH_SHA_384, tv_salt, tv_ikm[..], tv_info[..], 42);
    expect tv_okm_desired[..] == okm, ""expectation violation""
  }

  method {:test} Test7()
  {
    var tv_ikm := new [] [11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11];
    var tv_salt := new [] [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];
    var tv_info := new [] [240, 241, 242, 243, 244, 245, 246, 247, 248, 249];
    var tv_okm_desired := new [] [60, 178, 95, 37, 250, 172, 213, 122, 144, 67, 79, 100, 208, 54, 47, 42, 45, 45, 10, 144, 207, 26, 90, 76, 93, 176, 45, 86, 236, 196, 197, 191, 52, 0, 114, 8, 213, 184, 135, 24, 88, 101, 180, 176, 168, 90, 153, 59, 137, 185, 182, 86, 131, 214, 15, 1, 6, 210, 143, 255, 3, 157, 11, 111, 52, 8, 144, 12, 15, 42, 157, 68, 99, 222, 131, 98, 32, 86, 190, 80, 168, 129, 190, 191, 43, 152, 58, 180, 62, 6, 153, 18, 240, 165, 117, 130, 252, 177, 140, 167, 167, 254, 64, 163, 60, 118, 108, 130, 152, 18, 175, 50, 124, 50, 225, 38, 88, 157, 60, 100, 244, 25, 221, 255, 249, 216, 199, 135, 246, 149, 207, 234, 118, 150, 129, 103, 37, 227, 146, 198, 59, 83, 126, 102, 90, 107, 21, 225, 228, 90, 45, 248, 14, 98, 84, 167, 163, 237, 200, 67, 222, 25, 229, 176, 216, 151, 232, 4, 130, 158, 243, 237, 237, 162, 11, 188, 218, 124, 241, 49, 98, 22, 42, 29, 168, 134, 149, 243, 227, 161, 181, 245, 36, 229, 187, 152, 95, 115, 198, 109, 102, 223, 146, 112, 87, 79, 144, 183, 52, 142, 201, 101, 253, 81, 69, 117, 40, 253, 114, 172, 71, 88, 190, 87, 60, 109, 141, 2, 148, 225, 123, 201, 242, 103, 191, 159, 28, 170, 141, 56, 72, 103, 124, 185, 176, 250, 237, 138, 81, 242, 65, 80, 253, 200, 96, 58, 250, 130, 232, 213, 213, 130, 74, 113, 110, 63, 185, 91, 10, 204, 233, 167, 86, 6, 208, 111, 227, 88, 137, 239, 170, 109, 78, 12, 75, 61, 210, 223, 222, 0, 237, 155, 18, 211, 225, 243, 64, 167, 174, 78, 73, 81, 189, 103, 255, 251, 45, 179, 147, 160, 62, 62, 249, 44, 144, 191, 223, 222, 179, 16, 183, 82, 187, 134, 56, 26, 217, 2, 30, 238, 21, 21, 94, 187, 62, 191, 84, 102, 68, 46, 103, 223, 180, 126, 241, 243, 184, 47, 89, 14, 194, 202, 153, 104, 194, 211, 90, 50, 95, 39, 183, 97, 114, 86, 3, 247, 64, 201, 205, 16, 150, 21, 136, 241, 136, 156, 210, 108, 166, 202, 172, 112, 51, 87, 249, 137, 188, 79, 91, 72, 59, 83, 142, 174, 82, 191, 136, 136, 220, 225, 196, 19, 181, 156, 36, 162, 139, 193, 252, 133, 57, 121, 219, 84, 221, 138, 192, 207, 174, 114, 157, 155, 211, 168, 233, 161, 192, 111, 7, 246, 241, 194, 185, 215, 122, 109, 15, 33, 43, 36, 164, 60, 200, 16, 153, 192, 192, 101, 143, 158, 36, 103, 167, 14, 70, 61, 158, 247, 108, 239, 14, 107, 242, 202, 227, 215, 132, 113, 84, 115, 219, 65, 39, 98, 209, 9, 135, 36, 133, 249, 155, 44, 144, 20, 97, 14, 214, 18, 230, 95, 15, 21, 99, 94, 0, 11, 62, 21, 61, 136, 0, 186, 9, 39, 49, 155, 149, 71, 61, 46, 223, 150, 199, 57, 58, 97, 162, 166, 183, 124, 217, 53, 28, 111, 128, 77, 137, 141, 232, 98, 251, 94, 155, 48, 31, 243, 99, 245, 161, 143, 142, 162, 234, 35, 31, 244, 132, 119, 49, 20, 215, 56, 202, 171, 183, 125, 230, 11, 56, 34, 188, 136, 185, 143, 49, 223, 164, 229, 203, 154, 177, 235, 9, 180, 209, 212, 250, 238, 99, 63, 187, 87, 77, 58, 178, 253, 184, 161, 161, 91, 1, 55, 115, 181, 3, 199, 250, 153, 157, 237, 115, 129, 140, 114, 180, 103, 51, 189, 163, 117, 157, 213, 184, 112, 209, 197, 219, 110, 115, 209, 18, 232, 84, 137, 206, 135, 107, 179, 163, 225, 20, 167, 204, 7, 249, 212, 154, 181, 227, 51, 32, 181, 170, 69, 137, 160, 191, 95, 116, 50, 2, 37, 144, 160, 38, 25, 206, 172, 238, 151, 85, 102, 121, 250, 211, 201, 252, 220, 201, 151, 68, 221, 11, 182, 130, 43, 191, 131, 124, 182, 138, 11, 227, 47, 66, 7, 189, 240, 151, 101, 22, 218, 70, 88, 39, 63, 115, 194, 93, 61, 66, 14, 126, 114, 142, 142, 164, 133, 22, 2, 128, 230, 81, 1, 228, 21, 18, 76, 249, 211, 133, 47, 158, 108, 34, 166, 218, 138, 91, 48, 251, 193, 222, 98, 90, 162, 82, 198, 180, 7, 135, 9, 102, 154, 20, 118, 246, 85, 1, 172, 216, 97, 255, 186, 108, 208, 195, 158, 6, 77, 233, 221, 203, 242, 82, 156, 176, 66, 129, 211, 34, 218, 220, 166, 181, 122, 101, 191, 169, 212, 62, 127, 126, 132, 111, 111, 226, 3, 147, 235, 216, 61, 152, 119, 255, 34, 116, 176, 247, 117, 49, 19, 33, 92, 245, 180, 74, 230, 170, 150, 31, 148, 25, 108, 77, 125, 68, 107, 25, 146, 49, 207, 109, 159, 163, 168, 29, 39, 220, 213, 59, 23, 1, 123, 249, 79, 187, 190, 180, 179, 53, 60, 142, 251, 103, 92, 57, 48, 110, 221, 143, 205, 126, 2, 192, 163, 210, 79, 121, 82, 175, 187, 63, 56, 6, 201, 42, 240, 26, 194, 163, 183, 133, 88, 38, 151, 246, 100, 194, 212, 222, 18, 7, 168, 1, 155, 73, 59, 155, 255, 10, 211, 102, 116, 200, 89, 247, 127, 230, 59, 202, 238, 243, 179, 135, 230, 245, 66, 8, 136, 200, 53, 3, 249, 103, 7, 212, 65, 95, 171, 118, 51, 81, 90, 231, 91, 189, 60, 55, 113, 119, 6, 159, 59, 142, 108, 227, 192, 208, 122, 251, 73, 199, 107, 194, 202, 17, 94, 84, 155, 20, 13, 223, 43, 163, 75, 193, 247, 4, 109, 171, 46, 170, 86, 1, 166, 211, 203, 22, 158, 33, 170, 161, 171, 69, 149, 149, 145, 154, 9, 38, 31, 132, 171, 211, 170, 105, 153, 209, 96, 135, 243, 54, 18, 145, 127, 73, 102, 230, 74, 53, 187, 227, 65, 149, 81, 31, 110, 43, 74, 73, 97, 22, 231, 119, 212, 154, 64, 247, 221, 255, 219, 208, 65, 79, 188, 120, 186, 8, 43, 82, 232, 103, 117, 11, 163, 137, 174, 172, 124, 188, 38, 104, 166, 171, 146, 129, 107, 212, 237, 11, 113, 190, 12, 66, 223, 234, 97, 98, 17, 32, 106, 6, 228, 86, 25, 164, 82, 82, 67, 151, 149, 65, 172, 26, 144, 69, 142, 214, 240, 84, 144, 163, 171, 234, 192, 90, 248, 20, 196, 139, 108, 68, 246, 126, 186, 88, 55, 138, 248, 10, 38, 73, 84, 230, 144, 169, 243, 106, 220, 201, 67, 147, 156, 252, 140, 111, 127, 185, 107, 9, 30, 254, 186, 199, 233, 202, 65, 19, 187, 103, 157, 118, 224, 147, 206, 221, 216, 129, 102, 199, 50, 156, 28, 196, 49, 89, 129, 160, 199, 97, 30, 93, 100, 230, 20, 129, 215, 66, 136, 58, 192, 17, 199, 168, 169, 154, 217, 63, 33, 65, 220, 43, 69, 10, 246, 162, 183, 182, 5, 82, 97, 123, 134, 208, 8, 115, 104, 109, 24, 217, 242, 129, 125, 18, 8, 116, 77, 45, 154, 245, 201, 77, 71, 181, 72, 79, 20, 77, 178, 134, 186, 159, 167, 237, 32, 50, 124, 205, 236, 112, 92, 244, 164, 239, 31, 109, 33, 223, 93, 22, 222, 166, 62, 30, 214, 132, 206, 151, 53, 178, 250, 208, 52, 66, 153, 248, 63, 2, 12, 178, 117, 241, 24, 113, 47, 34, 235, 149, 40, 66, 229, 127, 204, 29, 163, 90, 35, 151, 244, 28, 249, 70, 91, 74, 205, 46, 235, 100, 194, 188, 97, 51, 164, 241, 35, 176, 8, 91, 67, 204, 51, 133, 157, 28, 237, 234, 135, 140, 68, 248, 195, 168, 48, 152, 86, 41, 176, 53, 39, 199, 99, 122, 86, 70, 225, 87, 225, 139, 57, 93, 93, 161, 228, 186, 192, 84, 229, 185, 3, 73, 196, 133, 137, 215, 192, 41, 30, 84, 160, 75, 206, 4, 245, 53, 52, 32, 182, 141, 66, 50, 238, 90, 81, 50, 55, 132, 3, 238, 68, 207, 144, 15, 12, 127, 195, 85, 18, 67, 55, 4, 249, 232, 170, 189, 205, 197, 169, 128, 156, 103, 221, 172, 213, 46, 143, 218, 107, 253, 77, 76, 190, 63, 151, 44, 57, 37, 225, 135, 125, 21, 217, 0, 62, 83, 50, 51, 2, 176, 160, 161, 82, 112, 198, 128, 235, 40, 101, 151, 189, 86, 46, 206, 202, 90, 229, 188, 108, 235, 245, 52, 22, 48, 189, 88, 192, 95, 153, 109, 92, 74, 146, 135, 44, 130, 221, 91, 17, 46, 49, 24, 97, 221, 22, 174, 32, 12, 189, 52, 252, 204, 133, 19, 122, 242, 26, 106, 233, 218, 176, 88, 71, 169, 76, 77, 71, 32, 235, 0, 204, 37, 71, 18, 175, 99, 202, 141, 95, 73, 81, 102, 224, 83, 97, 121, 41, 56, 4, 168, 25, 161, 181, 109, 109, 32, 119, 50, 239, 157, 76, 87, 131, 49, 194, 143, 60, 252, 204, 151, 84, 138, 227, 161, 25, 224, 185, 11, 244, 243, 71, 100, 58, 187, 100, 10, 114, 9, 150, 49, 55, 88, 50, 236, 54, 134, 117, 225, 138, 112, 54, 231, 10, 172, 222, 40, 134, 247, 223, 22, 127, 174, 217, 89, 228, 121, 213, 171, 117, 38, 115, 184, 151, 65, 116, 80, 180, 6, 44, 68, 100, 103, 62, 45, 161, 105, 91, 205, 163, 170, 194, 69, 7, 110, 85, 9, 1, 75, 138, 93, 63, 223, 224, 35, 41, 87, 86, 162, 251, 222, 96, 116, 144, 226, 203, 220, 53, 58, 173, 189, 251, 66, 48, 70, 179, 124, 43, 199, 97, 140, 17, 72, 95, 156, 86, 49, 121, 101, 171, 191, 239, 131, 88, 82, 87, 5, 137, 132, 94, 50, 170, 154, 151, 92, 140, 85, 46, 61, 153, 222, 231, 189, 141, 109, 1, 214, 204, 195, 222, 189, 125, 161, 123, 134, 161, 81, 225, 165, 244, 58, 102, 39, 171, 183, 233, 66, 194, 210, 8, 90, 115, 202, 198, 68, 59, 247, 136, 21, 62, 34, 166, 149, 125, 2, 212, 34, 115, 239, 145, 25, 222, 220, 251, 117, 200, 88, 153, 4, 20, 110, 231, 168, 237, 102, 7, 133, 51, 6, 252, 181, 67, 83, 9, 243, 79, 230, 204, 58, 25, 37, 34, 165, 145, 76, 56, 220, 68, 180, 28, 60, 57, 110, 148, 225, 37, 201, 201, 186, 93, 224, 191, 197, 48, 172, 144, 118, 103, 206, 71, 103, 245, 203, 38, 98, 67, 253, 80, 48, 241, 24, 231, 26, 198, 150, 104, 188, 33, 85, 73, 225, 23, 44, 218, 131, 130, 222, 148, 35, 181, 67, 134, 111, 17, 108, 57, 109, 17, 44, 54, 234, 175, 230, 8, 84, 2, 106, 19, 71, 72, 22, 234, 118, 91, 128, 235, 146, 29, 244, 202, 237, 109, 230, 223, 43, 43, 187, 38, 137, 179, 227, 187, 104, 153, 77, 132, 126, 162, 151, 245, 248, 148, 8, 231, 198, 191, 131, 96, 157, 29, 218, 183, 37, 69, 61, 57, 227, 83, 237, 142, 46, 42, 198, 142, 158, 216, 217, 53, 186, 250, 53, 123, 64, 11, 106, 130, 156, 194, 217, 209, 56, 208, 80, 182, 162, 138, 236, 151, 145, 17, 125, 140, 251, 244, 172, 223, 226, 175, 26, 116, 251, 58, 194, 248, 228, 122, 80, 247, 17, 37, 168, 248, 153, 56, 148, 12, 114, 220, 234, 74, 80, 5, 208, 238, 164, 208, 108, 198, 92, 55, 46, 20, 111, 58, 32, 17, 11, 43, 217, 241, 119, 90, 87, 225, 136, 59, 127, 102, 158, 69, 0, 149, 226, 106, 89, 223, 134, 165, 34, 41, 16, 59, 218, 188, 24, 149, 145, 2, 121, 66, 128, 186, 252, 168, 233, 102, 248, 102, 126, 49, 90, 212, 102, 202, 116, 97, 147, 94, 39, 245, 233, 34, 77, 7, 113, 237, 89, 14, 246, 156, 61, 30, 173, 163, 83, 164, 13, 11, 190, 52, 11, 165, 35, 70, 217, 19, 151, 112, 64, 190, 214, 142, 132, 48, 20, 51, 15, 242, 35, 27, 175, 106, 222, 165, 153, 231, 119, 71, 155, 75, 75, 124, 106, 225, 142, 247, 7, 22, 245, 213, 102, 86, 62, 162, 223, 102, 172, 215, 22, 202, 185, 35, 163, 84, 154, 188, 46, 203, 230, 172, 136, 130, 95, 86, 70, 128, 232, 26, 105, 20, 108, 34, 129, 36, 74, 39, 184, 87, 110, 204, 209, 205, 193, 229, 25, 142, 160, 255, 34, 217, 95, 228, 140, 121, 126, 22, 121, 117, 115, 233, 35, 77, 206, 92, 119, 242, 229, 204, 34, 155, 38, 212, 50, 48, 249, 191, 145, 50, 191, 150, 190, 93, 91, 29, 163, 122, 85, 254, 93, 14, 213, 129, 24, 158, 133, 185, 177, 110, 220, 109, 33, 45, 243, 25, 224, 131, 27, 110, 64, 151, 128, 18, 7, 103, 45, 245, 182, 171, 225, 236, 21, 98, 255, 137, 44, 40, 68, 124, 12, 21, 160, 230, 85, 83, 20, 2, 161, 219, 132, 150, 31, 140, 244, 103, 76, 144, 182, 70, 76, 191, 16, 242, 254, 9, 39, 46, 4, 156, 243, 6, 40, 119, 9, 202, 174, 55, 159, 225, 132, 78, 160, 53, 189, 77, 170, 185, 96, 169, 247, 122, 159, 195, 226, 255, 191, 142, 25, 168, 162, 79, 139, 164, 167, 11, 64, 133, 55, 227, 180, 192, 11, 166, 255, 65, 141, 110, 38, 94, 1, 43, 177, 25, 253, 199, 175, 247, 5, 35, 109, 177, 137, 162, 10, 177, 199, 202, 112, 131, 103, 248, 221, 232, 14, 189, 148, 150, 61, 107, 133, 4, 151, 175, 120, 56, 136, 135, 201, 94, 141, 42, 103, 150, 67, 72, 200, 81, 61, 7, 104, 248, 65, 99, 179, 57, 176, 246, 171, 165, 199, 2, 255, 244, 156, 85, 80, 59, 74, 109, 136, 118, 172, 254, 165, 231, 115, 245, 57, 227, 144, 3, 181, 247, 89, 6, 190, 10, 244, 123, 116, 144, 6, 33, 254, 139, 30, 115, 118, 72, 225, 150, 36, 203, 49, 219, 25, 254, 246, 59, 78, 71, 222, 157, 170, 63, 175, 170, 129, 236, 70, 155, 242, 111, 40, 134, 139, 148, 198, 49, 132, 69, 132, 145, 135, 119, 77, 109, 198, 208, 36, 226, 180, 36, 232, 208, 8, 94, 21, 155, 179, 174, 42, 133, 208, 251, 147, 26, 7, 220, 148, 61, 141, 228, 180, 232, 56, 28, 169, 35, 158, 79, 192, 26, 17, 90, 146, 187, 253, 120, 134, 86, 67, 144, 108, 70, 54, 48, 138, 13, 50, 179, 1, 146, 123, 235, 240, 248, 109, 173, 143, 34, 182, 81, 46, 48, 242, 60, 182, 230, 78, 169, 98, 38, 11, 53, 26, 81, 168, 66, 233, 95, 90, 161, 127, 186, 104, 159, 161, 182, 178, 237, 12, 230, 169, 179, 46, 214, 91, 154, 96, 212, 20, 212, 227, 161, 187, 181, 41, 201, 18, 149, 212, 216, 11, 152, 9, 217, 134, 223, 229, 195, 83, 4, 141, 188, 220, 177, 112, 161, 64, 127, 223, 173, 204, 116, 96, 26, 182, 204, 128, 146, 241, 212, 9, 234, 101, 42, 233, 85, 220, 185, 126, 25, 175, 72, 165, 239, 241, 124, 74, 10, 152, 218, 1, 36, 161, 251, 98, 148, 42, 38, 77, 103, 235, 150, 200, 182, 207, 150, 18, 207, 208, 199, 177, 172, 204, 9, 93, 93, 102, 20, 193, 235, 247, 8, 76, 84, 177, 199, 146, 136, 109, 238, 140, 180, 216, 71, 65, 76, 63, 80, 193, 162, 187, 92, 36, 37, 210, 177, 212, 228, 21, 204, 204, 239, 225, 64, 200, 118, 175, 166, 184, 43, 247, 177, 219, 99, 88, 69, 220, 143, 126, 144, 34, 245, 237, 46, 202, 146, 211, 146, 160, 232, 171, 18, 175, 150, 236, 169, 42, 71, 154, 151, 101, 148, 101, 102, 224, 197, 45, 223, 243, 97, 205, 29, 107, 72, 0, 94, 141, 145, 241, 30, 166, 97, 61, 222, 49, 2, 105, 129, 43, 43, 48, 46, 158, 176, 208, 71, 14, 83, 234, 3, 87, 193, 148, 98, 61, 206, 100, 3, 32, 147, 85, 47, 209, 201, 251, 150, 199, 57, 97, 220, 18, 135, 190, 30, 203, 234, 187, 135, 48, 61, 53, 20, 172, 63, 100, 138, 207, 205, 141, 233, 185, 191, 191, 199, 112, 208, 224, 111, 138, 91, 201, 199, 90, 206, 139, 48, 161, 245, 160, 253, 75, 36, 12, 243, 182, 252, 254, 185, 223, 187, 254, 33, 99, 185, 111, 233, 101, 15, 140, 62, 172, 45, 38, 204, 200, 104, 111, 50, 64, 145, 51, 27, 203, 240, 122, 17, 70, 120, 1, 192, 161, 246, 120, 221, 56, 102, 226, 243, 151, 47, 252, 221, 122, 216, 38, 84, 189, 181, 163, 148, 228, 8, 94, 101, 198, 88, 98, 83, 203, 70, 154, 54, 209, 246, 67, 249, 57, 16, 201, 51, 124, 26, 49, 145, 66, 223, 248, 72, 175, 165, 134, 74, 92, 72, 48, 98, 114, 35, 85, 105, 148, 156, 103, 97, 169, 153, 235, 239, 191, 231, 225, 126, 36, 98, 56, 168, 134, 215, 58, 160, 149, 35, 130, 124, 240, 92, 107, 167, 144, 47, 129, 4, 82, 170, 34, 226, 171, 7, 123, 34, 128, 236, 162, 117, 108, 83, 100, 180, 226, 40, 251, 227, 173, 171, 196, 81, 82, 242, 148, 193, 10, 183, 51, 142, 82, 76, 112, 80, 206, 9, 237, 227, 10, 115, 182, 76, 89, 224, 184, 94, 13, 210, 219, 136, 116, 221, 59, 195, 76, 144, 46, 149, 59, 55, 243, 129, 199, 46, 180, 164, 21, 0, 48, 56, 201, 67, 30, 190, 145, 161, 130, 124, 248, 29, 103, 111, 14, 113, 16, 54, 246, 60, 1, 202, 143, 67, 253, 183, 141, 247, 82, 84, 33, 155, 177, 95, 64, 132, 187, 210, 167, 26, 211, 170, 238, 182, 239, 64, 191, 31, 71, 61, 186, 145, 168, 133, 42, 19, 20, 242, 220, 132, 159, 235, 202, 151, 230, 219, 62, 57, 20, 230, 153, 229, 128, 20, 32, 228, 11, 179, 50, 90, 158, 105, 167, 76, 140, 183, 31, 159, 183, 44, 130, 32, 146, 240, 13, 57, 151, 65, 60, 180, 161, 96, 103, 8, 68, 204, 156, 202, 11, 68, 182, 177, 53, 73, 204, 167, 175, 193, 20, 1, 170, 111, 249, 29, 142, 198, 30, 147, 25, 241, 3, 22, 147, 72, 123, 245, 109, 181, 67, 162, 164, 154, 71, 28, 48, 11, 204, 2, 143, 150, 6, 72, 9, 108, 187, 16, 209, 184, 1, 183, 131, 219, 118, 1, 61, 12, 60, 187, 47, 30, 1, 154, 234, 127, 23, 194, 199, 194, 204, 226, 124, 222, 166, 249, 88, 54, 191, 118, 221, 27, 238, 61, 134, 23, 175, 218, 197, 42, 210, 43, 179, 250, 0, 245, 102, 222, 196, 95, 250, 62, 152, 49, 131, 181, 121, 77, 23, 50, 244, 106, 205, 227, 163, 221, 250, 232, 106, 230, 62, 134, 235, 121, 225, 253, 210, 123, 204, 57, 218, 6, 228, 128, 9, 13, 245, 98, 218, 158, 229, 137, 238, 231, 13, 197, 185, 214, 136, 249, 173, 108, 236, 122, 0, 70, 154, 216, 73, 195, 64, 195, 75, 204, 33, 188, 49, 244, 238, 203, 100, 137, 9, 102, 65, 109, 56, 211, 159, 204, 80, 109, 237, 106, 203, 41, 114, 50, 80, 65, 189, 52, 143, 97, 126, 61, 211, 99, 207, 82, 150, 91, 10, 35, 248, 10, 26, 191, 154, 177, 166, 156, 25, 127, 135, 193, 233, 15, 173, 208, 73, 11, 150, 25, 26, 29, 73, 141, 142, 147, 165, 109, 30, 58, 226, 226, 114, 128, 146, 59, 168, 6, 166, 94, 173, 53, 182, 178, 217, 238, 237, 0, 181, 161, 226, 15, 6, 225, 231, 180, 45, 62, 41, 186, 174, 29, 58, 89, 93, 239, 235, 210, 184, 20, 172, 82, 28, 90, 189, 232, 136, 72, 199, 222, 73, 202, 226, 11, 54, 127, 180, 169, 171, 70, 241, 127, 54, 10, 188, 18, 52, 179, 174, 41, 240, 214, 15, 3, 202, 144, 47, 170, 8, 230, 76, 202, 220, 151, 200, 155, 194, 211, 78, 4, 79, 107, 135, 10, 114, 195, 97, 80, 158, 160, 39, 159, 191, 12, 203, 8, 144, 0, 65, 65, 199, 187, 239, 153, 142, 22, 189, 24, 29, 14, 64, 129, 12, 145, 145, 129, 49, 40, 240, 223, 128, 201, 26, 182, 61, 174, 225, 1, 223, 171, 59, 159, 201, 74, 11, 204, 192, 93, 175, 109, 89, 186, 74, 148, 19, 207, 215, 60, 94, 188, 184, 87, 31, 170, 170, 200, 43, 193, 231, 116, 166, 2, 84, 77, 136, 177, 196, 19, 231, 169, 37, 139, 234, 103, 196, 47, 201, 140, 19, 80, 217, 202, 212, 19, 113, 208, 250, 49, 155, 47, 62, 119, 86, 36, 206, 139, 99, 18, 225, 41, 11, 37, 231, 220, 3, 189, 248, 198, 187, 123, 46, 7, 26, 160, 122, 227, 11, 71, 169, 210, 82, 62, 40, 133, 2, 58, 88, 177, 245, 84, 74, 33, 70, 146, 209, 67, 170, 38, 248, 134, 133, 137, 111, 82, 189, 205, 119, 37, 138, 173, 97, 220, 110, 131, 39, 51, 179, 80, 238, 111, 41, 47, 100, 82, 102, 226, 191, 244, 106, 26, 21, 81, 203, 54, 182, 88, 112, 153, 195, 82, 29, 182, 181, 56, 102, 230, 255, 245, 37, 145, 199, 62, 84, 201, 155, 19, 186, 75, 218, 57, 210, 210, 91, 163, 20, 133, 8, 120, 150, 20, 142, 4, 125, 233, 42, 248, 116, 117, 94, 133, 70, 7, 63, 114, 197, 67, 39, 222, 122, 234, 104, 125, 232, 122, 143, 195, 45, 157, 114, 176, 82, 229, 54, 250, 135, 1, 52, 55, 18, 138, 116, 134, 31, 74, 64, 43, 209, 254, 34, 111, 92, 200, 10, 140, 49, 67, 18, 114, 100, 189, 107, 231, 23, 114, 227, 253, 127, 246, 129, 118, 169, 67, 221, 82, 93, 188, 59, 247, 160, 148, 206, 214, 192, 220, 177, 160, 222, 130, 229, 165, 39, 49, 3, 173, 100, 148, 119, 124, 211, 223, 138, 142, 149, 32, 217, 135, 173, 39, 68, 196, 97, 178, 50, 65, 11, 167, 48, 40, 212, 93, 228, 219, 210, 173, 188, 45, 108, 29, 214, 177, 249, 194, 57, 145, 85, 2, 236, 155, 96, 186, 7, 219, 63, 26, 70, 109, 2, 247, 216, 110, 31, 122, 88, 160, 38, 240, 95, 241, 76, 18, 197, 108, 241, 133, 56, 119, 156, 84, 109, 141, 45, 39, 98, 12, 117, 130, 239, 179, 253, 24, 145, 104, 239, 225, 168, 105, 146, 191, 20, 196, 9, 44, 136, 238, 81, 135, 251, 183, 129, 43, 76, 105, 222, 136, 12, 183, 190, 46, 194, 166, 177, 230, 218, 209, 62, 79, 179, 85, 208, 187, 169, 227, 98, 251, 72, 179, 94, 109, 10, 209, 215, 78, 137, 1, 223, 211, 125, 57, 59, 2, 255, 121, 5, 101, 138, 223, 200, 141, 75, 17, 105, 48, 168, 138, 118, 26, 202, 244, 164, 246, 191, 83, 26, 187, 5, 250, 160, 180, 26, 133, 62, 89, 253, 243, 175, 121, 219, 19, 203, 32, 149, 134, 7, 222, 183, 3, 111, 219, 197, 99, 154, 127, 227, 197, 13, 137, 9, 176, 58, 91, 131, 55, 16, 102, 241, 177, 17, 253, 213, 21, 18, 136, 131, 52, 241, 186, 219, 201, 215, 42, 218, 127, 110, 109, 197, 230, 4, 32, 35, 136, 65, 239, 13, 186, 11, 193, 127, 98, 211, 233, 145, 159, 194, 26, 188, 122, 211, 138, 234, 174, 253, 62, 113, 219, 160, 127, 45, 121, 238, 131, 105, 205, 180, 51, 15, 131, 208, 167, 135, 118, 90, 156, 228, 206, 230, 236, 251, 129, 58, 169, 49, 140, 64, 224, 32, 108, 1, 3, 41, 5, 225, 33, 103, 205, 63, 0, 165, 54, 34, 51, 116, 125, 237, 157, 201, 250, 226, 218, 22, 34, 92, 168, 68, 166, 106, 75, 121, 66, 183, 214, 29, 39, 19, 226, 125, 46, 91, 48, 157, 10, 26, 205, 55, 139, 76, 129, 196, 33, 49, 32, 201, 219, 177, 237, 144, 73, 125, 228, 101, 245, 103, 17, 125, 19, 93, 161, 178, 243, 110, 40, 136, 2, 94, 244, 220, 80, 8, 14, 217, 238, 20, 126, 147, 142, 106, 68, 92, 207, 77, 229, 198, 225, 241, 195, 152, 46, 50, 76, 24, 175, 74, 28, 55, 44, 110, 108, 142, 207, 159, 207, 229, 8, 245, 66, 165, 28, 144, 50, 32, 225, 177, 229, 96, 50, 217, 83, 215, 17, 190, 176, 51, 128, 39, 122, 135, 71, 89, 17, 85, 80, 240, 165, 6, 131, 250, 6, 133, 153, 0, 14, 114, 44, 43, 20, 170, 254, 77, 226, 90, 23, 34, 219, 244, 84, 10, 127, 174, 211, 58, 225, 185, 217, 113, 187, 28, 82, 137, 172, 54, 229, 205, 65, 54, 255, 107, 230, 210, 163, 132, 139, 188, 177, 139, 72, 163, 88, 169, 144, 95, 234, 211, 49, 45, 154, 67, 190, 161, 120, 63, 212, 81, 252, 59, 210, 166, 195, 139, 232, 58, 141, 36, 153, 132, 109, 51, 60, 195, 210, 175, 25, 183, 205, 35, 92, 85, 40, 47, 6, 9, 74, 242, 27, 192, 148, 129, 130, 238, 140, 48, 158, 138, 138, 99, 20, 228, 114, 119, 149, 129, 85, 157, 54, 103, 187, 238, 213, 119, 147, 46, 205, 101, 24, 154, 28, 11, 76, 237, 44, 87, 118, 8, 84, 57, 28, 213, 237, 95, 243, 150, 200, 68, 41, 168, 116, 38, 184, 152, 140, 83, 191, 155, 202, 39, 220, 183, 179, 229, 227, 111, 94, 22, 232, 113, 113, 21, 213, 109, 129, 20, 111, 83, 163, 210, 195, 15, 75, 170, 197, 28, 128, 201, 196, 84, 60, 128, 253, 132, 22, 211, 100, 190, 129, 137, 174, 176, 221, 28, 126, 166, 48, 152, 114, 233, 102, 110, 89, 118, 59, 43, 31, 195, 56, 131, 187, 86, 113, 127, 219, 125, 251, 25, 162, 108, 190, 254, 20, 160, 18, 52, 81, 84, 252, 43, 69, 101, 115, 255, 197, 81, 100, 42, 242, 158, 5, 48, 4, 19, 241, 1, 37, 4, 211, 28, 9, 232, 200, 149, 64, 28, 218, 77, 134, 111, 201, 139, 171, 54, 190, 64, 246, 89, 26, 246, 140, 193, 133, 177, 77, 85, 125, 200, 119, 47, 38, 144, 38, 214, 98, 150, 90, 204, 205, 103, 114, 6, 213, 118, 36, 145, 109, 191, 139, 154, 179, 12, 210, 230, 21, 138, 204, 252, 192, 137, 97, 144, 250, 248, 193, 75, 156, 56, 114, 218, 127, 118, 36, 110, 103, 85, 191, 229, 197, 41, 250, 28, 220, 177, 227, 156, 50, 100, 219, 46, 126, 80, 107, 17, 157, 0, 140, 173, 46, 147, 36, 251, 155, 255, 123, 51, 136, 27, 120, 242, 39, 117, 241, 26, 161, 67, 213, 3, 101, 192, 129, 137, 165, 160, 124, 94, 214, 4, 215, 112, 187, 75, 189, 158, 88, 116, 170, 135, 129, 164, 191, 65, 71, 238, 201, 87, 207, 148, 246, 134, 175, 203, 122, 51, 193, 35, 50, 69, 203, 214, 44, 145, 121, 80, 25, 14, 249, 41, 246, 89, 245, 101, 46, 98, 93, 106, 193, 240, 42, 164, 112, 233, 198, 2, 162, 138, 207, 16, 86, 191, 83, 73, 32, 229, 77, 181, 69, 100, 158, 207, 26, 9, 190, 139, 223, 195, 17, 115, 22, 54, 150, 220, 28, 141, 110, 123, 80, 202, 130, 108, 86, 205, 60, 48, 75, 206, 38, 113, 44, 237, 245, 69, 21, 255, 85, 162, 137, 197, 107, 196, 103, 164, 68, 248, 46, 9, 178, 183, 231, 147, 97, 84, 56, 245, 75, 63, 24, 153, 169, 81, 103, 167, 74, 239, 19, 25, 151, 7, 17, 141, 185, 180, 251, 132, 211, 154, 156, 37, 3, 61, 109, 155, 12, 37, 132, 156, 195, 97, 150, 139, 175, 189, 199, 106, 74, 38, 212, 79, 64, 235, 192, 78, 135, 213, 217, 176, 172, 73, 182, 61, 86, 153, 227, 190, 174, 212, 239, 76, 71, 109, 177, 141, 193, 156, 161, 73, 182, 150, 29, 223, 86, 59, 170, 241, 209, 21, 188, 84, 23, 237, 233, 180, 92, 69, 72, 23, 253, 175, 180, 141, 120, 1, 148, 213, 168, 148, 62, 238, 243, 60, 113, 110, 244, 102, 62, 35, 122, 136, 179, 207, 240, 188, 67, 137, 28, 91, 74, 201, 240, 202, 178, 95, 224, 230, 232, 221, 14, 209, 174, 221, 111, 119, 122, 253, 237, 131, 104, 78, 200, 147, 247, 161, 197, 96, 16, 26, 249, 0, 125, 205, 247, 252, 159, 174, 189, 129, 176, 66, 212, 187, 13, 17, 174, 207, 237, 207, 28, 164, 168, 234, 52, 200, 253, 153, 237, 117, 111, 145, 66, 50, 245, 59, 90, 73, 234, 18, 188, 81, 212, 190, 26, 31, 107, 98, 37, 39, 98, 244, 191, 191, 178, 199, 16, 214, 85, 15, 5, 211, 23, 229, 144, 98, 90, 209, 59, 198, 215, 54, 195, 39, 124, 177, 48, 60, 123, 143, 37, 190, 176, 105, 13, 19, 97, 65, 31, 0, 156, 27, 234, 36, 239, 68, 223, 209, 211, 244, 244, 69, 220, 190, 117, 107, 48, 88, 22, 153, 255, 70, 16, 13, 74, 128, 216, 241, 230, 43, 166, 53, 69, 48, 105, 11, 46, 192, 108, 184, 117, 49, 138, 5, 96, 150, 51, 105, 26, 167, 29, 189, 95, 119, 52, 247, 0, 246, 227, 168, 236, 226, 115, 170, 196, 114, 62, 50, 249, 224, 247, 45, 238, 98, 163, 192, 230, 244, 222, 174, 188, 252, 89, 15, 83, 126, 225, 134, 227, 89, 253, 210, 104, 171, 153, 92, 102, 247, 22, 209, 236, 203, 7, 238, 65, 19, 8, 189, 186, 28, 120, 191, 108, 245, 119, 163, 189, 85, 175, 38, 146, 162, 60, 144, 0, 207, 153, 96, 129, 196, 207, 209, 186, 159, 98, 183, 139, 20, 73, 79, 167, 108, 60, 200, 153, 172, 106, 105, 54, 94, 49, 108, 88, 195, 191, 72, 71, 206, 91, 26, 11, 181, 11, 240, 17, 103, 133, 27, 16, 51, 69, 57, 193, 65, 239, 166, 164, 21, 3, 182, 236, 9, 61, 95, 34, 169, 112, 131, 161, 115, 230, 235, 251, 163, 146, 245, 33, 189, 3, 25, 21, 177, 115, 194, 230, 68, 185, 48, 14, 57, 206, 231, 7, 73, 123, 109, 123, 2, 116, 167, 189, 56, 53, 179, 89, 58, 16, 107, 244, 242, 186, 212, 181, 191, 225, 30, 0, 237, 51, 47, 199, 243, 69, 70, 175, 185, 242, 226, 7, 74, 241, 206, 166, 135, 47, 235, 88, 51, 194, 83, 178, 210, 94, 93, 133, 149, 166, 204, 78, 57, 99, 102, 164, 178, 123, 190, 129, 133, 225, 175, 176, 98, 159, 113, 225, 122, 209, 167, 185, 180, 140, 16, 175, 104, 214, 177, 201, 131, 10, 206, 117, 115, 183, 24, 25, 145, 228, 43, 81, 45, 123, 162, 111, 251, 6, 102, 198, 175, 156, 187, 122, 201, 49, 9, 236, 11, 44, 87, 83, 236, 215, 131, 104, 177, 211, 58, 87, 255, 228, 87, 3, 161, 227, 85, 10, 226, 12, 185, 121, 134, 123, 246, 248, 130, 13, 184, 68, 182, 75, 61, 30, 43, 164, 168, 191, 232, 69, 196, 221, 203, 238, 0, 250, 43, 167, 226, 215, 167, 239, 126, 144, 128, 127, 89, 42, 153, 253, 81, 225, 237, 4, 164, 254, 61, 39, 150, 233, 180, 237, 239, 112, 35, 96, 94, 67, 44, 126, 177, 251, 165, 31, 93, 48, 210, 106, 71, 22, 17, 56, 7, 60, 1, 12, 94, 16, 19, 149, 85, 133, 234, 20, 248, 218, 144, 17, 180, 42, 99, 137, 9, 19, 28, 144, 77, 34, 57, 128, 223, 168, 205, 149, 115, 145, 175, 97, 177, 193, 203, 103, 15, 222, 211, 184, 255, 119, 20, 10, 45, 179, 95, 141, 198, 68, 147, 79, 134, 87, 108, 162, 165, 5, 61, 3, 210, 79, 133, 68, 79, 81, 85, 37, 253, 184, 105, 28, 114, 153, 13, 180, 37, 66, 217, 19, 12, 86, 80, 141, 111, 126, 202, 168, 32, 209, 241, 159, 187, 194, 19, 250, 43, 70, 1, 243, 231, 42, 37, 96, 246, 178, 181, 156, 130, 64, 194, 220, 60, 84, 56, 122, 126, 165, 61, 209, 245, 101, 124, 62, 146, 24, 164, 231, 43, 120, 148, 165, 31, 73, 97, 82, 67, 228, 34, 46, 129, 167, 29, 37, 140, 240, 191, 236, 240, 160, 163, 112, 215, 146, 47, 177, 101, 117, 228, 25, 37, 185, 56, 222, 194, 100, 100, 57, 68, 147, 192, 139, 99, 162, 215, 107, 78, 117, 247, 141, 63, 168, 71, 58, 189, 40, 200, 243, 132, 96, 169, 208, 117, 6, 62, 173, 52, 86, 202, 223, 140, 24, 45, 111, 198, 165, 139, 152, 10, 87, 126, 28, 114, 185, 254, 193, 100, 21, 144, 142, 8, 233, 193, 87, 110, 79, 60, 170, 160, 92, 212, 10, 163, 135, 34, 247, 128, 232, 212, 235, 142, 46, 14, 247, 15, 86, 69, 88, 7, 28, 88, 188, 200, 216, 209, 227, 65, 234, 39, 241, 83, 235, 154, 212, 118, 223, 13, 112, 217, 18, 240, 179, 97, 206, 249, 0, 228, 36, 30, 124, 211, 155, 228, 165, 229, 240, 93, 2, 91, 82, 223, 216, 18, 189, 236, 217, 103, 148, 182, 101, 49, 58, 190, 243, 186, 133, 198, 141, 90, 0, 62, 231, 227, 145, 96, 3, 248, 232, 120, 142, 33, 252, 94, 60, 86, 137, 214, 39, 122, 185, 185, 160, 41, 123, 147, 121, 22, 141, 227, 142, 143, 40, 177, 16, 218, 52, 185, 201, 205, 142, 102, 87, 101, 119, 45, 68, 22, 131, 160, 116, 87, 37, 96, 56, 58, 241, 159, 137, 43, 209, 22, 212, 2, 162, 117, 154, 78, 228, 76, 169, 53, 86, 235, 164, 244, 163, 44, 13, 165, 236, 88, 69, 229, 152, 187, 29, 245, 155, 166, 106, 42, 158, 21, 213, 9, 158, 86, 252, 174, 12, 77, 176, 158, 4, 28, 183, 210, 61, 232, 141, 233, 71, 3, 18, 35, 217, 171, 81, 240, 66, 202, 35, 25, 133, 192, 52, 215, 232, 11, 245, 45, 228, 205, 219, 109, 138, 103, 127, 205, 174, 88, 72, 85, 239, 53, 182, 192, 47, 92, 195, 235, 211, 174, 243, 56, 55, 71, 12, 164, 16, 178, 196, 128, 171, 147, 108, 10, 112, 172, 9, 223, 52, 199, 120, 133, 51, 174, 242, 137, 161, 243, 234, 213, 128, 80, 140, 121, 224, 146, 217, 70, 20, 203, 90, 13, 212, 219, 139, 167, 71, 3, 182, 140, 209, 145, 224, 215, 63, 115, 169, 1, 162, 225, 108, 134, 225, 197, 245, 153, 116, 153, 135, 72, 208, 235, 154, 230, 68, 212, 88, 111, 181, 43, 167, 91, 170, 203, 222, 195, 9, 184, 246, 82, 174, 247, 84, 196, 6, 46, 120, 238, 223, 148, 133, 167, 80, 7, 102, 233, 22, 133, 107, 221, 149, 195, 208, 94, 188, 185, 62, 199, 71, 41, 250, 57, 178, 203, 73, 221, 183, 203, 119, 180, 34, 207, 60, 141, 142, 28, 107, 114, 195, 161, 8, 156, 69, 123, 97, 205, 97, 95, 196, 196, 201, 249, 65, 153, 30, 84, 93, 164, 206, 83, 62, 56, 14, 167, 255, 12, 73, 123, 141, 72, 38, 186, 71, 205, 97, 240, 91, 255, 79, 119, 115, 248, 145, 163, 40, 58, 108, 185, 187, 206, 143, 46, 3, 255, 16, 4, 58, 142, 77, 212, 134, 52, 234, 142, 84, 191, 129, 226, 210, 101, 116, 155, 57, 1, 131, 208, 206, 64, 11, 149, 16, 174, 194, 107, 187, 61, 184, 206, 29, 222, 189, 120, 237, 56, 217, 207, 55, 116, 246, 122, 241, 54, 235, 214, 118, 72, 195, 157, 13, 77, 231, 92, 29, 41, 105, 93, 223, 170, 165, 51, 17, 92, 39, 179, 65, 248, 20, 136, 93, 16, 61, 118, 158, 157, 49, 131, 41, 142, 252, 87, 216, 66, 109, 186, 40, 137, 235, 248, 120, 213, 224, 20, 96, 236, 150, 29, 37, 52, 140, 168, 156, 197, 56, 227, 168, 222, 128, 43, 149, 153, 26, 95, 153, 16, 182, 23, 103, 156, 93, 30, 75, 145, 26, 116, 46, 115, 63, 213, 124, 193, 42, 175, 180, 160, 24, 220, 189, 70, 23, 141, 250, 104, 84, 41, 39, 167, 242, 63, 70, 205, 115, 64, 238, 185, 229, 193, 26, 178, 203, 213, 229, 145, 83, 40, 234, 75, 217, 115, 84, 110, 228, 114, 150, 251, 116, 69, 196, 252, 99, 18, 247, 156, 22, 104, 149, 57, 133, 255, 190, 251, 59, 32, 108, 12, 32, 211, 97, 250, 119, 90, 13, 80, 56, 164, 44, 140, 49, 239, 97, 59, 137, 66, 238, 192, 227, 173, 153, 216, 221, 172, 150, 9, 221, 30, 54, 8, 118, 96, 131, 244, 163, 56, 233, 74, 157, 10, 64, 47, 241, 182, 28, 123, 108, 203, 240, 186, 121, 82, 200, 45, 227, 62, 161, 130, 147, 3, 211, 8, 86, 2, 141, 29, 254, 136, 39, 205, 77, 51, 74, 89, 183, 137, 237, 215, 138, 157, 105, 184, 248, 146, 242, 50, 98, 46, 8, 89, 40, 62, 255, 158, 42, 253, 146, 164, 126, 98, 23, 238, 162, 163, 76, 148, 239, 98, 40, 61, 48, 164, 207, 19, 39, 238, 76, 199, 11, 114, 66, 80, 198, 110, 67, 10, 246, 159, 46, 61, 111, 185, 38, 178, 86, 153, 196, 117, 51, 96, 24, 247, 121, 71, 6, 220, 98, 226, 225, 69, 217, 166, 175, 98, 62, 50, 254, 248, 193, 177, 30, 183, 238, 95, 226, 82, 214, 128, 54, 147, 122, 120, 99, 9, 219, 113, 30, 104, 133, 12, 237, 135, 99, 31, 121, 91, 106, 0, 161, 97, 167, 238, 86, 117, 235, 87, 175, 27, 18, 174, 36, 220, 167, 135, 198, 157, 82, 63, 108, 147, 149, 197, 97, 89, 76, 26, 103, 16, 35, 188, 90, 145, 254, 230, 56, 233, 230, 74, 96, 238, 255, 26, 148, 20, 211, 50, 48, 22, 190, 79, 55, 202, 51, 220, 12, 3, 222, 91, 1, 86, 97, 216, 90, 3, 209, 88, 40, 68, 209, 71, 233, 239, 54, 21, 171, 11, 95, 2, 180, 95, 74, 13, 133, 134, 32, 227, 39, 247, 113, 46, 247, 177, 89, 46, 3, 166, 227, 23, 123, 155, 57, 44, 142, 37, 80, 3, 247, 30, 196, 127, 158, 21, 73, 177, 90, 241, 204, 1, 224, 84, 225, 193, 213, 249, 167, 238, 48, 108, 189, 248, 123, 96, 115, 232, 237, 103, 78, 167, 222, 77, 96, 10, 56, 31, 214, 159, 236, 51, 134, 53, 185, 175, 139, 177, 40, 145, 15, 196, 38, 205, 222, 242, 198, 23, 113, 62, 116, 102, 71, 166, 92, 173, 50, 64, 167, 58, 255, 39, 5, 146, 91, 58, 15, 195, 244, 51, 251, 4, 176, 10, 222, 6, 130, 1, 255, 46, 130, 4, 224, 200, 134, 227, 175, 73, 152, 80, 115, 138, 139, 152, 255, 13, 16, 34, 20, 236, 123, 180, 197, 221, 133, 52, 132, 25, 80, 251, 127, 132, 199, 146, 66, 148, 47, 24, 67, 62, 165, 186, 212, 187, 224, 62, 1, 187, 118, 229, 214, 69, 222, 223, 67, 81, 238, 143, 4, 246, 60, 65, 67, 43, 90, 184, 110, 73, 231, 255, 93, 115, 131, 87, 15, 159, 130, 220, 3, 34, 51, 101, 154, 219, 3, 250, 81, 105, 192, 10, 32, 16, 200, 208, 196, 97, 72, 189, 135, 191, 42, 25, 52, 119, 69, 15, 230, 197, 143, 51, 243, 100, 130, 171, 176, 97, 192, 125, 168, 35, 127, 180, 223, 208, 51, 127, 69, 142, 93, 188, 205, 223, 172, 96, 178, 236, 23, 59, 207, 119, 109, 162, 253, 5, 226, 152, 239, 228, 109, 146, 168, 147, 56, 7, 166, 118, 131, 130, 207, 115, 24, 206, 215, 104, 244, 109, 230, 132, 79, 188, 89, 210, 91, 210, 28, 204, 96, 173, 104, 121, 112, 116, 89, 6, 191, 172, 67, 153, 98, 236, 118, 151, 17, 154, 133, 212, 237, 246, 32, 46, 60, 146, 93, 98, 34, 68, 189, 178, 59, 100, 130, 99, 225, 57, 198, 105, 11, 100, 201, 112, 203, 2, 137, 229, 109, 177, 45, 81, 45, 221, 228, 73, 82, 189, 156, 165, 236, 162, 164, 114, 57, 142, 226, 191, 188, 71, 190, 143, 134, 138, 173, 224, 70, 87, 183, 128, 173, 142, 68, 50, 2, 127, 128, 112, 221, 254, 113, 212, 39, 62, 135, 70, 32, 68, 97, 192, 81, 25, 84, 185, 96, 86, 48, 227, 250, 3, 56, 212, 7, 195, 34, 243, 88, 142, 29, 33, 218, 79, 152, 245, 121, 227, 215, 69, 72, 17, 139, 52, 206, 204, 234, 252, 36, 251, 17, 244, 245, 250, 5, 36, 199, 93, 126, 58, 101, 69, 250, 144, 231, 190, 2, 149, 191, 204, 225, 217, 135, 66, 255, 80, 135, 95, 112, 20, 206, 190, 183, 119, 251, 195, 196, 137, 75, 218, 59, 117, 55, 182, 148, 20, 215, 31, 228, 177, 192, 69, 176, 207, 121, 47, 35, 125, 129, 249, 79, 54, 224, 70, 240, 78, 251, 250, 149, 56, 254, 247, 207, 63, 146, 192, 175, 86, 20, 49, 226, 42, 113, 98, 142, 52, 198, 8, 15, 164, 58, 3, 26, 253, 66, 168, 185, 81, 230, 143, 53, 8, 38, 61, 245, 99, 242, 24, 56, 169, 33, 108, 240, 57, 34, 141, 62, 169, 212, 135, 102, 246, 183, 114, 111, 171, 200, 10, 42, 108, 121, 91, 2, 138, 44, 181, 54, 119, 9, 183, 97, 202, 137, 88, 200, 189, 162, 33, 43, 254, 22, 12, 36, 109, 225, 112, 120, 106, 213, 98, 122, 254, 95, 99, 85, 223, 212, 209, 50, 70, 131, 156, 218, 180, 106, 113, 184, 198, 230, 206, 0, 189, 26, 0, 119, 138, 60, 88, 203, 23, 145, 233, 8, 72, 17, 94, 227, 42, 247, 251, 135, 217, 142, 232, 240, 12, 19, 219, 22, 180, 107, 174, 178, 236, 40, 94, 121, 140, 140, 191, 59, 224, 117, 156, 167, 113, 131, 70, 216, 255, 45, 36, 16, 184, 138, 30, 149, 58, 240, 220, 227, 248, 12, 167, 131, 65, 237, 78, 227, 245, 62, 7, 179, 189, 138, 219, 115, 65, 243, 180, 245, 251, 24, 67, 119, 128, 48, 11, 81, 11, 226, 241, 13, 16, 72, 171, 125, 54, 15, 152, 162, 66, 239, 206, 12, 141, 232, 167, 251, 56, 180, 132, 109, 65, 254, 177, 138, 144, 241, 72, 248, 72, 70, 154, 85, 55, 236, 61, 234, 118, 67, 175, 34, 191, 91, 43, 123, 26, 125, 206, 255, 137, 247, 188, 111, 134, 77, 174, 108, 21, 91, 3, 213, 252, 156, 133, 11, 208, 40, 180, 252, 60, 192, 150, 175, 77, 179, 124, 234, 167, 114, 84, 115, 66, 65, 170, 108, 36, 31, 192, 13, 236, 169, 176, 62, 156, 89, 59, 89, 150, 155, 133, 5, 108, 175, 254, 164, 56, 45, 201, 173, 101, 129, 73, 64, 233, 208, 64, 15, 21, 203, 104, 204, 136, 143, 175, 107, 48, 43, 41, 55, 207, 196, 78, 66, 251, 178, 97, 145, 110, 195, 43, 213, 109, 141, 126, 120, 63, 129, 212, 175, 137, 175, 47, 230, 122, 49, 73, 153, 229, 126, 76, 26, 14, 162, 26, 62, 202, 236, 77, 247, 100, 212, 69, 228, 47, 213, 244, 225, 41, 231, 116, 93, 84, 183, 62, 51, 39, 121, 235, 158, 147, 224, 126, 254, 156, 132, 191, 155, 106, 252, 164, 221, 99, 132, 234, 153, 63, 23, 216, 176, 246, 219, 22, 50, 87, 240, 125, 204, 3, 210, 7, 225, 96, 1, 241, 234, 225, 216, 10, 185, 18, 180, 220, 245, 128, 11, 137, 118, 93, 131, 209, 203, 232, 156, 213, 243, 30, 92, 126, 60, 176, 210, 227, 73, 185, 20, 165, 49, 182, 20, 104, 223, 117, 116, 158, 211, 73, 198, 46, 69, 150, 182, 174, 219, 54, 39, 223, 187, 78, 63, 20, 209, 14, 37, 209, 107, 7, 147, 195, 195, 247, 231, 122, 108, 89, 219, 205, 230, 186, 1, 8, 196, 194, 244, 206, 176, 73, 55, 163, 213, 78, 255, 232, 81, 148, 106, 50, 141, 160, 134, 27, 223, 15, 87, 66, 100, 210, 215, 43, 113, 3, 218, 182, 232, 203, 192, 225, 139, 163, 213, 49, 55, 114, 105, 236, 215, 165, 251, 150, 171, 17, 124, 143, 158, 206, 109, 150, 43, 229, 236, 35, 170, 14, 81, 10, 27, 249, 220, 134, 128, 255, 71, 12, 35, 250, 41, 72, 143, 34, 203, 0, 21, 169, 42, 210, 31, 23, 86, 48, 125, 164, 248, 77, 236, 25, 248, 233, 72, 196, 64, 20, 104, 97, 249, 75, 168, 68, 148, 102, 55, 217, 242, 63, 219, 102, 45, 90, 112, 55, 96, 230, 155, 9, 64, 96, 17, 20, 64, 129, 183, 46, 41, 2, 171, 141, 78, 91, 190, 85, 26, 254, 111, 221, 180, 11, 152, 212, 65, 166, 176, 80, 107, 58, 89, 180, 207, 123, 20, 38, 30, 14, 83, 215, 75, 41, 129, 55, 104, 187, 157, 72, 142, 167, 246, 127, 38, 153, 58, 147, 190, 59, 95, 183, 188, 246, 34, 34, 12, 5, 219, 110, 9, 14, 125, 75, 140, 46, 255, 205, 77, 91, 253, 238, 106, 198, 55, 234, 247, 192, 139, 89, 237, 193, 164, 90, 127, 195, 129, 41, 73, 123, 248, 53, 4, 84, 17, 59, 25, 24, 118, 127, 206, 6, 194, 149, 224, 46, 166, 228, 194, 87, 252, 151, 111, 182, 135, 207, 144, 37, 239, 184, 31, 198, 220, 141, 205, 33, 51, 167, 126, 163, 154, 67, 16, 56, 197, 144, 40, 214, 62, 122, 20, 206, 94, 2, 210, 127, 230, 19, 47, 251, 50, 140, 209, 236, 235, 217, 3, 34, 49, 140, 166, 204, 195, 18, 135, 18, 36, 107, 115, 121, 21, 199, 147, 4, 213, 80, 55, 139, 169, 223, 204, 33, 180, 186, 202, 209, 222, 134, 78, 29, 32, 238, 162, 27, 90, 197, 42, 124, 99, 210, 218, 186, 227, 167, 213, 55, 91, 239, 115, 200, 24, 13, 23, 239, 83, 188, 205, 50, 253, 193, 188, 167, 214, 168, 220, 184, 152, 168, 247, 110, 86, 134, 45, 38, 66, 70, 37, 22, 67, 54, 191, 252, 120, 220, 123, 53, 201, 226, 72, 53, 216, 82, 201, 117, 236, 79, 172, 147, 185, 29, 108, 222, 161, 33, 218, 15, 60, 73, 120, 128, 236, 161, 163, 65, 34, 231, 138, 206, 187, 182, 239, 98, 130, 217, 150, 102, 225, 111, 160, 7, 192, 28, 97, 212, 83, 35, 9, 212, 52, 190, 58, 169, 95, 82, 162, 125, 189, 194, 203, 113, 170, 166, 202, 26, 158, 116, 244, 132, 2, 252, 15, 176, 79, 157, 60, 53, 130, 4, 224, 136, 36, 147, 41, 150, 122, 184, 183, 233, 236, 135, 190, 117, 97, 86, 128, 221, 84, 128, 222, 64, 226, 99, 98, 75, 90, 99, 7, 119, 186, 11, 144, 119, 168, 198, 36, 141, 208, 130, 205, 236, 17, 248, 186, 214, 108, 241, 26, 144, 167, 253, 255, 97, 205, 72, 147, 131, 236, 46, 82, 63, 203, 10, 6, 254, 70, 95, 229, 136, 187, 199, 39, 22, 239, 146, 180, 30, 102, 103, 66, 225, 211, 21, 241, 88, 141, 142, 66, 219, 53, 234, 205, 64, 89, 58, 179, 154, 201, 30, 79, 89, 32, 3, 223, 237, 62, 215, 187, 15, 11, 187, 240, 162, 159, 173, 142, 100, 28, 68, 159, 19, 30, 167, 211, 140, 122, 214, 253, 159, 162, 240, 97, 254, 41, 216, 132, 86, 150, 218, 169, 130, 21, 246, 121, 248, 230, 213, 220, 224, 253, 119, 75, 26, 60, 126, 97, 62, 31, 243, 5, 252, 172, 52, 43, 240, 149, 71, 49, 99, 233, 159, 75, 157, 194, 68, 212, 195, 187, 101, 195, 159, 207, 62, 227, 153, 137, 51, 97, 70, 220, 183, 186, 118];
    var okm := Hkdf(HKDF_WITH_SHA_256, Some(tv_salt[..]), tv_ikm[..], tv_info[..], 8129);
    expect tv_okm_desired[..] == okm, ""expectation violation""
  }
}

module TestAESKeyring {

  import opened Wrappers = Wrappers

  import opened UInt = StandardLibrary.UInt

  import AESEncryption = AESEncryption

  import RawAESKeyringDef = RawAESKeyringDef

  import MessageHeader = MessageHeader

  import Materials = Materials

  import EncryptionContext = EncryptionContext

  import EncryptionSuites = EncryptionSuites

  import AlgorithmSuite = AlgorithmSuite

  import UTF8 = UTF8

  import Crypto = Aws.Crypto

  import opened TestUtils = TestUtils
  method {:test} TestOnEncryptOnDecryptGenerateDataKey()
  {
    var namespace, name := TestUtils.NamespaceAndName(0);
    var rawAESKeyring := new RawAESKeyringDef.RawAESKeyring(namespace, name, seq(32, (i: int) => 0), EncryptionSuites.AES_GCM_256);
    var encryptionContext := TestUtils.SmallEncryptionContext(TestUtils.SmallEncryptionContextVariation.A);
    ExpectSerializableEncryptionContext(encryptionContext);
    var wrappingAlgorithmID := Crypto.ALG_AES_256_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384;
    var signingKey := seq(32, (i: int) => 0);
    var encryptionMaterialsIn := Crypto.EncryptionMaterials(encryptionContext := encryptionContext, algorithmSuiteId := wrappingAlgorithmID, plaintextDataKey := None(), encryptedDataKeys := [], signingKey := Some(signingKey));
    var encryptionMaterialsOut :- rawAESKeyring.OnEncrypt(Crypto.OnEncryptInput(materials := encryptionMaterialsIn));
    expect |encryptionMaterialsOut.materials.encryptedDataKeys| == 1, ""expectation violation""
    var pdk := encryptionMaterialsOut.materials.plaintextDataKey;
    var edk := encryptionMaterialsOut.materials.encryptedDataKeys[0];
    var verificationKey := seq(32, (i: int) => 0);
    var decryptionMaterialsIn := Crypto.DecryptionMaterials(encryptionContext := encryptionContext, algorithmSuiteId := wrappingAlgorithmID, plaintextDataKey := None(), verificationKey := Some(verificationKey));
    var decryptionMaterialsOut :- rawAESKeyring.OnDecrypt(Crypto.OnDecryptInput(materials := decryptionMaterialsIn, encryptedDataKeys := [edk]));
    expect encryptionMaterialsOut.materials.plaintextDataKey == pdk, ""expectation violation""
  }

  method {:test} TestOnEncryptOnDecryptSuppliedDataKey()
  {
    var namespace, name := TestUtils.NamespaceAndName(0);
    var rawAESKeyring := new RawAESKeyringDef.RawAESKeyring(namespace, name, seq(32, (i: int) => 0), EncryptionSuites.AES_GCM_256);
    var encryptionContext := TestUtils.SmallEncryptionContext(TestUtils.SmallEncryptionContextVariation.A);
    ExpectSerializableEncryptionContext(encryptionContext);
    var pdk := seq(32, (i: int) => 0);
    var wrappingAlgorithmID := Crypto.ALG_AES_256_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384;
    var signingKey := seq(32, (i: int) => 0);
    var encryptionMaterialsIn := Crypto.EncryptionMaterials(encryptionContext := encryptionContext, algorithmSuiteId := wrappingAlgorithmID, plaintextDataKey := Some(pdk), encryptedDataKeys := [], signingKey := Some(signingKey));
    var encryptionMaterialsOut :- rawAESKeyring.OnEncrypt(Crypto.OnEncryptInput(materials := encryptionMaterialsIn));
    expect |encryptionMaterialsOut.materials.encryptedDataKeys| == 1, ""expectation violation""
    var edk := encryptionMaterialsOut.materials.encryptedDataKeys[0];
    var verificationKey := seq(32, (i: int) => 0);
    var decryptionMaterialsIn := Crypto.DecryptionMaterials(encryptionContext := encryptionContext, algorithmSuiteId := wrappingAlgorithmID, plaintextDataKey := None(), verificationKey := Some(verificationKey));
    var decryptionMaterialsOut :- rawAESKeyring.OnDecrypt(Crypto.OnDecryptInput(materials := decryptionMaterialsIn, encryptedDataKeys := [edk]));
    expect decryptionMaterialsOut.materials.plaintextDataKey == Some(pdk), ""expectation violation""
  }

  method {:test} TestOnDecryptKeyNameMismatch()
  {
    var namespace, name := TestUtils.NamespaceAndName(0);
    var rawAESKeyring := new RawAESKeyringDef.RawAESKeyring(namespace, name, seq(32, (i: int) => 0), EncryptionSuites.AES_GCM_256);
    var mismatchName :- UTF8.Encode(""mismatched"");
    var mismatchedAESKeyring := new RawAESKeyringDef.RawAESKeyring(namespace, mismatchName, seq(32, (i: int) => 0), EncryptionSuites.AES_GCM_256);
    var encryptionContext := TestUtils.SmallEncryptionContext(TestUtils.SmallEncryptionContextVariation.A);
    ExpectSerializableEncryptionContext(encryptionContext);
    var pdk := seq(32, (i: int) => 0);
    var wrappingAlgorithmID := Crypto.ALG_AES_256_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384;
    var signingKey := seq(32, (i: int) => 0);
    var encryptionMaterialsIn := Crypto.EncryptionMaterials(encryptionContext := encryptionContext, algorithmSuiteId := wrappingAlgorithmID, plaintextDataKey := Some(pdk), encryptedDataKeys := [], signingKey := Some(signingKey));
    var encryptionMaterialsOut :- mismatchedAESKeyring.OnEncrypt(Crypto.OnEncryptInput(materials := encryptionMaterialsIn));
    expect |encryptionMaterialsOut.materials.encryptedDataKeys| == 1, ""expectation violation""
    var edk := encryptionMaterialsOut.materials.encryptedDataKeys[0];
    var verificationKey := seq(32, (i: int) => 0);
    var decryptionMaterialsIn := Crypto.DecryptionMaterials(encryptionContext := encryptionContext, algorithmSuiteId := wrappingAlgorithmID, plaintextDataKey := None(), verificationKey := Some(verificationKey));
    var decryptionMaterialsOut :- rawAESKeyring.OnDecrypt(Crypto.OnDecryptInput(materials := decryptionMaterialsIn, encryptedDataKeys := [edk]));
    expect decryptionMaterialsOut.materials.plaintextDataKey.None?, ""expectation violation""
  }

  method {:test} TestOnDecryptNoEDKs()
  {
    var namespace, name := TestUtils.NamespaceAndName(0);
    var rawAESKeyring := new RawAESKeyringDef.RawAESKeyring(namespace, name, seq(32, (i: int) => 0), EncryptionSuites.AES_GCM_256);
    var wrappingAlgorithmID := Crypto.ALG_AES_256_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384;
    var encryptionContext := TestUtils.SmallEncryptionContext(TestUtils.SmallEncryptionContextVariation.A);
    var verificationKey := seq(32, (i: int) => 0);
    var decryptionMaterialsIn := Crypto.DecryptionMaterials(encryptionContext := encryptionContext, algorithmSuiteId := wrappingAlgorithmID, plaintextDataKey := None(), verificationKey := Some(verificationKey));
    var decryptionMaterialsOut :- rawAESKeyring.OnDecrypt(Crypto.OnDecryptInput(materials := decryptionMaterialsIn, encryptedDataKeys := []));
    expect decryptionMaterialsOut.materials.plaintextDataKey.None?, ""expectation violation""
  }

  method {:test} TestOnEncryptUnserializableEC()
  {
    var namespace, name := TestUtils.NamespaceAndName(0);
    var rawAESKeyring := new RawAESKeyringDef.RawAESKeyring(namespace, name, seq(32, (i: int) => 0), EncryptionSuites.AES_GCM_256);
    var unserializableEncryptionContext := generateUnserializableEncryptionContext();
    ExpectNonSerializableEncryptionContext(unserializableEncryptionContext);
    var wrappingAlgorithmID := Crypto.ALG_AES_256_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384;
    var signingKey := seq(32, (i: int) => 0);
    var encryptionMaterialsIn := Crypto.EncryptionMaterials(encryptionContext := unserializableEncryptionContext, algorithmSuiteId := wrappingAlgorithmID, plaintextDataKey := None(), encryptedDataKeys := [], signingKey := Some(signingKey));
    var encryptionMaterialsOut := rawAESKeyring.OnEncrypt(Crypto.OnEncryptInput(materials := encryptionMaterialsIn));
    expect encryptionMaterialsOut.Failure?, ""expectation violation""
  }

  method {:test} TestOnDecryptUnserializableEC()
  {
    var encryptionContext := TestUtils.SmallEncryptionContext(TestUtils.SmallEncryptionContextVariation.A);
    var namespace, name := TestUtils.NamespaceAndName(0);
    var rawAESKeyring := new RawAESKeyringDef.RawAESKeyring(namespace, name, seq(32, (i: int) => 0), EncryptionSuites.AES_GCM_256);
    var wrappingAlgorithmID := Crypto.ALG_AES_256_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384;
    var signingKey := seq(32, (i: int) => 0);
    var encryptionMaterialsIn := Crypto.EncryptionMaterials(encryptionContext := encryptionContext, algorithmSuiteId := wrappingAlgorithmID, plaintextDataKey := None(), encryptedDataKeys := [], signingKey := Some(signingKey));
    var encryptionMaterialsOut :- rawAESKeyring.OnEncrypt(Crypto.OnEncryptInput(materials := encryptionMaterialsIn));
    expect encryptionMaterialsOut.materials.plaintextDataKey.Some?, ""expectation violation""
    expect |encryptionMaterialsOut.materials.encryptedDataKeys| == 1, ""expectation violation""
    var edk := encryptionMaterialsOut.materials.encryptedDataKeys[0];
    var unserializableEncryptionContext := generateUnserializableEncryptionContext();
    ExpectNonSerializableEncryptionContext(unserializableEncryptionContext);
    var verificationKey := seq(32, (i: int) => 0);
    var decryptionMaterialsIn := Crypto.DecryptionMaterials(encryptionContext := unserializableEncryptionContext, algorithmSuiteId := wrappingAlgorithmID, plaintextDataKey := None(), verificationKey := Some(verificationKey));
    var decryptionMaterialsOut := rawAESKeyring.OnDecrypt(Crypto.OnDecryptInput(materials := decryptionMaterialsIn, encryptedDataKeys := [edk]));
    expect decryptionMaterialsOut.Failure?, ""expectation violation""
  }

  method {:test} TestDeserializeEDKCiphertext()
  {
    var ciphertext := [0, 1, 2, 3];
    var authTag := [4, 5, 6, 7];
    var serializedEDKCiphertext := ciphertext + authTag;
    var encOutput := RawAESKeyringDef.DeserializeEDKCiphertext(serializedEDKCiphertext, |authTag|);
    expect encOutput.cipherText == ciphertext, ""expectation violation""
    expect encOutput.authTag == authTag, ""expectation violation""
  }

  method {:test} TestSerializeEDKCiphertext()
  {
    var ciphertext := [0, 1, 2, 3];
    var authTag := [4, 5, 6, 7];
    var encOutput := AESEncryption.EncryptionOutput(ciphertext, authTag);
    var serializedEDKCiphertext := RawAESKeyringDef.SerializeEDKCiphertext(encOutput);
    expect serializedEDKCiphertext == ciphertext + authTag, ""expectation violation""
  }

  method generateUnserializableEncryptionContext() returns (encCtx: EncryptionContext.Map)
  {
    var keyA :- UTF8.Encode(""keyA"");
    var invalidVal := seq(65536, (_: int) => 0);
    AssumeLongSeqIsValidUTF8(invalidVal);
    return map[keyA := invalidVal];
  }
}

module TestMessageHeader {

  import AlgorithmSuite = AlgorithmSuite

  import opened StandardLibrary = StandardLibrary

  import opened UInt = StandardLibrary.UInt

  import Materials = Materials

  import UTF8 = UTF8

  import EncryptionContext = EncryptionContext

  import opened TestUtils = TestUtils
  method {:test} TestKVPairSequenceToMapEmpty()
  {
    var kvPairs := [];
    var output := EncryptionContext.LinearToMap(kvPairs);
    var expected := map[];
    expect output == expected, ""expectation violation""
  }

  method {:test} TestKVPairSequenceToMap()
  {
    var keyA :- UTF8.Encode(""keyA"");
    var valA :- UTF8.Encode(""valA"");
    var keyB :- UTF8.Encode(""keyB"");
    var valB :- UTF8.Encode(""valB"");
    var kvPairs := [(keyA, valA), (keyB, valB)];
    var output := EncryptionContext.LinearToMap(kvPairs);
    var expected := map[keyA := valA, keyB := valB];
    expect output == expected, ""expectation violation""
  }

  method {:test} TestCheckSerializableEmpty()
  {
    var encCtx := map[];
    ExpectSerializableEncryptionContext(encCtx);
  }

  method {:test} TestCheckSerializableOnePair()
  {
    var keyA :- UTF8.Encode(""keyA"");
    var valA :- UTF8.Encode(""valA"");
    var encCtx := map[keyA := valA];
    ExpectSerializableEncryptionContext(encCtx);
  }

  method {:test} TestCheckSerializableOnePairMaxSize()
  {
    var keyA :- UTF8.Encode(""A"");
    var largeVal := seq(65528, (_: int) => 0);
    var encCtx := map[keyA := largeVal];
    TestUtils.AssumeLongSeqIsValidUTF8(largeVal);
    ExpectSerializableEncryptionContext(encCtx);
  }

  method {:test} TestCheckSerializableTooLarge()
  {
    var keyA :- UTF8.Encode(""keyA"");
    var keyB :- UTF8.Encode(""keyB"");
    var invalidVal := seq(65528, (_: int) => 0);
    TestUtils.AssumeLongSeqIsValidUTF8(invalidVal);
    var encCtx := map[keyA := invalidVal, keyB := invalidVal];
    ExpectNonSerializableEncryptionContext(encCtx);
  }

  method {:test} TestCheckSerializablePairTooBig()
  {
    var key :- UTF8.Encode(""keyA"");
    var invalidVal := seq(65536, (_: int) => 0);
    var encCtx := map[key := invalidVal];
    TestUtils.AssumeLongSeqIsValidUTF8(invalidVal);
    ExpectNonSerializableEncryptionContext(encCtx);
  }

  method {:test} TestComputeKVPairsLengthEmpty()
  {
    var encCtx := map[];
    var len := EncryptionContext.ComputeLength(encCtx);
    expect len as int == 0, ""expectation violation""
  }

  method {:test} TestComputeKVPairsLengthOnePair()
  {
    var keyA :- UTF8.Encode(""keyA"");
    var valA :- UTF8.Encode(""valA"");
    var encCtx := map[keyA := valA];
    var expectedSerialization := [0, 1, 0, 4, 107, 101, 121, 65, 0, 4, 118, 97, 108, 65];
    var len := EncryptionContext.ComputeLength(encCtx);
    expect len as int == |expectedSerialization|, ""expectation violation""
  }

  method {:test} TestComputeKVPairsLengthLong()
  {
    var keyA :- UTF8.Encode(""A"");
    var largeVal := seq(65536, (_: int) => 0);
    TestUtils.AssumeLongSeqIsValidUTF8(largeVal);
    var encCtx := map[keyA := largeVal];
    var len := EncryptionContext.ComputeLength(encCtx);
    expect len as int == 7 + |largeVal|, ""expectation violation""
  }

  method {:test} TestComputeOpoerationsOnLargeValidEC()
  {
    var encCtx := TestUtils.GenerateLargeValidEncryptionContext();
    var len := EncryptionContext.ComputeLength(encCtx);
    expect len as int == 2 + |encCtx| as int * 7, ""expectation violation""
    ExpectSerializableEncryptionContext(encCtx);
  }
}

module {:extern ""TestClient""} TestClient {

  import Esdk = Aws.Esdk

  import Crypto = Aws.Crypto

  import opened Wrappers = Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened StandardLibrary = StandardLibrary

  import RawAESKeyringDef = RawAESKeyringDef

  import EncryptionSuites = EncryptionSuites

  import Base64 = Base64

  import AwsCryptographicMaterialProviders = AwsCryptographicMaterialProviders

  import AwsEncryptionSdk = AwsEncryptionSdk

  import UTF8 = UTF8

  import TestUtils = TestUtils
  method {:test} HappyPath()
  {
    var materialsClient := new AwsCryptographicMaterialProviders.AwsCryptographicMaterialProvidersClient();
    var rawAESKeyring := materialsClient.CreateRawAesKeyring(Crypto.CreateRawAesKeyringInput(keyNamespace := ""someNamespace"", keyName := ""someName"", wrappingKey := seq(32, (i: int) => 0), wrappingAlg := Crypto.ALG_AES256_GCM_IV12_TAG16));
    var cmm := materialsClient.CreateDefaultCryptographicMaterialsManager(Crypto.CreateDefaultCryptographicMaterialsManagerInput(keyring := rawAESKeyring));
    var client := new AwsEncryptionSdk.AwsEncryptionSdkClient();
    var plaintext :- UTF8.Encode(""hello"");
    var encryptionContext := TestUtils.SmallEncryptionContext(TestUtils.SmallEncryptionContextVariation.A);
    var input := Esdk.EncryptInput(plaintext := plaintext, encryptionContext := encryptionContext, algorithmSuiteId := None(), materialsManager := cmm);
    var res :- client.Encrypt(input);
    var decryptInput := Esdk.DecryptInput(ciphertext := res.ciphertext, materialsManager := cmm);
    var d :- client.Decrypt(decryptInput);
    expect plaintext == d.plaintext, ""expectation violation""
  }
}

module TestSerialize {

  import opened StandardLibrary = StandardLibrary

  import opened UInt = StandardLibrary.UInt

  import opened Serialize = Serialize

  import UTF8 = UTF8

  import EncryptionContext = EncryptionContext

  import TestUtils = TestUtils
  method {:test} TestSerializeAAD()
  {
    var wr := new Streams.ByteWriter();
    var keyA :- UTF8.Encode(""keyA"");
    var valA :- UTF8.Encode(""valA"");
    var keyB :- UTF8.Encode(""keyB"");
    var valB :- UTF8.Encode(""valB"");
    var encryptionContext := map[keyB := valB, keyA := valA];
    TestUtils.ValidSmallEncryptionContext(encryptionContext);
    var expectedSerializedAAD := [0, 26, 0, 2, 0, 4, 107, 101, 121, 65, 0, 4, 118, 97, 108, 65, 0, 4, 107, 101, 121, 66, 0, 4, 118, 97, 108, 66];
    var len :- SerializeAAD(wr, encryptionContext);
    expect wr.GetDataWritten() == expectedSerializedAAD, ""expectation violation""
  }

  method {:test} TestSerializeAADEmpty()
  {
    reveal EncryptionContext.Serializable();
    var wr := new Streams.ByteWriter();
    var encryptionContext := map[];
    var expectedSerializedAAD := [0, 0];
    var len :- SerializeAAD(wr, encryptionContext);
    expect wr.GetDataWritten() == expectedSerializedAAD, ""expectation violation""
  }

  method {:test} TestSerializeLargeValidEC()
  {
    var wr := new Streams.ByteWriter();
    var encCtx := TestUtils.GenerateLargeValidEncryptionContext();
    var len :- SerializeAAD(wr, encCtx);
    expect len == 4 + |encCtx| as int * 7, ""expectation violation""
  }

  method {:test} TestSerializeKVPairs()
  {
    var wr := new Streams.ByteWriter();
    var keyA :- UTF8.Encode(""keyA"");
    var valA :- UTF8.Encode(""valA"");
    var keyB :- UTF8.Encode(""keyB"");
    var valB :- UTF8.Encode(""valB"");
    var encryptionContext := map[keyB := valB, keyA := valA];
    TestUtils.ValidSmallEncryptionContext(encryptionContext);
    var expectedSerializedAAD := [0, 2, 0, 4, 107, 101, 121, 65, 0, 4, 118, 97, 108, 65, 0, 4, 107, 101, 121, 66, 0, 4, 118, 97, 108, 66];
    var len :- SerializeKVPairs(wr, encryptionContext);
    expect wr.GetDataWritten() == expectedSerializedAAD, ""expectation violation""
  }

  method {:test} TestSerializeKVPairsEmpty()
  {
    reveal EncryptionContext.Serializable();
    var wr := new Streams.ByteWriter();
    var encryptionContext := map[];
    var expectedSerializedAAD := [];
    var len :- SerializeKVPairs(wr, encryptionContext);
    expect wr.GetDataWritten() == expectedSerializedAAD, ""expectation violation""
  }
}

module TestBase64 {

  import opened Wrappers = Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened Base64 = Base64
  const BASE64_TEST_VECTORS_ENCODED := ["""", ""VA=="", ""VGU="", ""VGVz"", ""VGVzdA=="", ""VGVzdGk="", ""VGVzdGlu"", ""VGVzdGluZw=="", ""VGVzdGluZys="", ""VGVzdGluZysx""]
  const BASE64_TEST_VECTORS_DECODED := ["""", ""T"", ""Te"", ""Tes"", ""Test"", ""Testi"", ""Testin"", ""Testing"", ""Testing+"", ""Testing+1""]
  const BASE64_TEST_VECTORS_DECODED_UINT8: seq<seq<uint8>> := [[], [84], [84, 101], [84, 101, 115], [84, 101, 115, 116], [84, 101, 115, 116, 105], [84, 101, 115, 116, 105, 110], [84, 101, 115, 116, 105, 110, 103], [84, 101, 115, 116, 105, 110, 103, 43], [84, 101, 115, 116, 105, 110, 103, 43, 49]]
  const BASE64_CHARS := ""+/0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz""

  lemma {:axiom} Base64TestVectorIsValid(i: int)
    requires 0 <= i < |BASE64_TEST_VECTORS_ENCODED|
    ensures IsBase64String(BASE64_TEST_VECTORS_ENCODED[i])
    decreases i

  method {:test} TestIsBase64CharSuccess()
  {
    expect forall c: char :: c in BASE64_CHARS ==> IsBase64Char(c), ""expectation violation""
  }

  method {:test} TestIsBase64CharFailure()
  {
    expect forall c: char :: c !in BASE64_CHARS ==> !IsBase64Char(c), ""expectation violation""
  }

  method {:test} TestIsUnpaddedBase64StringSuccess()
  {
    expect IsUnpaddedBase64String(""VGVz""), ""expectation violation""
  }

  method {:test} TestIsUnpaddedBase64StringTooShort()
  {
    expect !IsUnpaddedBase64String(""VGV""), ""expectation violation""
  }

  method {:test} TestIsUnpaddedBase64StringNotBase64()
  {
    expect !IsUnpaddedBase64String(""VGV$""), ""expectation violation""
  }

  method {:test} TestIndexToChar63()
  {
    expect IndexToChar(63) == '/', ""expectation violation""
  }

  method {:test} TestIndexToChar62()
  {
    expect IndexToChar(62) == '+', ""expectation violation""
  }

  method {:test} TestIndexToCharDigits()
  {
    var digits := ""0123456789"";
    expect forall i: index :: 52 <= i <= 61 ==> IndexToChar(i) in digits, ""expectation violation""
  }

  method {:test} TestIndexToCharLowercase()
  {
    var lowercase := ""abcdefghijklmnopqrstuvwxyz"";
    expect forall i: index :: 26 <= i <= 51 ==> IndexToChar(i) in lowercase, ""expectation violation""
  }

  method {:test} TestIndexToCharUppercase()
  {
    var uppercase := ""ABCDEFGHIJKLMNOPQRSTUVWXYZ"";
    expect forall i: index :: 0 <= i <= 25 ==> IndexToChar(i) in uppercase, ""expectation violation""
  }

  method {:test} TestCharToIndex63()
  {
    expect CharToIndex('/') == 63, ""expectation violation""
  }

  method {:test} TestCharToIndex62()
  {
    expect CharToIndex('+') == 62, ""expectation violation""
  }

  method {:test} TestCharToIndexDigits()
  {
    var digits := ""0123456789"";
    expect forall i: int :: 0 <= i < |digits| ==> CharToIndex(digits[i]) == (i + 52) as index, ""expectation violation""
  }

  method {:test} TestCharToIndexLowercase()
  {
    var lowercase := ""abcdefghijklmnopqrstuvwxyz"";
    expect forall i: int :: 0 <= i < |lowercase| ==> CharToIndex(lowercase[i]) == (i + 26) as index, ""expectation violation""
  }

  method {:test} TestCharToIndexUppercase()
  {
    var uppercase := ""ABCDEFGHIJKLMNOPQRSTUVWXYZ"";
    expect forall i: int :: 0 <= i < |uppercase| ==> CharToIndex(uppercase[i]) == i as index, ""expectation violation""
  }

  method {:test} TestUInt24ToSeq()
  {
    var input: uint24 := 1048833;
    var output := [16, 1, 1];
    expect output == UInt24ToSeq(input), ""expectation violation""
  }

  method {:test} TestSeqToUInt24()
  {
    var input := [16, 1, 1];
    var output: uint24 := 1048833;
    expect output == SeqToUInt24(input), ""expectation violation""
  }

  method {:test} TestUInt24ToIndexSeq()
  {
    var input: uint24 := 1048833;
    var output := [4, 0, 4, 1];
    expect output == UInt24ToIndexSeq(input), ""expectation violation""
  }

  method {:test} TestIndexSeqToUInt24()
  {
    var input := [4, 0, 4, 1];
    var output: uint24 := 1048833;
    expect output == IndexSeqToUInt24(input), ""expectation violation""
  }

  method {:test} TestDecodeBlock()
  {
    var input := [4, 0, 4, 1];
    var output := [16, 1, 1];
    expect output == DecodeBlock(input), ""expectation violation""
  }

  method {:test} TestEncodeBlock()
  {
    var input := [16, 1, 1];
    var output := [4, 0, 4, 1];
    expect output == EncodeBlock(input), ""expectation violation""
  }

  method {:test} TestDecodeRecursively()
  {
    var input := [4, 0, 4, 1, 4, 0, 4, 1];
    var output := [16, 1, 1, 16, 1, 1];
    expect output == DecodeRecursively(input), ""expectation violation""
  }

  method {:test} TestEncodeRecursively()
  {
    var input := [16, 1, 1, 16, 1, 1];
    var output := [4, 0, 4, 1, 4, 0, 4, 1];
    expect output == EncodeRecursively(input), ""expectation violation""
  }

  method {:test} TestFromCharsToIndices()
  {
    var input := ""aA1+/"";
    var output := [26, 0, 53, 62, 63];
    expect output == FromCharsToIndices(input), ""expectation violation""
  }

  method {:test} TestFromIndicesToChars()
  {
    var input := [26, 0, 53, 62, 63];
    var output := ""aA1+/"";
    expect output == FromIndicesToChars(input), ""expectation violation""
  }

  method {:test} TestDecodeUnpadded()
  {
    var input := ""VGVzdGluZysx"";
    var output := [84, 101, 115, 116, 105, 110, 103, 43, 49];
    expect output == DecodeUnpadded(input), ""expectation violation""
  }

  method {:test} TestEncodeUnpadded()
  {
    var input := [84, 101, 115, 116, 105, 110, 103, 43, 49];
    var output := ""VGVzdGluZysx"";
    expect output == EncodeUnpadded(input), ""expectation violation""
  }

  method {:test} TestDecodeUnpaddedEmpty()
  {
    expect [] == DecodeUnpadded([]), ""expectation violation""
  }

  method {:test} TestEncodeUnpaddedEmpty()
  {
    expect [] == EncodeUnpadded([]), ""expectation violation""
  }

  method {:test} TestIs1PaddingSuccess()
  {
    expect Is1Padding(""VGU=""), ""expectation violation""
  }

  method {:test} TestIs1PaddingTooShort()
  {
    expect !Is1Padding(""VG=""), ""expectation violation""
  }

  method {:test} TestIs1PaddingTooLong()
  {
    expect !Is1Padding(""VGUU=""), ""expectation violation""
  }

  method {:test} TestIs1PaddingInvalidChar0()
  {
    expect !Is1Padding(""$GU=""), ""expectation violation""
  }

  method {:test} TestIs1PaddingInvalidChar1()
  {
    expect !Is1Padding(""V$U=""), ""expectation violation""
  }

  method {:test} TestIs1PaddingInvalidChar2()
  {
    expect !Is1Padding(""VG$=""), ""expectation violation""
  }

  method {:test} TestIs1PaddingInvalidChar3()
  {
    expect !Is1Padding(""VGVz""), ""expectation violation""
  }

  method {:test} TestIs1PaddingInvalidChar2Modulus()
  {
    expect !Is1Padding(""VGV=""), ""expectation violation""
  }

  method {:test} TestDecode1Padding()
  {
    var input := ""VGU="";
    var output := [84, 101];
    expect output == Decode1Padding(input), ""expectation violation""
  }

  method {:test} TestEncode1Padding()
  {
    var input := [84, 101];
    var output := ""VGU="";
    expect output == Encode1Padding(input), ""expectation violation""
  }

  method {:test} TestIs2PaddingSuccess()
  {
    expect Is2Padding(""VA==""), ""expectation violation""
  }

  method {:test} TestIs2PaddingTooShort()
  {
    expect !Is2Padding(""VA=""), ""expectation violation""
  }

  method {:test} TestIs2PaddingTooLong()
  {
    expect !Is2Padding(""VAA==""), ""expectation violation""
  }

  method {:test} TestIs2PaddingInvalidChar0()
  {
    expect !Is2Padding(""$A==""), ""expectation violation""
  }

  method {:test} TestIs2PaddingInvalidChar1()
  {
    expect !Is2Padding(""V$==""), ""expectation violation""
  }

  method {:test} TestIs2PaddingInvalidChar2()
  {
    expect !Is2Padding(""VAA=""), ""expectation violation""
  }

  method {:test} TestIs2PaddingInvalidChar3()
  {
    expect !Is2Padding(""VA=A""), ""expectation violation""
  }

  method {:test} TestIs2PaddingInvalidChar1Modulus()
  {
    expect !Is2Padding(""VB==""), ""expectation violation""
  }

  method {:test} TestDecode2Padding()
  {
    var input := ""VA=="";
    var output := [84];
    expect output == Decode2Padding(input), ""expectation violation""
  }

  method {:test} TestEncode2Padding()
  {
    var input := [84];
    var output := ""VA=="";
    expect output == Encode2Padding(input), ""expectation violation""
  }

  method {:test} TestIsBase64StringTestVectors()
  {
    expect forall i: string :: i in BASE64_TEST_VECTORS_ENCODED ==> IsBase64String(i) == true, ""expectation violation""
  }

  method {:test} TestIsBase64StringBadLength()
  {
    expect !IsBase64String(""VG=""), ""expectation violation""
  }

  method {:test} TestIsBase64StringBadString()
  {
    expect !IsBase64String(""VC==""), ""expectation violation""
  }

  method {:test} TestSanityCheckDecodedTestVectors()
  {
    var testVectorIndex := 0;
    while testVectorIndex < |BASE64_TEST_VECTORS_DECODED|
      invariant 0 <= testVectorIndex <= |BASE64_TEST_VECTORS_DECODED|
      decreases |BASE64_TEST_VECTORS_DECODED| - testVectorIndex
    {
      var uint8Message: seq<uint8> := [];
      var strMessage := BASE64_TEST_VECTORS_DECODED[testVectorIndex];
      var msgIndex := 0;
      while msgIndex < |strMessage|
        invariant 0 <= msgIndex <= |strMessage|
        decreases |strMessage| - msgIndex
      {
        uint8Message := uint8Message + [strMessage[msgIndex] as uint8];
        msgIndex := msgIndex + 1;
      }
      expect BASE64_TEST_VECTORS_DECODED_UINT8[testVectorIndex] == uint8Message, ""expectation violation""
      testVectorIndex := testVectorIndex + 1;
    }
  }

  method {:test} TestDecodeValidTestVectors()
  {
    expect forall i: int :: 0 <= i < |BASE64_TEST_VECTORS_ENCODED| ==> DecodeValid(BASE64_TEST_VECTORS_ENCODED[i]) == BASE64_TEST_VECTORS_DECODED_UINT8[i], ""expectation violation""
  }

  method {:test} TestDecodeTestVectors()
  {
    expect forall i: int :: 0 <= i < |BASE64_TEST_VECTORS_ENCODED| ==> Decode(BASE64_TEST_VECTORS_ENCODED[i]) == Success(BASE64_TEST_VECTORS_DECODED_UINT8[i]), ""expectation violation""
  }

  method {:test} TestDecodeFailure()
  {
    expect Failure(""The encoding is malformed"") == Decode(""$""), ""expectation violation""
  }

  method {:test} TestEncode()
  {
    expect forall i: int :: 0 <= i < |BASE64_TEST_VECTORS_DECODED_UINT8| ==> Encode(BASE64_TEST_VECTORS_DECODED_UINT8[i]) == BASE64_TEST_VECTORS_ENCODED[i], ""expectation violation""
  }

  method {:test} TestEncodeDecode()
  {
    expect forall i: int :: 0 <= i < |BASE64_TEST_VECTORS_DECODED_UINT8| ==> Decode(Encode(BASE64_TEST_VECTORS_DECODED_UINT8[i])) == Success(BASE64_TEST_VECTORS_DECODED_UINT8[i]), ""expectation violation""
  }

  method {:test} TestDecodeEncode()
  {
    expect forall i: int :: 0 <= i < |BASE64_TEST_VECTORS_ENCODED| ==> Decode(BASE64_TEST_VECTORS_ENCODED[i]).Success? && Encode(Decode(BASE64_TEST_VECTORS_ENCODED[i]).value) == BASE64_TEST_VECTORS_ENCODED[i], ""expectation violation""
  }
}

module TestStandardLibrary {

  import opened Wrappers = Wrappers

  import opened StandardLibrary = StandardLibrary
  method {:test} TestJoinMultiElementSeq()
  {
    var input := [""comma"", ""separated"", ""list""];
    var output := Join(input, "","");
    expect ""comma,separated,list"" == output, ""expectation violation""
  }

  method {:test} TestJoinSingleElementSeq()
  {
    var input := [""one""];
    var output := Join(input, "","");
    expect ""one"" == output, ""expectation violation""
  }

  method {:test} TestJoinSplit()
  {
    var input := ""comma,separated,list"";
    var output := Join(Split(input, ','), "","");
    expect input == output, ""expectation violation""
  }

  method {:test} TestSplitJoin()
  {
    var input := [""comma"", ""separated"", ""list""];
    var output := Split(Join(input, "",""), ',');
    expect input == output, ""expectation violation""
  }

  method {:test} TestSplitByteSeq()
  {
    var input := ""comma,separated,list"";
    var output := Split(input, ',');
    expect [""comma"", ""separated"", ""list""] == output, ""expectation violation""
  }

  method {:test} TestSplitNumSeq()
  {
    var input := [1, 2, 3, 0, 1, 2, 3];
    var output := Split(input, 0);
    expect [[1, 2, 3], [1, 2, 3]] == output, ""expectation violation""
  }

  method {:test} TestSplitFinalElementDelim()
  {
    var input := ""one,"";
    var output := Split(input, ',');
    expect [""one"", """"] == output, ""expectation violation""
  }

  method {:test} TestSplitNoDelim()
  {
    var input := ""no comma"";
    var output := Split(input, ',');
    expect [""no comma""] == output, ""expectation violation""
  }

  method {:test} TestSplitOnlyElemIsDelim()
  {
    var input := "","";
    var output := Split(input, ',');
    expect ["""", """"] == output, ""expectation violation""
  }

  method {:test} TestSplitEmpty()
  {
    var input := """";
    var output := Split(input, ',');
    expect [""""] == output, ""expectation violation""
  }

  method {:test} TestFindIndexMatchingSimple()
  {
    var input := ""abcd"";
    var output := FindIndexMatching(input, 'c', 0);
    expect Some(2) == output, ""expectation violation""
  }

  method {:test} TestFindIndexMatchingDuplicates()
  {
    var input := ""abcdc"";
    var output := FindIndexMatching(input, 'c', 0);
    expect Some(2) == output, ""expectation violation""
  }

  method {:test} TestFindIndexMatchingNone()
  {
    var input := ""abcd"";
    var output := FindIndexMatching(input, 'e', 0);
    expect None == output, ""expectation violation""
  }

  method {:test} TestFindIndexSimple()
  {
    var input := ""abcd"";
    var output := FindIndex(input, (x: char) => x == 'c', 0);
    expect Some(2) == output, ""expectation violation""
  }

  method {:test} TestFindIndexComplex()
  {
    var input := ""abcd"";
    var output := FindIndex(input, (x: char) => x in ""crepe"", 0);
    expect Some(2) == output, ""expectation violation""
  }

  method {:test} TestFindIndexDuplicates()
  {
    var input := ""abcdc"";
    var output := FindIndex(input, (x: char) => x == 'c', 0);
    expect Some(2) == output, ""expectation violation""
  }

  method {:test} TestFindIndexNone()
  {
    var input := ""abcd"";
    var output := FindIndex(input, (x: char) => false, 0);
    expect None == output, ""expectation violation""
  }

  predicate method TestFilterPredicate(entry: seq<char>)
    decreases entry
  {
    entry in [""a""]
  }

  method {:test} TestFilterSomeValid()
  {
    var input := [""a"", ""b"", ""a""];
    var output := Filter(input, TestFilterPredicate);
    expect [""a"", ""a""] == output, ""expectation violation""
  }

  method {:test} TestFilterNoneValid()
  {
    var input := [""c"", ""b"", ""c""];
    var output := Filter(input, TestFilterPredicate);
    expect [] == output, ""expectation violation""
  }

  method {:test} TestFilterNothing()
  {
    var input := [];
    var output := Filter(input, TestFilterPredicate);
    expect [] == output, ""expectation violation""
  }

  method {:test} TestFillZero()
  {
    var output := Fill(0, 50);
    expect seq(50, (_: int) => 0) == output, ""expectation violation""
  }

  method {:test} TestFillChars()
  {
    var output := Fill(""a"", 25);
    expect seq(25, (_: int) => ""a"") == output, ""expectation violation""
  }

  method {:test} TestMinPositives()
  {
    expect 1 == Min(1, 2), ""expectation violation""
  }

  method {:test} TestMinNegatives()
  {
    expect -2 == Min(-1, -2), ""expectation violation""
  }

  method {:test} TestMinPositivesNegatives()
  {
    expect -1 == Min(-1, 1), ""expectation violation""
  }

  method {:test} TestMinDuplicateNumber()
  {
    expect 0 == Min(0, 0), ""expectation violation""
  }

  method {:test} TestSeqToArray()
  {
    var input: seq<int> := [1, 2, 3];
    var output := SeqToArray(input);
    var expected := new int[3] ((i: nat) => i + 1);
    expect expected.Length == output.Length, ""expectation violation""
    expect expected[0] == output[0], ""expectation violation""
    expect expected[1] == output[1], ""expectation violation""
    expect expected[2] == output[2], ""expectation violation""
  }

  method {:test} TestSeqToArrayEmpty()
  {
    var input: seq<char> := [];
    var output := SeqToArray(input);
    expect 0 == output.Length, ""expectation violation""
  }

  predicate method TestStandardLibraryLessPredicate(a: int, b: int)
    decreases a, b
  {
    a < b
  }

  method {:test} TestLexicographicLessOrEqualTrue()
  {
    var a: seq<int> := [1, 2, 3];
    var b: seq<int> := [1, 2, 4];
    expect LexicographicLessOrEqual(a, b, TestStandardLibraryLessPredicate), ""expectation violation""
  }

  method {:test} TestLexicographicLessOrEqualFalse()
  {
    var a: seq<int> := [1, 2, 3];
    var b: seq<int> := [1, 2, 4];
    expect !LexicographicLessOrEqual(b, a, TestStandardLibraryLessPredicate), ""expectation violation""
  }

  method {:test} TestLexicographicLessOrEqualAllEqual()
  {
    var a: seq<int> := [1, 2, 3];
    var b: seq<int> := [1, 2, 3];
    expect LexicographicLessOrEqual(a, b, TestStandardLibraryLessPredicate), ""expectation violation""
  }

  method {:test} TestLexicographicLessOrEqualNoneEqual()
  {
    var a: seq<int> := [1];
    var b: seq<int> := [2];
    expect LexicographicLessOrEqual(a, b, TestStandardLibraryLessPredicate), ""expectation violation""
  }

  method {:test} TestLexicographicLessOrEqualEmpty()
  {
    var a: seq<int> := [];
    var b: seq<int> := [];
    expect LexicographicLessOrEqual(a, b, TestStandardLibraryLessPredicate), ""expectation violation""
  }
}

module TestUInt {

  import opened UInt = StandardLibrary.UInt
  method {:test} TestUInt16ToSeq()
  {
    var x: uint16 := 290;
    expect [1, 34] == UInt16ToSeq(x), ""expectation violation""
  }

  method {:test} TestSeqToUInt16()
  {
    var s := [1, 34];
    expect 290 as uint16 == SeqToUInt16(s), ""expectation violation""
  }

  method {:test} TestUInt32ToSeq()
  {
    var x := 16920644;
    expect [1, 2, 48, 68] == UInt32ToSeq(x), ""expectation violation""
  }

  method {:test} TestSeqToUInt32()
  {
    var s := [1, 2, 48, 68];
    expect 16920644 as uint32 == SeqToUInt32(s), ""expectation violation""
  }

  method {:test} TestUInt64ToSeq()
  {
    var x: uint64 := 72673614040037256;
    expect [1, 2, 48, 68, 85, 102, 119, 136] == UInt64ToSeq(x), ""expectation violation""
  }

  method {:test} TestSeqToUInt64()
  {
    var s := [1, 2, 48, 68, 85, 102, 119, 136];
    expect 72673614040037256 as uint64 == SeqToUInt64(s), ""expectation violation""
  }
}

module TestSeqReaderReadElements {

  import opened StandardLibrary = StandardLibrary

  import opened UInt = StandardLibrary.UInt

  import opened Sets = Sets
  method {:test} TestSetToOrderedSequenceEmpty()
  {
    var output := ComputeSetToOrderedSequence({}, UInt8Less);
    var expected := [];
    expect output == expected, ""expectation violation""
  }

  method {:test} TestSetToOrderedSequenceOneItem()
  {
    var a := {[0]};
    var output := ComputeSetToOrderedSequence(a, UInt8Less);
    var expected := [[0]];
    expect output == expected, ""expectation violation""
  }

  method {:test} TestSetToOrderedSequenceSimple()
  {
    var a := {[0, 2], [0, 1]};
    var output := ComputeSetToOrderedSequence(a, UInt8Less);
    var expected := [[0, 1], [0, 2]];
    expect output == expected, ""expectation violation""
  }

  method {:test} TestSetToOrderedSequencePrefix()
  {
    var a := {[0, 1, 2], [0, 1]};
    var output := ComputeSetToOrderedSequence(a, UInt8Less);
    var expected := [[0, 1], [0, 1, 2]];
    expect output == expected, ""expectation violation""
  }

  method {:test} TestSetToOrderedSequenceComplex()
  {
    var a := {[0, 1, 2], [1, 1, 2], [0, 1]};
    var output := ComputeSetToOrderedSequence(a, UInt8Less);
    var expected := [[0, 1], [0, 1, 2], [1, 1, 2]];
    expect output == expected, ""expectation violation""
  }

  method {:test} TestSetToOrderedSequenceManyItems()
  {
    var a := set x: uint16 {:trigger UInt16ToSeq(x)} | 0 <= x < 65535 :: UInt16ToSeq(x);
    var output := ComputeSetToOrderedSequence(a, UInt8Less);
    var expected: seq<seq<uint8>> := seq(65535, (i: int) requires 0 <= i < 65535 => UInt16ToSeq(i as uint16));
    expect output == expected, ""expectation violation""
  }
}

module TestStreams {

  import opened UInt = StandardLibrary.UInt

  import opened Streams = Streams
  method {:test} TestSeqReaderReadElements()
  {
    var s: seq<nat> := [0, 100, 200, 300, 400];
    var reader := new Streams.SeqReader<nat>(s);
    var res := reader.ReadElements(3);
    expect [0, 100, 200] == res, ""expectation violation""
    res := reader.ReadElements(0);
    expect [] == res, ""expectation violation""
    res := reader.ReadElements(2);
    expect [300, 400] == res, ""expectation violation""
  }

  method {:test} TestSeqReaderReadExact()
  {
    var s: seq<nat> := [0, 100, 200, 300, 400];
    var reader := new Streams.SeqReader<nat>(s);
    var res :- reader.ReadExact(3);
    expect [0, 100, 200] == res, ""expectation violation""
    res :- reader.ReadExact(0);
    expect [] == res, ""expectation violation""
    res :- reader.ReadExact(2);
    expect [300, 400] == res, ""expectation violation""
    var isFailure := reader.ReadExact(1);
    expect isFailure.Failure?, ""expectation violation""
  }

  method {:test} TestByteReader()
  {
    var s: seq<uint8> := [0, 3, 10, 20, 50, 100, 150, 200, 250, 255];
    var reader := new Streams.ByteReader(s);
    var uint8Res :- reader.ReadByte();
    var sizeRead := reader.GetSizeRead();
    var isDoneReading := reader.IsDoneReading();
    expect 0 == uint8Res, ""expectation violation""
    expect 1 == sizeRead, ""expectation violation""
    expect !isDoneReading, ""expectation violation""
    var sRes :- reader.ReadBytes(0);
    sizeRead := reader.GetSizeRead();
    isDoneReading := reader.IsDoneReading();
    expect [] == sRes, ""expectation violation""
    expect 1 == sizeRead, ""expectation violation""
    expect !isDoneReading, ""expectation violation""
    sRes :- reader.ReadBytes(3);
    sizeRead := reader.GetSizeRead();
    isDoneReading := reader.IsDoneReading();
    expect [3, 10, 20] == sRes, ""expectation violation""
    expect 4 == sizeRead, ""expectation violation""
    expect !isDoneReading, ""expectation violation""
    var uint16 :- reader.ReadUInt16();
    var expectedUint16 := SeqToUInt16([50, 100]);
    sizeRead := reader.GetSizeRead();
    isDoneReading := reader.IsDoneReading();
    expect expectedUint16 == uint16, ""expectation violation""
    expect 6 == sizeRead, ""expectation violation""
    expect !isDoneReading, ""expectation violation""
    var uint32 :- reader.ReadUInt32();
    var expectedUint32 := SeqToUInt32([150, 200, 250, 255]);
    sizeRead := reader.GetSizeRead();
    isDoneReading := reader.IsDoneReading();
    expect expectedUint32 == uint32, ""expectation violation""
    expect 10 == sizeRead, ""expectation violation""
    expect isDoneReading, ""expectation violation""
    var isByteFailure := reader.ReadByte();
    sizeRead := reader.GetSizeRead();
    isDoneReading := reader.IsDoneReading();
    expect isByteFailure.Failure?, ""expectation violation""
    expect 10 == sizeRead, ""expectation violation""
    expect isDoneReading, ""expectation violation""
    var isBytesFailure := reader.ReadBytes(1);
    sizeRead := reader.GetSizeRead();
    isDoneReading := reader.IsDoneReading();
    expect isBytesFailure.Failure?, ""expectation violation""
    expect 10 == sizeRead, ""expectation violation""
    expect isDoneReading, ""expectation violation""
    var isUint16Failure := reader.ReadUInt16();
    sizeRead := reader.GetSizeRead();
    isDoneReading := reader.IsDoneReading();
    expect isUint16Failure.Failure?, ""expectation violation""
    expect 10 == sizeRead, ""expectation violation""
    expect isDoneReading, ""expectation violation""
    var isUint32Failure := reader.ReadUInt32();
    sizeRead := reader.GetSizeRead();
    isDoneReading := reader.IsDoneReading();
    expect isUint32Failure.Failure?, ""expectation violation""
    expect 10 == sizeRead, ""expectation violation""
    expect isDoneReading, ""expectation violation""
  }

  method {:test} TestSeqWriter()
  {
    var writer := new Streams.SeqWriter<nat>();
    expect [] == writer.data, ""expectation violation""
    var elemSize := writer.WriteElements([]);
    expect 0 == elemSize, ""expectation violation""
    expect [] == writer.data, ""expectation violation""
    elemSize := writer.WriteElements([0, 100, 200]);
    expect 3 == elemSize, ""expectation violation""
    expect [0, 100, 200] == writer.data, ""expectation violation""
    elemSize := writer.WriteElements([300, 400, 500, 600]);
    expect 4 == elemSize, ""expectation violation""
    expect [0, 100, 200, 300, 400, 500, 600] == writer.data, ""expectation violation""
  }

  method {:test} TestByteWriter()
  {
    var writer := new Streams.ByteWriter();
    var dataWritten := writer.GetDataWritten();
    expect [] == dataWritten, ""expectation violation""
    var sizeWritten := writer.GetSizeWritten();
    expect 0 == sizeWritten, ""expectation violation""
    var res := writer.WriteByte(0);
    expect 1 == res, ""expectation violation""
    dataWritten := writer.GetDataWritten();
    expect [0] == dataWritten, ""expectation violation""
    sizeWritten := writer.GetSizeWritten();
    expect 1 == sizeWritten, ""expectation violation""
    res := writer.WriteBytes([]);
    expect 0 == res, ""expectation violation""
    dataWritten := writer.GetDataWritten();
    expect [0] == dataWritten, ""expectation violation""
    sizeWritten := writer.GetSizeWritten();
    expect 1 == sizeWritten, ""expectation violation""
    res := writer.WriteBytes([5, 50, 100]);
    expect 3 == res, ""expectation violation""
    dataWritten := writer.GetDataWritten();
    expect [0, 5, 50, 100] == dataWritten, ""expectation violation""
    sizeWritten := writer.GetSizeWritten();
    expect 4 == sizeWritten, ""expectation violation""
    var uint16Written := SeqToUInt16([150, 200]);
    res := writer.WriteUInt16(uint16Written);
    expect 2 == res, ""expectation violation""
    dataWritten := writer.GetDataWritten();
    expect [0, 5, 50, 100, 150, 200] == dataWritten, ""expectation violation""
    sizeWritten := writer.GetSizeWritten();
    expect 6 == sizeWritten, ""expectation violation""
    var uint32Written := SeqToUInt32([50, 150, 200, 255]);
    res := writer.WriteUInt32(uint32Written);
    expect 4 == res, ""expectation violation""
    dataWritten := writer.GetDataWritten();
    expect [0, 5, 50, 100, 150, 200, 50, 150, 200, 255] == dataWritten, ""expectation violation""
    sizeWritten := writer.GetSizeWritten();
    expect 10 == sizeWritten, ""expectation violation""
  }
}

module {:extern ""TestUtils""} TestUtils {

  import opened StandardLibrary = StandardLibrary

  import opened Wrappers = Wrappers

  import opened UInt = StandardLibrary.UInt

  import UTF8 = UTF8

  import Materials = Materials

  import EncryptionContext = EncryptionContext

  import MessageHeader = MessageHeader

  import RawAESKeyringDef = RawAESKeyringDef

  import EncryptionSuites = EncryptionSuites
  datatype SmallEncryptionContextVariation = Empty | A | AB | BA

  const SHARED_TEST_KEY_ARN := ""arn:aws:kms:us-west-2:658956600833:key/b3537ef1-d8dc-4780-9f5a-55776cbb2f7f""

  lemma {:axiom} AssumeLongSeqIsValidUTF8(s: seq<uint8>)
    requires |s| >= 4096
    ensures UTF8.ValidUTF8Seq(s)
    decreases s

  method GenerateInvalidEncryptionContext() returns (encCtx: EncryptionContext.Map)
    ensures !EncryptionContext.Serializable(encCtx)
  {
    var validUTF8char: UTF8.ValidUTF8Bytes :- UTF8.Encode(""a"");
    var key: UTF8.ValidUTF8Bytes := [];
    while |key| < UINT16_LIMIT
      decreases UINT16_LIMIT - |key|
    {
      UTF8.ValidUTF8Concat(key, validUTF8char);
      key := key + validUTF8char;
    }
    encCtx := map[key := [0]];
    reveal EncryptionContext.Serializable();
    assert !EncryptionContext.Serializable(encCtx);
  }

  method GenerateLargeValidEncryptionContext() returns (r: EncryptionContext.Map)
    ensures EncryptionContext.Serializable(r)
  {
    assert (65536 - 1 - 2) / (2 + 2 + 2 + 1) == (65536 - 3) / 7 == 9361;
    var numMaxPairs := 9361;
    var val :- UTF8.Encode(""a"");
    var encCtx: map<UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes> := map[];
    var i := 0;
    while |encCtx| < numMaxPairs && i < 65536
      invariant forall k: seq<uint8> :: k in encCtx ==> |k| + |encCtx[k]| == 3
      decreases 65536 - i
    {
      var key := UInt16ToSeq(i as uint16);
      if UTF8.ValidUTF8Seq(key) {
        encCtx := encCtx[key := val];
      }
      i := i + 1;
    }
    expect |encCtx| == numMaxPairs, ""expectation violation""
    assert EncryptionContext.Serializable(encCtx) by {
      reveal EncryptionContext.Serializable();
      assert EncryptionContext.Length(encCtx) < UINT16_LIMIT by {
        ghost var keys: seq<UTF8.ValidUTF8Bytes> := SetToOrderedSequence(encCtx.Keys, UInt.UInt8Less);
        ghost var kvPairs := seq(|keys|, (i: int) requires 0 <= i < |keys| => (keys[i], encCtx[keys[i]]));
        KVPairsLengthBound(kvPairs, |kvPairs|, 3);
        assert EncryptionContext.LinearLength(kvPairs, 0, |kvPairs|) <= 2 + numMaxPairs * 7;
      }
    }
    return encCtx;
  }

  method ExpectSerializableEncryptionContext(encCtx: EncryptionContext.Map)
    ensures EncryptionContext.Serializable(encCtx)
    decreases encCtx
  {
    var valid := EncryptionContext.CheckSerializable(encCtx);
    expect valid, ""expectation violation""
  }

  method ExpectNonSerializableEncryptionContext(encCtx: EncryptionContext.Map)
    decreases encCtx
  {
    var valid := EncryptionContext.CheckSerializable(encCtx);
    expect !valid, ""expectation violation""
  }

  method SmallEncryptionContext(v: SmallEncryptionContextVariation) returns (encryptionContext: EncryptionContext.Map)
    ensures EncryptionContext.Serializable(encryptionContext)
    ensures encryptionContext.Keys !! Materials.RESERVED_KEY_VALUES
    decreases v
  {
    var keyA :- UTF8.Encode(""keyA"");
    var valA :- UTF8.Encode(""valA"");
    var keyB :- UTF8.Encode(""keyB"");
    var valB :- UTF8.Encode(""valB"");
    match v {
      case {:split false} Empty() =>
        encryptionContext := map[];
      case {:split false} A() =>
        encryptionContext := map[keyA := valA];
      case {:split false} AB() =>
        encryptionContext := map[keyA := valA, keyB := valB];
      case {:split false} BA() =>
        encryptionContext := map[keyB := valB, keyA := valA];
    }
    ValidSmallEncryptionContext(encryptionContext);
  }

  lemma ValidSmallEncryptionContext(encryptionContext: EncryptionContext.Map)
    requires |encryptionContext| <= 5
    requires forall k: seq<uint8> :: k in encryptionContext.Keys ==> |k| < 100 && |encryptionContext[k]| < 100
    ensures EncryptionContext.Serializable(encryptionContext)
    decreases encryptionContext
  {
    reveal EncryptionContext.Serializable();
    assert EncryptionContext.Length(encryptionContext) < UINT16_LIMIT by {
      if |encryptionContext| != 0 {
        ghost var keys: seq<UTF8.ValidUTF8Bytes> := SetToOrderedSequence(encryptionContext.Keys, UInt.UInt8Less);
        ghost var kvPairs := seq(|keys|, (i: int) requires 0 <= i < |keys| => (keys[i], encryptionContext[keys[i]]));
        assert EncryptionContext.Length(encryptionContext) == 2 + EncryptionContext.LinearLength(kvPairs, 0, |kvPairs|);
        ghost var n := |kvPairs|;
        assert n <= 5;
        assert EncryptionContext.LinearLength(kvPairs, 0, n) <= n * 204 by {
          KVPairsLengthBound(kvPairs, |kvPairs|, 200);
        }
        assert n * 204 <= 1020 < UINT16_LIMIT;
      }
    }
  }

  lemma /*{:_induction kvPairs, n}*/ KVPairsLengthBound(kvPairs: EncryptionContext.Linear, n: nat, kvBound: int)
    requires n <= |kvPairs|
    requires forall i: int :: 0 <= i < n ==> |kvPairs[i].0| + |kvPairs[i].1| <= kvBound
    ensures EncryptionContext.LinearLength(kvPairs, 0, n) <= n * (4 + kvBound)
    decreases kvPairs, n, kvBound
  {
  }

  method MakeAESKeyring() returns (res: Result<RawAESKeyringDef.RawAESKeyring, string>)
  {
    var namespace :- UTF8.Encode(""namespace"");
    var name :- UTF8.Encode(""MyKeyring"");
    var keyring := new RawAESKeyringDef.RawAESKeyring(namespace, name, seq(32, (i: int) => 0), EncryptionSuites.AES_GCM_256);
    return Success(keyring);
  }

  method NamespaceAndName(n: nat) returns (namespace: UTF8.ValidUTF8Bytes, name: UTF8.ValidUTF8Bytes)
    requires 0 <= n < 10
    ensures |namespace| < UINT16_LIMIT
    ensures |name| < UINT16_LIMIT
    decreases n
  {
    var s := ""child"" + [n as char + '0'];
    namespace :- UTF8.Encode(s + "" Namespace"");
    name :- UTF8.Encode(s + "" Name"");
  }
}

module TestUTF8 {

  import opened UInt = StandardLibrary.UInt

  import opened UTF8 = UTF8
  method {:test} TestEncodeHappyCase()
  {
    var unicodeString := ""abc\u0306\u01FD\u03B2"";
    var expectedBytes := [97, 98, 99, 204, 134, 199, 189, 206, 178];
    var encoded :- UTF8.Encode(unicodeString);
    expect expectedBytes == encoded, ""expectation violation""
  }

  method {:test} TestEncodeInvalidUnicode()
  {
    var invalidUnicode := ""abc\uD800"";
    var encoded := UTF8.Encode(invalidUnicode);
    expect encoded.Failure?, ""expectation violation""
  }

  method {:test} TestDecodeHappyCase()
  {
    var unicodeBytes := [97, 98, 99, 204, 134, 199, 189, 206, 178];
    assert UTF8.ValidUTF8Range(unicodeBytes, 3, 9);
    assert UTF8.ValidUTF8Range(unicodeBytes, 0, 9);
    var expectedString := ""abc\u0306\u01FD\u03B2"";
    var decoded :- UTF8.Decode(unicodeBytes);
    expect expectedString == decoded, ""expectation violation""
  }

  method {:test} TestDecodeInvalidUnicode()
  {
    var invalidUnicode := [97, 98, 99, 237, 160, 128];
    expect !ValidUTF8Seq(invalidUnicode), ""expectation violation""
  }

  method {:test} Test1Byte()
  {
    var decoded := ""\u0000"";
    var encoded :- UTF8.Encode(decoded);
    expect [0] == encoded, ""expectation violation""
    expect Uses1Byte(encoded), ""expectation violation""
    var redecoded :- UTF8.Decode(encoded);
    expect decoded == redecoded, ""expectation violation""
    decoded := ""\u0020"";
    encoded :- UTF8.Encode(decoded);
    expect [32] == encoded, ""expectation violation""
    expect Uses1Byte(encoded), ""expectation violation""
    redecoded :- UTF8.Decode(encoded);
    expect decoded == redecoded, ""expectation violation""
    decoded := ""$"";
    encoded :- UTF8.Encode(decoded);
    expect [36] == encoded, ""expectation violation""
    expect Uses1Byte(encoded), ""expectation violation""
    redecoded :- UTF8.Decode(encoded);
    expect decoded == redecoded, ""expectation violation""
    decoded := ""0"";
    encoded :- UTF8.Encode(decoded);
    expect [48] == encoded, ""expectation violation""
    expect Uses1Byte(encoded), ""expectation violation""
    redecoded :- UTF8.Decode(encoded);
    expect decoded == redecoded, ""expectation violation""
    decoded := ""A"";
    encoded :- UTF8.Encode(decoded);
    expect [65] == encoded, ""expectation violation""
    expect Uses1Byte(encoded), ""expectation violation""
    redecoded :- UTF8.Decode(encoded);
    expect decoded == redecoded, ""expectation violation""
    decoded := ""a"";
    encoded :- UTF8.Encode(decoded);
    expect [97] == encoded, ""expectation violation""
    expect Uses1Byte(encoded), ""expectation violation""
    redecoded :- UTF8.Decode(encoded);
    expect decoded == redecoded, ""expectation violation""
  }

  method {:test} Test2Bytes()
  {
    var decoded := ""\u00A3"";
    var encoded :- UTF8.Encode(decoded);
    expect [194, 163] == encoded, ""expectation violation""
    expect Uses2Bytes(encoded), ""expectation violation""
    var redecoded :- UTF8.Decode(encoded);
    expect decoded == redecoded, ""expectation violation""
    decoded := ""\u00A9"";
    encoded :- UTF8.Encode(decoded);
    expect [194, 169] == encoded, ""expectation violation""
    expect Uses2Bytes(encoded), ""expectation violation""
    redecoded :- UTF8.Decode(encoded);
    expect decoded == redecoded, ""expectation violation""
    decoded := ""\u00AE"";
    encoded :- UTF8.Encode(decoded);
    expect [194, 174] == encoded, ""expectation violation""
    expect Uses2Bytes(encoded), ""expectation violation""
    redecoded :- UTF8.Decode(encoded);
    expect decoded == redecoded, ""expectation violation""
    decoded := ""\u03C0"";
    encoded :- UTF8.Encode(decoded);
    expect [207, 128] == encoded, ""expectation violation""
    expect Uses2Bytes(encoded), ""expectation violation""
    redecoded :- UTF8.Decode(encoded);
    expect decoded == redecoded, ""expectation violation""
  }

  method {:test} Test3Bytes()
  {
    var decoded := ""\u2386"";
    var encoded :- UTF8.Encode(decoded);
    expect [226, 142, 134] == encoded, ""expectation violation""
    expect Uses3Bytes(encoded), ""expectation violation""
    var redecoded :- UTF8.Decode(encoded);
    expect decoded == redecoded, ""expectation violation""
    decoded := ""\u2387"";
    encoded :- UTF8.Encode(decoded);
    expect [226, 142, 135] == encoded, ""expectation violation""
    expect Uses3Bytes(encoded), ""expectation violation""
    redecoded :- UTF8.Decode(encoded);
    expect decoded == redecoded, ""expectation violation""
    decoded := ""\u231B"";
    encoded :- UTF8.Encode(decoded);
    expect [226, 140, 155] == encoded, ""expectation violation""
    expect Uses3Bytes(encoded), ""expectation violation""
    redecoded :- UTF8.Decode(encoded);
    expect decoded == redecoded, ""expectation violation""
    decoded := ""\u1D78"";
    encoded :- UTF8.Encode(decoded);
    expect [225, 181, 184] == encoded, ""expectation violation""
    expect Uses3Bytes(encoded), ""expectation violation""
    redecoded :- UTF8.Decode(encoded);
    expect decoded == redecoded, ""expectation violation""
    decoded := ""\u732B"";
    encoded :- UTF8.Encode(decoded);
    expect [231, 140, 171] == encoded, ""expectation violation""
    expect Uses3Bytes(encoded), ""expectation violation""
    redecoded :- UTF8.Decode(encoded);
    expect decoded == redecoded, ""expectation violation""
  }

  method {:test} Test4Bytes()
  {
    var decoded := ""\uD808\uDC00"";
    var encoded :- UTF8.Encode(decoded);
    expect [240, 146, 128, 128] == encoded, ""expectation violation""
    expect Uses4Bytes(encoded), ""expectation violation""
    var redecoded :- UTF8.Decode(encoded);
    expect decoded == redecoded, ""expectation violation""
    decoded := ""\uD835\uDFC1"";
    encoded :- UTF8.Encode(decoded);
    expect [240, 157, 159, 129] == encoded, ""expectation violation""
    expect Uses4Bytes(encoded), ""expectation violation""
    redecoded :- UTF8.Decode(encoded);
    expect decoded == redecoded, ""expectation violation""
  }
}

module Wrappers {
  datatype Option<+T> = None | Some(value: T) {
    function method ToResult(): Result<T, string>
      decreases this
    {
      match this
      case Some(v) =>
        Success(v)
      case None() =>
        Failure(""Option is None"")
    }

    function method UnwrapOr(default: T): T
      decreases this
    {
      match this
      case Some(v) =>
        v
      case None() =>
        default
    }

    predicate method IsFailure()
      decreases this
    {
      None?
    }

    function method PropagateFailure<U>(): Option<U>
      requires None?
      decreases this
    {
      None
    }

    function method Extract(): T
      requires Some?
      decreases this
    {
      value
    }
  }

  datatype Result<+T, +R> = Success(value: T) | Failure(error: R) {
    function method ToOption(): Option<T>
      decreases this
    {
      match this
      case Success(s) =>
        Some(s)
      case Failure(e) =>
        None()
    }

    function method UnwrapOr(default: T): T
      decreases this
    {
      match this
      case Success(s) =>
        s
      case Failure(e) =>
        default
    }

    predicate method IsFailure()
      decreases this
    {
      Failure?
    }

    function method PropagateFailure<U>(): Result<U, R>
      requires Failure?
      decreases this
    {
      Failure(this.error)
    }

    function method Extract(): T
      requires Success?
      decreases this
    {
      value
    }
  }

  datatype Outcome<E> = Pass | Fail(error: E) {
    predicate method IsFailure()
      decreases this
    {
      Fail?
    }

    function method PropagateFailure<U>(): Result<U, E>
      requires Fail?
      decreases this
    {
      Failure(this.error)
    }
  }

  function method Need<E>(condition: bool, error: E): (result: Outcome<E>)
    decreases condition
  {
    if condition then
      Pass
    else
      Fail(error)
  }
}

module Seq {

  import opened Wrappers = Wrappers

  import Math = Math
  function method First<T>(s: seq<T>): T
    requires |s| > 0
    decreases s
  {
    s[0]
  }

  function method DropFirst<T>(s: seq<T>): seq<T>
    requires |s| > 0
    decreases s
  {
    s[1..]
  }

  function method Last<T>(s: seq<T>): T
    requires |s| > 0
    decreases s
  {
    s[|s| - 1]
  }

  function method DropLast<T>(s: seq<T>): seq<T>
    requires |s| > 0
    decreases s
  {
    s[..|s| - 1]
  }

  lemma LemmaLast<T>(s: seq<T>)
    requires |s| > 0
    ensures DropLast(s) + [Last(s)] == s
    decreases s
  {
  }

  lemma LemmaAppendLast<T>(a: seq<T>, b: seq<T>)
    requires 0 < |a + b| && 0 < |b|
    ensures Last(a + b) == Last(b)
    decreases a, b
  {
  }

  lemma LemmaConcatIsAssociative<T>(a: seq<T>, b: seq<T>, c: seq<T>)
    ensures a + (b + c) == a + b + c
    decreases a, b, c
  {
  }

  predicate IsPrefix<T>(a: seq<T>, b: seq<T>)
    ensures IsPrefix(a, b) ==> |a| <= |b| && a == b[..|a|]
    decreases a, b
  {
    a <= b
  }

  predicate IsSuffix<T>(a: seq<T>, b: seq<T>)
    decreases a, b
  {
    |a| <= |b| &&
    a == b[|b| - |a|..]
  }

  lemma LemmaSplitAt<T>(s: seq<T>, pos: nat)
    requires pos < |s|
    ensures s[..pos] + s[pos..] == s
    decreases s, pos
  {
  }

  lemma LemmaElementFromSlice<T>(s: seq<T>, s': seq<T>, a: int, b: int, pos: nat)
    requires 0 <= a <= b <= |s|
    requires s' == s[a .. b]
    requires a <= pos < b
    ensures pos - a < |s'|
    ensures s'[pos - a] == s[pos]
    decreases s, s', a, b, pos
  {
  }

  lemma LemmaSliceOfSlice<T>(s: seq<T>, s1: int, e1: int, s2: int, e2: int)
    requires 0 <= s1 <= e1 <= |s|
    requires 0 <= s2 <= e2 <= e1 - s1
    ensures s[s1 .. e1][s2 .. e2] == s[s1 + s2 .. s1 + e2]
    decreases s, s1, e1, s2, e2
  {
  }

  method ToArray<T>(s: seq<T>) returns (a: array<T>)
    ensures fresh(a)
    ensures a.Length == |s|
    ensures forall i: int :: 0 <= i < |s| ==> a[i] == s[i]
    decreases s
  {
    a := new T[|s|] ((i: int) requires 0 <= i < |s| => s[i]);
  }

  function method {:opaque} {:fuel 0, 0} ToSet<T>(s: seq<T>): set<T>
    decreases s
  {
    set x: T {:trigger x in s} | x in s
  }

  lemma LemmaCardinalityOfSet<T>(s: seq<T>)
    ensures |ToSet(s)| <= |s|
    decreases s
  {
  }

  lemma LemmaCardinalityOfEmptySetIs0<T>(s: seq<T>)
    ensures |ToSet(s)| == 0 <==> |s| == 0
    decreases s
  {
  }

  predicate {:opaque} {:fuel 0, 0} HasNoDuplicates<T>(s: seq<T>)
    decreases s
  {
    forall i: int, j: int {:trigger s[i], s[j]} :: 
      0 <= i < |s| &&
      0 <= j < |s| &&
      i != j ==>
        s[i] != s[j]
  }

  lemma {:timeLimitMultiplier 3} /*{:_timeLimit 30}*/ LemmaNoDuplicatesInConcat<T>(a: seq<T>, b: seq<T>)
    requires HasNoDuplicates(a)
    requires HasNoDuplicates(b)
    requires multiset(a) !! multiset(b)
    ensures HasNoDuplicates(a + b)
    decreases a, b
  {
  }

  lemma LemmaCardinalityOfSetNoDuplicates<T>(s: seq<T>)
    requires HasNoDuplicates(s)
    ensures |ToSet(s)| == |s|
    decreases s
  {
  }

  lemma LemmaNoDuplicatesCardinalityOfSet<T>(s: seq<T>)
    requires |ToSet(s)| == |s|
    ensures HasNoDuplicates(s)
    decreases s
  {
  }

  lemma LemmaMultisetHasNoDuplicates<T>(s: seq<T>)
    requires HasNoDuplicates(s)
    ensures forall x: T {:trigger multiset(s)[x]} | x in multiset(s) :: multiset(s)[x] == 1
    decreases s
  {
  }

  function method {:opaque} {:fuel 0, 0} IndexOf<T(==)>(s: seq<T>, v: T): (i: nat)
    requires v in s
    ensures i < |s| && s[i] == v
    ensures forall j: int {:trigger s[j]} :: 0 <= j < i ==> s[j] != v
    decreases s
  {
    if s[0] == v then
      0
    else
      1 + IndexOf(s[1..], v)
  }

  function method {:opaque} {:fuel 0, 0} IndexOfOption<T(==)>(s: seq<T>, v: T): (o: Option<nat>)
    ensures if o.Some? then o.value < |s| && s[o.value] == v && forall j: int {:trigger s[j]} :: 0 <= j < o.value ==> s[j] != v else v !in s
    decreases s
  {
    if |s| == 0 then
      None()
    else if s[0] == v then
      Some(0)
    else
      var o': Option<nat> := IndexOfOption(s[1..], v); if o'.Some? then Some(o'.value + 1) else None()
  }

  function method {:opaque} {:fuel 0, 0} LastIndexOf<T(==)>(s: seq<T>, v: T): (i: nat)
    requires v in s
    ensures i < |s| && s[i] == v
    ensures forall j: int {:trigger s[j]} :: i < j < |s| ==> s[j] != v
    decreases s
  {
    if s[|s| - 1] == v then
      |s| - 1
    else
      LastIndexOf(s[..|s| - 1], v)
  }

  function method {:opaque} {:fuel 0, 0} LastIndexOfOption<T(==)>(s: seq<T>, v: T): (o: Option<nat>)
    ensures if o.Some? then o.value < |s| && s[o.value] == v && forall j: int {:trigger s[j]} :: o.value < j < |s| ==> s[j] != v else v !in s
    decreases s
  {
    if |s| == 0 then
      None()
    else if s[|s| - 1] == v then
      Some(|s| - 1)
    else
      LastIndexOfOption(s[..|s| - 1], v)
  }

  function method {:opaque} {:fuel 0, 0} Remove<T>(s: seq<T>, pos: nat): (s': seq<T>)
    requires pos < |s|
    ensures |s'| == |s| - 1
    ensures forall i: int {:trigger s'[i], s[i]} | 0 <= i < pos :: s'[i] == s[i]
    ensures forall i: int {:trigger s'[i]} | pos <= i < |s| - 1 :: s'[i] == s[i + 1]
    decreases s, pos
  {
    s[..pos] + s[pos + 1..]
  }

  function method {:opaque} {:fuel 0, 0} RemoveValue<T(==)>(s: seq<T>, v: T): (s': seq<T>)
    ensures v !in s ==> s == s'
    ensures v in s ==> |multiset(s')| == |multiset(s)| - 1
    ensures v in s ==> multiset(s')[v] == multiset(s)[v] - 1
    ensures HasNoDuplicates(s) ==> HasNoDuplicates(s') && ToSet(s') == ToSet(s) - {v}
    decreases s
  {
    reveal HasNoDuplicates();
    reveal ToSet();
    if v !in s then
      s
    else
      var i: nat := IndexOf(s, v); assert s == s[..i] + [v] + s[i + 1..]; s[..i] + s[i + 1..]
  }

  function method {:opaque} {:fuel 0, 0} Insert<T>(s: seq<T>, a: T, pos: nat): seq<T>
    requires pos <= |s|
    ensures |Insert(s, a, pos)| == |s| + 1
    ensures forall i: int {:trigger Insert(s, a, pos)[i], s[i]} :: 0 <= i < pos ==> Insert(s, a, pos)[i] == s[i]
    ensures forall i: int {:trigger s[i]} :: pos <= i < |s| ==> Insert(s, a, pos)[i + 1] == s[i]
    ensures Insert(s, a, pos)[pos] == a
    ensures multiset(Insert(s, a, pos)) == multiset(s) + multiset{a}
    decreases s, pos
  {
    assert s == s[..pos] + s[pos..];
    s[..pos] + [a] + s[pos..]
  }

  function method {:opaque} {:fuel 0, 0} Reverse<T>(s: seq<T>): (s': seq<T>)
    ensures |s'| == |s|
    ensures forall i: int {:trigger s'[i]} {:trigger s[|s| - i - 1]} :: 0 <= i < |s| ==> s'[i] == s[|s| - i - 1]
    decreases s
  {
    if s == [] then
      []
    else
      [s[|s| - 1]] + Reverse(s[0 .. |s| - 1])
  }

  function method {:opaque} {:fuel 0, 0} Repeat<T>(v: T, length: nat): (s: seq<T>)
    ensures |s| == length
    ensures forall i: nat {:trigger s[i]} | i < |s| :: s[i] == v
    decreases length
  {
    if length == 0 then
      []
    else
      [v] + Repeat(v, length - 1)
  }

  function method {:opaque} {:fuel 0, 0} Unzip<A, B>(s: seq<(A, B)>): (seq<A>, seq<B>)
    ensures |Unzip(s).0| == |Unzip(s).1| == |s|
    ensures forall i: int {:trigger Unzip(s).0[i]} {:trigger Unzip(s).1[i]} :: 0 <= i < |s| ==> (Unzip(s).0[i], Unzip(s).1[i]) == s[i]
    decreases s
  {
    if |s| == 0 then
      ([], [])
    else
      var (a: seq<A>, b: seq<B>) := Unzip(DropLast(s)); (a + [Last(s).0], b + [Last(s).1])
  }

  function method {:opaque} {:fuel 0, 0} Zip<A, B>(a: seq<A>, b: seq<B>): seq<(A, B)>
    requires |a| == |b|
    ensures |Zip(a, b)| == |a|
    ensures forall i: int {:trigger Zip(a, b)[i]} :: 0 <= i < |Zip(a, b)| ==> Zip(a, b)[i] == (a[i], b[i])
    ensures Unzip(Zip(a, b)).0 == a
    ensures Unzip(Zip(a, b)).1 == b
    decreases a, b
  {
    if |a| == 0 then
      []
    else
      Zip(DropLast(a), DropLast(b)) + [(Last(a), Last(b))]
  }

  lemma /*{:_induction s}*/ LemmaZipOfUnzip<A, B>(s: seq<(A, B)>)
    ensures Zip(Unzip(s).0, Unzip(s).1) == s
    decreases s
  {
  }

  function method {:opaque} {:fuel 0, 0} Max(s: seq<int>): int
    requires 0 < |s|
    ensures forall k: int {:trigger k in s} :: k in s ==> Max(s) >= k
    ensures Max(s) in s
    decreases s
  {
    assert s == [s[0]] + s[1..];
    if |s| == 1 then
      s[0]
    else
      Math.Max(s[0], Max(s[1..]))
  }

  lemma /*{:_induction a, b}*/ LemmaMaxOfConcat(a: seq<int>, b: seq<int>)
    requires 0 < |a| && 0 < |b|
    ensures Max(a + b) >= Max(a)
    ensures Max(a + b) >= Max(b)
    ensures forall i: int {:trigger i in [Max(a + b)]} :: i in a + b ==> Max(a + b) >= i
    decreases a, b
  {
  }

  function method {:opaque} {:fuel 0, 0} Min(s: seq<int>): int
    requires 0 < |s|
    ensures forall k: int {:trigger k in s} :: k in s ==> Min(s) <= k
    ensures Min(s) in s
    decreases s
  {
    assert s == [s[0]] + s[1..];
    if |s| == 1 then
      s[0]
    else
      Math.Min(s[0], Min(s[1..]))
  }

  lemma /*{:_induction a, b}*/ LemmaMinOfConcat(a: seq<int>, b: seq<int>)
    requires 0 < |a| && 0 < |b|
    ensures Min(a + b) <= Min(a)
    ensures Min(a + b) <= Min(b)
    ensures forall i: int {:trigger i in a + b} :: i in a + b ==> Min(a + b) <= i
    decreases a, b
  {
  }

  lemma /*{:_induction s}*/ LemmaSubseqMax(s: seq<int>, from: nat, to: nat)
    requires from < to <= |s|
    ensures Max(s[from .. to]) <= Max(s)
    decreases s, from, to
  {
  }

  lemma /*{:_induction s}*/ LemmaSubseqMin(s: seq<int>, from: nat, to: nat)
    requires from < to <= |s|
    ensures Min(s[from .. to]) >= Min(s)
    decreases s, from, to
  {
  }

  function method Flatten<T>(s: seq<seq<T>>): seq<T>
    decreases |s|
  {
    if |s| == 0 then
      []
    else
      s[0] + Flatten(s[1..])
  }

  lemma /*{:_induction a, b}*/ LemmaFlattenConcat<T>(a: seq<seq<T>>, b: seq<seq<T>>)
    ensures Flatten(a + b) == Flatten(a) + Flatten(b)
    decreases a, b
  {
  }

  function method FlattenReverse<T>(s: seq<seq<T>>): seq<T>
    decreases |s|
  {
    if |s| == 0 then
      []
    else
      FlattenReverse(DropLast(s)) + Last(s)
  }

  lemma /*{:_induction a, b}*/ LemmaFlattenReverseConcat<T>(a: seq<seq<T>>, b: seq<seq<T>>)
    ensures FlattenReverse(a + b) == FlattenReverse(a) + FlattenReverse(b)
    decreases a, b
  {
  }

  lemma /*{:_induction s}*/ LemmaFlattenAndFlattenReverseAreEquivalent<T>(s: seq<seq<T>>)
    ensures Flatten(s) == FlattenReverse(s)
    decreases s
  {
  }

  lemma /*{:_induction s}*/ LemmaFlattenLengthGeSingleElementLength<T>(s: seq<seq<T>>, i: int)
    requires 0 <= i < |s|
    ensures |FlattenReverse(s)| >= |s[i]|
    decreases s, i
  {
  }

  lemma /*{:_induction s}*/ LemmaFlattenLengthLeMul<T>(s: seq<seq<T>>, j: int)
    requires forall i: int {:trigger s[i]} | 0 <= i < |s| :: |s[i]| <= j
    ensures |FlattenReverse(s)| <= |s| * j
    decreases s, j
  {
  }

  function method {:opaque} {:fuel 0, 0} Map<T, R>(f: T ~> R, s: seq<T>): (result: seq<R>)
    requires forall i: int {:trigger s[i]} :: 0 <= i < |s| ==> f.requires(s[i])
    reads set i: int, o: object? {:trigger o in f.reads(s[i])} | 0 <= i < |s| && o in f.reads(s[i]) :: o
    ensures |result| == |s|
    ensures forall i: int {:trigger result[i]} :: 0 <= i < |s| ==> result[i] == f(s[i])
    decreases set i: int, o: object? {:trigger o in f.reads(s[i])} | 0 <= i < |s| && o in f.reads(s[i]) :: o, s
  {
    if |s| == 0 then
      []
    else
      [f(s[0])] + Map(f, s[1..])
  }

  function method {:opaque} {:fuel 0, 0} MapWithResult<T, R, E>(f: T ~> Result<R, E>, s: seq<T>): (result: Result<seq<R>, E>)
    requires forall i: int :: 0 <= i < |s| ==> f.requires(s[i])
    reads set i: int, o: object? {:trigger o in f.reads(s[i])} | 0 <= i < |s| && o in f.reads(s[i]) :: o
    ensures result.Success? ==> |result.value| == |s| && forall i: int :: 0 <= i < |s| ==> f(s[i]).Success? && result.value[i] == f(s[i]).value
    decreases set i: int, o: object? {:trigger o in f.reads(s[i])} | 0 <= i < |s| && o in f.reads(s[i]) :: o, s
  {
    if |s| == 0 then
      Success([])
    else
      var head: R :- f(s[0]); var tail: seq<R> :- MapWithResult(f, s[1..]); Success([head] + tail)
  }

  lemma {:opaque} /*{:_induction f, a, b}*/ LemmaMapDistributesOverConcat<T, R>(f: T ~> R, a: seq<T>, b: seq<T>)
    requires forall i: int {:trigger a[i]} :: 0 <= i < |a| ==> f.requires(a[i])
    requires forall j: int {:trigger b[j]} :: 0 <= j < |b| ==> f.requires(b[j])
    ensures Map(f, a + b) == Map(f, a) + Map(f, b)
    decreases a, b
  {
  }

  function method {:opaque} {:fuel 0, 0} Filter<T>(f: T ~> bool, s: seq<T>): (result: seq<T>)
    requires forall i: int :: 0 <= i < |s| ==> f.requires(s[i])
    reads f.reads
    ensures |result| <= |s|
    ensures forall i: nat {:trigger result[i]} :: i < |result| && f.requires(result[i]) ==> f(result[i])
    decreases set _x0: T, _o0: object? | _o0 in f.reads(_x0) :: _o0, s
  {
    if |s| == 0 then
      []
    else
      (if f(s[0]) then [s[0]] else []) + Filter(f, s[1..])
  }

  lemma {:opaque} /*{:_induction f, a, b}*/ LemmaFilterDistributesOverConcat<T>(f: T ~> bool, a: seq<T>, b: seq<T>)
    requires forall i: int {:trigger a[i]} :: 0 <= i < |a| ==> f.requires(a[i])
    requires forall j: int {:trigger b[j]} :: 0 <= j < |b| ==> f.requires(b[j])
    ensures Filter(f, a + b) == Filter(f, a) + Filter(f, b)
    decreases a, b
  {
  }

  function method {:opaque} {:fuel 0, 0} FoldLeft<A, T>(f: (A, T) -> A, init: A, s: seq<T>): A
    decreases s
  {
    if |s| == 0 then
      init
    else
      FoldLeft(f, f(init, s[0]), s[1..])
  }

  lemma {:opaque} /*{:_induction f, a, b}*/ LemmaFoldLeftDistributesOverConcat<A, T>(f: (A, T) -> A, init: A, a: seq<T>, b: seq<T>)
    requires 0 <= |a + b|
    ensures FoldLeft(f, init, a + b) == FoldLeft(f, FoldLeft(f, init, a), b)
    decreases a, b
  {
  }

  predicate InvFoldLeft<A(!new), B(!new)>(inv: (B, seq<A>) -> bool, stp: (B, A, B) -> bool)
  {
    forall x: A, xs: seq<A>, b: B, b': B :: 
      inv(b, [x] + xs) &&
      stp(b, x, b') ==>
        inv(b', xs)
  }

  lemma /*{:_induction f, xs}*/ LemmaInvFoldLeft<A, B>(inv: (B, seq<A>) -> bool, stp: (B, A, B) -> bool, f: (B, A) -> B, b: B, xs: seq<A>)
    requires InvFoldLeft(inv, stp)
    requires forall b: B, a: A :: stp(b, a, f(b, a))
    requires inv(b, xs)
    ensures inv(FoldLeft(f, b, xs), [])
    decreases xs
  {
  }

  function method {:opaque} {:fuel 0, 0} FoldRight<A, T>(f: (T, A) -> A, s: seq<T>, init: A): A
    decreases s
  {
    if |s| == 0 then
      init
    else
      f(s[0], FoldRight(f, s[1..], init))
  }

  lemma {:opaque} /*{:_induction f, a, b}*/ LemmaFoldRightDistributesOverConcat<A, T>(f: (T, A) -> A, init: A, a: seq<T>, b: seq<T>)
    requires 0 <= |a + b|
    ensures FoldRight(f, a + b, init) == FoldRight(f, a, FoldRight(f, b, init))
    decreases a, b
  {
  }

  predicate InvFoldRight<A(!new), B(!new)>(inv: (seq<A>, B) -> bool, stp: (A, B, B) -> bool)
  {
    forall x: A, xs: seq<A>, b: B, b': B :: 
      inv(xs, b) &&
      stp(x, b, b') ==>
        inv([x] + xs, b')
  }

  lemma /*{:_induction f, xs}*/ LemmaInvFoldRight<A, B>(inv: (seq<A>, B) -> bool, stp: (A, B, B) -> bool, f: (A, B) -> B, b: B, xs: seq<A>)
    requires InvFoldRight(inv, stp)
    requires forall a: A, b: B :: stp(a, b, f(a, b))
    requires inv([], b)
    ensures inv(xs, FoldRight(f, xs, b))
    decreases xs
  {
  }
}

module Math {
  function method Min(a: int, b: int): int
    decreases a, b
  {
    if a < b then
      a
    else
      b
  }

  function method Max(a: int, b: int): int
    decreases a, b
  {
    if a < b then
      b
    else
      a
  }
}
")]

// Copyright by the contributors to the Dafny Project
// SPDX-License-Identifier: MIT

#if ISDAFNYRUNTIMELIB
using System; // for Func
using System.Numerics;
#endif

namespace DafnyAssembly {
  [AttributeUsage(AttributeTargets.Assembly)]
  public class DafnySourceAttribute : Attribute {
    public readonly string dafnySourceText;
    public DafnySourceAttribute(string txt) { dafnySourceText = txt; }
  }
}

namespace Dafny
{
  using System.Collections.Generic;
  using System.Collections.Immutable;
  using System.Linq;

  public interface ISet<out T>
  {
    int Count { get; }
    long LongCount { get; }
    IEnumerable<T> Elements { get; }
    IEnumerable<ISet<T>> AllSubsets { get; }
    bool Contains<G>(G t);
    bool EqualsAux(ISet<object> other);
    ISet<U> DowncastClone<U>(Func<T, U> converter);
  }

  public class Set<T> : ISet<T>
  {
    readonly ImmutableHashSet<T> setImpl;
    readonly bool containsNull;
    Set(ImmutableHashSet<T> d, bool containsNull) {
      this.setImpl = d;
      this.containsNull = containsNull;
    }
    public static readonly ISet<T> Empty = new Set<T>(ImmutableHashSet<T>.Empty, false);

    private static readonly TypeDescriptor<ISet<T>> _TYPE = new Dafny.TypeDescriptor<ISet<T>>(Empty);
    public static TypeDescriptor<ISet<T>> _TypeDescriptor() {
      return _TYPE;
    }

    public static ISet<T> FromElements(params T[] values) {
      return FromCollection(values);
    }

    public static Set<T> FromISet(ISet<T> s) {
      return s as Set<T> ?? FromCollection(s.Elements);
    }
    public static Set<T> FromCollection(IEnumerable<T> values) {
      var d = ImmutableHashSet<T>.Empty.ToBuilder();
      var containsNull = false;
      foreach (T t in values) {
        if (t == null) {
          containsNull = true;
        } else {
          d.Add(t);
        }
      }
      return new Set<T>(d.ToImmutable(), containsNull);
    }
    public static ISet<T> FromCollectionPlusOne(IEnumerable<T> values, T oneMoreValue) {
      var d = ImmutableHashSet<T>.Empty.ToBuilder();
      var containsNull = false;
      if (oneMoreValue == null) {
        containsNull = true;
      } else {
        d.Add(oneMoreValue);
      }
      foreach (T t in values) {
        if (t == null) {
          containsNull = true;
        } else {
          d.Add(t);
        }
      }
      return new Set<T>(d.ToImmutable(), containsNull);
    }
    public ISet<U> DowncastClone<U>(Func<T, U> converter) {
      if (this is ISet<U> th) {
        return th;
      } else {
        var d = ImmutableHashSet<U>.Empty.ToBuilder();
        foreach (var t in this.setImpl) {
          var u = converter(t);
          d.Add(u);
        }
        return new Set<U>(d.ToImmutable(), this.containsNull);
      }
    }
    public int Count {
      get { return this.setImpl.Count + (containsNull ? 1 : 0); }
    }
    public long LongCount {
      get { return this.setImpl.Count + (containsNull ? 1 : 0); }
    }
    public IEnumerable<T> Elements {
      get {
        if (containsNull) {
          yield return default(T);
        }
        foreach (var t in this.setImpl) {
          yield return t;
        }
      }
    }

    /// <summary>
    /// This is an inefficient iterator for producing all subsets of "this".
    /// </summary>
    public IEnumerable<ISet<T>> AllSubsets {
      get {
        // Start by putting all set elements into a list, but don't include null
        var elmts = new List<T>();
        elmts.AddRange(this.setImpl);
        var n = elmts.Count;
        var which = new bool[n];
        var s = ImmutableHashSet<T>.Empty.ToBuilder();
        while (true) {
          // yield both the subset without null and, if null is in the original set, the subset with null included
          var ihs = s.ToImmutable();
          yield return new Set<T>(ihs, false);
          if (containsNull) {
            yield return new Set<T>(ihs, true);
          }
          // "add 1" to "which", as if doing a carry chain.  For every digit changed, change the membership of the corresponding element in "s".
          int i = 0;
          for (; i < n && which[i]; i++) {
            which[i] = false;
            s.Remove(elmts[i]);
          }
          if (i == n) {
            // we have cycled through all the subsets
            break;
          }
          which[i] = true;
          s.Add(elmts[i]);
        }
      }
    }
    public bool Equals(ISet<T> other) {
      if (other == null || Count != other.Count) {
        return false;
      } else if (this == other) {
        return true;
      }
      foreach (var elmt in Elements) {
        if (!other.Contains(elmt)) {
          return false;
        }
      }
      return true;
    }
    public override bool Equals(object other) {
      if (other is ISet<T>) {
        return Equals((ISet<T>)other);
      }
      var th = this as ISet<object>;
      var oth = other as ISet<object>;
      if (th != null && oth != null) {
        // We'd like to obtain the more specific type parameter U for oth's type ISet<U>.
        // We do that by making a dynamically dispatched call, like:
        //     oth.Equals(this)
        // The hope is then that its comparison "this is ISet<U>" (that is, the first "if" test
        // above, but in the call "oth.Equals(this)") will be true and the non-virtual Equals
        // can be called. However, such a recursive call to "oth.Equals(this)" could turn
        // into infinite recursion. Therefore, we instead call "oth.EqualsAux(this)", which
        // performs the desired type test, but doesn't recurse any further.
        return oth.EqualsAux(th);
      } else {
        return false;
      }
    }

    public bool EqualsAux(ISet<object> other) {
      var s = other as ISet<T>;
      if (s != null) {
        return Equals(s);
      } else {
        return false;
      }
    }

    public override int GetHashCode() {
      var hashCode = 1;
      if (containsNull) {
        hashCode = hashCode * (Dafny.Helpers.GetHashCode(default(T)) + 3);
      }
      foreach (var t in this.setImpl) {
        hashCode = hashCode * (Dafny.Helpers.GetHashCode(t) + 3);
      }
      return hashCode;
    }
    public override string ToString() {
      var s = "{";
      var sep = "";
      if (containsNull) {
        s += sep + Dafny.Helpers.ToString(default(T));
        sep = ", ";
      }
      foreach (var t in this.setImpl) {
        s += sep + Dafny.Helpers.ToString(t);
        sep = ", ";
      }
      return s + "}";
    }
    public static bool IsProperSubsetOf(ISet<T> th, ISet<T> other) {
      return th.Count < other.Count && IsSubsetOf(th, other);
    }
    public static bool IsSubsetOf(ISet<T> th, ISet<T> other) {
      if (other.Count < th.Count) {
        return false;
      }
      foreach (T t in th.Elements) {
        if (!other.Contains(t)) {
          return false;
        }
      }
      return true;
    }
    public static bool IsDisjointFrom(ISet<T> th, ISet<T> other) {
      ISet<T> a, b;
      if (th.Count < other.Count) {
        a = th; b = other;
      } else {
        a = other; b = th;
      }
      foreach (T t in a.Elements) {
        if (b.Contains(t)) {
          return false;
        }
      }
      return true;
    }
    public bool Contains<G>(G t) {
      return t == null ? containsNull : t is T && this.setImpl.Contains((T)(object)t);
    }
    public static ISet<T> Union(ISet<T> th, ISet<T> other) {
      var a = FromISet(th);
      var b = FromISet(other);
      return new Set<T>(a.setImpl.Union(b.setImpl), a.containsNull || b.containsNull);
    }
    public static ISet<T> Intersect(ISet<T> th, ISet<T> other) {
      var a = FromISet(th);
      var b = FromISet(other);
      return new Set<T>(a.setImpl.Intersect(b.setImpl), a.containsNull && b.containsNull);
    }
    public static ISet<T> Difference(ISet<T> th, ISet<T> other) {
      var a = FromISet(th);
      var b = FromISet(other);
      return new Set<T>(a.setImpl.Except(b.setImpl), a.containsNull && !b.containsNull);
    }
  }

  public interface IMultiSet<out T>
  {
    bool IsEmpty { get; }
    int Count { get; }
    long LongCount { get; }
    IEnumerable<T> Elements { get; }
    IEnumerable<T> UniqueElements { get; }
    bool Contains<G>(G t);
    BigInteger Select<G>(G t);
    IMultiSet<T> Update<G>(G t, BigInteger i);
    bool EqualsAux(IMultiSet<object> other);
    IMultiSet<U> DowncastClone<U>(Func<T, U> converter);
  }

  public class MultiSet<T> : IMultiSet<T>
  {
    readonly ImmutableDictionary<T, BigInteger> dict;
    readonly BigInteger occurrencesOfNull;  // stupidly, a Dictionary in .NET cannot use "null" as a key
    MultiSet(ImmutableDictionary<T, BigInteger>.Builder d, BigInteger occurrencesOfNull) {
      dict = d.ToImmutable();
      this.occurrencesOfNull = occurrencesOfNull;
    }
    public static readonly MultiSet<T> Empty = new MultiSet<T>(ImmutableDictionary<T, BigInteger>.Empty.ToBuilder(), BigInteger.Zero);

    private static readonly TypeDescriptor<IMultiSet<T>> _TYPE = new Dafny.TypeDescriptor<IMultiSet<T>>(Empty);
    public static TypeDescriptor<IMultiSet<T>> _TypeDescriptor() {
      return _TYPE;
    }

    public static MultiSet<T> FromIMultiSet(IMultiSet<T> s) {
      return s as MultiSet<T> ?? FromCollection(s.Elements);
    }
    public static MultiSet<T> FromElements(params T[] values) {
      var d = ImmutableDictionary<T, BigInteger>.Empty.ToBuilder();
      var occurrencesOfNull = BigInteger.Zero;
      foreach (T t in values) {
        if (t == null) {
          occurrencesOfNull++;
        } else {
          BigInteger i;
          if (!d.TryGetValue(t, out i)) {
            i = BigInteger.Zero;
          }
          d[t] = i + 1;
        }
      }
      return new MultiSet<T>(d, occurrencesOfNull);
    }
    public static MultiSet<T> FromCollection(IEnumerable<T> values) {
      var d = ImmutableDictionary<T, BigInteger>.Empty.ToBuilder();
      var occurrencesOfNull = BigInteger.Zero;
      foreach (T t in values) {
        if (t == null) {
          occurrencesOfNull++;
        } else {
          BigInteger i;
          if (!d.TryGetValue(t, out i)) {
            i = BigInteger.Zero;
          }
          d[t] = i + 1;
        }
      }
      return new MultiSet<T>(d, occurrencesOfNull);
    }
    public static MultiSet<T> FromSeq(ISequence<T> values) {
      var d = ImmutableDictionary<T, BigInteger>.Empty.ToBuilder();
      var occurrencesOfNull = BigInteger.Zero;
      foreach (T t in values.Elements) {
        if (t == null) {
          occurrencesOfNull++;
        } else {
          BigInteger i;
          if (!d.TryGetValue(t, out i)) {
            i = BigInteger.Zero;
          }
          d[t] = i + 1;
        }
      }
      return new MultiSet<T>(d, occurrencesOfNull);
    }
    public static MultiSet<T> FromSet(ISet<T> values) {
      var d = ImmutableDictionary<T, BigInteger>.Empty.ToBuilder();
      var containsNull = false;
      foreach (T t in values.Elements) {
        if (t == null) {
          containsNull = true;
        } else {
          d[t] = BigInteger.One;
        }
      }
      return new MultiSet<T>(d, containsNull ? BigInteger.One : BigInteger.Zero);
    }
    public IMultiSet<U> DowncastClone<U>(Func<T, U> converter) {
      if (this is IMultiSet<U> th) {
        return th;
      } else {
        var d = ImmutableDictionary<U, BigInteger>.Empty.ToBuilder();
        foreach (var item in this.dict) {
          var k = converter(item.Key);
          d.Add(k, item.Value);
        }
        return new MultiSet<U>(d, this.occurrencesOfNull);
      }
    }

    public bool Equals(IMultiSet<T> other) {
      return IsSubsetOf(this, other) && IsSubsetOf(other, this);
    }
    public override bool Equals(object other) {
      if (other is IMultiSet<T>) {
        return Equals((IMultiSet<T>)other);
      }
      var th = this as IMultiSet<object>;
      var oth = other as IMultiSet<object>;
      if (th != null && oth != null) {
        // See comment in Set.Equals
        return oth.EqualsAux(th);
      } else {
        return false;
      }
    }

    public bool EqualsAux(IMultiSet<object> other) {
      var s = other as IMultiSet<T>;
      if (s != null) {
        return Equals(s);
      } else {
        return false;
      }
    }

    public override int GetHashCode() {
      var hashCode = 1;
      if (occurrencesOfNull > 0) {
        var key = Dafny.Helpers.GetHashCode(default(T));
        key = (key << 3) | (key >> 29) ^ occurrencesOfNull.GetHashCode();
        hashCode = hashCode * (key + 3);
      }
      foreach (var kv in dict) {
        var key = Dafny.Helpers.GetHashCode(kv.Key);
        key = (key << 3) | (key >> 29) ^ kv.Value.GetHashCode();
        hashCode = hashCode * (key + 3);
      }
      return hashCode;
    }
    public override string ToString() {
      var s = "multiset{";
      var sep = "";
      for (var i = BigInteger.Zero; i < occurrencesOfNull; i++) {
        s += sep + Dafny.Helpers.ToString(default(T));
        sep = ", ";
      }
      foreach (var kv in dict) {
        var t = Dafny.Helpers.ToString(kv.Key);
        for (var i = BigInteger.Zero; i < kv.Value; i++) {
          s += sep + t;
          sep = ", ";
        }
      }
      return s + "}";
    }
    public static bool IsProperSubsetOf(IMultiSet<T> th, IMultiSet<T> other) {
      return th.Count < other.Count && IsSubsetOf(th, other);
    }
    public static bool IsSubsetOf(IMultiSet<T> th, IMultiSet<T> other) {
      var a = FromIMultiSet(th);
      var b = FromIMultiSet(other);
      if (b.occurrencesOfNull < a.occurrencesOfNull) {
        return false;
      }
      foreach (T t in a.dict.Keys) {
        if (!b.dict.ContainsKey(t) || b.dict[t] < a.dict[t]) {
          return false;
        }
      }
      return true;
    }
    public static bool IsDisjointFrom(IMultiSet<T> th, IMultiSet<T> other) {
      foreach (T t in th.UniqueElements) {
        if (other.Contains(t)) {
          return false;
        }
      }
      return true;
    }

    public bool Contains<G>(G t) {
      return t == null ? occurrencesOfNull > 0 : t is T && dict.ContainsKey((T)(object)t);
    }
    public BigInteger Select<G>(G t) {
      if (t == null) {
        return occurrencesOfNull;
      }
      BigInteger m;
      if (t is T && dict.TryGetValue((T)(object)t, out m)) {
        return m;
      } else {
        return BigInteger.Zero;
      }
    }
    public IMultiSet<T> Update<G>(G t, BigInteger i) {
      if (Select(t) == i) {
        return this;
      } else if (t == null) {
        var r = dict.ToBuilder();
        return new MultiSet<T>(r, i);
      } else {
        var r = dict.ToBuilder();
        r[(T)(object)t] = i;
        return new MultiSet<T>(r, occurrencesOfNull);
      }
    }
    public static IMultiSet<T> Union(IMultiSet<T> th, IMultiSet<T> other) {
      if (th.IsEmpty) {
        return other;
      } else if (other.IsEmpty) {
        return th;
      }
      var a = FromIMultiSet(th);
      var b = FromIMultiSet(other);
      var r = ImmutableDictionary<T, BigInteger>.Empty.ToBuilder();
      foreach (T t in a.dict.Keys) {
        BigInteger i;
        if (!r.TryGetValue(t, out i)) {
          i = BigInteger.Zero;
        }
        r[t] = i + a.dict[t];
      }
      foreach (T t in b.dict.Keys) {
        BigInteger i;
        if (!r.TryGetValue(t, out i)) {
          i = BigInteger.Zero;
        }
        r[t] = i + b.dict[t];
      }
      return new MultiSet<T>(r, a.occurrencesOfNull + b.occurrencesOfNull);
    }
    public static IMultiSet<T> Intersect(IMultiSet<T> th, IMultiSet<T> other) {
      if (th.IsEmpty) {
        return th;
      } else if (other.IsEmpty) {
        return other;
      }
      var a = FromIMultiSet(th);
      var b = FromIMultiSet(other);
      var r = ImmutableDictionary<T, BigInteger>.Empty.ToBuilder();
      foreach (T t in a.dict.Keys) {
        if (b.dict.ContainsKey(t)) {
          r.Add(t, a.dict[t] < b.dict[t] ? a.dict[t] : b.dict[t]);
        }
      }
      return new MultiSet<T>(r, a.occurrencesOfNull < b.occurrencesOfNull ? a.occurrencesOfNull : b.occurrencesOfNull);
    }
    public static IMultiSet<T> Difference(IMultiSet<T> th, IMultiSet<T> other) { // \result == this - other
      if (other.IsEmpty) {
        return th;
      }
      var a = FromIMultiSet(th);
      var b = FromIMultiSet(other);
      var r = ImmutableDictionary<T, BigInteger>.Empty.ToBuilder();
      foreach (T t in a.dict.Keys) {
        if (!b.dict.ContainsKey(t)) {
          r.Add(t, a.dict[t]);
        } else if (b.dict[t] < a.dict[t]) {
          r.Add(t, a.dict[t] - b.dict[t]);
        }
      }
      return new MultiSet<T>(r, b.occurrencesOfNull < a.occurrencesOfNull ? a.occurrencesOfNull - b.occurrencesOfNull : BigInteger.Zero);
    }

    public bool IsEmpty { get { return occurrencesOfNull == 0 && dict.IsEmpty; } }

    public int Count {
      get { return (int)ElementCount(); }
    }
    public long LongCount {
      get { return (long)ElementCount(); }
    }
    private BigInteger ElementCount() {
      // This is inefficient
      var c = occurrencesOfNull;
      foreach (var item in dict) {
        c += item.Value;
      }
      return c;
    }

    public IEnumerable<T> Elements {
      get {
        for (var i = BigInteger.Zero; i < occurrencesOfNull; i++) {
          yield return default(T);
        }
        foreach (var item in dict) {
          for (var i = BigInteger.Zero; i < item.Value; i++) {
            yield return item.Key;
          }
        }
      }
    }

    public IEnumerable<T> UniqueElements {
      get {
        if (!occurrencesOfNull.IsZero) {
          yield return default(T);
        }
        foreach (var key in dict.Keys) {
          yield return key;
        }
      }
    }
  }

  public interface IMap<out U, out V>
  {
    int Count { get; }
    long LongCount { get; }
    ISet<U> Keys { get; }
    ISet<V> Values { get; }
    IEnumerable<IPair<U, V>> ItemEnumerable { get; }
    bool Contains<G>(G t);
    /// <summary>
    /// Returns "true" iff "this is IMap<object, object>" and "this" equals "other".
    /// </summary>
    bool EqualsObjObj(IMap<object, object> other);
    IMap<UU, VV> DowncastClone<UU, VV>(Func<U, UU> keyConverter, Func<V, VV> valueConverter);
  }

  public class Map<U, V> : IMap<U, V>
  {
    readonly ImmutableDictionary<U, V> dict;
    readonly bool hasNullKey;  // true when "null" is a key of the Map
    readonly V nullValue;  // if "hasNullKey", the value that "null" maps to

    private Map(ImmutableDictionary<U, V>.Builder d, bool hasNullKey, V nullValue) {
      dict = d.ToImmutable();
      this.hasNullKey = hasNullKey;
      this.nullValue = nullValue;
    }
    public static readonly Map<U, V> Empty = new Map<U, V>(ImmutableDictionary<U, V>.Empty.ToBuilder(), false, default(V));

    private Map(ImmutableDictionary<U, V> d, bool hasNullKey, V nullValue) {
      dict = d;
      this.hasNullKey = hasNullKey;
      this.nullValue = nullValue;
    }

    private static readonly TypeDescriptor<IMap<U, V>> _TYPE = new Dafny.TypeDescriptor<IMap<U, V>>(Empty);
    public static TypeDescriptor<IMap<U, V>> _TypeDescriptor() {
      return _TYPE;
    }

    public static Map<U, V> FromElements(params IPair<U, V>[] values) {
      var d = ImmutableDictionary<U, V>.Empty.ToBuilder();
      var hasNullKey = false;
      var nullValue = default(V);
      foreach (var p in values) {
        if (p.Car == null) {
          hasNullKey = true;
          nullValue = p.Cdr;
        } else {
          d[p.Car] = p.Cdr;
        }
      }
      return new Map<U, V>(d, hasNullKey, nullValue);
    }
    public static Map<U, V> FromCollection(IEnumerable<IPair<U, V>> values) {
      var d = ImmutableDictionary<U, V>.Empty.ToBuilder();
      var hasNullKey = false;
      var nullValue = default(V);
      foreach (var p in values) {
        if (p.Car == null) {
          hasNullKey = true;
          nullValue = p.Cdr;
        } else {
          d[p.Car] = p.Cdr;
        }
      }
      return new Map<U, V>(d, hasNullKey, nullValue);
    }
    public static Map<U, V> FromIMap(IMap<U, V> m) {
      return m as Map<U, V> ?? FromCollection(m.ItemEnumerable);
    }
    public IMap<UU, VV> DowncastClone<UU, VV>(Func<U, UU> keyConverter, Func<V, VV> valueConverter) {
      if (this is IMap<UU, VV> th) {
        return th;
      } else {
        var d = ImmutableDictionary<UU, VV>.Empty.ToBuilder();
        foreach (var item in this.dict) {
          var k = keyConverter(item.Key);
          var v = valueConverter(item.Value);
          d.Add(k, v);
        }
        return new Map<UU, VV>(d, this.hasNullKey, (VV)(object)this.nullValue);
      }
    }
    public int Count {
      get { return dict.Count + (hasNullKey ? 1 : 0); }
    }
    public long LongCount {
      get { return dict.Count + (hasNullKey ? 1 : 0); }
    }

    public bool Equals(IMap<U, V> other) {
      if (other == null || LongCount != other.LongCount) {
        return false;
      } else if (this == other) {
        return true;
      }
      if (hasNullKey) {
        if (!other.Contains(default(U)) || !object.Equals(nullValue, Select(other, default(U)))) {
          return false;
        }
      }
      foreach (var item in dict) {
        if (!other.Contains(item.Key) || !object.Equals(item.Value, Select(other, item.Key))) {
          return false;
        }
      }
      return true;
    }
    public bool EqualsObjObj(IMap<object, object> other) {
      if (!(this is IMap<object, object>) || other == null || LongCount != other.LongCount) {
        return false;
      } else if (this == other) {
        return true;
      }
      var oth = Map<object, object>.FromIMap(other);
      if (hasNullKey) {
        if (!oth.Contains(default(U)) || !object.Equals(nullValue, Map<object, object>.Select(oth, default(U)))) {
          return false;
        }
      }
      foreach (var item in dict) {
        if (!other.Contains(item.Key) || !object.Equals(item.Value, Map<object, object>.Select(oth, item.Key))) {
          return false;
        }
      }
      return true;
    }
    public override bool Equals(object other) {
      // See comment in Set.Equals
      var m = other as IMap<U, V>;
      if (m != null) {
        return Equals(m);
      }
      var imapoo = other as IMap<object, object>;
      if (imapoo != null) {
        return EqualsObjObj(imapoo);
      } else {
        return false;
      }
    }

    public override int GetHashCode() {
      var hashCode = 1;
      if (hasNullKey) {
        var key = Dafny.Helpers.GetHashCode(default(U));
        key = (key << 3) | (key >> 29) ^ Dafny.Helpers.GetHashCode(nullValue);
        hashCode = hashCode * (key + 3);
      }
      foreach (var kv in dict) {
        var key = Dafny.Helpers.GetHashCode(kv.Key);
        key = (key << 3) | (key >> 29) ^ Dafny.Helpers.GetHashCode(kv.Value);
        hashCode = hashCode * (key + 3);
      }
      return hashCode;
    }
    public override string ToString() {
      var s = "map[";
      var sep = "";
      if (hasNullKey) {
        s += sep + Dafny.Helpers.ToString(default(U)) + " := " + Dafny.Helpers.ToString(nullValue);
        sep = ", ";
      }
      foreach (var kv in dict) {
        s += sep + Dafny.Helpers.ToString(kv.Key) + " := " + Dafny.Helpers.ToString(kv.Value);
        sep = ", ";
      }
      return s + "]";
    }
    public bool Contains<G>(G u) {
      return u == null ? hasNullKey : u is U && dict.ContainsKey((U)(object)u);
    }
    public static V Select(IMap<U, V> th, U index) {
      // the following will throw an exception if "index" in not a key of the map
      var m = FromIMap(th);
      return index == null && m.hasNullKey ? m.nullValue : m.dict[index];
    }
    public static IMap<U, V> Update(IMap<U, V> th, U index, V val) {
      var m = FromIMap(th);
      var d = m.dict.ToBuilder();
      if (index == null) {
        return new Map<U, V>(d, true, val);
      } else {
        d[index] = val;
        return new Map<U, V>(d, m.hasNullKey, m.nullValue);
      }
    }

    public static IMap<U, V> Merge(IMap<U, V> th, IMap<U, V> other) {
      var a = FromIMap(th);
      var b = FromIMap(other);
      ImmutableDictionary<U, V> d = a.dict.SetItems(b.dict);
      return new Map<U, V>(d, a.hasNullKey || b.hasNullKey, b.hasNullKey ? b.nullValue : a.nullValue);
    }

    public static IMap<U, V> Subtract(IMap<U, V> th, ISet<U> keys) {
      var a = FromIMap(th);
      ImmutableDictionary<U, V> d = a.dict.RemoveRange(keys.Elements);
      return new Map<U, V>(d, a.hasNullKey && !keys.Contains<object>(null), a.nullValue);
    }

    public ISet<U> Keys {
      get {
        if (hasNullKey) {
          return Dafny.Set<U>.FromCollectionPlusOne(dict.Keys, default(U));
        } else {
          return Dafny.Set<U>.FromCollection(dict.Keys);
        }
      }
    }
    public ISet<V> Values {
      get {
        if (hasNullKey) {
          return Dafny.Set<V>.FromCollectionPlusOne(dict.Values, nullValue);
        } else {
          return Dafny.Set<V>.FromCollection(dict.Values);
        }
      }
    }

    public IEnumerable<IPair<U, V>> ItemEnumerable {
      get {
        if (hasNullKey) {
          yield return new Pair<U, V>(default(U), nullValue);
        }
        foreach (KeyValuePair<U, V> kvp in dict) {
          yield return new Pair<U, V>(kvp.Key, kvp.Value);
        }
      }
    }

    public static ISet<_System.Tuple2<U, V>> Items(IMap<U, V> m) {
      var result = new HashSet<_System.Tuple2<U, V>>();
      foreach (var item in m.ItemEnumerable) {
        result.Add(_System.Tuple2<U, V>.create(item.Car, item.Cdr));
      }
      return Dafny.Set<_System.Tuple2<U, V>>.FromCollection(result);
    }
  }

  public interface ISequence<out T> {
    long LongCount { get; }
    int Count { get; }
    T[] Elements { get; }
    IEnumerable<T> UniqueElements { get; }
    T Select(ulong index);
    T Select(long index);
    T Select(uint index);
    T Select(int index);
    T Select(BigInteger index);
    bool Contains<G>(G g);
    ISequence<T> Take(long m);
    ISequence<T> Take(ulong n);
    ISequence<T> Take(BigInteger n);
    ISequence<T> Drop(long m);
    ISequence<T> Drop(ulong n);
    ISequence<T> Drop(BigInteger n);
    ISequence<T> Subsequence(long lo, long hi);
    ISequence<T> Subsequence(long lo, ulong hi);
    ISequence<T> Subsequence(long lo, BigInteger hi);
    ISequence<T> Subsequence(ulong lo, long hi);
    ISequence<T> Subsequence(ulong lo, ulong hi);
    ISequence<T> Subsequence(ulong lo, BigInteger hi);
    ISequence<T> Subsequence(BigInteger lo, long hi);
    ISequence<T> Subsequence(BigInteger lo, ulong hi);
    ISequence<T> Subsequence(BigInteger lo, BigInteger hi);
    bool EqualsAux(ISequence<object> other);
    ISequence<U> DowncastClone<U>(Func<T, U> converter);
  }

  public abstract class Sequence<T> : ISequence<T>
  {
    public static readonly ISequence<T> Empty = new ArraySequence<T>(new T[0]);

    private static readonly TypeDescriptor<ISequence<T>> _TYPE = new Dafny.TypeDescriptor<ISequence<T>>(Empty);
    public static TypeDescriptor<ISequence<T>> _TypeDescriptor() {
      return _TYPE;
    }

    public static ISequence<T> Create(BigInteger length, System.Func<BigInteger, T> init) {
      var len = (int)length;
      var values = new T[len];
      for (int i = 0; i < len; i++) {
        values[i] = init(new BigInteger(i));
      }
      return new ArraySequence<T>(values);
    }
    public static ISequence<T> FromArray(T[] values) {
      return new ArraySequence<T>(values);
    }
    public static ISequence<T> FromElements(params T[] values) {
      return new ArraySequence<T>(values);
    }
    public static ISequence<char> FromString(string s) {
      return new ArraySequence<char>(s.ToCharArray());
    }
    public ISequence<U> DowncastClone<U>(Func<T, U> converter) {
      if (this is ISequence<U> th) {
        return th;
      } else {
        var values = new U[this.LongCount];
        for (long i = 0; i < this.LongCount; i++) {
          var val = converter(this.Select(i));
          values[i] = val;
        }
        return new ArraySequence<U>(values);
      }
    }
    public static ISequence<T> Update(ISequence<T> sequence, long index, T t) {
      T[] tmp = (T[])sequence.Elements.Clone();
      tmp[index] = t;
      return new ArraySequence<T>(tmp);
    }
    public static ISequence<T> Update(ISequence<T> sequence, ulong index, T t) {
      return Update(sequence, (long)index, t);
    }
    public static ISequence<T> Update(ISequence<T> sequence, BigInteger index, T t) {
      return Update(sequence, (long)index, t);
    }
    public static bool EqualUntil(ISequence<T> left, ISequence<T> right, int n) {
      T[] leftElmts = left.Elements, rightElmts = right.Elements;
      for (int i = 0; i < n; i++) {
        if (!object.Equals(leftElmts[i], rightElmts[i]))
          return false;
      }
      return true;
    }
    public static bool IsPrefixOf(ISequence<T> left, ISequence<T> right) {
      int n = left.Elements.Length;
      return n <= right.Elements.Length && EqualUntil(left, right, n);
    }
    public static bool IsProperPrefixOf(ISequence<T> left, ISequence<T> right) {
      int n = left.Elements.Length;
      return n < right.Elements.Length && EqualUntil(left, right, n);
    }
    public static ISequence<T> Concat(ISequence<T> left, ISequence<T> right) {
      if (left.Count == 0) {
        return right;
      }
      if (right.Count == 0) {
        return left;
      }
      return new ConcatSequence<T>(left, right);
    }
    // Make Count a public abstract instead of LongCount, since the "array size is limited to a total of 4 billion
    // elements, and to a maximum index of 0X7FEFFFFF". Therefore, as a protection, limit this to int32.
    // https://docs.microsoft.com/en-us/dotnet/api/system.array
    public abstract int Count  { get; }
    public long LongCount {
      get { return Count; }
    }
    // ImmutableElements cannot be public in the interface since ImmutableArray<T> leads to a
    // "covariant type T occurs in invariant position" error. There do not appear to be interfaces for ImmutableArray<T>
    // that resolve this.
    protected abstract ImmutableArray<T> ImmutableElements { get; }

    public T[] Elements
    {
      get { return ImmutableElements.ToArray(); }
    }
    public IEnumerable<T> UniqueElements {
      get {
        var st = Set<T>.FromCollection(ImmutableElements);
        return st.Elements;
      }
    }

    public T Select(ulong index) {
      return ImmutableElements[checked((int)index)];
    }
    public T Select(long index) {
      return ImmutableElements[checked((int)index)];
    }
    public T Select(uint index) {
      return ImmutableElements[checked((int)index)];
    }
    public T Select(int index) {
      return ImmutableElements[index];
    }
    public T Select(BigInteger index) {
      return ImmutableElements[(int)index];
    }
    public bool Equals(ISequence<T> other) {
      int n = ImmutableElements.Length;
      return n == other.Elements.Length && EqualUntil(this, other, n);
    }
    public override bool Equals(object other) {
      if (other is ISequence<T>) {
        return Equals((ISequence<T>)other);
      }
      var th = this as ISequence<object>;
      var oth = other as ISequence<object>;
      if (th != null && oth != null) {
        // see explanation in Set.Equals
        return oth.EqualsAux(th);
      } else {
        return false;
      }
    }
    public bool EqualsAux(ISequence<object> other) {
      var s = other as ISequence<T>;
      if (s != null) {
        return Equals(s);
      } else {
        return false;
      }
    }
    public override int GetHashCode() {
      ImmutableArray<T> elmts = ImmutableElements;
      // https://devblogs.microsoft.com/dotnet/please-welcome-immutablearrayt/
      if (elmts.IsDefaultOrEmpty)
        return 0;
      var hashCode = 0;
      for (var i = 0; i < elmts.Length; i++) {
        hashCode = (hashCode << 3) | (hashCode >> 29) ^ Dafny.Helpers.GetHashCode(elmts[i]);
      }
      return hashCode;
    }
    public override string ToString() {
      // This is required because (ImmutableElements is ImmutableArray<char>) is not a valid type check
      var typeCheckTmp = new T[0];
      ImmutableArray<T> elmts = ImmutableElements;
      if (typeCheckTmp is char[]) {
        var s = "";
        foreach (var t in elmts) {
          s += t.ToString();
        }
        return s;
      } else {
        var s = "[";
        var sep = "";
        foreach (var t in elmts) {
          s += sep + Dafny.Helpers.ToString(t);
          sep = ", ";
        }
        return s + "]";
      }
    }
    public bool Contains<G>(G g) {
      if (g == null || g is T) {
        var t = (T)(object)g;
        return ImmutableElements.Contains(t);
      }
      return false;
    }
    public ISequence<T> Take(long m) {
      if (ImmutableElements.Length == m)
        return this;
      int length = checked((int)m);
      T[] tmp = new T[length];
      ImmutableElements.CopyTo(0, tmp, 0, length);
      return new ArraySequence<T>(tmp);
    }
    public ISequence<T> Take(ulong n) {
      return Take((long)n);
    }
    public ISequence<T> Take(BigInteger n) {
      return Take((long)n);
    }
    public ISequence<T> Drop(long m)
    {
      int startingElement = checked((int)m);
      if (startingElement == 0)
        return this;
      int length = ImmutableElements.Length - startingElement;
      T[] tmp = new T[length];
      ImmutableElements.CopyTo(startingElement, tmp, 0, length);
      return new ArraySequence<T>(tmp);
    }
    public ISequence<T> Drop(ulong n) {
      return Drop((long)n);
    }
    public ISequence<T> Drop(BigInteger n) {
      if (n.IsZero)
        return this;
      return Drop((long)n);
    }
    public ISequence<T> Subsequence(long lo, long hi) {
      if (lo == 0 && hi == ImmutableElements.Length) {
        return this;
      }
      int startingIndex = checked((int) lo);
      int endingIndex = checked((int)hi);
      var length = endingIndex - startingIndex;
      T[] tmp = new T[length];
      ImmutableElements.CopyTo(startingIndex, tmp, 0, length);
      return new ArraySequence<T>(tmp);
    }
    public ISequence<T> Subsequence(long lo, ulong hi) {
      return Subsequence(lo, (long)hi);
    }
    public ISequence<T> Subsequence(long lo, BigInteger hi) {
      return Subsequence(lo, (long)hi);
    }
    public ISequence<T> Subsequence(ulong lo, long hi) {
      return Subsequence((long)lo, hi);
    }
    public ISequence<T> Subsequence(ulong lo, ulong hi) {
      return Subsequence((long)lo, (long)hi);
    }
    public ISequence<T> Subsequence(ulong lo, BigInteger hi) {
      return Subsequence((long)lo, (long)hi);
    }
    public ISequence<T> Subsequence(BigInteger lo, long hi) {
      return Subsequence((long)lo, hi);
    }
    public ISequence<T> Subsequence(BigInteger lo, ulong hi) {
      return Subsequence((long)lo, (long)hi);
    }
    public ISequence<T> Subsequence(BigInteger lo, BigInteger hi) {
      return Subsequence((long)lo, (long)hi);
    }
  }
  internal class ArraySequence<T> : Sequence<T> {
    private readonly ImmutableArray<T> elmts;

    internal ArraySequence(ImmutableArray<T> ee) {
      elmts = ee;
    }
    internal ArraySequence(T[] ee) {
      elmts = ImmutableArray.Create<T>(ee);
    }

    protected override ImmutableArray<T> ImmutableElements {
      get
      {
        return elmts;
      }
    }
    public override int Count {
      get {
        return elmts.Length;
      }
    }
  }
  internal class ConcatSequence<T> : Sequence<T> {
    // INVARIANT: Either left != null, right != null, and elmts's underlying array == null or
    // left == null, right == null, and elmts's underlying array != null
    private ISequence<T> left, right;
    private ImmutableArray<T> elmts;
    private readonly int count;

    internal ConcatSequence(ISequence<T> left, ISequence<T> right) {
      this.left = left;
      this.right = right;
      this.count = left.Count + right.Count;
    }

    protected override ImmutableArray<T> ImmutableElements {
      get {
        // IsDefault returns true if the underlying array is a null reference
        // https://devblogs.microsoft.com/dotnet/please-welcome-immutablearrayt/
        if (elmts.IsDefault) {
          elmts = ComputeElements();
          // We don't need the original sequences anymore; let them be
          // garbage-collected
          left = null;
          right = null;
        }
        return elmts;
      }
    }

    public override int Count {
      get {
        return count;
      }
    }

    private ImmutableArray<T> ComputeElements() {
      // Traverse the tree formed by all descendants which are ConcatSequences
      var ansBuilder = ImmutableArray.CreateBuilder<T>();
      var toVisit = new Stack<ISequence<T>>();
      toVisit.Push(right);
      toVisit.Push(left);

      while (toVisit.Count != 0) {
        var seq = toVisit.Pop();
        var cs = seq as ConcatSequence<T>;
        if (cs != null && cs.elmts.IsDefault) {
          toVisit.Push(cs.right);
          toVisit.Push(cs.left);
        } else {
          var array = seq.Elements;
          ansBuilder.AddRange(array);
        }
      }
      return ansBuilder.ToImmutable();
    }
  }

  public interface IPair<out A, out B>
  {
    A Car { get; }
    B Cdr { get; }
  }
  public class Pair<A, B> : IPair<A, B>
  {
    private A car;
    private B cdr;
    public A Car { get { return car; } }
    public B Cdr { get { return cdr; } }
    public Pair(A a, B b) {
      this.car = a;
      this.cdr = b;
    }
  }

  public class TypeDescriptor<T>
  {
    private readonly T initValue;
    public TypeDescriptor(T initValue) {
      this.initValue = initValue;
    }
    public T Default() {
      return initValue;
    }
  }

  public partial class Helpers
  {
    public static int GetHashCode<G>(G g) {
      return g == null ? 1001 : g.GetHashCode();
    }

    public static int ToIntChecked(BigInteger i, string msg) {
      if (i > Int32.MaxValue || i < Int32.MinValue) {
        if (msg == null) msg = "value out of range for a 32-bit int";
        throw new HaltException(msg + ": " + i);
      }
      return (int)i;
    }
    public static int ToIntChecked(long i, string msg) {
      if (i > Int32.MaxValue || i < Int32.MinValue) {
        if (msg == null) msg = "value out of range for a 32-bit int";
        throw new HaltException(msg + ": " + i);
      }
      return (int)i;
    }
    public static int ToIntChecked(int i, string msg) {
      return i;
    }

    public static string ToString<G>(G g) {
      if (g == null) {
        return "null";
      } else if (g is bool) {
        return (bool)(object)g ? "true" : "false";  // capitalize boolean literals like in Dafny
      } else {
        return g.ToString();
      }
    }
    public static void Print<G>(G g) {
      System.Console.Write(ToString(g));
    }

    public static readonly TypeDescriptor<bool> BOOL = new TypeDescriptor<bool>(false);
    public static readonly TypeDescriptor<char> CHAR = new TypeDescriptor<char>('D');  // See CharType.DefaultValue in Dafny source code
    public static readonly TypeDescriptor<BigInteger> INT = new TypeDescriptor<BigInteger>(BigInteger.Zero);
    public static readonly TypeDescriptor<BigRational> REAL = new TypeDescriptor<BigRational>(BigRational.ZERO);
    public static readonly TypeDescriptor<byte> UINT8 = new TypeDescriptor<byte>(0);
    public static readonly TypeDescriptor<ushort> UINT16 = new TypeDescriptor<ushort>(0);
    public static readonly TypeDescriptor<uint> UINT32 = new TypeDescriptor<uint>(0);
    public static readonly TypeDescriptor<ulong> UINT64 = new TypeDescriptor<ulong>(0);

    public static TypeDescriptor<T> NULL<T>() where T : class {
      return new TypeDescriptor<T>(null);
    }

    public static TypeDescriptor<A[]> ARRAY<A>() {
      return new TypeDescriptor<A[]>(new A[0]);
    }

    public static bool Quantifier<T>(IEnumerable<T> vals, bool frall, System.Predicate<T> pred) {
      foreach (var u in vals) {
        if (pred(u) != frall) { return !frall; }
      }
      return frall;
    }
    // Enumerating other collections
    public static IEnumerable<bool> AllBooleans() {
      yield return false;
      yield return true;
    }
    public static IEnumerable<char> AllChars() {
      for (int i = 0; i < 0x10000; i++) {
        yield return (char)i;
      }
    }
    public static IEnumerable<BigInteger> AllIntegers() {
      yield return new BigInteger(0);
      for (var j = new BigInteger(1);; j++) {
        yield return j;
        yield return -j;
      }
    }
    public static IEnumerable<BigInteger> IntegerRange(Nullable<BigInteger> lo, Nullable<BigInteger> hi) {
      if (lo == null) {
        for (var j = (BigInteger)hi; true; ) {
          j--;
          yield return j;
        }
      } else if (hi == null) {
        for (var j = (BigInteger)lo; true; j++) {
          yield return j;
        }
      } else {
        for (var j = (BigInteger)lo; j < hi; j++) {
          yield return j;
        }
      }
    }
    public static IEnumerable<T> SingleValue<T>(T e) {
      yield return e;
    }
    // pre: b != 0
    // post: result == a/b, as defined by Euclidean Division (http://en.wikipedia.org/wiki/Modulo_operation)
    public static sbyte EuclideanDivision_sbyte(sbyte a, sbyte b) {
      return (sbyte)EuclideanDivision_int(a, b);
    }
    public static short EuclideanDivision_short(short a, short b) {
      return (short)EuclideanDivision_int(a, b);
    }
    public static int EuclideanDivision_int(int a, int b) {
      if (0 <= a) {
        if (0 <= b) {
          // +a +b: a/b
          return (int)(((uint)(a)) / ((uint)(b)));
        } else {
          // +a -b: -(a/(-b))
          return -((int)(((uint)(a)) / ((uint)(unchecked(-b)))));
        }
      } else {
        if (0 <= b) {
          // -a +b: -((-a-1)/b) - 1
          return -((int)(((uint)(-(a + 1))) / ((uint)(b)))) - 1;
        } else {
          // -a -b: ((-a-1)/(-b)) + 1
          return ((int)(((uint)(-(a + 1))) / ((uint)(unchecked(-b))))) + 1;
        }
      }
    }
    public static long EuclideanDivision_long(long a, long b) {
      if (0 <= a) {
        if (0 <= b) {
          // +a +b: a/b
          return (long)(((ulong)(a)) / ((ulong)(b)));
        } else {
          // +a -b: -(a/(-b))
          return -((long)(((ulong)(a)) / ((ulong)(unchecked(-b)))));
        }
      } else {
        if (0 <= b) {
          // -a +b: -((-a-1)/b) - 1
          return -((long)(((ulong)(-(a + 1))) / ((ulong)(b)))) - 1;
        } else {
          // -a -b: ((-a-1)/(-b)) + 1
          return ((long)(((ulong)(-(a + 1))) / ((ulong)(unchecked(-b))))) + 1;
        }
      }
    }
    public static BigInteger EuclideanDivision(BigInteger a, BigInteger b) {
      if (0 <= a.Sign) {
        if (0 <= b.Sign) {
          // +a +b: a/b
          return BigInteger.Divide(a, b);
        } else {
          // +a -b: -(a/(-b))
          return BigInteger.Negate(BigInteger.Divide(a, BigInteger.Negate(b)));
        }
      } else {
        if (0 <= b.Sign) {
          // -a +b: -((-a-1)/b) - 1
          return BigInteger.Negate(BigInteger.Divide(BigInteger.Negate(a) - 1, b)) - 1;
        } else {
          // -a -b: ((-a-1)/(-b)) + 1
          return BigInteger.Divide(BigInteger.Negate(a) - 1, BigInteger.Negate(b)) + 1;
        }
      }
    }
    // pre: b != 0
    // post: result == a%b, as defined by Euclidean Division (http://en.wikipedia.org/wiki/Modulo_operation)
    public static sbyte EuclideanModulus_sbyte(sbyte a, sbyte b) {
      return (sbyte)EuclideanModulus_int(a, b);
    }
    public static short EuclideanModulus_short(short a, short b) {
      return (short)EuclideanModulus_int(a, b);
    }
    public static int EuclideanModulus_int(int a, int b) {
      uint bp = (0 <= b) ? (uint)b : (uint)(unchecked(-b));
      if (0 <= a) {
        // +a: a % b'
        return (int)(((uint)a) % bp);
      } else {
        // c = ((-a) % b')
        // -a: b' - c if c > 0
        // -a: 0 if c == 0
        uint c = ((uint)(unchecked(-a))) % bp;
        return (int)(c == 0 ? c : bp - c);
      }
    }
    public static long EuclideanModulus_long(long a, long b) {
      ulong bp = (0 <= b) ? (ulong)b : (ulong)(unchecked(-b));
      if (0 <= a) {
        // +a: a % b'
        return (long)(((ulong)a) % bp);
      } else {
        // c = ((-a) % b')
        // -a: b' - c if c > 0
        // -a: 0 if c == 0
        ulong c = ((ulong)(unchecked(-a))) % bp;
        return (long)(c == 0 ? c : bp - c);
      }
    }
    public static BigInteger EuclideanModulus(BigInteger a, BigInteger b) {
      var bp = BigInteger.Abs(b);
      if (0 <= a.Sign) {
        // +a: a % b'
        return BigInteger.Remainder(a, bp);
      } else {
        // c = ((-a) % b')
        // -a: b' - c if c > 0
        // -a: 0 if c == 0
        var c = BigInteger.Remainder(BigInteger.Negate(a), bp);
        return c.IsZero ? c : BigInteger.Subtract(bp, c);
      }
    }

    public static U CastConverter<T, U>(T t) {
      return (U)(object)t;
    }

    public static Sequence<T> SeqFromArray<T>(T[] array) {
      return new ArraySequence<T>((T[])array.Clone());
    }
    // In .NET version 4.5, it is possible to mark a method with "AggressiveInlining", which says to inline the
    // method if possible.  Method "ExpressionSequence" would be a good candidate for it:
    // [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
    public static U ExpressionSequence<T, U>(T t, U u)
    {
      return u;
    }

    public static U Let<T, U>(T t, Func<T,U> f) {
      return f(t);
    }

    public static A Id<A>(A a) {
      return a;
    }

    public static void WithHaltHandling(Action action) {
      try {
        action();
      } catch (HaltException e) {
        Console.WriteLine("[Program halted] " + e.Message);
      }
    }
  }

  public class BigOrdinal {
    public static bool IsLimit(BigInteger ord) {
      return ord == 0;
    }
    public static bool IsSucc(BigInteger ord) {
      return 0 < ord;
    }
    public static BigInteger Offset(BigInteger ord) {
      return ord;
    }
    public static bool IsNat(BigInteger ord) {
      return true;  // at run time, every ORDINAL is a natural number
    }
  }

  public struct BigRational
  {
    public static readonly BigRational ZERO = new BigRational(0);

    // We need to deal with the special case "num == 0 && den == 0", because
    // that's what C#'s default struct constructor will produce for BigRational. :(
    // To deal with it, we ignore "den" when "num" is 0.
    BigInteger num, den;  // invariant 1 <= den || (num == 0 && den == 0)
    public override string ToString() {
      int log10;
      if (num.IsZero || den.IsOne) {
        return string.Format("{0}.0", num);
      } else if (IsPowerOf10(den, out log10)) {
        string sign;
        string digits;
        if (num.Sign < 0) {
          sign = "-"; digits = (-num).ToString();
        } else {
          sign = ""; digits = num.ToString();
        }
        if (log10 < digits.Length) {
          var n = digits.Length - log10;
          return string.Format("{0}{1}.{2}", sign, digits.Substring(0, n), digits.Substring(n));
        } else {
          return string.Format("{0}0.{1}{2}", sign, new string('0', log10 - digits.Length), digits);
        }
      } else {
        return string.Format("({0}.0 / {1}.0)", num, den);
      }
    }
    public bool IsPowerOf10(BigInteger x, out int log10) {
      log10 = 0;
      if (x.IsZero) {
        return false;
      }
      while (true) {  // invariant: x != 0 && x * 10^log10 == old(x)
        if (x.IsOne) {
          return true;
        } else if (x % 10 == 0) {
          log10++;
          x /= 10;
        } else {
          return false;
        }
      }
    }
    public BigRational(int n) {
      num = new BigInteger(n);
      den = BigInteger.One;
    }
    public BigRational(BigInteger n, BigInteger d) {
      // requires 1 <= d
      num = n;
      den = d;
    }
    public BigInteger ToBigInteger() {
      if (num.IsZero || den.IsOne) {
        return num;
      } else if (0 < num.Sign) {
        return num / den;
      } else {
        return (num - den + 1) / den;
      }
    }
    /// <summary>
    /// Returns values such that aa/dd == a and bb/dd == b.
    /// </summary>
    private static void Normalize(BigRational a, BigRational b, out BigInteger aa, out BigInteger bb, out BigInteger dd) {
      if (a.num.IsZero) {
        aa = a.num;
        bb = b.num;
        dd = b.den;
      } else if (b.num.IsZero) {
        aa = a.num;
        dd = a.den;
        bb = b.num;
      } else {
        var gcd = BigInteger.GreatestCommonDivisor(a.den, b.den);
        var xx = a.den / gcd;
        var yy = b.den / gcd;
        // We now have a == a.num / (xx * gcd) and b == b.num / (yy * gcd).
        aa = a.num * yy;
        bb = b.num * xx;
        dd = a.den * yy;
      }
    }
    public int CompareTo(BigRational that) {
      // simple things first
      int asign = this.num.Sign;
      int bsign = that.num.Sign;
      if (asign < 0 && 0 <= bsign) {
        return -1;
      } else if (asign <= 0 && 0 < bsign) {
        return -1;
      } else if (bsign < 0 && 0 <= asign) {
        return 1;
      } else if (bsign <= 0 && 0 < asign) {
        return 1;
      }
      BigInteger aa, bb, dd;
      Normalize(this, that, out aa, out bb, out dd);
      return aa.CompareTo(bb);
    }
    public int Sign {
      get {
        return num.Sign;
      }
    }
    public override int GetHashCode() {
      return num.GetHashCode() + 29 * den.GetHashCode();
    }
    public override bool Equals(object obj) {
      if (obj is BigRational) {
        return this == (BigRational)obj;
      } else {
        return false;
      }
    }
    public static bool operator ==(BigRational a, BigRational b) {
      return a.CompareTo(b) == 0;
    }
    public static bool operator !=(BigRational a, BigRational b) {
      return a.CompareTo(b) != 0;
    }
    public static bool operator >(BigRational a, BigRational b) {
      return a.CompareTo(b) > 0;
    }
    public static bool operator >=(BigRational a, BigRational b) {
      return a.CompareTo(b) >= 0;
    }
    public static bool operator <(BigRational a, BigRational b) {
      return a.CompareTo(b) < 0;
    }
    public static bool operator <=(BigRational a, BigRational b) {
      return a.CompareTo(b) <= 0;
    }
    public static BigRational operator +(BigRational a, BigRational b) {
      BigInteger aa, bb, dd;
      Normalize(a, b, out aa, out bb, out dd);
      return new BigRational(aa + bb, dd);
    }
    public static BigRational operator -(BigRational a, BigRational b) {
      BigInteger aa, bb, dd;
      Normalize(a, b, out aa, out bb, out dd);
      return new BigRational(aa - bb, dd);
    }
    public static BigRational operator -(BigRational a) {
      return new BigRational(-a.num, a.den);
    }
    public static BigRational operator *(BigRational a, BigRational b) {
      return new BigRational(a.num * b.num, a.den * b.den);
    }
    public static BigRational operator /(BigRational a, BigRational b) {
      // Compute the reciprocal of b
      BigRational bReciprocal;
      if (0 < b.num.Sign) {
        bReciprocal = new BigRational(b.den, b.num);
      } else {
        // this is the case b.num < 0
        bReciprocal = new BigRational(-b.den, -b.num);
      }
      return a * bReciprocal;
    }
  }

  public class HaltException : Exception {
    public HaltException(object message) : base(message.ToString())
    {
    }
  }
}

namespace @_System
{
  public class Tuple2<T0,T1> {
    public readonly T0 _0;
    public readonly T1 _1;
    public Tuple2(T0 _0, T1 _1) {
      this._0 = _0;
      this._1 = _1;
    }
    public override bool Equals(object other) {
      var oth = other as _System.Tuple2<T0,T1>;
      return oth != null && object.Equals(this._0, oth._0) && object.Equals(this._1, oth._1);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._0));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._1));
      return (int) hash;
    }
    public override string ToString() {
      string s = "";
      s += "(";
      s += Dafny.Helpers.ToString(this._0);
      s += ", ";
      s += Dafny.Helpers.ToString(this._1);
      s += ")";
      return s;
    }
    public static Tuple2<T0,T1> Default(T0 _default_T0, T1 _default_T1) {
      return create(_default_T0, _default_T1);
    }
    public static Dafny.TypeDescriptor<_System.Tuple2<T0, T1>> _TypeDescriptor(Dafny.TypeDescriptor<T0> _td_T0, Dafny.TypeDescriptor<T1> _td_T1) {
      return new Dafny.TypeDescriptor<_System.Tuple2<T0, T1>>(_System.Tuple2<T0, T1>.Default(_td_T0.Default(), _td_T1.Default()));
    }
    public static Tuple2<T0,T1> create(T0 _0, T1 _1) {
      return new Tuple2<T0,T1>(_0, _1);
    }
    public bool is____hMake2 { get { return true; } }
    public T0 dtor__0 {
      get {
        return this._0;
      }
    }
    public T1 dtor__1 {
      get {
        return this._1;
      }
    }
  }

} // end of namespace _System
namespace Dafny {
  internal class ArrayHelpers {
    public static T[] InitNewArray1<T>(T z, BigInteger size0) {
      int s0 = (int)size0;
      T[] a = new T[s0];
      for (int i0 = 0; i0 < s0; i0++) {
        a[i0] = z;
      }
      return a;
    }
  }
} // end of namespace Dafny
namespace _System {


  public partial class nat {
    private static readonly Dafny.TypeDescriptor<BigInteger> _TYPE = new Dafny.TypeDescriptor<BigInteger>(BigInteger.Zero);
    public static Dafny.TypeDescriptor<BigInteger> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public class Tuple0 {
    public Tuple0() {
    }
    public override bool Equals(object other) {
      var oth = other as _System.Tuple0;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      return (int) hash;
    }
    public override string ToString() {
      return "()";
    }
    private static readonly Tuple0 theDefault = create();
    public static Tuple0 Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<_System.Tuple0> _TYPE = new Dafny.TypeDescriptor<_System.Tuple0>(_System.Tuple0.Default());
    public static Dafny.TypeDescriptor<_System.Tuple0> _TypeDescriptor() {
      return _TYPE;
    }
    public static Tuple0 create() {
      return new Tuple0();
    }
    public static System.Collections.Generic.IEnumerable<Tuple0> AllSingletonConstructors {
      get {
        yield return Tuple0.create();
      }
    }
  }

  public class Tuple3<T0, T1, T2> {
    public readonly T0 _0;
    public readonly T1 _1;
    public readonly T2 _2;
    public Tuple3(T0 _0, T1 _1, T2 _2) {
      this._0 = _0;
      this._1 = _1;
      this._2 = _2;
    }
    public override bool Equals(object other) {
      var oth = other as _System.Tuple3<T0, T1, T2>;
      return oth != null && object.Equals(this._0, oth._0) && object.Equals(this._1, oth._1) && object.Equals(this._2, oth._2);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._0));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._1));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._2));
      return (int) hash;
    }
    public override string ToString() {
      string s = "";
      s += "(";
      s += Dafny.Helpers.ToString(this._0);
      s += ", ";
      s += Dafny.Helpers.ToString(this._1);
      s += ", ";
      s += Dafny.Helpers.ToString(this._2);
      s += ")";
      return s;
    }
    public static Tuple3<T0, T1, T2> Default(T0 _default_T0, T1 _default_T1, T2 _default_T2) {
      return create(_default_T0, _default_T1, _default_T2);
    }
    public static Dafny.TypeDescriptor<_System.Tuple3<T0, T1, T2>> _TypeDescriptor(Dafny.TypeDescriptor<T0> _td_T0, Dafny.TypeDescriptor<T1> _td_T1, Dafny.TypeDescriptor<T2> _td_T2) {
      return new Dafny.TypeDescriptor<_System.Tuple3<T0, T1, T2>>(_System.Tuple3<T0, T1, T2>.Default(_td_T0.Default(), _td_T1.Default(), _td_T2.Default()));
    }
    public static Tuple3<T0, T1, T2> create(T0 _0, T1 _1, T2 _2) {
      return new Tuple3<T0, T1, T2>(_0, _1, _2);
    }
    public T0 dtor__0 {
      get {
        return this._0;
      }
    }
    public T1 dtor__1 {
      get {
        return this._1;
      }
    }
    public T2 dtor__2 {
      get {
        return this._2;
      }
    }
  }







} // end of namespace _System
namespace Wrappers_Compile {

  public abstract class Option<T> {
    public Option() { }
    public static Option<T> Default() {
      return create_None();
    }
    public static Dafny.TypeDescriptor<Wrappers_Compile.Option<T>> _TypeDescriptor() {
      return new Dafny.TypeDescriptor<Wrappers_Compile.Option<T>>(Wrappers_Compile.Option<T>.Default());
    }
    public static Option<T> create_None() {
      return new Option_None<T>();
    }
    public static Option<T> create_Some(T @value) {
      return new Option_Some<T>(@value);
    }
    public bool is_None { get { return this is Option_None<T>; } }
    public bool is_Some { get { return this is Option_Some<T>; } }
    public T dtor_value {
      get {
        var d = this;
        return ((Option_Some<T>)d).@value; 
      }
    }
    public Wrappers_Compile.Result<T, Dafny.ISequence<char>> ToResult() {
      Wrappers_Compile.Option<T> _source0 = this;
      if (_source0.is_None) {
        return @Wrappers_Compile.Result<T, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Option is None"));
      } else {
        T _17856___mcc_h0 = ((Wrappers_Compile.Option_Some<T>)_source0).@value;
        T _17857_v = _17856___mcc_h0;
        return @Wrappers_Compile.Result<T, Dafny.ISequence<char>>.create_Success(_17857_v);
      }
    }
    public T UnwrapOr(T @default) {
      Wrappers_Compile.Option<T> _source1 = this;
      if (_source1.is_None) {
        return @default;
      } else {
        T _17858___mcc_h0 = ((Wrappers_Compile.Option_Some<T>)_source1).@value;
        T _17859_v = _17858___mcc_h0;
        return _17859_v;
      }
    }
    public bool IsFailure() {
      return (this).is_None;
    }
    public Wrappers_Compile.Option<__U> PropagateFailure<__U>() {
      return @Wrappers_Compile.Option<__U>.create_None();
    }
    public T Extract() {
      return (this).dtor_value;
    }
  }
  public class Option_None<T> : Option<T> {
    public Option_None() {
    }
    public override bool Equals(object other) {
      var oth = other as Wrappers_Compile.Option_None<T>;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      return (int) hash;
    }
    public override string ToString() {
      string s = "Wrappers_Compile.Option.None";
      return s;
    }
  }
  public class Option_Some<T> : Option<T> {
    public readonly T @value;
    public Option_Some(T @value) {
      this.@value = @value;
    }
    public override bool Equals(object other) {
      var oth = other as Wrappers_Compile.Option_Some<T>;
      return oth != null && object.Equals(this.@value, oth.@value);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.@value));
      return (int) hash;
    }
    public override string ToString() {
      string s = "Wrappers_Compile.Option.Some";
      s += "(";
      s += Dafny.Helpers.ToString(this.@value);
      s += ")";
      return s;
    }
  }

  public abstract class Result<T, R> {
    public Result() { }
    public static Result<T, R> Default(T _default_T) {
      return create_Success(_default_T);
    }
    public static Dafny.TypeDescriptor<Wrappers_Compile.Result<T, R>> _TypeDescriptor(Dafny.TypeDescriptor<T> _td_T) {
      return new Dafny.TypeDescriptor<Wrappers_Compile.Result<T, R>>(Wrappers_Compile.Result<T, R>.Default(_td_T.Default()));
    }
    public static Result<T, R> create_Success(T @value) {
      return new Result_Success<T, R>(@value);
    }
    public static Result<T, R> create_Failure(R error) {
      return new Result_Failure<T, R>(error);
    }
    public bool is_Success { get { return this is Result_Success<T, R>; } }
    public bool is_Failure { get { return this is Result_Failure<T, R>; } }
    public T dtor_value {
      get {
        var d = this;
        return ((Result_Success<T, R>)d).@value; 
      }
    }
    public R dtor_error {
      get {
        var d = this;
        return ((Result_Failure<T, R>)d).error; 
      }
    }
    public Wrappers_Compile.Option<T> ToOption() {
      Wrappers_Compile.Result<T, R> _source2 = this;
      if (_source2.is_Success) {
        T _17860___mcc_h0 = ((Wrappers_Compile.Result_Success<T, R>)_source2).@value;
        T _17861_s = _17860___mcc_h0;
        return @Wrappers_Compile.Option<T>.create_Some(_17861_s);
      } else {
        R _17862___mcc_h1 = ((Wrappers_Compile.Result_Failure<T, R>)_source2).error;
        R _17863_e = _17862___mcc_h1;
        return @Wrappers_Compile.Option<T>.create_None();
      }
    }
    public T UnwrapOr(T @default) {
      Wrappers_Compile.Result<T, R> _source3 = this;
      if (_source3.is_Success) {
        T _17864___mcc_h0 = ((Wrappers_Compile.Result_Success<T, R>)_source3).@value;
        T _17865_s = _17864___mcc_h0;
        return _17865_s;
      } else {
        R _17866___mcc_h1 = ((Wrappers_Compile.Result_Failure<T, R>)_source3).error;
        R _17867_e = _17866___mcc_h1;
        return @default;
      }
    }
    public bool IsFailure() {
      return (this).is_Failure;
    }
    public Wrappers_Compile.Result<__U, R> PropagateFailure<__U>() {
      return @Wrappers_Compile.Result<__U, R>.create_Failure((this).dtor_error);
    }
    public T Extract() {
      return (this).dtor_value;
    }
  }
  public class Result_Success<T, R> : Result<T, R> {
    public readonly T @value;
    public Result_Success(T @value) {
      this.@value = @value;
    }
    public override bool Equals(object other) {
      var oth = other as Wrappers_Compile.Result_Success<T, R>;
      return oth != null && object.Equals(this.@value, oth.@value);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.@value));
      return (int) hash;
    }
    public override string ToString() {
      string s = "Wrappers_Compile.Result.Success";
      s += "(";
      s += Dafny.Helpers.ToString(this.@value);
      s += ")";
      return s;
    }
  }
  public class Result_Failure<T, R> : Result<T, R> {
    public readonly R error;
    public Result_Failure(R error) {
      this.error = error;
    }
    public override bool Equals(object other) {
      var oth = other as Wrappers_Compile.Result_Failure<T, R>;
      return oth != null && object.Equals(this.error, oth.error);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.error));
      return (int) hash;
    }
    public override string ToString() {
      string s = "Wrappers_Compile.Result.Failure";
      s += "(";
      s += Dafny.Helpers.ToString(this.error);
      s += ")";
      return s;
    }
  }

  public abstract class Outcome<E> {
    public Outcome() { }
    public static Outcome<E> Default() {
      return create_Pass();
    }
    public static Dafny.TypeDescriptor<Wrappers_Compile.Outcome<E>> _TypeDescriptor() {
      return new Dafny.TypeDescriptor<Wrappers_Compile.Outcome<E>>(Wrappers_Compile.Outcome<E>.Default());
    }
    public static Outcome<E> create_Pass() {
      return new Outcome_Pass<E>();
    }
    public static Outcome<E> create_Fail(E error) {
      return new Outcome_Fail<E>(error);
    }
    public bool is_Pass { get { return this is Outcome_Pass<E>; } }
    public bool is_Fail { get { return this is Outcome_Fail<E>; } }
    public E dtor_error {
      get {
        var d = this;
        return ((Outcome_Fail<E>)d).error; 
      }
    }
    public bool IsFailure() {
      return (this).is_Fail;
    }
    public Wrappers_Compile.Result<__U, E> PropagateFailure<__U>() {
      return @Wrappers_Compile.Result<__U, E>.create_Failure((this).dtor_error);
    }
  }
  public class Outcome_Pass<E> : Outcome<E> {
    public Outcome_Pass() {
    }
    public override bool Equals(object other) {
      var oth = other as Wrappers_Compile.Outcome_Pass<E>;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      return (int) hash;
    }
    public override string ToString() {
      string s = "Wrappers_Compile.Outcome.Pass";
      return s;
    }
  }
  public class Outcome_Fail<E> : Outcome<E> {
    public readonly E error;
    public Outcome_Fail(E error) {
      this.error = error;
    }
    public override bool Equals(object other) {
      var oth = other as Wrappers_Compile.Outcome_Fail<E>;
      return oth != null && object.Equals(this.error, oth.error);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.error));
      return (int) hash;
    }
    public override string ToString() {
      string s = "Wrappers_Compile.Outcome.Fail";
      s += "(";
      s += Dafny.Helpers.ToString(this.error);
      s += ")";
      return s;
    }
  }

  public partial class __default {
    public static Wrappers_Compile.Outcome<__E> Need<__E>(bool condition, __E error)
    {
      if (condition) {
        return @Wrappers_Compile.Outcome<__E>.create_Pass();
      } else {
        return @Wrappers_Compile.Outcome<__E>.create_Fail(error);
      }
    }
  }
} // end of namespace Wrappers_Compile
namespace StandardLibrary_mUInt_Compile {

  public partial class uint8 {
    public static System.Collections.Generic.IEnumerable<byte> IntegerRange(BigInteger lo, BigInteger hi) {
      for (var j = lo; j < hi; j++) { yield return (byte)j; }
    }
    private static readonly Dafny.TypeDescriptor<byte> _TYPE = new Dafny.TypeDescriptor<byte>(0);
    public static Dafny.TypeDescriptor<byte> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public partial class uint16 {
    public static System.Collections.Generic.IEnumerable<ushort> IntegerRange(BigInteger lo, BigInteger hi) {
      for (var j = lo; j < hi; j++) { yield return (ushort)j; }
    }
    private static readonly Dafny.TypeDescriptor<ushort> _TYPE = new Dafny.TypeDescriptor<ushort>(0);
    public static Dafny.TypeDescriptor<ushort> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public partial class uint32 {
    public static System.Collections.Generic.IEnumerable<uint> IntegerRange(BigInteger lo, BigInteger hi) {
      for (var j = lo; j < hi; j++) { yield return (uint)j; }
    }
    private static readonly Dafny.TypeDescriptor<uint> _TYPE = new Dafny.TypeDescriptor<uint>(0);
    public static Dafny.TypeDescriptor<uint> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public partial class uint64 {
    public static System.Collections.Generic.IEnumerable<ulong> IntegerRange(BigInteger lo, BigInteger hi) {
      for (var j = lo; j < hi; j++) { yield return (ulong)j; }
    }
    private static readonly Dafny.TypeDescriptor<ulong> _TYPE = new Dafny.TypeDescriptor<ulong>(0);
    public static Dafny.TypeDescriptor<ulong> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public partial class int32 {
    public static System.Collections.Generic.IEnumerable<int> IntegerRange(BigInteger lo, BigInteger hi) {
      for (var j = lo; j < hi; j++) { yield return (int)j; }
    }
    private static readonly Dafny.TypeDescriptor<int> _TYPE = new Dafny.TypeDescriptor<int>(0);
    public static Dafny.TypeDescriptor<int> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public partial class int64 {
    public static System.Collections.Generic.IEnumerable<long> IntegerRange(BigInteger lo, BigInteger hi) {
      for (var j = lo; j < hi; j++) { yield return (long)j; }
    }
    private static readonly Dafny.TypeDescriptor<long> _TYPE = new Dafny.TypeDescriptor<long>(0);
    public static Dafny.TypeDescriptor<long> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public partial class __default {
    public static bool UInt8Less(byte a, byte b)
    {
      return (a) < (b);
    }
    public static Dafny.ISequence<byte> UInt16ToSeq(ushort x) {
      byte _17868_b0 = (byte)((ushort)((x) / (256)));
      byte _17869_b1 = (byte)((ushort)((x) % (256)));
      return Dafny.Sequence<byte>.FromElements(_17868_b0, _17869_b1);
    }
    public static ushort SeqToUInt16(Dafny.ISequence<byte> s) {
      ushort _17870_x0 = (ushort)(((ushort)((s).Select(BigInteger.Zero))) * (256));
      return (ushort)((_17870_x0) + ((ushort)((s).Select(BigInteger.One))));
    }
    public static Dafny.ISequence<byte> UInt32ToSeq(uint x) {
      byte _17871_b0 = (byte)((x) / (16777216U));
      uint _17872_x0 = (x) - (((uint)(_17871_b0)) * (16777216U));
      byte _17873_b1 = (byte)((_17872_x0) / (65536U));
      uint _17874_x1 = (_17872_x0) - (((uint)(_17873_b1)) * (65536U));
      byte _17875_b2 = (byte)((_17874_x1) / (256U));
      byte _17876_b3 = (byte)((_17874_x1) % (256U));
      return Dafny.Sequence<byte>.FromElements(_17871_b0, _17873_b1, _17875_b2, _17876_b3);
    }
    public static uint SeqToUInt32(Dafny.ISequence<byte> s) {
      uint _17877_x0 = ((uint)((s).Select(BigInteger.Zero))) * (16777216U);
      uint _17878_x1 = (_17877_x0) + (((uint)((s).Select(BigInteger.One))) * (65536U));
      uint _17879_x2 = (_17878_x1) + (((uint)((s).Select(new BigInteger(2)))) * (256U));
      return (_17879_x2) + ((uint)((s).Select(new BigInteger(3))));
    }
    public static Dafny.ISequence<byte> UInt64ToSeq(ulong x) {
      byte _17880_b0 = (byte)((x) / (72057594037927936UL));
      ulong _17881_x0 = (x) - (((ulong)(_17880_b0)) * (72057594037927936UL));
      byte _17882_b1 = (byte)((_17881_x0) / (281474976710656UL));
      ulong _17883_x1 = (_17881_x0) - (((ulong)(_17882_b1)) * (281474976710656UL));
      byte _17884_b2 = (byte)((_17883_x1) / (1099511627776UL));
      ulong _17885_x2 = (_17883_x1) - (((ulong)(_17884_b2)) * (1099511627776UL));
      byte _17886_b3 = (byte)((_17885_x2) / (4294967296UL));
      ulong _17887_x3 = (_17885_x2) - (((ulong)(_17886_b3)) * (4294967296UL));
      byte _17888_b4 = (byte)((_17887_x3) / (16777216UL));
      ulong _17889_x4 = (_17887_x3) - (((ulong)(_17888_b4)) * (16777216UL));
      byte _17890_b5 = (byte)((_17889_x4) / (65536UL));
      ulong _17891_x5 = (_17889_x4) - (((ulong)(_17890_b5)) * (65536UL));
      byte _17892_b6 = (byte)((_17891_x5) / (256UL));
      byte _17893_b7 = (byte)((_17891_x5) % (256UL));
      return Dafny.Sequence<byte>.FromElements(_17880_b0, _17882_b1, _17884_b2, _17886_b3, _17888_b4, _17890_b5, _17892_b6, _17893_b7);
    }
    public static ulong SeqToUInt64(Dafny.ISequence<byte> s) {
      ulong _17894_x0 = ((ulong)((s).Select(BigInteger.Zero))) * (72057594037927936UL);
      ulong _17895_x1 = (_17894_x0) + (((ulong)((s).Select(BigInteger.One))) * (281474976710656UL));
      ulong _17896_x2 = (_17895_x1) + (((ulong)((s).Select(new BigInteger(2)))) * (1099511627776UL));
      ulong _17897_x3 = (_17896_x2) + (((ulong)((s).Select(new BigInteger(3)))) * (4294967296UL));
      ulong _17898_x4 = (_17897_x3) + (((ulong)((s).Select(new BigInteger(4)))) * (16777216UL));
      ulong _17899_x5 = (_17898_x4) + (((ulong)((s).Select(new BigInteger(5)))) * (65536UL));
      ulong _17900_x6 = (_17899_x5) + (((ulong)((s).Select(new BigInteger(6)))) * (256UL));
      ulong _17901_x = (_17900_x6) + ((ulong)((s).Select(new BigInteger(7))));
      return _17901_x;
    }
    public static BigInteger UINT32__LIMIT { get {
      return new BigInteger(4294967296L);
    } }
    public static BigInteger UINT16__LIMIT { get {
      return new BigInteger(65536);
    } }
    public static BigInteger INT32__MAX__LIMIT { get {
      return new BigInteger(2147483648L);
    } }
    public static BigInteger INT64__MAX__LIMIT { get {
      return new BigInteger(9223372036854775808UL);
    } }
  }
} // end of namespace StandardLibrary_mUInt_Compile
namespace StandardLibrary_Compile {



  public partial class __default {
    public static Dafny.ISequence<__T> Join<__T>(Dafny.ISequence<Dafny.ISequence<__T>> ss, Dafny.ISequence<__T> joiner)
    {
      Dafny.ISequence<__T> _17902___accumulator = Dafny.Sequence<__T>.FromElements();
    TAIL_CALL_START: ;
      if ((new BigInteger((ss).Count)) == (BigInteger.One)) {
        return Dafny.Sequence<__T>.Concat(_17902___accumulator, (ss).Select(BigInteger.Zero));
      } else {
        _17902___accumulator = Dafny.Sequence<__T>.Concat(_17902___accumulator, Dafny.Sequence<__T>.Concat((ss).Select(BigInteger.Zero), joiner));
        Dafny.ISequence<Dafny.ISequence<__T>> _in0 = (ss).Drop(BigInteger.One);
        Dafny.ISequence<__T> _in1 = joiner;
        ss = _in0;
        joiner = _in1;
        goto TAIL_CALL_START;
      }
    }
    public static Dafny.ISequence<Dafny.ISequence<__T>> Split<__T>(Dafny.ISequence<__T> s, __T delim)
    {
      Dafny.ISequence<Dafny.ISequence<__T>> _17903___accumulator = Dafny.Sequence<Dafny.ISequence<__T>>.FromElements();
    TAIL_CALL_START: ;
      Wrappers_Compile.Option<BigInteger> _17904_i = StandardLibrary_Compile.__default.FindIndexMatching<__T>(s, delim, BigInteger.Zero);
      if ((_17904_i).is_Some) {
        _17903___accumulator = Dafny.Sequence<Dafny.ISequence<__T>>.Concat(_17903___accumulator, Dafny.Sequence<Dafny.ISequence<__T>>.FromElements((s).Take((_17904_i).dtor_value)));
        Dafny.ISequence<__T> _in2 = (s).Drop(((_17904_i).dtor_value) + (BigInteger.One));
        __T _in3 = delim;
        s = _in2;
        delim = _in3;
        goto TAIL_CALL_START;
      } else {
        return Dafny.Sequence<Dafny.ISequence<__T>>.Concat(_17903___accumulator, Dafny.Sequence<Dafny.ISequence<__T>>.FromElements(s));
      }
    }
    public static Wrappers_Compile.Option<BigInteger> FindIndexMatching<__T>(Dafny.ISequence<__T> s, __T c, BigInteger i)
    {
      return StandardLibrary_Compile.__default.FindIndex<__T>(s, Dafny.Helpers.Id<Func<__T, Func<__T, bool>>>((_17905_c) => ((System.Func<__T, bool>)((_17906_x) => {
        return object.Equals(_17906_x, _17905_c);
      })))(c), i);
    }
    public static Wrappers_Compile.Option<BigInteger> FindIndex<__T>(Dafny.ISequence<__T> s, Func<__T, bool> f, BigInteger i)
    {
    TAIL_CALL_START: ;
      if ((i) == (new BigInteger((s).Count))) {
        return @Wrappers_Compile.Option<BigInteger>.create_None();
      } else if (Dafny.Helpers.Id<Func<__T, bool>>(f)((s).Select(i))) {
        return @Wrappers_Compile.Option<BigInteger>.create_Some(i);
      } else {
        Dafny.ISequence<__T> _in4 = s;
        Func<__T, bool> _in5 = f;
        BigInteger _in6 = (i) + (BigInteger.One);
        s = _in4;
        f = _in5;
        i = _in6;
        goto TAIL_CALL_START;
      }
    }
    public static Dafny.ISequence<__T> Filter<__T>(Dafny.ISequence<__T> s, Func<__T, bool> f)
    {
      Dafny.ISequence<__T> _17907___accumulator = Dafny.Sequence<__T>.FromElements();
    TAIL_CALL_START: ;
      if ((new BigInteger((s).Count)).Sign == 0) {
        return Dafny.Sequence<__T>.Concat(_17907___accumulator, Dafny.Sequence<__T>.FromElements());
      } else if (Dafny.Helpers.Id<Func<__T, bool>>(f)((s).Select(BigInteger.Zero))) {
        _17907___accumulator = Dafny.Sequence<__T>.Concat(_17907___accumulator, Dafny.Sequence<__T>.FromElements((s).Select(BigInteger.Zero)));
        Dafny.ISequence<__T> _in7 = (s).Drop(BigInteger.One);
        Func<__T, bool> _in8 = f;
        s = _in7;
        f = _in8;
        goto TAIL_CALL_START;
      } else {
        Dafny.ISequence<__T> _in9 = (s).Drop(BigInteger.One);
        Func<__T, bool> _in10 = f;
        s = _in9;
        f = _in10;
        goto TAIL_CALL_START;
      }
    }
    public static BigInteger Min(BigInteger a, BigInteger b)
    {
      if ((a) < (b)) {
        return a;
      } else {
        return b;
      }
    }
    public static Dafny.ISequence<__T> Fill<__T>(__T @value, BigInteger n)
    {
      return ((System.Func<Dafny.ISequence<__T>>) (() => {
        BigInteger dim0 = n;
        var arr0 = new __T[Dafny.Helpers.ToIntChecked(dim0,"C# array size must not be larger than max 32-bit int")];
        for (int i0 = 0; i0 < dim0; i0++) {
          var _17908___v0 = (BigInteger) i0;
          arr0[(int)(_17908___v0)] = @value;
        }
        return Dafny.Sequence<__T>.FromArray(arr0);
      }))();
    }
    public static __T[] SeqToArray<__T>(Dafny.ISequence<__T> s)
    {
      __T[] a = new __T[0];
      __T[] _nw0 = new __T[Dafny.Helpers.ToIntChecked(Dafny.Helpers.ToIntChecked(new BigInteger((s).Count), "C# arrays may not be larger than the max 32-bit integer"),"C# array size must not be larger than max 32-bit int")];
      Func<BigInteger, __T> _arrayinit0 = Dafny.Helpers.Id<Func<Dafny.ISequence<__T>, Func<BigInteger, __T>>>((_17909_s) => ((System.Func<BigInteger, __T>)((_17910_i) => {
        return (_17909_s).Select(_17910_i);
      })))(s);
      for (var _arrayinit_00 = 0; _arrayinit_00 < new BigInteger(_nw0.Length); _arrayinit_00++) {
        _nw0[(int)(_arrayinit_00)] = _arrayinit0(_arrayinit_00);
      }
      a = _nw0;
      return a;
    }
    public static bool LexicographicLessOrEqual<__T>(Dafny.ISequence<__T> a, Dafny.ISequence<__T> b, Func<__T, __T, bool> less)
    {
      return Dafny.Helpers.Id<Func<Dafny.ISequence<__T>, Dafny.ISequence<__T>, Func<__T, __T, bool>, bool>>((_17911_a, _17912_b, _17913_less) => Dafny.Helpers.Quantifier<BigInteger>(Dafny.Helpers.IntegerRange(BigInteger.Zero, (new BigInteger((_17911_a).Count)) + (BigInteger.One)), false, (((_17914_k) => {
        return (((_17914_k).Sign != -1) && ((_17914_k) <= (new BigInteger((_17911_a).Count)))) && (StandardLibrary_Compile.__default.LexicographicLessOrEqualAux<__T>(_17911_a, _17912_b, _17913_less, _17914_k));
      }))))(a, b, less);
    }
    public static bool LexicographicLessOrEqualAux<__T>(Dafny.ISequence<__T> a, Dafny.ISequence<__T> b, Func<__T, __T, bool> less, BigInteger lengthOfCommonPrefix)
    {
      return (((lengthOfCommonPrefix) <= (new BigInteger((b).Count))) && (Dafny.Helpers.Id<Func<BigInteger, Dafny.ISequence<__T>, Dafny.ISequence<__T>, bool>>((_17915_lengthOfCommonPrefix, _17916_a, _17917_b) => Dafny.Helpers.Quantifier<BigInteger>(Dafny.Helpers.IntegerRange(BigInteger.Zero, _17915_lengthOfCommonPrefix), true, (((_17918_i) => {
        return !(((_17918_i).Sign != -1) && ((_17918_i) < (_17915_lengthOfCommonPrefix))) || (object.Equals((_17916_a).Select(_17918_i), (_17917_b).Select(_17918_i)));
      }))))(lengthOfCommonPrefix, a, b))) && (((lengthOfCommonPrefix) == (new BigInteger((a).Count))) || (((lengthOfCommonPrefix) < (new BigInteger((b).Count))) && (Dafny.Helpers.Id<Func<__T, __T, bool>>(less)((a).Select(lengthOfCommonPrefix), (b).Select(lengthOfCommonPrefix)))));
    }
    public static Dafny.ISequence<Dafny.ISequence<__T>> SetToOrderedSequence<__T>(Dafny.ISet<Dafny.ISequence<__T>> s, Func<__T, __T, bool> less)
    {
      Dafny.ISequence<Dafny.ISequence<__T>> _17919___accumulator = Dafny.Sequence<Dafny.ISequence<__T>>.FromElements();
    TAIL_CALL_START: ;
      if ((s).Equals((Dafny.Set<Dafny.ISequence<__T>>.FromElements()))) {
        return Dafny.Sequence<Dafny.ISequence<__T>>.Concat(_17919___accumulator, Dafny.Sequence<Dafny.ISequence<__T>>.FromElements());
      } else {
        return Dafny.Helpers.Let<int, Dafny.ISequence<Dafny.ISequence<__T>>>(0, _let_dummy_0 =>  {
          Dafny.ISequence<__T> _17920_a = Dafny.Sequence<__T>.Empty;
          foreach (Dafny.ISequence<__T> _assign_such_that_0 in (s).Elements) {
            _17920_a = (Dafny.ISequence<__T>)_assign_such_that_0;
            if (((s).Contains((_17920_a))) && (StandardLibrary_Compile.__default.IsMinimum<__T>(_17920_a, s, less))) {
              goto after__ASSIGN_SUCH_THAT_0;
            }
          }
          throw new System.Exception("assign-such-that search produced no value (line 343)");
        after__ASSIGN_SUCH_THAT_0: ;
          return Dafny.Sequence<Dafny.ISequence<__T>>.Concat(Dafny.Sequence<Dafny.ISequence<__T>>.FromElements(_17920_a), StandardLibrary_Compile.__default.SetToOrderedSequence<__T>(Dafny.Set<Dafny.ISequence<__T>>.Difference(s, Dafny.Set<Dafny.ISequence<__T>>.FromElements(_17920_a)), less));
        });
      }
    }
    public static bool IsMinimum<__T>(Dafny.ISequence<__T> a, Dafny.ISet<Dafny.ISequence<__T>> s, Func<__T, __T, bool> less)
    {
      return ((s).Contains((a))) && (Dafny.Helpers.Id<Func<Dafny.ISet<Dafny.ISequence<__T>>, Dafny.ISequence<__T>, Func<__T, __T, bool>, bool>>((_17921_s, _17922_a, _17923_less) => Dafny.Helpers.Quantifier<Dafny.ISequence<__T>>((_17921_s).Elements, true, (((_17924_z) => {
        return !((_17921_s).Contains((_17924_z))) || (StandardLibrary_Compile.__default.LexicographicLessOrEqual<__T>(_17922_a, _17924_z, _17923_less));
      }))))(s, a, less));
    }
  }

} // end of namespace StandardLibrary_Compile
namespace EncryptionSuites {


  public class EncryptionAlgorithm {
    public readonly EncryptionSuites.AESMode mode;
    public EncryptionAlgorithm(EncryptionSuites.AESMode mode) {
      this.mode = mode;
    }
    public override bool Equals(object other) {
      var oth = other as EncryptionSuites.EncryptionAlgorithm;
      return oth != null && object.Equals(this.mode, oth.mode);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.mode));
      return (int) hash;
    }
    public override string ToString() {
      string s = "EncryptionSuites_Compile.EncryptionAlgorithm.AES";
      s += "(";
      s += Dafny.Helpers.ToString(this.mode);
      s += ")";
      return s;
    }
    private static readonly EncryptionAlgorithm theDefault = create(EncryptionSuites.AESMode.Default());
    public static EncryptionAlgorithm Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<EncryptionSuites.EncryptionAlgorithm> _TYPE = new Dafny.TypeDescriptor<EncryptionSuites.EncryptionAlgorithm>(EncryptionSuites.EncryptionAlgorithm.Default());
    public static Dafny.TypeDescriptor<EncryptionSuites.EncryptionAlgorithm> _TypeDescriptor() {
      return _TYPE;
    }
    public static EncryptionAlgorithm create(EncryptionSuites.AESMode mode) {
      return new EncryptionAlgorithm(mode);
    }
    public bool is_AES { get { return true; } }
    public EncryptionSuites.AESMode dtor_mode {
      get {
        return this.mode;
      }
    }
  }

  public class AESMode {
    public AESMode() {
    }
    public override bool Equals(object other) {
      var oth = other as EncryptionSuites.AESMode;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      return (int) hash;
    }
    public override string ToString() {
      string s = "EncryptionSuites_Compile.AESMode.GCM";
      return s;
    }
    private static readonly AESMode theDefault = create();
    public static AESMode Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<EncryptionSuites.AESMode> _TYPE = new Dafny.TypeDescriptor<EncryptionSuites.AESMode>(EncryptionSuites.AESMode.Default());
    public static Dafny.TypeDescriptor<EncryptionSuites.AESMode> _TypeDescriptor() {
      return _TYPE;
    }
    public static AESMode create() {
      return new AESMode();
    }
    public bool is_GCM { get { return true; } }
    public static System.Collections.Generic.IEnumerable<AESMode> AllSingletonConstructors {
      get {
        yield return AESMode.create();
      }
    }
  }

  public class EncryptionSuite {
    public readonly EncryptionSuites.EncryptionAlgorithm alg;
    public readonly byte keyLen;
    public readonly byte tagLen;
    public readonly byte ivLen;
    public EncryptionSuite(EncryptionSuites.EncryptionAlgorithm alg, byte keyLen, byte tagLen, byte ivLen) {
      this.alg = alg;
      this.keyLen = keyLen;
      this.tagLen = tagLen;
      this.ivLen = ivLen;
    }
    public override bool Equals(object other) {
      var oth = other as EncryptionSuites.EncryptionSuite;
      return oth != null && object.Equals(this.alg, oth.alg) && this.keyLen == oth.keyLen && this.tagLen == oth.tagLen && this.ivLen == oth.ivLen;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.alg));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.keyLen));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.tagLen));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.ivLen));
      return (int) hash;
    }
    public override string ToString() {
      string s = "EncryptionSuites_Compile.EncryptionSuite.EncryptionSuite";
      s += "(";
      s += Dafny.Helpers.ToString(this.alg);
      s += ", ";
      s += Dafny.Helpers.ToString(this.keyLen);
      s += ", ";
      s += Dafny.Helpers.ToString(this.tagLen);
      s += ", ";
      s += Dafny.Helpers.ToString(this.ivLen);
      s += ")";
      return s;
    }
    private static readonly EncryptionSuite theDefault = create(EncryptionSuites.EncryptionAlgorithm.Default(), 0, 0, 0);
    public static EncryptionSuite Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<EncryptionSuites.EncryptionSuite> _TYPE = new Dafny.TypeDescriptor<EncryptionSuites.EncryptionSuite>(EncryptionSuites.EncryptionSuite.Default());
    public static Dafny.TypeDescriptor<EncryptionSuites.EncryptionSuite> _TypeDescriptor() {
      return _TYPE;
    }
    public static EncryptionSuite create(EncryptionSuites.EncryptionAlgorithm alg, byte keyLen, byte tagLen, byte ivLen) {
      return new EncryptionSuite(alg, keyLen, tagLen, ivLen);
    }
    public bool is_EncryptionSuite { get { return true; } }
    public EncryptionSuites.EncryptionAlgorithm dtor_alg {
      get {
        return this.alg;
      }
    }
    public byte dtor_keyLen {
      get {
        return this.keyLen;
      }
    }
    public byte dtor_tagLen {
      get {
        return this.tagLen;
      }
    }
    public byte dtor_ivLen {
      get {
        return this.ivLen;
      }
    }
    public bool Valid() {
      EncryptionSuites.EncryptionAlgorithm _source4 = (this).dtor_alg;
      {
        EncryptionSuites.AESMode _17925___mcc_h0 = ((EncryptionSuites.EncryptionAlgorithm)_source4).mode;
        EncryptionSuites.AESMode _17926_mode = _17925___mcc_h0;
        return ((((EncryptionSuites.__default.AES__CIPHER__KEY__LENGTHS).Contains((new BigInteger((this).dtor_keyLen)))) && (((this).dtor_tagLen) == (EncryptionSuites.__default.AES__TAG__LEN))) && (((this).dtor_ivLen) == (EncryptionSuites.__default.AES__IV__LEN))) && (object.Equals(_17926_mode, @EncryptionSuites.AESMode.create()));
      }
    }
  }

  public partial class __default {
    public static byte AES__TAG__LEN { get {
      return (byte)(16);
    } }
    public static byte AES__IV__LEN { get {
      return (byte)(12);
    } }
    public static EncryptionSuites.EncryptionSuite AES__GCM__128 { get {
      return @EncryptionSuites.EncryptionSuite.create(@EncryptionSuites.EncryptionAlgorithm.create(@EncryptionSuites.AESMode.create()), 16, EncryptionSuites.__default.AES__TAG__LEN, EncryptionSuites.__default.AES__IV__LEN);
    } }
    public static EncryptionSuites.EncryptionSuite AES__GCM__192 { get {
      return @EncryptionSuites.EncryptionSuite.create(@EncryptionSuites.EncryptionAlgorithm.create(@EncryptionSuites.AESMode.create()), 24, EncryptionSuites.__default.AES__TAG__LEN, EncryptionSuites.__default.AES__IV__LEN);
    } }
    public static EncryptionSuites.EncryptionSuite AES__GCM__256 { get {
      return @EncryptionSuites.EncryptionSuite.create(@EncryptionSuites.EncryptionAlgorithm.create(@EncryptionSuites.AESMode.create()), 32, EncryptionSuites.__default.AES__TAG__LEN, EncryptionSuites.__default.AES__IV__LEN);
    } }
    public static Dafny.ISet<BigInteger> AES__CIPHER__KEY__LENGTHS { get {
      return Dafny.Set<BigInteger>.FromElements(new BigInteger(32), new BigInteger(24), new BigInteger(16));
    } }
    public static BigInteger AES__MAX__KEY__LEN { get {
      return new BigInteger(32);
    } }
  }
} // end of namespace EncryptionSuites
namespace AESEncryption {





  public class EncryptionOutput {
    public readonly Dafny.ISequence<byte> cipherText;
    public readonly Dafny.ISequence<byte> authTag;
    public EncryptionOutput(Dafny.ISequence<byte> cipherText, Dafny.ISequence<byte> authTag) {
      this.cipherText = cipherText;
      this.authTag = authTag;
    }
    public override bool Equals(object other) {
      var oth = other as AESEncryption.EncryptionOutput;
      return oth != null && object.Equals(this.cipherText, oth.cipherText) && object.Equals(this.authTag, oth.authTag);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.cipherText));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.authTag));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AESEncryption_Compile.EncryptionOutput.EncryptionOutput";
      s += "(";
      s += Dafny.Helpers.ToString(this.cipherText);
      s += ", ";
      s += Dafny.Helpers.ToString(this.authTag);
      s += ")";
      return s;
    }
    private static readonly EncryptionOutput theDefault = create(Dafny.Sequence<byte>.Empty, Dafny.Sequence<byte>.Empty);
    public static EncryptionOutput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<AESEncryption.EncryptionOutput> _TYPE = new Dafny.TypeDescriptor<AESEncryption.EncryptionOutput>(AESEncryption.EncryptionOutput.Default());
    public static Dafny.TypeDescriptor<AESEncryption.EncryptionOutput> _TypeDescriptor() {
      return _TYPE;
    }
    public static EncryptionOutput create(Dafny.ISequence<byte> cipherText, Dafny.ISequence<byte> authTag) {
      return new EncryptionOutput(cipherText, authTag);
    }
    public bool is_EncryptionOutput { get { return true; } }
    public Dafny.ISequence<byte> dtor_cipherText {
      get {
        return this.cipherText;
      }
    }
    public Dafny.ISequence<byte> dtor_authTag {
      get {
        return this.authTag;
      }
    }
  }

  public partial class __default {
    public static AESEncryption.EncryptionOutput EncryptionOutputFromByteSeq(Dafny.ISequence<byte> s, EncryptionSuites.EncryptionSuite encAlg)
    {
      return @AESEncryption.EncryptionOutput.create((s).Take((new BigInteger((s).Count)) - (new BigInteger((encAlg).dtor_tagLen))), (s).Drop((new BigInteger((s).Count)) - (new BigInteger((encAlg).dtor_tagLen))));
    }
    public static Wrappers_Compile.Result<AESEncryption.EncryptionOutput, Dafny.ISequence<char>> AESEncrypt(EncryptionSuites.EncryptionSuite encAlg, Dafny.ISequence<byte> iv, Dafny.ISequence<byte> key, Dafny.ISequence<byte> msg, Dafny.ISequence<byte> aad)
    {
      Wrappers_Compile.Result<AESEncryption.EncryptionOutput, Dafny.ISequence<char>> res = Wrappers_Compile.Result<AESEncryption.EncryptionOutput, Dafny.ISequence<char>>.Default(AESEncryption.EncryptionOutput.Default());
      Wrappers_Compile.Result<AESEncryption.EncryptionOutput, Dafny.ISequence<char>> _out0;
      _out0 = AESEncryption.AES_GCM.AESEncryptExtern(encAlg, iv, key, msg, aad);
      res = _out0;
      if (((res).is_Success) && ((new BigInteger((((res).dtor_value).dtor_cipherText).Count)) != (new BigInteger((msg).Count)))) {
        res = @Wrappers_Compile.Result<AESEncryption.EncryptionOutput, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("AESEncrypt did not return cipherText of expected length"));
      }
      if (((res).is_Success) && ((new BigInteger((((res).dtor_value).dtor_authTag).Count)) != (new BigInteger((encAlg).dtor_tagLen)))) {
        res = @Wrappers_Compile.Result<AESEncryption.EncryptionOutput, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("AESEncryption did not return valid tag"));
      }
      return res;
    }
    public static Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> AESDecrypt(EncryptionSuites.EncryptionSuite encAlg, Dafny.ISequence<byte> key, Dafny.ISequence<byte> cipherTxt, Dafny.ISequence<byte> authTag, Dafny.ISequence<byte> iv, Dafny.ISequence<byte> aad)
    {
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> res = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out1;
      _out1 = AESEncryption.AES_GCM.AESDecryptExtern(encAlg, key, cipherTxt, authTag, iv, aad);
      res = _out1;
      if (((res).is_Success) && ((new BigInteger((cipherTxt).Count)) != (new BigInteger(((res).dtor_value).Count)))) {
        res = @Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("AESDecrypt did not return plaintext of expected length"));
      }
      return res;
    }
  }
} // end of namespace AESEncryption
namespace CryptoDatatypes_Compile {

  public class DigestAlgorithm {
    public DigestAlgorithm() {
    }
    public override bool Equals(object other) {
      var oth = other as CryptoDatatypes_Compile.DigestAlgorithm;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      return (int) hash;
    }
    public override string ToString() {
      string s = "CryptoDatatypes_Compile.DigestAlgorithm.SHA_512";
      return s;
    }
    private static readonly DigestAlgorithm theDefault = create();
    public static DigestAlgorithm Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<CryptoDatatypes_Compile.DigestAlgorithm> _TYPE = new Dafny.TypeDescriptor<CryptoDatatypes_Compile.DigestAlgorithm>(CryptoDatatypes_Compile.DigestAlgorithm.Default());
    public static Dafny.TypeDescriptor<CryptoDatatypes_Compile.DigestAlgorithm> _TypeDescriptor() {
      return _TYPE;
    }
    public static DigestAlgorithm create() {
      return new DigestAlgorithm();
    }
    public bool is_SHA__512 { get { return true; } }
    public static System.Collections.Generic.IEnumerable<DigestAlgorithm> AllSingletonConstructors {
      get {
        yield return DigestAlgorithm.create();
      }
    }
  }

} // end of namespace CryptoDatatypes_Compile
namespace ExternDigest {




} // end of namespace ExternDigest
namespace Digest_Compile {





  public partial class __default {
    public static BigInteger Length(CryptoDatatypes_Compile.DigestAlgorithm alg) {
      CryptoDatatypes_Compile.DigestAlgorithm _source5 = alg;
      {
        return new BigInteger(64);
      }
    }
    public static Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> Digest(CryptoDatatypes_Compile.DigestAlgorithm alg, Dafny.ISequence<byte> msg)
    {
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> res = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _17927_result;
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out2;
      _out2 = ExternDigest.__default.Digest(alg, msg);
      _17927_result = _out2;
      if (((_17927_result).is_Success) && ((new BigInteger(((_17927_result).dtor_value).Count)) != (Digest_Compile.__default.Length(alg)))) {
        res = @Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Incorrect length digest from ExternDigest."));
        return res;
      }
      res = _17927_result;
      return res;
      return res;
    }
  }
} // end of namespace Digest_Compile
namespace KeyDerivationAlgorithms {


  public abstract class KeyDerivationAlgorithm {
    public KeyDerivationAlgorithm() { }
    private static readonly KeyDerivationAlgorithm theDefault = create_HKDF__WITH__SHA__384();
    public static KeyDerivationAlgorithm Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<KeyDerivationAlgorithms.KeyDerivationAlgorithm> _TYPE = new Dafny.TypeDescriptor<KeyDerivationAlgorithms.KeyDerivationAlgorithm>(KeyDerivationAlgorithms.KeyDerivationAlgorithm.Default());
    public static Dafny.TypeDescriptor<KeyDerivationAlgorithms.KeyDerivationAlgorithm> _TypeDescriptor() {
      return _TYPE;
    }
    public static KeyDerivationAlgorithm create_HKDF__WITH__SHA__384() {
      return new KeyDerivationAlgorithm_HKDF__WITH__SHA__384();
    }
    public static KeyDerivationAlgorithm create_HKDF__WITH__SHA__256() {
      return new KeyDerivationAlgorithm_HKDF__WITH__SHA__256();
    }
    public static KeyDerivationAlgorithm create_IDENTITY() {
      return new KeyDerivationAlgorithm_IDENTITY();
    }
    public bool is_HKDF__WITH__SHA__384 { get { return this is KeyDerivationAlgorithm_HKDF__WITH__SHA__384; } }
    public bool is_HKDF__WITH__SHA__256 { get { return this is KeyDerivationAlgorithm_HKDF__WITH__SHA__256; } }
    public bool is_IDENTITY { get { return this is KeyDerivationAlgorithm_IDENTITY; } }
    public static System.Collections.Generic.IEnumerable<KeyDerivationAlgorithm> AllSingletonConstructors {
      get {
        yield return KeyDerivationAlgorithm.create_HKDF__WITH__SHA__384();
        yield return KeyDerivationAlgorithm.create_HKDF__WITH__SHA__256();
        yield return KeyDerivationAlgorithm.create_IDENTITY();
      }
    }
  }
  public class KeyDerivationAlgorithm_HKDF__WITH__SHA__384 : KeyDerivationAlgorithm {
    public KeyDerivationAlgorithm_HKDF__WITH__SHA__384() {
    }
    public override bool Equals(object other) {
      var oth = other as KeyDerivationAlgorithms.KeyDerivationAlgorithm_HKDF__WITH__SHA__384;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      return (int) hash;
    }
    public override string ToString() {
      string s = "KeyDerivationAlgorithms_Compile.KeyDerivationAlgorithm.HKDF_WITH_SHA_384";
      return s;
    }
  }
  public class KeyDerivationAlgorithm_HKDF__WITH__SHA__256 : KeyDerivationAlgorithm {
    public KeyDerivationAlgorithm_HKDF__WITH__SHA__256() {
    }
    public override bool Equals(object other) {
      var oth = other as KeyDerivationAlgorithms.KeyDerivationAlgorithm_HKDF__WITH__SHA__256;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      return (int) hash;
    }
    public override string ToString() {
      string s = "KeyDerivationAlgorithms_Compile.KeyDerivationAlgorithm.HKDF_WITH_SHA_256";
      return s;
    }
  }
  public class KeyDerivationAlgorithm_IDENTITY : KeyDerivationAlgorithm {
    public KeyDerivationAlgorithm_IDENTITY() {
    }
    public override bool Equals(object other) {
      var oth = other as KeyDerivationAlgorithms.KeyDerivationAlgorithm_IDENTITY;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 2;
      return (int) hash;
    }
    public override string ToString() {
      string s = "KeyDerivationAlgorithms_Compile.KeyDerivationAlgorithm.IDENTITY";
      return s;
    }
  }

  public partial class HKDFAlgorithms {
    private static readonly KeyDerivationAlgorithms.KeyDerivationAlgorithm Witness = @KeyDerivationAlgorithms.KeyDerivationAlgorithm.create_HKDF__WITH__SHA__384();
    public static KeyDerivationAlgorithms.KeyDerivationAlgorithm Default() {
      return Witness;
    }
    private static readonly Dafny.TypeDescriptor<KeyDerivationAlgorithms.KeyDerivationAlgorithm> _TYPE = new Dafny.TypeDescriptor<KeyDerivationAlgorithms.KeyDerivationAlgorithm>(KeyDerivationAlgorithms.HKDFAlgorithms.Default());
    public static Dafny.TypeDescriptor<KeyDerivationAlgorithms.KeyDerivationAlgorithm> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public partial class IdentityAlgorithm {
    private static readonly KeyDerivationAlgorithms.KeyDerivationAlgorithm Witness = @KeyDerivationAlgorithms.KeyDerivationAlgorithm.create_IDENTITY();
    public static KeyDerivationAlgorithms.KeyDerivationAlgorithm Default() {
      return Witness;
    }
    private static readonly Dafny.TypeDescriptor<KeyDerivationAlgorithms.KeyDerivationAlgorithm> _TYPE = new Dafny.TypeDescriptor<KeyDerivationAlgorithms.KeyDerivationAlgorithm>(KeyDerivationAlgorithms.IdentityAlgorithm.Default());
    public static Dafny.TypeDescriptor<KeyDerivationAlgorithms.KeyDerivationAlgorithm> _TypeDescriptor() {
      return _TYPE;
    }
  }

} // end of namespace KeyDerivationAlgorithms
namespace HMAC {




  public abstract class Digests {
    public Digests() { }
    private static readonly Digests theDefault = create_SHA__256();
    public static Digests Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<HMAC.Digests> _TYPE = new Dafny.TypeDescriptor<HMAC.Digests>(HMAC.Digests.Default());
    public static Dafny.TypeDescriptor<HMAC.Digests> _TypeDescriptor() {
      return _TYPE;
    }
    public static Digests create_SHA__256() {
      return new Digests_SHA__256();
    }
    public static Digests create_SHA__384() {
      return new Digests_SHA__384();
    }
    public bool is_SHA__256 { get { return this is Digests_SHA__256; } }
    public bool is_SHA__384 { get { return this is Digests_SHA__384; } }
    public static System.Collections.Generic.IEnumerable<Digests> AllSingletonConstructors {
      get {
        yield return Digests.create_SHA__256();
        yield return Digests.create_SHA__384();
      }
    }
  }
  public class Digests_SHA__256 : Digests {
    public Digests_SHA__256() {
    }
    public override bool Equals(object other) {
      var oth = other as HMAC.Digests_SHA__256;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      return (int) hash;
    }
    public override string ToString() {
      string s = "HMAC_Compile.Digests.SHA_256";
      return s;
    }
  }
  public class Digests_SHA__384 : Digests {
    public Digests_SHA__384() {
    }
    public override bool Equals(object other) {
      var oth = other as HMAC.Digests_SHA__384;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      return (int) hash;
    }
    public override string ToString() {
      string s = "HMAC_Compile.Digests.SHA_384";
      return s;
    }
  }


  public partial class __default {
    public static BigInteger GetHashLength(HMAC.Digests digest) {
      HMAC.Digests _source6 = digest;
      if (_source6.is_SHA__256) {
        return new BigInteger(32);
      } else {
        return new BigInteger(48);
      }
    }
  }
} // end of namespace HMAC
namespace HKDF_Compile {





  public partial class __default {
    public static HMAC.Digests GetHMACDigestFromHKDFAlgorithm(KeyDerivationAlgorithms.KeyDerivationAlgorithm algorithm) {
      KeyDerivationAlgorithms.KeyDerivationAlgorithm _source7 = algorithm;
      if (_source7.is_HKDF__WITH__SHA__384) {
        return @HMAC.Digests.create_SHA__384();
      } else {
        return @HMAC.Digests.create_SHA__256();
      }
    }
    public static Dafny.ISequence<byte> Extract(HMAC.HMac hmac, Dafny.ISequence<byte> salt, Dafny.ISequence<byte> ikm)
    {
      Dafny.ISequence<byte> prk = Dafny.Sequence<byte>.Empty;
      (hmac).Init(salt);
      (hmac).BlockUpdate(ikm);
      Dafny.ISequence<byte> _out3;
      _out3 = (hmac).GetResult();
      prk = _out3;
      prk = prk;
      return prk;
      return prk;
    }
    public static Dafny.ISequence<byte> Expand(HMAC.HMac hmac, Dafny.ISequence<byte> prk, Dafny.ISequence<byte> info, BigInteger expectedLength, HMAC.Digests digest)
    {
      Dafny.ISequence<byte> okm = Dafny.Sequence<byte>.Empty;
      BigInteger _17928_hashLength;
      _17928_hashLength = HMAC.__default.GetHashLength(digest);
      BigInteger _17929_n;
      _17929_n = Dafny.Helpers.EuclideanDivision(((_17928_hashLength) + (expectedLength)) - (BigInteger.One), _17928_hashLength);
      (hmac).Init(prk);
      Dafny.ISequence<byte> _17930_t__prev;
      _17930_t__prev = Dafny.Sequence<byte>.FromElements();
      Dafny.ISequence<byte> _17931_t__n;
      _17931_t__n = _17930_t__prev;
      BigInteger _17932_i;
      _17932_i = BigInteger.One;
      while ((_17932_i) <= (_17929_n)) {
        (hmac).BlockUpdate(_17930_t__prev);
        (hmac).BlockUpdate(info);
        (hmac).BlockUpdate(Dafny.Sequence<byte>.FromElements((byte)(_17932_i)));
        Dafny.ISequence<byte> _out4;
        _out4 = (hmac).GetResult();
        _17930_t__prev = _out4;
        _17931_t__n = Dafny.Sequence<byte>.Concat(_17931_t__n, _17930_t__prev);
        _17932_i = (_17932_i) + (BigInteger.One);
      }
      okm = _17931_t__n;
      if ((expectedLength) < (new BigInteger((okm).Count))) {
        okm = (okm).Take(expectedLength);
      }
      return okm;
    }
    public static Dafny.ISequence<byte> Hkdf(KeyDerivationAlgorithms.KeyDerivationAlgorithm algorithm, Wrappers_Compile.Option<Dafny.ISequence<byte>> salt, Dafny.ISequence<byte> ikm, Dafny.ISequence<byte> info, BigInteger L)
    {
      Dafny.ISequence<byte> okm = Dafny.Sequence<byte>.Empty;
      if ((L).Sign == 0) {
        okm = Dafny.Sequence<byte>.FromElements();
        return okm;
      }
      HMAC.Digests _17933_digest;
      _17933_digest = HKDF_Compile.__default.GetHMACDigestFromHKDFAlgorithm(algorithm);
      HMAC.HMac _17934_hmac;
      HMAC.HMac _nw1 = new HMAC.HMac(_17933_digest);
      _17934_hmac = _nw1;
      BigInteger _17935_hashLength;
      _17935_hashLength = HMAC.__default.GetHashLength(_17933_digest);
      Dafny.ISequence<byte> _17936_nonEmptySalt = Dafny.Sequence<byte>.Empty;
      Wrappers_Compile.Option<Dafny.ISequence<byte>> _source8 = salt;
      if (_source8.is_None) {
        {
          _17936_nonEmptySalt = StandardLibrary_Compile.__default.Fill<byte>(0, _17935_hashLength);
        }
      } else {
        Dafny.ISequence<byte> _17937___mcc_h0 = ((Wrappers_Compile.Option_Some<Dafny.ISequence<byte>>)_source8).@value;
        {
          Dafny.ISequence<byte> _17938_s = _17937___mcc_h0;
          _17936_nonEmptySalt = _17938_s;
        }
      }
      Dafny.ISequence<byte> _17939_prk;
      Dafny.ISequence<byte> _out5;
      _out5 = HKDF_Compile.__default.Extract(_17934_hmac, _17936_nonEmptySalt, ikm);
      _17939_prk = _out5;
      Dafny.ISequence<byte> _out6;
      _out6 = HKDF_Compile.__default.Expand(_17934_hmac, _17939_prk, info, L, _17933_digest);
      okm = _out6;
      return okm;
    }
  }
} // end of namespace HKDF_Compile
namespace ExternRandom {



} // end of namespace ExternRandom
namespace Random_Compile {





  public partial class __default {
    public static Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> GenerateBytes(int i)
    {
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> res = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _17940_result;
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out7;
      _out7 = ExternRandom.__default.GenerateBytes(i);
      _17940_result = _out7;
      if (((_17940_result).is_Success) && ((new BigInteger(((_17940_result).dtor_value).Count)) != (new BigInteger(i)))) {
        res = @Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Incorrect length from ExternRandom."));
        return res;
      }
      res = _17940_result;
      return res;
      return res;
    }
  }
} // end of namespace Random_Compile
namespace RSAEncryption {



  public abstract class PaddingMode {
    public PaddingMode() { }
    private static readonly PaddingMode theDefault = create_PKCS1();
    public static PaddingMode Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<RSAEncryption.PaddingMode> _TYPE = new Dafny.TypeDescriptor<RSAEncryption.PaddingMode>(RSAEncryption.PaddingMode.Default());
    public static Dafny.TypeDescriptor<RSAEncryption.PaddingMode> _TypeDescriptor() {
      return _TYPE;
    }
    public static PaddingMode create_PKCS1() {
      return new PaddingMode_PKCS1();
    }
    public static PaddingMode create_OAEP__SHA1() {
      return new PaddingMode_OAEP__SHA1();
    }
    public static PaddingMode create_OAEP__SHA256() {
      return new PaddingMode_OAEP__SHA256();
    }
    public static PaddingMode create_OAEP__SHA384() {
      return new PaddingMode_OAEP__SHA384();
    }
    public static PaddingMode create_OAEP__SHA512() {
      return new PaddingMode_OAEP__SHA512();
    }
    public bool is_PKCS1 { get { return this is PaddingMode_PKCS1; } }
    public bool is_OAEP__SHA1 { get { return this is PaddingMode_OAEP__SHA1; } }
    public bool is_OAEP__SHA256 { get { return this is PaddingMode_OAEP__SHA256; } }
    public bool is_OAEP__SHA384 { get { return this is PaddingMode_OAEP__SHA384; } }
    public bool is_OAEP__SHA512 { get { return this is PaddingMode_OAEP__SHA512; } }
    public static System.Collections.Generic.IEnumerable<PaddingMode> AllSingletonConstructors {
      get {
        yield return PaddingMode.create_PKCS1();
        yield return PaddingMode.create_OAEP__SHA1();
        yield return PaddingMode.create_OAEP__SHA256();
        yield return PaddingMode.create_OAEP__SHA384();
        yield return PaddingMode.create_OAEP__SHA512();
      }
    }
  }
  public class PaddingMode_PKCS1 : PaddingMode {
    public PaddingMode_PKCS1() {
    }
    public override bool Equals(object other) {
      var oth = other as RSAEncryption.PaddingMode_PKCS1;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      return (int) hash;
    }
    public override string ToString() {
      string s = "RSAEncryption_Compile.PaddingMode.PKCS1";
      return s;
    }
  }
  public class PaddingMode_OAEP__SHA1 : PaddingMode {
    public PaddingMode_OAEP__SHA1() {
    }
    public override bool Equals(object other) {
      var oth = other as RSAEncryption.PaddingMode_OAEP__SHA1;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      return (int) hash;
    }
    public override string ToString() {
      string s = "RSAEncryption_Compile.PaddingMode.OAEP_SHA1";
      return s;
    }
  }
  public class PaddingMode_OAEP__SHA256 : PaddingMode {
    public PaddingMode_OAEP__SHA256() {
    }
    public override bool Equals(object other) {
      var oth = other as RSAEncryption.PaddingMode_OAEP__SHA256;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 2;
      return (int) hash;
    }
    public override string ToString() {
      string s = "RSAEncryption_Compile.PaddingMode.OAEP_SHA256";
      return s;
    }
  }
  public class PaddingMode_OAEP__SHA384 : PaddingMode {
    public PaddingMode_OAEP__SHA384() {
    }
    public override bool Equals(object other) {
      var oth = other as RSAEncryption.PaddingMode_OAEP__SHA384;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 3;
      return (int) hash;
    }
    public override string ToString() {
      string s = "RSAEncryption_Compile.PaddingMode.OAEP_SHA384";
      return s;
    }
  }
  public class PaddingMode_OAEP__SHA512 : PaddingMode {
    public PaddingMode_OAEP__SHA512() {
    }
    public override bool Equals(object other) {
      var oth = other as RSAEncryption.PaddingMode_OAEP__SHA512;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 4;
      return (int) hash;
    }
    public override string ToString() {
      string s = "RSAEncryption_Compile.PaddingMode.OAEP_SHA512";
      return s;
    }
  }

  public partial class StrengthBits {
    public static System.Collections.Generic.IEnumerable<int> IntegerRange(BigInteger lo, BigInteger hi) {
      for (var j = lo; j < hi; j++) { yield return (int)j; }
    }
    public static readonly int Witness = (int)(new BigInteger(81));
    private static readonly Dafny.TypeDescriptor<int> _TYPE = new Dafny.TypeDescriptor<int>(RSAEncryption.StrengthBits.Witness);
    public static Dafny.TypeDescriptor<int> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public interface Key {
    Dafny.ISequence<byte> pem { get; }
  }
  public class _Companion_Key {
  }

  public partial class PrivateKey : RSAEncryption.Key {
    public PrivateKey() {
      this._pem = Dafny.Sequence<byte>.Empty;
    }
    public Dafny.ISequence<byte> _pem;public Dafny.ISequence<byte> pem { get {
      return this._pem;
    } }
    public void __ctor(Dafny.ISequence<byte> pem)
    {
      (this)._pem = pem;
    }
  }

  public partial class PublicKey : RSAEncryption.Key {
    public PublicKey() {
      this._pem = Dafny.Sequence<byte>.Empty;
    }
    public Dafny.ISequence<byte> _pem;public Dafny.ISequence<byte> pem { get {
      return this._pem;
    } }
    public void __ctor(Dafny.ISequence<byte> pem)
    {
      (this)._pem = pem;
    }
  }

  public partial class __default {
    public static void GenerateKeyPair(int strength, RSAEncryption.PaddingMode padding, out RSAEncryption.PublicKey publicKey, out RSAEncryption.PrivateKey privateKey)
    {
      publicKey = default(RSAEncryption.PublicKey);
      privateKey = default(RSAEncryption.PrivateKey);
      Dafny.ISequence<byte> _17941_pemPublic;
      Dafny.ISequence<byte> _17942_pemPrivate;
      Dafny.ISequence<byte> _out8;
      Dafny.ISequence<byte> _out9;
      RSAEncryption.RSA.GenerateKeyPairExtern(strength, padding, out _out8, out _out9);
      _17941_pemPublic = _out8;
      _17942_pemPrivate = _out9;
      RSAEncryption.PrivateKey _nw2 = new RSAEncryption.PrivateKey();
      _nw2.__ctor(_17942_pemPrivate);
      privateKey = _nw2;
      RSAEncryption.PublicKey _nw3 = new RSAEncryption.PublicKey();
      _nw3.__ctor(_17941_pemPublic);
      publicKey = _nw3;
    }
    public static Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> Decrypt(RSAEncryption.PaddingMode padding, RSAEncryption.PrivateKey privateKey, Dafny.ISequence<byte> cipherText)
    {
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> res = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out10;
      _out10 = RSAEncryption.RSA.DecryptExtern(padding, (privateKey).pem, cipherText);
      res = _out10;
      return res;
    }
    public static Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> Encrypt(RSAEncryption.PaddingMode padding, RSAEncryption.PublicKey publicKey, Dafny.ISequence<byte> plaintextData)
    {
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> res = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out11;
      _out11 = RSAEncryption.RSA.EncryptExtern(padding, (publicKey).pem, plaintextData);
      res = _out11;
      return res;
    }
    public static BigInteger SHA1__HASH__BYTES { get {
      return new BigInteger(20);
    } }
    public static BigInteger SHA256__HASH__BYTES { get {
      return new BigInteger(32);
    } }
    public static BigInteger SHA384__HASH__BYTES { get {
      return new BigInteger(48);
    } }
    public static BigInteger SHA512__HASH__BYTES { get {
      return new BigInteger(64);
    } }
  }
} // end of namespace RSAEncryption
namespace Signature {




  public class SignatureKeyPair {
    public readonly Dafny.ISequence<byte> verificationKey;
    public readonly Dafny.ISequence<byte> signingKey;
    public SignatureKeyPair(Dafny.ISequence<byte> verificationKey, Dafny.ISequence<byte> signingKey) {
      this.verificationKey = verificationKey;
      this.signingKey = signingKey;
    }
    public override bool Equals(object other) {
      var oth = other as Signature.SignatureKeyPair;
      return oth != null && object.Equals(this.verificationKey, oth.verificationKey) && object.Equals(this.signingKey, oth.signingKey);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.verificationKey));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.signingKey));
      return (int) hash;
    }
    public override string ToString() {
      string s = "Signature_Compile.SignatureKeyPair.SignatureKeyPair";
      s += "(";
      s += Dafny.Helpers.ToString(this.verificationKey);
      s += ", ";
      s += Dafny.Helpers.ToString(this.signingKey);
      s += ")";
      return s;
    }
    private static readonly SignatureKeyPair theDefault = create(Dafny.Sequence<byte>.Empty, Dafny.Sequence<byte>.Empty);
    public static SignatureKeyPair Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<Signature.SignatureKeyPair> _TYPE = new Dafny.TypeDescriptor<Signature.SignatureKeyPair>(Signature.SignatureKeyPair.Default());
    public static Dafny.TypeDescriptor<Signature.SignatureKeyPair> _TypeDescriptor() {
      return _TYPE;
    }
    public static SignatureKeyPair create(Dafny.ISequence<byte> verificationKey, Dafny.ISequence<byte> signingKey) {
      return new SignatureKeyPair(verificationKey, signingKey);
    }
    public bool is_SignatureKeyPair { get { return true; } }
    public Dafny.ISequence<byte> dtor_verificationKey {
      get {
        return this.verificationKey;
      }
    }
    public Dafny.ISequence<byte> dtor_signingKey {
      get {
        return this.signingKey;
      }
    }
  }

  public abstract class ECDSAParams {
    public ECDSAParams() { }
    private static readonly ECDSAParams theDefault = create_ECDSA__P384();
    public static ECDSAParams Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<Signature.ECDSAParams> _TYPE = new Dafny.TypeDescriptor<Signature.ECDSAParams>(Signature.ECDSAParams.Default());
    public static Dafny.TypeDescriptor<Signature.ECDSAParams> _TypeDescriptor() {
      return _TYPE;
    }
    public static ECDSAParams create_ECDSA__P384() {
      return new ECDSAParams_ECDSA__P384();
    }
    public static ECDSAParams create_ECDSA__P256() {
      return new ECDSAParams_ECDSA__P256();
    }
    public bool is_ECDSA__P384 { get { return this is ECDSAParams_ECDSA__P384; } }
    public bool is_ECDSA__P256 { get { return this is ECDSAParams_ECDSA__P256; } }
    public static System.Collections.Generic.IEnumerable<ECDSAParams> AllSingletonConstructors {
      get {
        yield return ECDSAParams.create_ECDSA__P384();
        yield return ECDSAParams.create_ECDSA__P256();
      }
    }
    public ushort SignatureLength() {
      Signature.ECDSAParams _source9 = this;
      if (_source9.is_ECDSA__P384) {
        return 103;
      } else {
        return 71;
      }
    }
    public BigInteger FieldSize() {
      Signature.ECDSAParams _source10 = this;
      if (_source10.is_ECDSA__P384) {
        return new BigInteger(49);
      } else {
        return new BigInteger(33);
      }
    }
  }
  public class ECDSAParams_ECDSA__P384 : ECDSAParams {
    public ECDSAParams_ECDSA__P384() {
    }
    public override bool Equals(object other) {
      var oth = other as Signature.ECDSAParams_ECDSA__P384;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      return (int) hash;
    }
    public override string ToString() {
      string s = "Signature_Compile.ECDSAParams.ECDSA_P384";
      return s;
    }
  }
  public class ECDSAParams_ECDSA__P256 : ECDSAParams {
    public ECDSAParams_ECDSA__P256() {
    }
    public override bool Equals(object other) {
      var oth = other as Signature.ECDSAParams_ECDSA__P256;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      return (int) hash;
    }
    public override string ToString() {
      string s = "Signature_Compile.ECDSAParams.ECDSA_P256";
      return s;
    }
  }

  public partial class __default {
    public static Wrappers_Compile.Result<Signature.SignatureKeyPair, Dafny.ISequence<char>> KeyGen(Signature.ECDSAParams s)
    {
      Wrappers_Compile.Result<Signature.SignatureKeyPair, Dafny.ISequence<char>> res = Wrappers_Compile.Result<Signature.SignatureKeyPair, Dafny.ISequence<char>>.Default(Signature.SignatureKeyPair.Default());
      Signature.SignatureKeyPair _17943_sigKeyPair = Signature.SignatureKeyPair.Default();
      Wrappers_Compile.Result<Signature.SignatureKeyPair, Dafny.ISequence<char>> _17944_valueOrError0 = Wrappers_Compile.Result<Signature.SignatureKeyPair, Dafny.ISequence<char>>.Default(Signature.SignatureKeyPair.Default());
      Wrappers_Compile.Result<Signature.SignatureKeyPair, Dafny.ISequence<char>> _out12;
      _out12 = Signature.ECDSA.ExternKeyGen(s);
      _17944_valueOrError0 = _out12;
      if ((_17944_valueOrError0).IsFailure()) {
        res = (_17944_valueOrError0).PropagateFailure<Signature.SignatureKeyPair>();
        return res;
      }
      _17943_sigKeyPair = (_17944_valueOrError0).Extract();
      if ((new BigInteger(((_17943_sigKeyPair).dtor_verificationKey).Count)) == ((s).FieldSize())) {
        res = @Wrappers_Compile.Result<Signature.SignatureKeyPair, Dafny.ISequence<char>>.create_Success(_17943_sigKeyPair);
        return res;
      } else {
        res = @Wrappers_Compile.Result<Signature.SignatureKeyPair, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Incorrect verification-key length from ExternKeyGen."));
        return res;
      }
      return res;
    }
  }
} // end of namespace Signature
namespace Amazon.KeyManagementService {


} // end of namespace Amazon.KeyManagementService
namespace UTF8 {



  public partial class ValidUTF8Bytes {
    private static readonly Dafny.ISequence<byte> Witness = Dafny.Sequence<byte>.FromElements();
    public static Dafny.ISequence<byte> Default() {
      return Witness;
    }
    private static readonly Dafny.TypeDescriptor<Dafny.ISequence<byte>> _TYPE = new Dafny.TypeDescriptor<Dafny.ISequence<byte>>(UTF8.ValidUTF8Bytes.Default());
    public static Dafny.TypeDescriptor<Dafny.ISequence<byte>> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public partial class __default {
    public static bool IsASCIIString(Dafny.ISequence<char> s) {
      return Dafny.Helpers.Id<Func<Dafny.ISequence<char>, bool>>((_17945_s) => Dafny.Helpers.Quantifier<BigInteger>(Dafny.Helpers.IntegerRange(BigInteger.Zero, new BigInteger((_17945_s).Count)), true, (((_17946_i) => {
        return !(((_17946_i).Sign != -1) && ((_17946_i) < (new BigInteger((_17945_s).Count)))) || ((new BigInteger((_17945_s).Select(_17946_i))) < (new BigInteger(128)));
      }))))(s);
    }
    public static bool Uses1Byte(Dafny.ISequence<byte> s) {
      return ((0) <= ((s).Select(BigInteger.Zero))) && (((s).Select(BigInteger.Zero)) <= (127));
    }
    public static bool Uses2Bytes(Dafny.ISequence<byte> s) {
      return (((194) <= ((s).Select(BigInteger.Zero))) && (((s).Select(BigInteger.Zero)) <= (223))) && (((128) <= ((s).Select(BigInteger.One))) && (((s).Select(BigInteger.One)) <= (191)));
    }
    public static bool Uses3Bytes(Dafny.ISequence<byte> s) {
      return (((((((s).Select(BigInteger.Zero)) == (224)) && (((160) <= ((s).Select(BigInteger.One))) && (((s).Select(BigInteger.One)) <= (191)))) && (((128) <= ((s).Select(new BigInteger(2)))) && (((s).Select(new BigInteger(2))) <= (191)))) || (((((225) <= ((s).Select(BigInteger.Zero))) && (((s).Select(BigInteger.Zero)) <= (236))) && (((128) <= ((s).Select(BigInteger.One))) && (((s).Select(BigInteger.One)) <= (191)))) && (((128) <= ((s).Select(new BigInteger(2)))) && (((s).Select(new BigInteger(2))) <= (191))))) || (((((s).Select(BigInteger.Zero)) == (237)) && (((128) <= ((s).Select(BigInteger.One))) && (((s).Select(BigInteger.One)) <= (159)))) && (((128) <= ((s).Select(new BigInteger(2)))) && (((s).Select(new BigInteger(2))) <= (191))))) || (((((238) <= ((s).Select(BigInteger.Zero))) && (((s).Select(BigInteger.Zero)) <= (239))) && (((128) <= ((s).Select(BigInteger.One))) && (((s).Select(BigInteger.One)) <= (191)))) && (((128) <= ((s).Select(new BigInteger(2)))) && (((s).Select(new BigInteger(2))) <= (191))));
    }
    public static bool Uses4Bytes(Dafny.ISequence<byte> s) {
      return (((((((s).Select(BigInteger.Zero)) == (240)) && (((144) <= ((s).Select(BigInteger.One))) && (((s).Select(BigInteger.One)) <= (191)))) && (((128) <= ((s).Select(new BigInteger(2)))) && (((s).Select(new BigInteger(2))) <= (191)))) && (((128) <= ((s).Select(new BigInteger(3)))) && (((s).Select(new BigInteger(3))) <= (191)))) || ((((((241) <= ((s).Select(BigInteger.Zero))) && (((s).Select(BigInteger.Zero)) <= (243))) && (((128) <= ((s).Select(BigInteger.One))) && (((s).Select(BigInteger.One)) <= (191)))) && (((128) <= ((s).Select(new BigInteger(2)))) && (((s).Select(new BigInteger(2))) <= (191)))) && (((128) <= ((s).Select(new BigInteger(3)))) && (((s).Select(new BigInteger(3))) <= (191))))) || ((((((s).Select(BigInteger.Zero)) == (244)) && (((128) <= ((s).Select(BigInteger.One))) && (((s).Select(BigInteger.One)) <= (143)))) && (((128) <= ((s).Select(new BigInteger(2)))) && (((s).Select(new BigInteger(2))) <= (191)))) && (((128) <= ((s).Select(new BigInteger(3)))) && (((s).Select(new BigInteger(3))) <= (191))));
    }
    public static bool ValidUTF8Range(Dafny.ISequence<byte> a, BigInteger lo, BigInteger hi)
    {
      if ((lo) == (hi)) {
        return true;
      } else {
        Dafny.ISequence<byte> _17947_r = (a).Subsequence(lo, hi);
        if (UTF8.__default.Uses1Byte(_17947_r)) {
          return UTF8.__default.ValidUTF8Range(a, (lo) + (BigInteger.One), hi);
        } else if (((new BigInteger(2)) <= (new BigInteger((_17947_r).Count))) && (UTF8.__default.Uses2Bytes(_17947_r))) {
          return UTF8.__default.ValidUTF8Range(a, (lo) + (new BigInteger(2)), hi);
        } else if (((new BigInteger(3)) <= (new BigInteger((_17947_r).Count))) && (UTF8.__default.Uses3Bytes(_17947_r))) {
          return UTF8.__default.ValidUTF8Range(a, (lo) + (new BigInteger(3)), hi);
        } else {
          return (((new BigInteger(4)) <= (new BigInteger((_17947_r).Count))) && (UTF8.__default.Uses4Bytes(_17947_r))) && (UTF8.__default.ValidUTF8Range(a, (lo) + (new BigInteger(4)), hi));
        }
      }
    }
    public static bool ValidUTF8Seq(Dafny.ISequence<byte> s) {
      return UTF8.__default.ValidUTF8Range(s, BigInteger.Zero, new BigInteger((s).Count));
    }
  }
} // end of namespace UTF8
namespace Dafny.Aws.Crypto {












  public class DiscoveryFilter {
    public readonly Dafny.ISequence<char> accountId;
    public readonly Dafny.ISequence<char> partition;
    public DiscoveryFilter(Dafny.ISequence<char> accountId, Dafny.ISequence<char> partition) {
      this.accountId = accountId;
      this.partition = partition;
    }
    public override bool Equals(object other) {
      var oth = other as Dafny.Aws.Crypto.DiscoveryFilter;
      return oth != null && object.Equals(this.accountId, oth.accountId) && object.Equals(this.partition, oth.partition);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.accountId));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.partition));
      return (int) hash;
    }
    public override string ToString() {
      string s = "Dafny.Aws.Crypto_Compile.DiscoveryFilter.DiscoveryFilter";
      s += "(";
      s += Dafny.Helpers.ToString(this.accountId);
      s += ", ";
      s += Dafny.Helpers.ToString(this.partition);
      s += ")";
      return s;
    }
    private static readonly DiscoveryFilter theDefault = create(Dafny.Sequence<char>.Empty, Dafny.Sequence<char>.Empty);
    public static DiscoveryFilter Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<Dafny.Aws.Crypto.DiscoveryFilter> _TYPE = new Dafny.TypeDescriptor<Dafny.Aws.Crypto.DiscoveryFilter>(Dafny.Aws.Crypto.DiscoveryFilter.Default());
    public static Dafny.TypeDescriptor<Dafny.Aws.Crypto.DiscoveryFilter> _TypeDescriptor() {
      return _TYPE;
    }
    public static DiscoveryFilter create(Dafny.ISequence<char> accountId, Dafny.ISequence<char> partition) {
      return new DiscoveryFilter(accountId, partition);
    }
    public bool is_DiscoveryFilter { get { return true; } }
    public Dafny.ISequence<char> dtor_accountId {
      get {
        return this.accountId;
      }
    }
    public Dafny.ISequence<char> dtor_partition {
      get {
        return this.partition;
      }
    }
  }

  public class GetClientInput {
    public readonly Dafny.ISequence<char> region;
    public GetClientInput(Dafny.ISequence<char> region) {
      this.region = region;
    }
    public override bool Equals(object other) {
      var oth = other as Dafny.Aws.Crypto.GetClientInput;
      return oth != null && object.Equals(this.region, oth.region);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.region));
      return (int) hash;
    }
    public override string ToString() {
      string s = "Dafny.Aws.Crypto_Compile.GetClientInput.GetClientInput";
      s += "(";
      s += Dafny.Helpers.ToString(this.region);
      s += ")";
      return s;
    }
    private static readonly GetClientInput theDefault = create(Dafny.Sequence<char>.Empty);
    public static GetClientInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<Dafny.Aws.Crypto.GetClientInput> _TYPE = new Dafny.TypeDescriptor<Dafny.Aws.Crypto.GetClientInput>(Dafny.Aws.Crypto.GetClientInput.Default());
    public static Dafny.TypeDescriptor<Dafny.Aws.Crypto.GetClientInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static GetClientInput create(Dafny.ISequence<char> region) {
      return new GetClientInput(region);
    }
    public bool is_GetClientInput { get { return true; } }
    public Dafny.ISequence<char> dtor_region {
      get {
        return this.region;
      }
    }
  }

  public interface IKmsClient {
  }
  public class _Companion_IKmsClient {
  }

  public interface IClientSupplier {
    Dafny.Aws.Crypto.IKmsClient GetClient(Dafny.Aws.Crypto.GetClientInput input);
  }
  public class _Companion_IClientSupplier {
  }


  public class EncryptedDataKey {
    public readonly Dafny.ISequence<byte> keyProviderId;
    public readonly Dafny.ISequence<byte> keyProviderInfo;
    public readonly Dafny.ISequence<byte> ciphertext;
    public EncryptedDataKey(Dafny.ISequence<byte> keyProviderId, Dafny.ISequence<byte> keyProviderInfo, Dafny.ISequence<byte> ciphertext) {
      this.keyProviderId = keyProviderId;
      this.keyProviderInfo = keyProviderInfo;
      this.ciphertext = ciphertext;
    }
    public override bool Equals(object other) {
      var oth = other as Dafny.Aws.Crypto.EncryptedDataKey;
      return oth != null && object.Equals(this.keyProviderId, oth.keyProviderId) && object.Equals(this.keyProviderInfo, oth.keyProviderInfo) && object.Equals(this.ciphertext, oth.ciphertext);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.keyProviderId));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.keyProviderInfo));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.ciphertext));
      return (int) hash;
    }
    public override string ToString() {
      string s = "Dafny.Aws.Crypto_Compile.EncryptedDataKey.EncryptedDataKey";
      s += "(";
      s += Dafny.Helpers.ToString(this.keyProviderId);
      s += ", ";
      s += Dafny.Helpers.ToString(this.keyProviderInfo);
      s += ", ";
      s += Dafny.Helpers.ToString(this.ciphertext);
      s += ")";
      return s;
    }
    private static readonly EncryptedDataKey theDefault = create(UTF8.ValidUTF8Bytes.Default(), Dafny.Sequence<byte>.Empty, Dafny.Sequence<byte>.Empty);
    public static EncryptedDataKey Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<Dafny.Aws.Crypto.EncryptedDataKey> _TYPE = new Dafny.TypeDescriptor<Dafny.Aws.Crypto.EncryptedDataKey>(Dafny.Aws.Crypto.EncryptedDataKey.Default());
    public static Dafny.TypeDescriptor<Dafny.Aws.Crypto.EncryptedDataKey> _TypeDescriptor() {
      return _TYPE;
    }
    public static EncryptedDataKey create(Dafny.ISequence<byte> keyProviderId, Dafny.ISequence<byte> keyProviderInfo, Dafny.ISequence<byte> ciphertext) {
      return new EncryptedDataKey(keyProviderId, keyProviderInfo, ciphertext);
    }
    public bool is_EncryptedDataKey { get { return true; } }
    public Dafny.ISequence<byte> dtor_keyProviderId {
      get {
        return this.keyProviderId;
      }
    }
    public Dafny.ISequence<byte> dtor_keyProviderInfo {
      get {
        return this.keyProviderInfo;
      }
    }
    public Dafny.ISequence<byte> dtor_ciphertext {
      get {
        return this.ciphertext;
      }
    }
  }

  public partial class ValidEncryptedDataKey {
    private static readonly Dafny.TypeDescriptor<Dafny.Aws.Crypto.EncryptedDataKey> _TYPE = new Dafny.TypeDescriptor<Dafny.Aws.Crypto.EncryptedDataKey>(Dafny.Aws.Crypto.EncryptedDataKey.Default());
    public static Dafny.TypeDescriptor<Dafny.Aws.Crypto.EncryptedDataKey> _TypeDescriptor() {
      return _TYPE;
    }
  }


  public class EncryptionMaterials {
    public readonly Dafny.Aws.Crypto.AlgorithmSuiteId algorithmSuiteId;
    public readonly Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext;
    public readonly Dafny.ISequence<Dafny.Aws.Crypto.EncryptedDataKey> encryptedDataKeys;
    public readonly Wrappers_Compile.Option<Dafny.ISequence<byte>> plaintextDataKey;
    public readonly Wrappers_Compile.Option<Dafny.ISequence<byte>> signingKey;
    public EncryptionMaterials(Dafny.Aws.Crypto.AlgorithmSuiteId algorithmSuiteId, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext, Dafny.ISequence<Dafny.Aws.Crypto.EncryptedDataKey> encryptedDataKeys, Wrappers_Compile.Option<Dafny.ISequence<byte>> plaintextDataKey, Wrappers_Compile.Option<Dafny.ISequence<byte>> signingKey) {
      this.algorithmSuiteId = algorithmSuiteId;
      this.encryptionContext = encryptionContext;
      this.encryptedDataKeys = encryptedDataKeys;
      this.plaintextDataKey = plaintextDataKey;
      this.signingKey = signingKey;
    }
    public override bool Equals(object other) {
      var oth = other as Dafny.Aws.Crypto.EncryptionMaterials;
      return oth != null && object.Equals(this.algorithmSuiteId, oth.algorithmSuiteId) && object.Equals(this.encryptionContext, oth.encryptionContext) && object.Equals(this.encryptedDataKeys, oth.encryptedDataKeys) && object.Equals(this.plaintextDataKey, oth.plaintextDataKey) && object.Equals(this.signingKey, oth.signingKey);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.algorithmSuiteId));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.encryptionContext));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.encryptedDataKeys));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.plaintextDataKey));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.signingKey));
      return (int) hash;
    }
    public override string ToString() {
      string s = "Dafny.Aws.Crypto_Compile.EncryptionMaterials.EncryptionMaterials";
      s += "(";
      s += Dafny.Helpers.ToString(this.algorithmSuiteId);
      s += ", ";
      s += Dafny.Helpers.ToString(this.encryptionContext);
      s += ", ";
      s += Dafny.Helpers.ToString(this.encryptedDataKeys);
      s += ", ";
      s += Dafny.Helpers.ToString(this.plaintextDataKey);
      s += ", ";
      s += Dafny.Helpers.ToString(this.signingKey);
      s += ")";
      return s;
    }
    private static readonly EncryptionMaterials theDefault = create(Dafny.Aws.Crypto.AlgorithmSuiteId.Default(), Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Empty, Dafny.Sequence<Dafny.Aws.Crypto.EncryptedDataKey>.Empty, Wrappers_Compile.Option<Dafny.ISequence<byte>>.Default(), Wrappers_Compile.Option<Dafny.ISequence<byte>>.Default());
    public static EncryptionMaterials Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<Dafny.Aws.Crypto.EncryptionMaterials> _TYPE = new Dafny.TypeDescriptor<Dafny.Aws.Crypto.EncryptionMaterials>(Dafny.Aws.Crypto.EncryptionMaterials.Default());
    public static Dafny.TypeDescriptor<Dafny.Aws.Crypto.EncryptionMaterials> _TypeDescriptor() {
      return _TYPE;
    }
    public static EncryptionMaterials create(Dafny.Aws.Crypto.AlgorithmSuiteId algorithmSuiteId, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext, Dafny.ISequence<Dafny.Aws.Crypto.EncryptedDataKey> encryptedDataKeys, Wrappers_Compile.Option<Dafny.ISequence<byte>> plaintextDataKey, Wrappers_Compile.Option<Dafny.ISequence<byte>> signingKey) {
      return new EncryptionMaterials(algorithmSuiteId, encryptionContext, encryptedDataKeys, plaintextDataKey, signingKey);
    }
    public bool is_EncryptionMaterials { get { return true; } }
    public Dafny.Aws.Crypto.AlgorithmSuiteId dtor_algorithmSuiteId {
      get {
        return this.algorithmSuiteId;
      }
    }
    public Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> dtor_encryptionContext {
      get {
        return this.encryptionContext;
      }
    }
    public Dafny.ISequence<Dafny.Aws.Crypto.EncryptedDataKey> dtor_encryptedDataKeys {
      get {
        return this.encryptedDataKeys;
      }
    }
    public Wrappers_Compile.Option<Dafny.ISequence<byte>> dtor_plaintextDataKey {
      get {
        return this.plaintextDataKey;
      }
    }
    public Wrappers_Compile.Option<Dafny.ISequence<byte>> dtor_signingKey {
      get {
        return this.signingKey;
      }
    }
  }

  public class DecryptionMaterials {
    public readonly Dafny.Aws.Crypto.AlgorithmSuiteId algorithmSuiteId;
    public readonly Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext;
    public readonly Wrappers_Compile.Option<Dafny.ISequence<byte>> plaintextDataKey;
    public readonly Wrappers_Compile.Option<Dafny.ISequence<byte>> verificationKey;
    public DecryptionMaterials(Dafny.Aws.Crypto.AlgorithmSuiteId algorithmSuiteId, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext, Wrappers_Compile.Option<Dafny.ISequence<byte>> plaintextDataKey, Wrappers_Compile.Option<Dafny.ISequence<byte>> verificationKey) {
      this.algorithmSuiteId = algorithmSuiteId;
      this.encryptionContext = encryptionContext;
      this.plaintextDataKey = plaintextDataKey;
      this.verificationKey = verificationKey;
    }
    public override bool Equals(object other) {
      var oth = other as Dafny.Aws.Crypto.DecryptionMaterials;
      return oth != null && object.Equals(this.algorithmSuiteId, oth.algorithmSuiteId) && object.Equals(this.encryptionContext, oth.encryptionContext) && object.Equals(this.plaintextDataKey, oth.plaintextDataKey) && object.Equals(this.verificationKey, oth.verificationKey);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.algorithmSuiteId));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.encryptionContext));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.plaintextDataKey));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.verificationKey));
      return (int) hash;
    }
    public override string ToString() {
      string s = "Dafny.Aws.Crypto_Compile.DecryptionMaterials.DecryptionMaterials";
      s += "(";
      s += Dafny.Helpers.ToString(this.algorithmSuiteId);
      s += ", ";
      s += Dafny.Helpers.ToString(this.encryptionContext);
      s += ", ";
      s += Dafny.Helpers.ToString(this.plaintextDataKey);
      s += ", ";
      s += Dafny.Helpers.ToString(this.verificationKey);
      s += ")";
      return s;
    }
    private static readonly DecryptionMaterials theDefault = create(Dafny.Aws.Crypto.AlgorithmSuiteId.Default(), Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Empty, Wrappers_Compile.Option<Dafny.ISequence<byte>>.Default(), Wrappers_Compile.Option<Dafny.ISequence<byte>>.Default());
    public static DecryptionMaterials Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<Dafny.Aws.Crypto.DecryptionMaterials> _TYPE = new Dafny.TypeDescriptor<Dafny.Aws.Crypto.DecryptionMaterials>(Dafny.Aws.Crypto.DecryptionMaterials.Default());
    public static Dafny.TypeDescriptor<Dafny.Aws.Crypto.DecryptionMaterials> _TypeDescriptor() {
      return _TYPE;
    }
    public static DecryptionMaterials create(Dafny.Aws.Crypto.AlgorithmSuiteId algorithmSuiteId, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext, Wrappers_Compile.Option<Dafny.ISequence<byte>> plaintextDataKey, Wrappers_Compile.Option<Dafny.ISequence<byte>> verificationKey) {
      return new DecryptionMaterials(algorithmSuiteId, encryptionContext, plaintextDataKey, verificationKey);
    }
    public bool is_DecryptionMaterials { get { return true; } }
    public Dafny.Aws.Crypto.AlgorithmSuiteId dtor_algorithmSuiteId {
      get {
        return this.algorithmSuiteId;
      }
    }
    public Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> dtor_encryptionContext {
      get {
        return this.encryptionContext;
      }
    }
    public Wrappers_Compile.Option<Dafny.ISequence<byte>> dtor_plaintextDataKey {
      get {
        return this.plaintextDataKey;
      }
    }
    public Wrappers_Compile.Option<Dafny.ISequence<byte>> dtor_verificationKey {
      get {
        return this.verificationKey;
      }
    }
  }

  public abstract class CommitmentPolicy {
    public CommitmentPolicy() { }
    private static readonly CommitmentPolicy theDefault = create_FORBID__ENCRYPT__FORBID__DECRYPT();
    public static CommitmentPolicy Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<Dafny.Aws.Crypto.CommitmentPolicy> _TYPE = new Dafny.TypeDescriptor<Dafny.Aws.Crypto.CommitmentPolicy>(Dafny.Aws.Crypto.CommitmentPolicy.Default());
    public static Dafny.TypeDescriptor<Dafny.Aws.Crypto.CommitmentPolicy> _TypeDescriptor() {
      return _TYPE;
    }
    public static CommitmentPolicy create_FORBID__ENCRYPT__FORBID__DECRYPT() {
      return new CommitmentPolicy_FORBID__ENCRYPT__FORBID__DECRYPT();
    }
    public static CommitmentPolicy create_REQUIRE__ENCRYPT__ALLOW__DECRYPT() {
      return new CommitmentPolicy_REQUIRE__ENCRYPT__ALLOW__DECRYPT();
    }
    public static CommitmentPolicy create_REQUIRE__ENCRYPT__REQUIRE__DECRYPT() {
      return new CommitmentPolicy_REQUIRE__ENCRYPT__REQUIRE__DECRYPT();
    }
    public bool is_FORBID__ENCRYPT__FORBID__DECRYPT { get { return this is CommitmentPolicy_FORBID__ENCRYPT__FORBID__DECRYPT; } }
    public bool is_REQUIRE__ENCRYPT__ALLOW__DECRYPT { get { return this is CommitmentPolicy_REQUIRE__ENCRYPT__ALLOW__DECRYPT; } }
    public bool is_REQUIRE__ENCRYPT__REQUIRE__DECRYPT { get { return this is CommitmentPolicy_REQUIRE__ENCRYPT__REQUIRE__DECRYPT; } }
    public static System.Collections.Generic.IEnumerable<CommitmentPolicy> AllSingletonConstructors {
      get {
        yield return CommitmentPolicy.create_FORBID__ENCRYPT__FORBID__DECRYPT();
        yield return CommitmentPolicy.create_REQUIRE__ENCRYPT__ALLOW__DECRYPT();
        yield return CommitmentPolicy.create_REQUIRE__ENCRYPT__REQUIRE__DECRYPT();
      }
    }
  }
  public class CommitmentPolicy_FORBID__ENCRYPT__FORBID__DECRYPT : CommitmentPolicy {
    public CommitmentPolicy_FORBID__ENCRYPT__FORBID__DECRYPT() {
    }
    public override bool Equals(object other) {
      var oth = other as Dafny.Aws.Crypto.CommitmentPolicy_FORBID__ENCRYPT__FORBID__DECRYPT;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      return (int) hash;
    }
    public override string ToString() {
      string s = "Dafny.Aws.Crypto_Compile.CommitmentPolicy.FORBID_ENCRYPT_FORBID_DECRYPT";
      return s;
    }
  }
  public class CommitmentPolicy_REQUIRE__ENCRYPT__ALLOW__DECRYPT : CommitmentPolicy {
    public CommitmentPolicy_REQUIRE__ENCRYPT__ALLOW__DECRYPT() {
    }
    public override bool Equals(object other) {
      var oth = other as Dafny.Aws.Crypto.CommitmentPolicy_REQUIRE__ENCRYPT__ALLOW__DECRYPT;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      return (int) hash;
    }
    public override string ToString() {
      string s = "Dafny.Aws.Crypto_Compile.CommitmentPolicy.REQUIRE_ENCRYPT_ALLOW_DECRYPT";
      return s;
    }
  }
  public class CommitmentPolicy_REQUIRE__ENCRYPT__REQUIRE__DECRYPT : CommitmentPolicy {
    public CommitmentPolicy_REQUIRE__ENCRYPT__REQUIRE__DECRYPT() {
    }
    public override bool Equals(object other) {
      var oth = other as Dafny.Aws.Crypto.CommitmentPolicy_REQUIRE__ENCRYPT__REQUIRE__DECRYPT;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 2;
      return (int) hash;
    }
    public override string ToString() {
      string s = "Dafny.Aws.Crypto_Compile.CommitmentPolicy.REQUIRE_ENCRYPT_REQUIRE_DECRYPT";
      return s;
    }
  }

  public abstract class AesWrappingAlg {
    public AesWrappingAlg() { }
    private static readonly AesWrappingAlg theDefault = create_ALG__AES128__GCM__IV12__TAG16();
    public static AesWrappingAlg Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<Dafny.Aws.Crypto.AesWrappingAlg> _TYPE = new Dafny.TypeDescriptor<Dafny.Aws.Crypto.AesWrappingAlg>(Dafny.Aws.Crypto.AesWrappingAlg.Default());
    public static Dafny.TypeDescriptor<Dafny.Aws.Crypto.AesWrappingAlg> _TypeDescriptor() {
      return _TYPE;
    }
    public static AesWrappingAlg create_ALG__AES128__GCM__IV12__TAG16() {
      return new AesWrappingAlg_ALG__AES128__GCM__IV12__TAG16();
    }
    public static AesWrappingAlg create_ALG__AES192__GCM__IV12__TAG16() {
      return new AesWrappingAlg_ALG__AES192__GCM__IV12__TAG16();
    }
    public static AesWrappingAlg create_ALG__AES256__GCM__IV12__TAG16() {
      return new AesWrappingAlg_ALG__AES256__GCM__IV12__TAG16();
    }
    public bool is_ALG__AES128__GCM__IV12__TAG16 { get { return this is AesWrappingAlg_ALG__AES128__GCM__IV12__TAG16; } }
    public bool is_ALG__AES192__GCM__IV12__TAG16 { get { return this is AesWrappingAlg_ALG__AES192__GCM__IV12__TAG16; } }
    public bool is_ALG__AES256__GCM__IV12__TAG16 { get { return this is AesWrappingAlg_ALG__AES256__GCM__IV12__TAG16; } }
    public static System.Collections.Generic.IEnumerable<AesWrappingAlg> AllSingletonConstructors {
      get {
        yield return AesWrappingAlg.create_ALG__AES128__GCM__IV12__TAG16();
        yield return AesWrappingAlg.create_ALG__AES192__GCM__IV12__TAG16();
        yield return AesWrappingAlg.create_ALG__AES256__GCM__IV12__TAG16();
      }
    }
  }
  public class AesWrappingAlg_ALG__AES128__GCM__IV12__TAG16 : AesWrappingAlg {
    public AesWrappingAlg_ALG__AES128__GCM__IV12__TAG16() {
    }
    public override bool Equals(object other) {
      var oth = other as Dafny.Aws.Crypto.AesWrappingAlg_ALG__AES128__GCM__IV12__TAG16;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      return (int) hash;
    }
    public override string ToString() {
      string s = "Dafny.Aws.Crypto_Compile.AesWrappingAlg.ALG_AES128_GCM_IV12_TAG16";
      return s;
    }
  }
  public class AesWrappingAlg_ALG__AES192__GCM__IV12__TAG16 : AesWrappingAlg {
    public AesWrappingAlg_ALG__AES192__GCM__IV12__TAG16() {
    }
    public override bool Equals(object other) {
      var oth = other as Dafny.Aws.Crypto.AesWrappingAlg_ALG__AES192__GCM__IV12__TAG16;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      return (int) hash;
    }
    public override string ToString() {
      string s = "Dafny.Aws.Crypto_Compile.AesWrappingAlg.ALG_AES192_GCM_IV12_TAG16";
      return s;
    }
  }
  public class AesWrappingAlg_ALG__AES256__GCM__IV12__TAG16 : AesWrappingAlg {
    public AesWrappingAlg_ALG__AES256__GCM__IV12__TAG16() {
    }
    public override bool Equals(object other) {
      var oth = other as Dafny.Aws.Crypto.AesWrappingAlg_ALG__AES256__GCM__IV12__TAG16;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 2;
      return (int) hash;
    }
    public override string ToString() {
      string s = "Dafny.Aws.Crypto_Compile.AesWrappingAlg.ALG_AES256_GCM_IV12_TAG16";
      return s;
    }
  }

  public abstract class AlgorithmSuiteId {
    public AlgorithmSuiteId() { }
    private static readonly AlgorithmSuiteId theDefault = create_ALG__AES__128__GCM__IV12__TAG16__NO__KDF();
    public static AlgorithmSuiteId Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<Dafny.Aws.Crypto.AlgorithmSuiteId> _TYPE = new Dafny.TypeDescriptor<Dafny.Aws.Crypto.AlgorithmSuiteId>(Dafny.Aws.Crypto.AlgorithmSuiteId.Default());
    public static Dafny.TypeDescriptor<Dafny.Aws.Crypto.AlgorithmSuiteId> _TypeDescriptor() {
      return _TYPE;
    }
    public static AlgorithmSuiteId create_ALG__AES__128__GCM__IV12__TAG16__NO__KDF() {
      return new AlgorithmSuiteId_ALG__AES__128__GCM__IV12__TAG16__NO__KDF();
    }
    public static AlgorithmSuiteId create_ALG__AES__192__GCM__IV12__TAG16__NO__KDF() {
      return new AlgorithmSuiteId_ALG__AES__192__GCM__IV12__TAG16__NO__KDF();
    }
    public static AlgorithmSuiteId create_ALG__AES__256__GCM__IV12__TAG16__NO__KDF() {
      return new AlgorithmSuiteId_ALG__AES__256__GCM__IV12__TAG16__NO__KDF();
    }
    public static AlgorithmSuiteId create_ALG__AES__128__GCM__IV12__TAG16__HKDF__SHA256() {
      return new AlgorithmSuiteId_ALG__AES__128__GCM__IV12__TAG16__HKDF__SHA256();
    }
    public static AlgorithmSuiteId create_ALG__AES__192__GCM__IV12__TAG16__HKDF__SHA256() {
      return new AlgorithmSuiteId_ALG__AES__192__GCM__IV12__TAG16__HKDF__SHA256();
    }
    public static AlgorithmSuiteId create_ALG__AES__256__GCM__IV12__TAG16__HKDF__SHA256() {
      return new AlgorithmSuiteId_ALG__AES__256__GCM__IV12__TAG16__HKDF__SHA256();
    }
    public static AlgorithmSuiteId create_ALG__AES__128__GCM__IV12__TAG16__HKDF__SHA256__ECDSA__P256() {
      return new AlgorithmSuiteId_ALG__AES__128__GCM__IV12__TAG16__HKDF__SHA256__ECDSA__P256();
    }
    public static AlgorithmSuiteId create_ALG__AES__192__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384() {
      return new AlgorithmSuiteId_ALG__AES__192__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384();
    }
    public static AlgorithmSuiteId create_ALG__AES__256__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384() {
      return new AlgorithmSuiteId_ALG__AES__256__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384();
    }
    public bool is_ALG__AES__128__GCM__IV12__TAG16__NO__KDF { get { return this is AlgorithmSuiteId_ALG__AES__128__GCM__IV12__TAG16__NO__KDF; } }
    public bool is_ALG__AES__192__GCM__IV12__TAG16__NO__KDF { get { return this is AlgorithmSuiteId_ALG__AES__192__GCM__IV12__TAG16__NO__KDF; } }
    public bool is_ALG__AES__256__GCM__IV12__TAG16__NO__KDF { get { return this is AlgorithmSuiteId_ALG__AES__256__GCM__IV12__TAG16__NO__KDF; } }
    public bool is_ALG__AES__128__GCM__IV12__TAG16__HKDF__SHA256 { get { return this is AlgorithmSuiteId_ALG__AES__128__GCM__IV12__TAG16__HKDF__SHA256; } }
    public bool is_ALG__AES__192__GCM__IV12__TAG16__HKDF__SHA256 { get { return this is AlgorithmSuiteId_ALG__AES__192__GCM__IV12__TAG16__HKDF__SHA256; } }
    public bool is_ALG__AES__256__GCM__IV12__TAG16__HKDF__SHA256 { get { return this is AlgorithmSuiteId_ALG__AES__256__GCM__IV12__TAG16__HKDF__SHA256; } }
    public bool is_ALG__AES__128__GCM__IV12__TAG16__HKDF__SHA256__ECDSA__P256 { get { return this is AlgorithmSuiteId_ALG__AES__128__GCM__IV12__TAG16__HKDF__SHA256__ECDSA__P256; } }
    public bool is_ALG__AES__192__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384 { get { return this is AlgorithmSuiteId_ALG__AES__192__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384; } }
    public bool is_ALG__AES__256__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384 { get { return this is AlgorithmSuiteId_ALG__AES__256__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384; } }
    public static System.Collections.Generic.IEnumerable<AlgorithmSuiteId> AllSingletonConstructors {
      get {
        yield return AlgorithmSuiteId.create_ALG__AES__128__GCM__IV12__TAG16__NO__KDF();
        yield return AlgorithmSuiteId.create_ALG__AES__192__GCM__IV12__TAG16__NO__KDF();
        yield return AlgorithmSuiteId.create_ALG__AES__256__GCM__IV12__TAG16__NO__KDF();
        yield return AlgorithmSuiteId.create_ALG__AES__128__GCM__IV12__TAG16__HKDF__SHA256();
        yield return AlgorithmSuiteId.create_ALG__AES__192__GCM__IV12__TAG16__HKDF__SHA256();
        yield return AlgorithmSuiteId.create_ALG__AES__256__GCM__IV12__TAG16__HKDF__SHA256();
        yield return AlgorithmSuiteId.create_ALG__AES__128__GCM__IV12__TAG16__HKDF__SHA256__ECDSA__P256();
        yield return AlgorithmSuiteId.create_ALG__AES__192__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384();
        yield return AlgorithmSuiteId.create_ALG__AES__256__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384();
      }
    }
  }
  public class AlgorithmSuiteId_ALG__AES__128__GCM__IV12__TAG16__NO__KDF : AlgorithmSuiteId {
    public AlgorithmSuiteId_ALG__AES__128__GCM__IV12__TAG16__NO__KDF() {
    }
    public override bool Equals(object other) {
      var oth = other as Dafny.Aws.Crypto.AlgorithmSuiteId_ALG__AES__128__GCM__IV12__TAG16__NO__KDF;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      return (int) hash;
    }
    public override string ToString() {
      string s = "Dafny.Aws.Crypto_Compile.AlgorithmSuiteId.ALG_AES_128_GCM_IV12_TAG16_NO_KDF";
      return s;
    }
  }
  public class AlgorithmSuiteId_ALG__AES__192__GCM__IV12__TAG16__NO__KDF : AlgorithmSuiteId {
    public AlgorithmSuiteId_ALG__AES__192__GCM__IV12__TAG16__NO__KDF() {
    }
    public override bool Equals(object other) {
      var oth = other as Dafny.Aws.Crypto.AlgorithmSuiteId_ALG__AES__192__GCM__IV12__TAG16__NO__KDF;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      return (int) hash;
    }
    public override string ToString() {
      string s = "Dafny.Aws.Crypto_Compile.AlgorithmSuiteId.ALG_AES_192_GCM_IV12_TAG16_NO_KDF";
      return s;
    }
  }
  public class AlgorithmSuiteId_ALG__AES__256__GCM__IV12__TAG16__NO__KDF : AlgorithmSuiteId {
    public AlgorithmSuiteId_ALG__AES__256__GCM__IV12__TAG16__NO__KDF() {
    }
    public override bool Equals(object other) {
      var oth = other as Dafny.Aws.Crypto.AlgorithmSuiteId_ALG__AES__256__GCM__IV12__TAG16__NO__KDF;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 2;
      return (int) hash;
    }
    public override string ToString() {
      string s = "Dafny.Aws.Crypto_Compile.AlgorithmSuiteId.ALG_AES_256_GCM_IV12_TAG16_NO_KDF";
      return s;
    }
  }
  public class AlgorithmSuiteId_ALG__AES__128__GCM__IV12__TAG16__HKDF__SHA256 : AlgorithmSuiteId {
    public AlgorithmSuiteId_ALG__AES__128__GCM__IV12__TAG16__HKDF__SHA256() {
    }
    public override bool Equals(object other) {
      var oth = other as Dafny.Aws.Crypto.AlgorithmSuiteId_ALG__AES__128__GCM__IV12__TAG16__HKDF__SHA256;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 3;
      return (int) hash;
    }
    public override string ToString() {
      string s = "Dafny.Aws.Crypto_Compile.AlgorithmSuiteId.ALG_AES_128_GCM_IV12_TAG16_HKDF_SHA256";
      return s;
    }
  }
  public class AlgorithmSuiteId_ALG__AES__192__GCM__IV12__TAG16__HKDF__SHA256 : AlgorithmSuiteId {
    public AlgorithmSuiteId_ALG__AES__192__GCM__IV12__TAG16__HKDF__SHA256() {
    }
    public override bool Equals(object other) {
      var oth = other as Dafny.Aws.Crypto.AlgorithmSuiteId_ALG__AES__192__GCM__IV12__TAG16__HKDF__SHA256;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 4;
      return (int) hash;
    }
    public override string ToString() {
      string s = "Dafny.Aws.Crypto_Compile.AlgorithmSuiteId.ALG_AES_192_GCM_IV12_TAG16_HKDF_SHA256";
      return s;
    }
  }
  public class AlgorithmSuiteId_ALG__AES__256__GCM__IV12__TAG16__HKDF__SHA256 : AlgorithmSuiteId {
    public AlgorithmSuiteId_ALG__AES__256__GCM__IV12__TAG16__HKDF__SHA256() {
    }
    public override bool Equals(object other) {
      var oth = other as Dafny.Aws.Crypto.AlgorithmSuiteId_ALG__AES__256__GCM__IV12__TAG16__HKDF__SHA256;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 5;
      return (int) hash;
    }
    public override string ToString() {
      string s = "Dafny.Aws.Crypto_Compile.AlgorithmSuiteId.ALG_AES_256_GCM_IV12_TAG16_HKDF_SHA256";
      return s;
    }
  }
  public class AlgorithmSuiteId_ALG__AES__128__GCM__IV12__TAG16__HKDF__SHA256__ECDSA__P256 : AlgorithmSuiteId {
    public AlgorithmSuiteId_ALG__AES__128__GCM__IV12__TAG16__HKDF__SHA256__ECDSA__P256() {
    }
    public override bool Equals(object other) {
      var oth = other as Dafny.Aws.Crypto.AlgorithmSuiteId_ALG__AES__128__GCM__IV12__TAG16__HKDF__SHA256__ECDSA__P256;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 6;
      return (int) hash;
    }
    public override string ToString() {
      string s = "Dafny.Aws.Crypto_Compile.AlgorithmSuiteId.ALG_AES_128_GCM_IV12_TAG16_HKDF_SHA256_ECDSA_P256";
      return s;
    }
  }
  public class AlgorithmSuiteId_ALG__AES__192__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384 : AlgorithmSuiteId {
    public AlgorithmSuiteId_ALG__AES__192__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384() {
    }
    public override bool Equals(object other) {
      var oth = other as Dafny.Aws.Crypto.AlgorithmSuiteId_ALG__AES__192__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 7;
      return (int) hash;
    }
    public override string ToString() {
      string s = "Dafny.Aws.Crypto_Compile.AlgorithmSuiteId.ALG_AES_192_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384";
      return s;
    }
  }
  public class AlgorithmSuiteId_ALG__AES__256__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384 : AlgorithmSuiteId {
    public AlgorithmSuiteId_ALG__AES__256__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384() {
    }
    public override bool Equals(object other) {
      var oth = other as Dafny.Aws.Crypto.AlgorithmSuiteId_ALG__AES__256__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 8;
      return (int) hash;
    }
    public override string ToString() {
      string s = "Dafny.Aws.Crypto_Compile.AlgorithmSuiteId.ALG_AES_256_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384";
      return s;
    }
  }

  public abstract class PaddingScheme {
    public PaddingScheme() { }
    private static readonly PaddingScheme theDefault = create_PKCS1();
    public static PaddingScheme Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<Dafny.Aws.Crypto.PaddingScheme> _TYPE = new Dafny.TypeDescriptor<Dafny.Aws.Crypto.PaddingScheme>(Dafny.Aws.Crypto.PaddingScheme.Default());
    public static Dafny.TypeDescriptor<Dafny.Aws.Crypto.PaddingScheme> _TypeDescriptor() {
      return _TYPE;
    }
    public static PaddingScheme create_PKCS1() {
      return new PaddingScheme_PKCS1();
    }
    public static PaddingScheme create_OAEP__SHA1__MGF1() {
      return new PaddingScheme_OAEP__SHA1__MGF1();
    }
    public static PaddingScheme create_OAEP__SHA256__MGF1() {
      return new PaddingScheme_OAEP__SHA256__MGF1();
    }
    public static PaddingScheme create_OAEP__SHA384__MGF1() {
      return new PaddingScheme_OAEP__SHA384__MGF1();
    }
    public static PaddingScheme create_OAEP__SHA512__MGF1() {
      return new PaddingScheme_OAEP__SHA512__MGF1();
    }
    public bool is_PKCS1 { get { return this is PaddingScheme_PKCS1; } }
    public bool is_OAEP__SHA1__MGF1 { get { return this is PaddingScheme_OAEP__SHA1__MGF1; } }
    public bool is_OAEP__SHA256__MGF1 { get { return this is PaddingScheme_OAEP__SHA256__MGF1; } }
    public bool is_OAEP__SHA384__MGF1 { get { return this is PaddingScheme_OAEP__SHA384__MGF1; } }
    public bool is_OAEP__SHA512__MGF1 { get { return this is PaddingScheme_OAEP__SHA512__MGF1; } }
    public static System.Collections.Generic.IEnumerable<PaddingScheme> AllSingletonConstructors {
      get {
        yield return PaddingScheme.create_PKCS1();
        yield return PaddingScheme.create_OAEP__SHA1__MGF1();
        yield return PaddingScheme.create_OAEP__SHA256__MGF1();
        yield return PaddingScheme.create_OAEP__SHA384__MGF1();
        yield return PaddingScheme.create_OAEP__SHA512__MGF1();
      }
    }
  }
  public class PaddingScheme_PKCS1 : PaddingScheme {
    public PaddingScheme_PKCS1() {
    }
    public override bool Equals(object other) {
      var oth = other as Dafny.Aws.Crypto.PaddingScheme_PKCS1;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      return (int) hash;
    }
    public override string ToString() {
      string s = "Dafny.Aws.Crypto_Compile.PaddingScheme.PKCS1";
      return s;
    }
  }
  public class PaddingScheme_OAEP__SHA1__MGF1 : PaddingScheme {
    public PaddingScheme_OAEP__SHA1__MGF1() {
    }
    public override bool Equals(object other) {
      var oth = other as Dafny.Aws.Crypto.PaddingScheme_OAEP__SHA1__MGF1;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      return (int) hash;
    }
    public override string ToString() {
      string s = "Dafny.Aws.Crypto_Compile.PaddingScheme.OAEP_SHA1_MGF1";
      return s;
    }
  }
  public class PaddingScheme_OAEP__SHA256__MGF1 : PaddingScheme {
    public PaddingScheme_OAEP__SHA256__MGF1() {
    }
    public override bool Equals(object other) {
      var oth = other as Dafny.Aws.Crypto.PaddingScheme_OAEP__SHA256__MGF1;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 2;
      return (int) hash;
    }
    public override string ToString() {
      string s = "Dafny.Aws.Crypto_Compile.PaddingScheme.OAEP_SHA256_MGF1";
      return s;
    }
  }
  public class PaddingScheme_OAEP__SHA384__MGF1 : PaddingScheme {
    public PaddingScheme_OAEP__SHA384__MGF1() {
    }
    public override bool Equals(object other) {
      var oth = other as Dafny.Aws.Crypto.PaddingScheme_OAEP__SHA384__MGF1;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 3;
      return (int) hash;
    }
    public override string ToString() {
      string s = "Dafny.Aws.Crypto_Compile.PaddingScheme.OAEP_SHA384_MGF1";
      return s;
    }
  }
  public class PaddingScheme_OAEP__SHA512__MGF1 : PaddingScheme {
    public PaddingScheme_OAEP__SHA512__MGF1() {
    }
    public override bool Equals(object other) {
      var oth = other as Dafny.Aws.Crypto.PaddingScheme_OAEP__SHA512__MGF1;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 4;
      return (int) hash;
    }
    public override string ToString() {
      string s = "Dafny.Aws.Crypto_Compile.PaddingScheme.OAEP_SHA512_MGF1";
      return s;
    }
  }

  public class OnEncryptInput {
    public readonly Dafny.Aws.Crypto.EncryptionMaterials materials;
    public OnEncryptInput(Dafny.Aws.Crypto.EncryptionMaterials materials) {
      this.materials = materials;
    }
    public override bool Equals(object other) {
      var oth = other as Dafny.Aws.Crypto.OnEncryptInput;
      return oth != null && object.Equals(this.materials, oth.materials);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.materials));
      return (int) hash;
    }
    public override string ToString() {
      string s = "Dafny.Aws.Crypto_Compile.OnEncryptInput.OnEncryptInput";
      s += "(";
      s += Dafny.Helpers.ToString(this.materials);
      s += ")";
      return s;
    }
    private static readonly OnEncryptInput theDefault = create(Dafny.Aws.Crypto.EncryptionMaterials.Default());
    public static OnEncryptInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<Dafny.Aws.Crypto.OnEncryptInput> _TYPE = new Dafny.TypeDescriptor<Dafny.Aws.Crypto.OnEncryptInput>(Dafny.Aws.Crypto.OnEncryptInput.Default());
    public static Dafny.TypeDescriptor<Dafny.Aws.Crypto.OnEncryptInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static OnEncryptInput create(Dafny.Aws.Crypto.EncryptionMaterials materials) {
      return new OnEncryptInput(materials);
    }
    public bool is_OnEncryptInput { get { return true; } }
    public Dafny.Aws.Crypto.EncryptionMaterials dtor_materials {
      get {
        return this.materials;
      }
    }
  }

  public class OnEncryptOutput {
    public readonly Dafny.Aws.Crypto.EncryptionMaterials materials;
    public OnEncryptOutput(Dafny.Aws.Crypto.EncryptionMaterials materials) {
      this.materials = materials;
    }
    public override bool Equals(object other) {
      var oth = other as Dafny.Aws.Crypto.OnEncryptOutput;
      return oth != null && object.Equals(this.materials, oth.materials);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.materials));
      return (int) hash;
    }
    public override string ToString() {
      string s = "Dafny.Aws.Crypto_Compile.OnEncryptOutput.OnEncryptOutput";
      s += "(";
      s += Dafny.Helpers.ToString(this.materials);
      s += ")";
      return s;
    }
    private static readonly OnEncryptOutput theDefault = create(Dafny.Aws.Crypto.EncryptionMaterials.Default());
    public static OnEncryptOutput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<Dafny.Aws.Crypto.OnEncryptOutput> _TYPE = new Dafny.TypeDescriptor<Dafny.Aws.Crypto.OnEncryptOutput>(Dafny.Aws.Crypto.OnEncryptOutput.Default());
    public static Dafny.TypeDescriptor<Dafny.Aws.Crypto.OnEncryptOutput> _TypeDescriptor() {
      return _TYPE;
    }
    public static OnEncryptOutput create(Dafny.Aws.Crypto.EncryptionMaterials materials) {
      return new OnEncryptOutput(materials);
    }
    public bool is_OnEncryptOutput { get { return true; } }
    public Dafny.Aws.Crypto.EncryptionMaterials dtor_materials {
      get {
        return this.materials;
      }
    }
  }

  public class OnDecryptInput {
    public readonly Dafny.Aws.Crypto.DecryptionMaterials materials;
    public readonly Dafny.ISequence<Dafny.Aws.Crypto.EncryptedDataKey> encryptedDataKeys;
    public OnDecryptInput(Dafny.Aws.Crypto.DecryptionMaterials materials, Dafny.ISequence<Dafny.Aws.Crypto.EncryptedDataKey> encryptedDataKeys) {
      this.materials = materials;
      this.encryptedDataKeys = encryptedDataKeys;
    }
    public override bool Equals(object other) {
      var oth = other as Dafny.Aws.Crypto.OnDecryptInput;
      return oth != null && object.Equals(this.materials, oth.materials) && object.Equals(this.encryptedDataKeys, oth.encryptedDataKeys);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.materials));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.encryptedDataKeys));
      return (int) hash;
    }
    public override string ToString() {
      string s = "Dafny.Aws.Crypto_Compile.OnDecryptInput.OnDecryptInput";
      s += "(";
      s += Dafny.Helpers.ToString(this.materials);
      s += ", ";
      s += Dafny.Helpers.ToString(this.encryptedDataKeys);
      s += ")";
      return s;
    }
    private static readonly OnDecryptInput theDefault = create(Dafny.Aws.Crypto.DecryptionMaterials.Default(), Dafny.Sequence<Dafny.Aws.Crypto.EncryptedDataKey>.Empty);
    public static OnDecryptInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<Dafny.Aws.Crypto.OnDecryptInput> _TYPE = new Dafny.TypeDescriptor<Dafny.Aws.Crypto.OnDecryptInput>(Dafny.Aws.Crypto.OnDecryptInput.Default());
    public static Dafny.TypeDescriptor<Dafny.Aws.Crypto.OnDecryptInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static OnDecryptInput create(Dafny.Aws.Crypto.DecryptionMaterials materials, Dafny.ISequence<Dafny.Aws.Crypto.EncryptedDataKey> encryptedDataKeys) {
      return new OnDecryptInput(materials, encryptedDataKeys);
    }
    public bool is_OnDecryptInput { get { return true; } }
    public Dafny.Aws.Crypto.DecryptionMaterials dtor_materials {
      get {
        return this.materials;
      }
    }
    public Dafny.ISequence<Dafny.Aws.Crypto.EncryptedDataKey> dtor_encryptedDataKeys {
      get {
        return this.encryptedDataKeys;
      }
    }
  }

  public class OnDecryptOutput {
    public readonly Dafny.Aws.Crypto.DecryptionMaterials materials;
    public OnDecryptOutput(Dafny.Aws.Crypto.DecryptionMaterials materials) {
      this.materials = materials;
    }
    public override bool Equals(object other) {
      var oth = other as Dafny.Aws.Crypto.OnDecryptOutput;
      return oth != null && object.Equals(this.materials, oth.materials);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.materials));
      return (int) hash;
    }
    public override string ToString() {
      string s = "Dafny.Aws.Crypto_Compile.OnDecryptOutput.OnDecryptOutput";
      s += "(";
      s += Dafny.Helpers.ToString(this.materials);
      s += ")";
      return s;
    }
    private static readonly OnDecryptOutput theDefault = create(Dafny.Aws.Crypto.DecryptionMaterials.Default());
    public static OnDecryptOutput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<Dafny.Aws.Crypto.OnDecryptOutput> _TYPE = new Dafny.TypeDescriptor<Dafny.Aws.Crypto.OnDecryptOutput>(Dafny.Aws.Crypto.OnDecryptOutput.Default());
    public static Dafny.TypeDescriptor<Dafny.Aws.Crypto.OnDecryptOutput> _TypeDescriptor() {
      return _TYPE;
    }
    public static OnDecryptOutput create(Dafny.Aws.Crypto.DecryptionMaterials materials) {
      return new OnDecryptOutput(materials);
    }
    public bool is_OnDecryptOutput { get { return true; } }
    public Dafny.Aws.Crypto.DecryptionMaterials dtor_materials {
      get {
        return this.materials;
      }
    }
  }

  public interface IKeyring {
    Wrappers_Compile.Result<Dafny.Aws.Crypto.OnEncryptOutput, Dafny.ISequence<char>> OnEncrypt(Dafny.Aws.Crypto.OnEncryptInput input);
    Wrappers_Compile.Result<Dafny.Aws.Crypto.OnDecryptOutput, Dafny.ISequence<char>> OnDecrypt(Dafny.Aws.Crypto.OnDecryptInput input);
  }
  public class _Companion_IKeyring {
  }

  public class CacheUsageMetadata {
    public readonly long messageUsage;
    public readonly long byteUsage;
    public CacheUsageMetadata(long messageUsage, long byteUsage) {
      this.messageUsage = messageUsage;
      this.byteUsage = byteUsage;
    }
    public override bool Equals(object other) {
      var oth = other as Dafny.Aws.Crypto.CacheUsageMetadata;
      return oth != null && this.messageUsage == oth.messageUsage && this.byteUsage == oth.byteUsage;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.messageUsage));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.byteUsage));
      return (int) hash;
    }
    public override string ToString() {
      string s = "Dafny.Aws.Crypto_Compile.CacheUsageMetadata.CacheUsageMetadata";
      s += "(";
      s += Dafny.Helpers.ToString(this.messageUsage);
      s += ", ";
      s += Dafny.Helpers.ToString(this.byteUsage);
      s += ")";
      return s;
    }
    private static readonly CacheUsageMetadata theDefault = create(0, 0);
    public static CacheUsageMetadata Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<Dafny.Aws.Crypto.CacheUsageMetadata> _TYPE = new Dafny.TypeDescriptor<Dafny.Aws.Crypto.CacheUsageMetadata>(Dafny.Aws.Crypto.CacheUsageMetadata.Default());
    public static Dafny.TypeDescriptor<Dafny.Aws.Crypto.CacheUsageMetadata> _TypeDescriptor() {
      return _TYPE;
    }
    public static CacheUsageMetadata create(long messageUsage, long byteUsage) {
      return new CacheUsageMetadata(messageUsage, byteUsage);
    }
    public bool is_CacheUsageMetadata { get { return true; } }
    public long dtor_messageUsage {
      get {
        return this.messageUsage;
      }
    }
    public long dtor_byteUsage {
      get {
        return this.byteUsage;
      }
    }
  }

  public class EncryptEntry {
    public readonly Dafny.ISequence<byte> identifier;
    public readonly Dafny.Aws.Crypto.EncryptionMaterials encryptionMaterials;
    public readonly long creationTime;
    public readonly long expiryTime;
    public readonly Dafny.Aws.Crypto.CacheUsageMetadata usageMetadata;
    public EncryptEntry(Dafny.ISequence<byte> identifier, Dafny.Aws.Crypto.EncryptionMaterials encryptionMaterials, long creationTime, long expiryTime, Dafny.Aws.Crypto.CacheUsageMetadata usageMetadata) {
      this.identifier = identifier;
      this.encryptionMaterials = encryptionMaterials;
      this.creationTime = creationTime;
      this.expiryTime = expiryTime;
      this.usageMetadata = usageMetadata;
    }
    public override bool Equals(object other) {
      var oth = other as Dafny.Aws.Crypto.EncryptEntry;
      return oth != null && object.Equals(this.identifier, oth.identifier) && object.Equals(this.encryptionMaterials, oth.encryptionMaterials) && this.creationTime == oth.creationTime && this.expiryTime == oth.expiryTime && object.Equals(this.usageMetadata, oth.usageMetadata);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.identifier));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.encryptionMaterials));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.creationTime));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.expiryTime));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.usageMetadata));
      return (int) hash;
    }
    public override string ToString() {
      string s = "Dafny.Aws.Crypto_Compile.EncryptEntry.EncryptEntry";
      s += "(";
      s += Dafny.Helpers.ToString(this.identifier);
      s += ", ";
      s += Dafny.Helpers.ToString(this.encryptionMaterials);
      s += ", ";
      s += Dafny.Helpers.ToString(this.creationTime);
      s += ", ";
      s += Dafny.Helpers.ToString(this.expiryTime);
      s += ", ";
      s += Dafny.Helpers.ToString(this.usageMetadata);
      s += ")";
      return s;
    }
    private static readonly EncryptEntry theDefault = create(Dafny.Sequence<byte>.Empty, Dafny.Aws.Crypto.EncryptionMaterials.Default(), 0, 0, Dafny.Aws.Crypto.CacheUsageMetadata.Default());
    public static EncryptEntry Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<Dafny.Aws.Crypto.EncryptEntry> _TYPE = new Dafny.TypeDescriptor<Dafny.Aws.Crypto.EncryptEntry>(Dafny.Aws.Crypto.EncryptEntry.Default());
    public static Dafny.TypeDescriptor<Dafny.Aws.Crypto.EncryptEntry> _TypeDescriptor() {
      return _TYPE;
    }
    public static EncryptEntry create(Dafny.ISequence<byte> identifier, Dafny.Aws.Crypto.EncryptionMaterials encryptionMaterials, long creationTime, long expiryTime, Dafny.Aws.Crypto.CacheUsageMetadata usageMetadata) {
      return new EncryptEntry(identifier, encryptionMaterials, creationTime, expiryTime, usageMetadata);
    }
    public bool is_EncryptEntry { get { return true; } }
    public Dafny.ISequence<byte> dtor_identifier {
      get {
        return this.identifier;
      }
    }
    public Dafny.Aws.Crypto.EncryptionMaterials dtor_encryptionMaterials {
      get {
        return this.encryptionMaterials;
      }
    }
    public long dtor_creationTime {
      get {
        return this.creationTime;
      }
    }
    public long dtor_expiryTime {
      get {
        return this.expiryTime;
      }
    }
    public Dafny.Aws.Crypto.CacheUsageMetadata dtor_usageMetadata {
      get {
        return this.usageMetadata;
      }
    }
  }

  public class DecryptEntry {
    public readonly Dafny.ISequence<byte> identifier;
    public readonly Dafny.Aws.Crypto.DecryptionMaterials decryptionMaterials;
    public readonly long creationTime;
    public readonly long expiryTime;
    public readonly Dafny.Aws.Crypto.CacheUsageMetadata usageMetadata;
    public DecryptEntry(Dafny.ISequence<byte> identifier, Dafny.Aws.Crypto.DecryptionMaterials decryptionMaterials, long creationTime, long expiryTime, Dafny.Aws.Crypto.CacheUsageMetadata usageMetadata) {
      this.identifier = identifier;
      this.decryptionMaterials = decryptionMaterials;
      this.creationTime = creationTime;
      this.expiryTime = expiryTime;
      this.usageMetadata = usageMetadata;
    }
    public override bool Equals(object other) {
      var oth = other as Dafny.Aws.Crypto.DecryptEntry;
      return oth != null && object.Equals(this.identifier, oth.identifier) && object.Equals(this.decryptionMaterials, oth.decryptionMaterials) && this.creationTime == oth.creationTime && this.expiryTime == oth.expiryTime && object.Equals(this.usageMetadata, oth.usageMetadata);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.identifier));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.decryptionMaterials));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.creationTime));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.expiryTime));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.usageMetadata));
      return (int) hash;
    }
    public override string ToString() {
      string s = "Dafny.Aws.Crypto_Compile.DecryptEntry.DecryptEntry";
      s += "(";
      s += Dafny.Helpers.ToString(this.identifier);
      s += ", ";
      s += Dafny.Helpers.ToString(this.decryptionMaterials);
      s += ", ";
      s += Dafny.Helpers.ToString(this.creationTime);
      s += ", ";
      s += Dafny.Helpers.ToString(this.expiryTime);
      s += ", ";
      s += Dafny.Helpers.ToString(this.usageMetadata);
      s += ")";
      return s;
    }
    private static readonly DecryptEntry theDefault = create(Dafny.Sequence<byte>.Empty, Dafny.Aws.Crypto.DecryptionMaterials.Default(), 0, 0, Dafny.Aws.Crypto.CacheUsageMetadata.Default());
    public static DecryptEntry Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<Dafny.Aws.Crypto.DecryptEntry> _TYPE = new Dafny.TypeDescriptor<Dafny.Aws.Crypto.DecryptEntry>(Dafny.Aws.Crypto.DecryptEntry.Default());
    public static Dafny.TypeDescriptor<Dafny.Aws.Crypto.DecryptEntry> _TypeDescriptor() {
      return _TYPE;
    }
    public static DecryptEntry create(Dafny.ISequence<byte> identifier, Dafny.Aws.Crypto.DecryptionMaterials decryptionMaterials, long creationTime, long expiryTime, Dafny.Aws.Crypto.CacheUsageMetadata usageMetadata) {
      return new DecryptEntry(identifier, decryptionMaterials, creationTime, expiryTime, usageMetadata);
    }
    public bool is_DecryptEntry { get { return true; } }
    public Dafny.ISequence<byte> dtor_identifier {
      get {
        return this.identifier;
      }
    }
    public Dafny.Aws.Crypto.DecryptionMaterials dtor_decryptionMaterials {
      get {
        return this.decryptionMaterials;
      }
    }
    public long dtor_creationTime {
      get {
        return this.creationTime;
      }
    }
    public long dtor_expiryTime {
      get {
        return this.expiryTime;
      }
    }
    public Dafny.Aws.Crypto.CacheUsageMetadata dtor_usageMetadata {
      get {
        return this.usageMetadata;
      }
    }
  }

  public class PutEntryForEncryptInput {
    public readonly Dafny.ISequence<byte> identifier;
    public readonly Dafny.Aws.Crypto.EncryptionMaterials encryptionMaterials;
    public readonly Dafny.Aws.Crypto.CacheUsageMetadata usageMetadata;
    public PutEntryForEncryptInput(Dafny.ISequence<byte> identifier, Dafny.Aws.Crypto.EncryptionMaterials encryptionMaterials, Dafny.Aws.Crypto.CacheUsageMetadata usageMetadata) {
      this.identifier = identifier;
      this.encryptionMaterials = encryptionMaterials;
      this.usageMetadata = usageMetadata;
    }
    public override bool Equals(object other) {
      var oth = other as Dafny.Aws.Crypto.PutEntryForEncryptInput;
      return oth != null && object.Equals(this.identifier, oth.identifier) && object.Equals(this.encryptionMaterials, oth.encryptionMaterials) && object.Equals(this.usageMetadata, oth.usageMetadata);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.identifier));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.encryptionMaterials));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.usageMetadata));
      return (int) hash;
    }
    public override string ToString() {
      string s = "Dafny.Aws.Crypto_Compile.PutEntryForEncryptInput.PutEntryForEncryptInput";
      s += "(";
      s += Dafny.Helpers.ToString(this.identifier);
      s += ", ";
      s += Dafny.Helpers.ToString(this.encryptionMaterials);
      s += ", ";
      s += Dafny.Helpers.ToString(this.usageMetadata);
      s += ")";
      return s;
    }
    private static readonly PutEntryForEncryptInput theDefault = create(Dafny.Sequence<byte>.Empty, Dafny.Aws.Crypto.EncryptionMaterials.Default(), Dafny.Aws.Crypto.CacheUsageMetadata.Default());
    public static PutEntryForEncryptInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<Dafny.Aws.Crypto.PutEntryForEncryptInput> _TYPE = new Dafny.TypeDescriptor<Dafny.Aws.Crypto.PutEntryForEncryptInput>(Dafny.Aws.Crypto.PutEntryForEncryptInput.Default());
    public static Dafny.TypeDescriptor<Dafny.Aws.Crypto.PutEntryForEncryptInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static PutEntryForEncryptInput create(Dafny.ISequence<byte> identifier, Dafny.Aws.Crypto.EncryptionMaterials encryptionMaterials, Dafny.Aws.Crypto.CacheUsageMetadata usageMetadata) {
      return new PutEntryForEncryptInput(identifier, encryptionMaterials, usageMetadata);
    }
    public bool is_PutEntryForEncryptInput { get { return true; } }
    public Dafny.ISequence<byte> dtor_identifier {
      get {
        return this.identifier;
      }
    }
    public Dafny.Aws.Crypto.EncryptionMaterials dtor_encryptionMaterials {
      get {
        return this.encryptionMaterials;
      }
    }
    public Dafny.Aws.Crypto.CacheUsageMetadata dtor_usageMetadata {
      get {
        return this.usageMetadata;
      }
    }
  }

  public class PutEntryForEncryptOutput {
    public PutEntryForEncryptOutput() {
    }
    public override bool Equals(object other) {
      var oth = other as Dafny.Aws.Crypto.PutEntryForEncryptOutput;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      return (int) hash;
    }
    public override string ToString() {
      string s = "Dafny.Aws.Crypto_Compile.PutEntryForEncryptOutput.PutEntryForEncryptOutput";
      return s;
    }
    private static readonly PutEntryForEncryptOutput theDefault = create();
    public static PutEntryForEncryptOutput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<Dafny.Aws.Crypto.PutEntryForEncryptOutput> _TYPE = new Dafny.TypeDescriptor<Dafny.Aws.Crypto.PutEntryForEncryptOutput>(Dafny.Aws.Crypto.PutEntryForEncryptOutput.Default());
    public static Dafny.TypeDescriptor<Dafny.Aws.Crypto.PutEntryForEncryptOutput> _TypeDescriptor() {
      return _TYPE;
    }
    public static PutEntryForEncryptOutput create() {
      return new PutEntryForEncryptOutput();
    }
    public bool is_PutEntryForEncryptOutput { get { return true; } }
    public static System.Collections.Generic.IEnumerable<PutEntryForEncryptOutput> AllSingletonConstructors {
      get {
        yield return PutEntryForEncryptOutput.create();
      }
    }
  }

  public class GetEntryForEncryptInput {
    public readonly Dafny.ISequence<byte> identifier;
    public GetEntryForEncryptInput(Dafny.ISequence<byte> identifier) {
      this.identifier = identifier;
    }
    public override bool Equals(object other) {
      var oth = other as Dafny.Aws.Crypto.GetEntryForEncryptInput;
      return oth != null && object.Equals(this.identifier, oth.identifier);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.identifier));
      return (int) hash;
    }
    public override string ToString() {
      string s = "Dafny.Aws.Crypto_Compile.GetEntryForEncryptInput.GetEntryForEncryptInput";
      s += "(";
      s += Dafny.Helpers.ToString(this.identifier);
      s += ")";
      return s;
    }
    private static readonly GetEntryForEncryptInput theDefault = create(Dafny.Sequence<byte>.Empty);
    public static GetEntryForEncryptInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<Dafny.Aws.Crypto.GetEntryForEncryptInput> _TYPE = new Dafny.TypeDescriptor<Dafny.Aws.Crypto.GetEntryForEncryptInput>(Dafny.Aws.Crypto.GetEntryForEncryptInput.Default());
    public static Dafny.TypeDescriptor<Dafny.Aws.Crypto.GetEntryForEncryptInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static GetEntryForEncryptInput create(Dafny.ISequence<byte> identifier) {
      return new GetEntryForEncryptInput(identifier);
    }
    public bool is_GetEntryForEncryptInput { get { return true; } }
    public Dafny.ISequence<byte> dtor_identifier {
      get {
        return this.identifier;
      }
    }
  }

  public class GetEntryForEncryptOutput {
    public readonly Dafny.Aws.Crypto.EncryptEntry cacheEntry;
    public GetEntryForEncryptOutput(Dafny.Aws.Crypto.EncryptEntry cacheEntry) {
      this.cacheEntry = cacheEntry;
    }
    public override bool Equals(object other) {
      var oth = other as Dafny.Aws.Crypto.GetEntryForEncryptOutput;
      return oth != null && object.Equals(this.cacheEntry, oth.cacheEntry);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.cacheEntry));
      return (int) hash;
    }
    public override string ToString() {
      string s = "Dafny.Aws.Crypto_Compile.GetEntryForEncryptOutput.GetEntryForEncryptOutput";
      s += "(";
      s += Dafny.Helpers.ToString(this.cacheEntry);
      s += ")";
      return s;
    }
    private static readonly GetEntryForEncryptOutput theDefault = create(Dafny.Aws.Crypto.EncryptEntry.Default());
    public static GetEntryForEncryptOutput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<Dafny.Aws.Crypto.GetEntryForEncryptOutput> _TYPE = new Dafny.TypeDescriptor<Dafny.Aws.Crypto.GetEntryForEncryptOutput>(Dafny.Aws.Crypto.GetEntryForEncryptOutput.Default());
    public static Dafny.TypeDescriptor<Dafny.Aws.Crypto.GetEntryForEncryptOutput> _TypeDescriptor() {
      return _TYPE;
    }
    public static GetEntryForEncryptOutput create(Dafny.Aws.Crypto.EncryptEntry cacheEntry) {
      return new GetEntryForEncryptOutput(cacheEntry);
    }
    public bool is_GetEntryForEncryptOutput { get { return true; } }
    public Dafny.Aws.Crypto.EncryptEntry dtor_cacheEntry {
      get {
        return this.cacheEntry;
      }
    }
  }

  public class PutEntryForDecryptInput {
    public readonly Dafny.ISequence<byte> identifier;
    public readonly Dafny.Aws.Crypto.DecryptionMaterials decryptionMaterials;
    public PutEntryForDecryptInput(Dafny.ISequence<byte> identifier, Dafny.Aws.Crypto.DecryptionMaterials decryptionMaterials) {
      this.identifier = identifier;
      this.decryptionMaterials = decryptionMaterials;
    }
    public override bool Equals(object other) {
      var oth = other as Dafny.Aws.Crypto.PutEntryForDecryptInput;
      return oth != null && object.Equals(this.identifier, oth.identifier) && object.Equals(this.decryptionMaterials, oth.decryptionMaterials);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.identifier));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.decryptionMaterials));
      return (int) hash;
    }
    public override string ToString() {
      string s = "Dafny.Aws.Crypto_Compile.PutEntryForDecryptInput.PutEntryForDecryptInput";
      s += "(";
      s += Dafny.Helpers.ToString(this.identifier);
      s += ", ";
      s += Dafny.Helpers.ToString(this.decryptionMaterials);
      s += ")";
      return s;
    }
    private static readonly PutEntryForDecryptInput theDefault = create(Dafny.Sequence<byte>.Empty, Dafny.Aws.Crypto.DecryptionMaterials.Default());
    public static PutEntryForDecryptInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<Dafny.Aws.Crypto.PutEntryForDecryptInput> _TYPE = new Dafny.TypeDescriptor<Dafny.Aws.Crypto.PutEntryForDecryptInput>(Dafny.Aws.Crypto.PutEntryForDecryptInput.Default());
    public static Dafny.TypeDescriptor<Dafny.Aws.Crypto.PutEntryForDecryptInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static PutEntryForDecryptInput create(Dafny.ISequence<byte> identifier, Dafny.Aws.Crypto.DecryptionMaterials decryptionMaterials) {
      return new PutEntryForDecryptInput(identifier, decryptionMaterials);
    }
    public bool is_PutEntryForDecryptInput { get { return true; } }
    public Dafny.ISequence<byte> dtor_identifier {
      get {
        return this.identifier;
      }
    }
    public Dafny.Aws.Crypto.DecryptionMaterials dtor_decryptionMaterials {
      get {
        return this.decryptionMaterials;
      }
    }
  }

  public class PutEntryForDecryptOutput {
    public PutEntryForDecryptOutput() {
    }
    public override bool Equals(object other) {
      var oth = other as Dafny.Aws.Crypto.PutEntryForDecryptOutput;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      return (int) hash;
    }
    public override string ToString() {
      string s = "Dafny.Aws.Crypto_Compile.PutEntryForDecryptOutput.PutEntryForDecryptOutput";
      return s;
    }
    private static readonly PutEntryForDecryptOutput theDefault = create();
    public static PutEntryForDecryptOutput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<Dafny.Aws.Crypto.PutEntryForDecryptOutput> _TYPE = new Dafny.TypeDescriptor<Dafny.Aws.Crypto.PutEntryForDecryptOutput>(Dafny.Aws.Crypto.PutEntryForDecryptOutput.Default());
    public static Dafny.TypeDescriptor<Dafny.Aws.Crypto.PutEntryForDecryptOutput> _TypeDescriptor() {
      return _TYPE;
    }
    public static PutEntryForDecryptOutput create() {
      return new PutEntryForDecryptOutput();
    }
    public bool is_PutEntryForDecryptOutput { get { return true; } }
    public static System.Collections.Generic.IEnumerable<PutEntryForDecryptOutput> AllSingletonConstructors {
      get {
        yield return PutEntryForDecryptOutput.create();
      }
    }
  }

  public class GetEntryForDecryptInput {
    public readonly Dafny.ISequence<byte> identifier;
    public GetEntryForDecryptInput(Dafny.ISequence<byte> identifier) {
      this.identifier = identifier;
    }
    public override bool Equals(object other) {
      var oth = other as Dafny.Aws.Crypto.GetEntryForDecryptInput;
      return oth != null && object.Equals(this.identifier, oth.identifier);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.identifier));
      return (int) hash;
    }
    public override string ToString() {
      string s = "Dafny.Aws.Crypto_Compile.GetEntryForDecryptInput.GetEntryForDecryptInput";
      s += "(";
      s += Dafny.Helpers.ToString(this.identifier);
      s += ")";
      return s;
    }
    private static readonly GetEntryForDecryptInput theDefault = create(Dafny.Sequence<byte>.Empty);
    public static GetEntryForDecryptInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<Dafny.Aws.Crypto.GetEntryForDecryptInput> _TYPE = new Dafny.TypeDescriptor<Dafny.Aws.Crypto.GetEntryForDecryptInput>(Dafny.Aws.Crypto.GetEntryForDecryptInput.Default());
    public static Dafny.TypeDescriptor<Dafny.Aws.Crypto.GetEntryForDecryptInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static GetEntryForDecryptInput create(Dafny.ISequence<byte> identifier) {
      return new GetEntryForDecryptInput(identifier);
    }
    public bool is_GetEntryForDecryptInput { get { return true; } }
    public Dafny.ISequence<byte> dtor_identifier {
      get {
        return this.identifier;
      }
    }
  }

  public class GetEntryForDecryptOutput {
    public readonly Dafny.Aws.Crypto.DecryptEntry cacheEntry;
    public GetEntryForDecryptOutput(Dafny.Aws.Crypto.DecryptEntry cacheEntry) {
      this.cacheEntry = cacheEntry;
    }
    public override bool Equals(object other) {
      var oth = other as Dafny.Aws.Crypto.GetEntryForDecryptOutput;
      return oth != null && object.Equals(this.cacheEntry, oth.cacheEntry);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.cacheEntry));
      return (int) hash;
    }
    public override string ToString() {
      string s = "Dafny.Aws.Crypto_Compile.GetEntryForDecryptOutput.GetEntryForDecryptOutput";
      s += "(";
      s += Dafny.Helpers.ToString(this.cacheEntry);
      s += ")";
      return s;
    }
    private static readonly GetEntryForDecryptOutput theDefault = create(Dafny.Aws.Crypto.DecryptEntry.Default());
    public static GetEntryForDecryptOutput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<Dafny.Aws.Crypto.GetEntryForDecryptOutput> _TYPE = new Dafny.TypeDescriptor<Dafny.Aws.Crypto.GetEntryForDecryptOutput>(Dafny.Aws.Crypto.GetEntryForDecryptOutput.Default());
    public static Dafny.TypeDescriptor<Dafny.Aws.Crypto.GetEntryForDecryptOutput> _TypeDescriptor() {
      return _TYPE;
    }
    public static GetEntryForDecryptOutput create(Dafny.Aws.Crypto.DecryptEntry cacheEntry) {
      return new GetEntryForDecryptOutput(cacheEntry);
    }
    public bool is_GetEntryForDecryptOutput { get { return true; } }
    public Dafny.Aws.Crypto.DecryptEntry dtor_cacheEntry {
      get {
        return this.cacheEntry;
      }
    }
  }

  public class DeleteEntryInput {
    public readonly Dafny.ISequence<byte> identifier;
    public DeleteEntryInput(Dafny.ISequence<byte> identifier) {
      this.identifier = identifier;
    }
    public override bool Equals(object other) {
      var oth = other as Dafny.Aws.Crypto.DeleteEntryInput;
      return oth != null && object.Equals(this.identifier, oth.identifier);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.identifier));
      return (int) hash;
    }
    public override string ToString() {
      string s = "Dafny.Aws.Crypto_Compile.DeleteEntryInput.DeleteEntryInput";
      s += "(";
      s += Dafny.Helpers.ToString(this.identifier);
      s += ")";
      return s;
    }
    private static readonly DeleteEntryInput theDefault = create(Dafny.Sequence<byte>.Empty);
    public static DeleteEntryInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<Dafny.Aws.Crypto.DeleteEntryInput> _TYPE = new Dafny.TypeDescriptor<Dafny.Aws.Crypto.DeleteEntryInput>(Dafny.Aws.Crypto.DeleteEntryInput.Default());
    public static Dafny.TypeDescriptor<Dafny.Aws.Crypto.DeleteEntryInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static DeleteEntryInput create(Dafny.ISequence<byte> identifier) {
      return new DeleteEntryInput(identifier);
    }
    public bool is_DeleteEntryInput { get { return true; } }
    public Dafny.ISequence<byte> dtor_identifier {
      get {
        return this.identifier;
      }
    }
  }

  public class DeleteEntryOutput {
    public DeleteEntryOutput() {
    }
    public override bool Equals(object other) {
      var oth = other as Dafny.Aws.Crypto.DeleteEntryOutput;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      return (int) hash;
    }
    public override string ToString() {
      string s = "Dafny.Aws.Crypto_Compile.DeleteEntryOutput.DeleteEntryOutput";
      return s;
    }
    private static readonly DeleteEntryOutput theDefault = create();
    public static DeleteEntryOutput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<Dafny.Aws.Crypto.DeleteEntryOutput> _TYPE = new Dafny.TypeDescriptor<Dafny.Aws.Crypto.DeleteEntryOutput>(Dafny.Aws.Crypto.DeleteEntryOutput.Default());
    public static Dafny.TypeDescriptor<Dafny.Aws.Crypto.DeleteEntryOutput> _TypeDescriptor() {
      return _TYPE;
    }
    public static DeleteEntryOutput create() {
      return new DeleteEntryOutput();
    }
    public bool is_DeleteEntryOutput { get { return true; } }
    public static System.Collections.Generic.IEnumerable<DeleteEntryOutput> AllSingletonConstructors {
      get {
        yield return DeleteEntryOutput.create();
      }
    }
  }

  public interface ICryptoMaterialsCache {
    Dafny.Aws.Crypto.PutEntryForEncryptOutput PutEntryForEncrypt(Dafny.Aws.Crypto.PutEntryForEncryptInput input);
    Dafny.Aws.Crypto.GetEntryForEncryptOutput GetEntryForEncrypt(Dafny.Aws.Crypto.GetEntryForEncryptInput input);
    Dafny.Aws.Crypto.PutEntryForDecryptOutput PutEntryForDecrypt(Dafny.Aws.Crypto.PutEntryForDecryptInput input);
    Dafny.Aws.Crypto.GetEntryForDecryptOutput GetEntryForDecrypt(Dafny.Aws.Crypto.GetEntryForDecryptInput input);
    Dafny.Aws.Crypto.DeleteEntryOutput DeleteEntry(Dafny.Aws.Crypto.DeleteEntryInput input);
  }
  public class _Companion_ICryptoMaterialsCache {
  }

  public class GetEncryptionMaterialsInput {
    public readonly Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext;
    public readonly Wrappers_Compile.Option<Dafny.Aws.Crypto.AlgorithmSuiteId> algorithmSuiteId;
    public readonly Wrappers_Compile.Option<long> maxPlaintextLength;
    public GetEncryptionMaterialsInput(Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext, Wrappers_Compile.Option<Dafny.Aws.Crypto.AlgorithmSuiteId> algorithmSuiteId, Wrappers_Compile.Option<long> maxPlaintextLength) {
      this.encryptionContext = encryptionContext;
      this.algorithmSuiteId = algorithmSuiteId;
      this.maxPlaintextLength = maxPlaintextLength;
    }
    public override bool Equals(object other) {
      var oth = other as Dafny.Aws.Crypto.GetEncryptionMaterialsInput;
      return oth != null && object.Equals(this.encryptionContext, oth.encryptionContext) && object.Equals(this.algorithmSuiteId, oth.algorithmSuiteId) && object.Equals(this.maxPlaintextLength, oth.maxPlaintextLength);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.encryptionContext));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.algorithmSuiteId));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.maxPlaintextLength));
      return (int) hash;
    }
    public override string ToString() {
      string s = "Dafny.Aws.Crypto_Compile.GetEncryptionMaterialsInput.GetEncryptionMaterialsInput";
      s += "(";
      s += Dafny.Helpers.ToString(this.encryptionContext);
      s += ", ";
      s += Dafny.Helpers.ToString(this.algorithmSuiteId);
      s += ", ";
      s += Dafny.Helpers.ToString(this.maxPlaintextLength);
      s += ")";
      return s;
    }
    private static readonly GetEncryptionMaterialsInput theDefault = create(Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Empty, Wrappers_Compile.Option<Dafny.Aws.Crypto.AlgorithmSuiteId>.Default(), Wrappers_Compile.Option<long>.Default());
    public static GetEncryptionMaterialsInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<Dafny.Aws.Crypto.GetEncryptionMaterialsInput> _TYPE = new Dafny.TypeDescriptor<Dafny.Aws.Crypto.GetEncryptionMaterialsInput>(Dafny.Aws.Crypto.GetEncryptionMaterialsInput.Default());
    public static Dafny.TypeDescriptor<Dafny.Aws.Crypto.GetEncryptionMaterialsInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static GetEncryptionMaterialsInput create(Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext, Wrappers_Compile.Option<Dafny.Aws.Crypto.AlgorithmSuiteId> algorithmSuiteId, Wrappers_Compile.Option<long> maxPlaintextLength) {
      return new GetEncryptionMaterialsInput(encryptionContext, algorithmSuiteId, maxPlaintextLength);
    }
    public bool is_GetEncryptionMaterialsInput { get { return true; } }
    public Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> dtor_encryptionContext {
      get {
        return this.encryptionContext;
      }
    }
    public Wrappers_Compile.Option<Dafny.Aws.Crypto.AlgorithmSuiteId> dtor_algorithmSuiteId {
      get {
        return this.algorithmSuiteId;
      }
    }
    public Wrappers_Compile.Option<long> dtor_maxPlaintextLength {
      get {
        return this.maxPlaintextLength;
      }
    }
  }

  public class GetEncryptionMaterialsOutput {
    public readonly Dafny.Aws.Crypto.EncryptionMaterials encryptionMaterials;
    public GetEncryptionMaterialsOutput(Dafny.Aws.Crypto.EncryptionMaterials encryptionMaterials) {
      this.encryptionMaterials = encryptionMaterials;
    }
    public override bool Equals(object other) {
      var oth = other as Dafny.Aws.Crypto.GetEncryptionMaterialsOutput;
      return oth != null && object.Equals(this.encryptionMaterials, oth.encryptionMaterials);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.encryptionMaterials));
      return (int) hash;
    }
    public override string ToString() {
      string s = "Dafny.Aws.Crypto_Compile.GetEncryptionMaterialsOutput.GetEncryptionMaterialsOutput";
      s += "(";
      s += Dafny.Helpers.ToString(this.encryptionMaterials);
      s += ")";
      return s;
    }
    private static readonly GetEncryptionMaterialsOutput theDefault = create(Dafny.Aws.Crypto.EncryptionMaterials.Default());
    public static GetEncryptionMaterialsOutput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<Dafny.Aws.Crypto.GetEncryptionMaterialsOutput> _TYPE = new Dafny.TypeDescriptor<Dafny.Aws.Crypto.GetEncryptionMaterialsOutput>(Dafny.Aws.Crypto.GetEncryptionMaterialsOutput.Default());
    public static Dafny.TypeDescriptor<Dafny.Aws.Crypto.GetEncryptionMaterialsOutput> _TypeDescriptor() {
      return _TYPE;
    }
    public static GetEncryptionMaterialsOutput create(Dafny.Aws.Crypto.EncryptionMaterials encryptionMaterials) {
      return new GetEncryptionMaterialsOutput(encryptionMaterials);
    }
    public bool is_GetEncryptionMaterialsOutput { get { return true; } }
    public Dafny.Aws.Crypto.EncryptionMaterials dtor_encryptionMaterials {
      get {
        return this.encryptionMaterials;
      }
    }
  }

  public class DecryptMaterialsInput {
    public readonly Dafny.Aws.Crypto.AlgorithmSuiteId algorithmSuiteId;
    public readonly Dafny.ISequence<Dafny.Aws.Crypto.EncryptedDataKey> encryptedDataKeys;
    public readonly Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext;
    public DecryptMaterialsInput(Dafny.Aws.Crypto.AlgorithmSuiteId algorithmSuiteId, Dafny.ISequence<Dafny.Aws.Crypto.EncryptedDataKey> encryptedDataKeys, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext) {
      this.algorithmSuiteId = algorithmSuiteId;
      this.encryptedDataKeys = encryptedDataKeys;
      this.encryptionContext = encryptionContext;
    }
    public override bool Equals(object other) {
      var oth = other as Dafny.Aws.Crypto.DecryptMaterialsInput;
      return oth != null && object.Equals(this.algorithmSuiteId, oth.algorithmSuiteId) && object.Equals(this.encryptedDataKeys, oth.encryptedDataKeys) && object.Equals(this.encryptionContext, oth.encryptionContext);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.algorithmSuiteId));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.encryptedDataKeys));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.encryptionContext));
      return (int) hash;
    }
    public override string ToString() {
      string s = "Dafny.Aws.Crypto_Compile.DecryptMaterialsInput.DecryptMaterialsInput";
      s += "(";
      s += Dafny.Helpers.ToString(this.algorithmSuiteId);
      s += ", ";
      s += Dafny.Helpers.ToString(this.encryptedDataKeys);
      s += ", ";
      s += Dafny.Helpers.ToString(this.encryptionContext);
      s += ")";
      return s;
    }
    private static readonly DecryptMaterialsInput theDefault = create(Dafny.Aws.Crypto.AlgorithmSuiteId.Default(), Dafny.Sequence<Dafny.Aws.Crypto.EncryptedDataKey>.Empty, Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Empty);
    public static DecryptMaterialsInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<Dafny.Aws.Crypto.DecryptMaterialsInput> _TYPE = new Dafny.TypeDescriptor<Dafny.Aws.Crypto.DecryptMaterialsInput>(Dafny.Aws.Crypto.DecryptMaterialsInput.Default());
    public static Dafny.TypeDescriptor<Dafny.Aws.Crypto.DecryptMaterialsInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static DecryptMaterialsInput create(Dafny.Aws.Crypto.AlgorithmSuiteId algorithmSuiteId, Dafny.ISequence<Dafny.Aws.Crypto.EncryptedDataKey> encryptedDataKeys, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext) {
      return new DecryptMaterialsInput(algorithmSuiteId, encryptedDataKeys, encryptionContext);
    }
    public bool is_DecryptMaterialsInput { get { return true; } }
    public Dafny.Aws.Crypto.AlgorithmSuiteId dtor_algorithmSuiteId {
      get {
        return this.algorithmSuiteId;
      }
    }
    public Dafny.ISequence<Dafny.Aws.Crypto.EncryptedDataKey> dtor_encryptedDataKeys {
      get {
        return this.encryptedDataKeys;
      }
    }
    public Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> dtor_encryptionContext {
      get {
        return this.encryptionContext;
      }
    }
  }

  public class DecryptMaterialsOutput {
    public readonly Dafny.Aws.Crypto.DecryptionMaterials decryptionMaterials;
    public DecryptMaterialsOutput(Dafny.Aws.Crypto.DecryptionMaterials decryptionMaterials) {
      this.decryptionMaterials = decryptionMaterials;
    }
    public override bool Equals(object other) {
      var oth = other as Dafny.Aws.Crypto.DecryptMaterialsOutput;
      return oth != null && object.Equals(this.decryptionMaterials, oth.decryptionMaterials);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.decryptionMaterials));
      return (int) hash;
    }
    public override string ToString() {
      string s = "Dafny.Aws.Crypto_Compile.DecryptMaterialsOutput.DecryptMaterialsOutput";
      s += "(";
      s += Dafny.Helpers.ToString(this.decryptionMaterials);
      s += ")";
      return s;
    }
    private static readonly DecryptMaterialsOutput theDefault = create(Dafny.Aws.Crypto.DecryptionMaterials.Default());
    public static DecryptMaterialsOutput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<Dafny.Aws.Crypto.DecryptMaterialsOutput> _TYPE = new Dafny.TypeDescriptor<Dafny.Aws.Crypto.DecryptMaterialsOutput>(Dafny.Aws.Crypto.DecryptMaterialsOutput.Default());
    public static Dafny.TypeDescriptor<Dafny.Aws.Crypto.DecryptMaterialsOutput> _TypeDescriptor() {
      return _TYPE;
    }
    public static DecryptMaterialsOutput create(Dafny.Aws.Crypto.DecryptionMaterials decryptionMaterials) {
      return new DecryptMaterialsOutput(decryptionMaterials);
    }
    public bool is_DecryptMaterialsOutput { get { return true; } }
    public Dafny.Aws.Crypto.DecryptionMaterials dtor_decryptionMaterials {
      get {
        return this.decryptionMaterials;
      }
    }
  }

  public interface ICryptographicMaterialsManager {
    Wrappers_Compile.Result<Dafny.Aws.Crypto.GetEncryptionMaterialsOutput, Dafny.ISequence<char>> GetEncryptionMaterials(Dafny.Aws.Crypto.GetEncryptionMaterialsInput input);
    Wrappers_Compile.Result<Dafny.Aws.Crypto.DecryptMaterialsOutput, Dafny.ISequence<char>> DecryptMaterials(Dafny.Aws.Crypto.DecryptMaterialsInput input);
  }
  public class _Companion_ICryptographicMaterialsManager {
  }

  public class CreateAwsKmsKeyringInput {
    public readonly Dafny.Aws.Crypto.IClientSupplier clientSupplier;
    public readonly Wrappers_Compile.Option<Dafny.ISequence<char>> generator;
    public readonly Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<char>>> keyIds;
    public readonly Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<char>>> grantTokens;
    public CreateAwsKmsKeyringInput(Dafny.Aws.Crypto.IClientSupplier clientSupplier, Wrappers_Compile.Option<Dafny.ISequence<char>> generator, Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<char>>> keyIds, Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<char>>> grantTokens) {
      this.clientSupplier = clientSupplier;
      this.generator = generator;
      this.keyIds = keyIds;
      this.grantTokens = grantTokens;
    }
    public override bool Equals(object other) {
      var oth = other as Dafny.Aws.Crypto.CreateAwsKmsKeyringInput;
      return oth != null && this.clientSupplier == oth.clientSupplier && object.Equals(this.generator, oth.generator) && object.Equals(this.keyIds, oth.keyIds) && object.Equals(this.grantTokens, oth.grantTokens);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.clientSupplier));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.generator));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.keyIds));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.grantTokens));
      return (int) hash;
    }
    public override string ToString() {
      string s = "Dafny.Aws.Crypto_Compile.CreateAwsKmsKeyringInput.CreateAwsKmsKeyringInput";
      s += "(";
      s += Dafny.Helpers.ToString(this.clientSupplier);
      s += ", ";
      s += Dafny.Helpers.ToString(this.generator);
      s += ", ";
      s += Dafny.Helpers.ToString(this.keyIds);
      s += ", ";
      s += Dafny.Helpers.ToString(this.grantTokens);
      s += ")";
      return s;
    }
    private static readonly CreateAwsKmsKeyringInput theDefault = create(default(Dafny.Aws.Crypto.IClientSupplier), Wrappers_Compile.Option<Dafny.ISequence<char>>.Default(), Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<char>>>.Default(), Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<char>>>.Default());
    public static CreateAwsKmsKeyringInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<Dafny.Aws.Crypto.CreateAwsKmsKeyringInput> _TYPE = new Dafny.TypeDescriptor<Dafny.Aws.Crypto.CreateAwsKmsKeyringInput>(Dafny.Aws.Crypto.CreateAwsKmsKeyringInput.Default());
    public static Dafny.TypeDescriptor<Dafny.Aws.Crypto.CreateAwsKmsKeyringInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static CreateAwsKmsKeyringInput create(Dafny.Aws.Crypto.IClientSupplier clientSupplier, Wrappers_Compile.Option<Dafny.ISequence<char>> generator, Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<char>>> keyIds, Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<char>>> grantTokens) {
      return new CreateAwsKmsKeyringInput(clientSupplier, generator, keyIds, grantTokens);
    }
    public bool is_CreateAwsKmsKeyringInput { get { return true; } }
    public Dafny.Aws.Crypto.IClientSupplier dtor_clientSupplier {
      get {
        return this.clientSupplier;
      }
    }
    public Wrappers_Compile.Option<Dafny.ISequence<char>> dtor_generator {
      get {
        return this.generator;
      }
    }
    public Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<char>>> dtor_keyIds {
      get {
        return this.keyIds;
      }
    }
    public Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<char>>> dtor_grantTokens {
      get {
        return this.grantTokens;
      }
    }
  }

  public class CreateMrkAwareStrictAwsKmsKeyringInput {
    public readonly Dafny.ISequence<char> kmsKeyId;
    public readonly Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<char>>> grantTokens;
    public readonly Amazon.KeyManagementService.IAmazonKeyManagementService kmsClient;
    public CreateMrkAwareStrictAwsKmsKeyringInput(Dafny.ISequence<char> kmsKeyId, Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<char>>> grantTokens, Amazon.KeyManagementService.IAmazonKeyManagementService kmsClient) {
      this.kmsKeyId = kmsKeyId;
      this.grantTokens = grantTokens;
      this.kmsClient = kmsClient;
    }
    public override bool Equals(object other) {
      var oth = other as Dafny.Aws.Crypto.CreateMrkAwareStrictAwsKmsKeyringInput;
      return oth != null && object.Equals(this.kmsKeyId, oth.kmsKeyId) && object.Equals(this.grantTokens, oth.grantTokens) && this.kmsClient == oth.kmsClient;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.kmsKeyId));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.grantTokens));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.kmsClient));
      return (int) hash;
    }
    public override string ToString() {
      string s = "Dafny.Aws.Crypto_Compile.CreateMrkAwareStrictAwsKmsKeyringInput.CreateMrkAwareStrictAwsKmsKeyringInput";
      s += "(";
      s += Dafny.Helpers.ToString(this.kmsKeyId);
      s += ", ";
      s += Dafny.Helpers.ToString(this.grantTokens);
      s += ", ";
      s += Dafny.Helpers.ToString(this.kmsClient);
      s += ")";
      return s;
    }
    private static readonly CreateMrkAwareStrictAwsKmsKeyringInput theDefault = create(Dafny.Sequence<char>.Empty, Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<char>>>.Default(), default(Amazon.KeyManagementService.IAmazonKeyManagementService));
    public static CreateMrkAwareStrictAwsKmsKeyringInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<Dafny.Aws.Crypto.CreateMrkAwareStrictAwsKmsKeyringInput> _TYPE = new Dafny.TypeDescriptor<Dafny.Aws.Crypto.CreateMrkAwareStrictAwsKmsKeyringInput>(Dafny.Aws.Crypto.CreateMrkAwareStrictAwsKmsKeyringInput.Default());
    public static Dafny.TypeDescriptor<Dafny.Aws.Crypto.CreateMrkAwareStrictAwsKmsKeyringInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static CreateMrkAwareStrictAwsKmsKeyringInput create(Dafny.ISequence<char> kmsKeyId, Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<char>>> grantTokens, Amazon.KeyManagementService.IAmazonKeyManagementService kmsClient) {
      return new CreateMrkAwareStrictAwsKmsKeyringInput(kmsKeyId, grantTokens, kmsClient);
    }
    public bool is_CreateMrkAwareStrictAwsKmsKeyringInput { get { return true; } }
    public Dafny.ISequence<char> dtor_kmsKeyId {
      get {
        return this.kmsKeyId;
      }
    }
    public Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<char>>> dtor_grantTokens {
      get {
        return this.grantTokens;
      }
    }
    public Amazon.KeyManagementService.IAmazonKeyManagementService dtor_kmsClient {
      get {
        return this.kmsClient;
      }
    }
  }

  public class CreateMrkAwareStrictMultiKeyringInput {
    public readonly Wrappers_Compile.Option<Dafny.ISequence<char>> generator;
    public readonly Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<char>>> kmsKeyIds;
    public readonly Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<char>>> grantTokens;
    public readonly Dafny.Aws.Crypto.IClientSupplier clientSupplier;
    public CreateMrkAwareStrictMultiKeyringInput(Wrappers_Compile.Option<Dafny.ISequence<char>> generator, Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<char>>> kmsKeyIds, Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<char>>> grantTokens, Dafny.Aws.Crypto.IClientSupplier clientSupplier) {
      this.generator = generator;
      this.kmsKeyIds = kmsKeyIds;
      this.grantTokens = grantTokens;
      this.clientSupplier = clientSupplier;
    }
    public override bool Equals(object other) {
      var oth = other as Dafny.Aws.Crypto.CreateMrkAwareStrictMultiKeyringInput;
      return oth != null && object.Equals(this.generator, oth.generator) && object.Equals(this.kmsKeyIds, oth.kmsKeyIds) && object.Equals(this.grantTokens, oth.grantTokens) && this.clientSupplier == oth.clientSupplier;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.generator));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.kmsKeyIds));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.grantTokens));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.clientSupplier));
      return (int) hash;
    }
    public override string ToString() {
      string s = "Dafny.Aws.Crypto_Compile.CreateMrkAwareStrictMultiKeyringInput.CreateMrkAwareStrictMultiKeyringInput";
      s += "(";
      s += Dafny.Helpers.ToString(this.generator);
      s += ", ";
      s += Dafny.Helpers.ToString(this.kmsKeyIds);
      s += ", ";
      s += Dafny.Helpers.ToString(this.grantTokens);
      s += ", ";
      s += Dafny.Helpers.ToString(this.clientSupplier);
      s += ")";
      return s;
    }
    private static readonly CreateMrkAwareStrictMultiKeyringInput theDefault = create(Wrappers_Compile.Option<Dafny.ISequence<char>>.Default(), Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<char>>>.Default(), Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<char>>>.Default(), (Dafny.Aws.Crypto.IClientSupplier)null);
    public static CreateMrkAwareStrictMultiKeyringInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<Dafny.Aws.Crypto.CreateMrkAwareStrictMultiKeyringInput> _TYPE = new Dafny.TypeDescriptor<Dafny.Aws.Crypto.CreateMrkAwareStrictMultiKeyringInput>(Dafny.Aws.Crypto.CreateMrkAwareStrictMultiKeyringInput.Default());
    public static Dafny.TypeDescriptor<Dafny.Aws.Crypto.CreateMrkAwareStrictMultiKeyringInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static CreateMrkAwareStrictMultiKeyringInput create(Wrappers_Compile.Option<Dafny.ISequence<char>> generator, Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<char>>> kmsKeyIds, Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<char>>> grantTokens, Dafny.Aws.Crypto.IClientSupplier clientSupplier) {
      return new CreateMrkAwareStrictMultiKeyringInput(generator, kmsKeyIds, grantTokens, clientSupplier);
    }
    public bool is_CreateMrkAwareStrictMultiKeyringInput { get { return true; } }
    public Wrappers_Compile.Option<Dafny.ISequence<char>> dtor_generator {
      get {
        return this.generator;
      }
    }
    public Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<char>>> dtor_kmsKeyIds {
      get {
        return this.kmsKeyIds;
      }
    }
    public Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<char>>> dtor_grantTokens {
      get {
        return this.grantTokens;
      }
    }
    public Dafny.Aws.Crypto.IClientSupplier dtor_clientSupplier {
      get {
        return this.clientSupplier;
      }
    }
  }

  public class CreateMrkAwareDiscoveryAwsKmsKeyringInput {
    public readonly Amazon.KeyManagementService.IAmazonKeyManagementService kmsClient;
    public readonly Wrappers_Compile.Option<Dafny.Aws.Crypto.DiscoveryFilter> discoveryFilter;
    public readonly Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<char>>> grantTokens;
    public CreateMrkAwareDiscoveryAwsKmsKeyringInput(Amazon.KeyManagementService.IAmazonKeyManagementService kmsClient, Wrappers_Compile.Option<Dafny.Aws.Crypto.DiscoveryFilter> discoveryFilter, Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<char>>> grantTokens) {
      this.kmsClient = kmsClient;
      this.discoveryFilter = discoveryFilter;
      this.grantTokens = grantTokens;
    }
    public override bool Equals(object other) {
      var oth = other as Dafny.Aws.Crypto.CreateMrkAwareDiscoveryAwsKmsKeyringInput;
      return oth != null && this.kmsClient == oth.kmsClient && object.Equals(this.discoveryFilter, oth.discoveryFilter) && object.Equals(this.grantTokens, oth.grantTokens);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.kmsClient));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.discoveryFilter));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.grantTokens));
      return (int) hash;
    }
    public override string ToString() {
      string s = "Dafny.Aws.Crypto_Compile.CreateMrkAwareDiscoveryAwsKmsKeyringInput.CreateMrkAwareDiscoveryAwsKmsKeyringInput";
      s += "(";
      s += Dafny.Helpers.ToString(this.kmsClient);
      s += ", ";
      s += Dafny.Helpers.ToString(this.discoveryFilter);
      s += ", ";
      s += Dafny.Helpers.ToString(this.grantTokens);
      s += ")";
      return s;
    }
    private static readonly CreateMrkAwareDiscoveryAwsKmsKeyringInput theDefault = create(default(Amazon.KeyManagementService.IAmazonKeyManagementService), Wrappers_Compile.Option<Dafny.Aws.Crypto.DiscoveryFilter>.Default(), Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<char>>>.Default());
    public static CreateMrkAwareDiscoveryAwsKmsKeyringInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<Dafny.Aws.Crypto.CreateMrkAwareDiscoveryAwsKmsKeyringInput> _TYPE = new Dafny.TypeDescriptor<Dafny.Aws.Crypto.CreateMrkAwareDiscoveryAwsKmsKeyringInput>(Dafny.Aws.Crypto.CreateMrkAwareDiscoveryAwsKmsKeyringInput.Default());
    public static Dafny.TypeDescriptor<Dafny.Aws.Crypto.CreateMrkAwareDiscoveryAwsKmsKeyringInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static CreateMrkAwareDiscoveryAwsKmsKeyringInput create(Amazon.KeyManagementService.IAmazonKeyManagementService kmsClient, Wrappers_Compile.Option<Dafny.Aws.Crypto.DiscoveryFilter> discoveryFilter, Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<char>>> grantTokens) {
      return new CreateMrkAwareDiscoveryAwsKmsKeyringInput(kmsClient, discoveryFilter, grantTokens);
    }
    public bool is_CreateMrkAwareDiscoveryAwsKmsKeyringInput { get { return true; } }
    public Amazon.KeyManagementService.IAmazonKeyManagementService dtor_kmsClient {
      get {
        return this.kmsClient;
      }
    }
    public Wrappers_Compile.Option<Dafny.Aws.Crypto.DiscoveryFilter> dtor_discoveryFilter {
      get {
        return this.discoveryFilter;
      }
    }
    public Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<char>>> dtor_grantTokens {
      get {
        return this.grantTokens;
      }
    }
  }

  public class CreateMrkAwareDiscoveryMultiKeyringInput {
    public readonly Dafny.ISequence<Dafny.ISequence<char>> regions;
    public readonly Wrappers_Compile.Option<Dafny.Aws.Crypto.DiscoveryFilter> discoveryFilter;
    public readonly Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<char>>> grantTokens;
    public readonly Dafny.Aws.Crypto.IClientSupplier clientSupplier;
    public CreateMrkAwareDiscoveryMultiKeyringInput(Dafny.ISequence<Dafny.ISequence<char>> regions, Wrappers_Compile.Option<Dafny.Aws.Crypto.DiscoveryFilter> discoveryFilter, Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<char>>> grantTokens, Dafny.Aws.Crypto.IClientSupplier clientSupplier) {
      this.regions = regions;
      this.discoveryFilter = discoveryFilter;
      this.grantTokens = grantTokens;
      this.clientSupplier = clientSupplier;
    }
    public override bool Equals(object other) {
      var oth = other as Dafny.Aws.Crypto.CreateMrkAwareDiscoveryMultiKeyringInput;
      return oth != null && object.Equals(this.regions, oth.regions) && object.Equals(this.discoveryFilter, oth.discoveryFilter) && object.Equals(this.grantTokens, oth.grantTokens) && this.clientSupplier == oth.clientSupplier;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.regions));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.discoveryFilter));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.grantTokens));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.clientSupplier));
      return (int) hash;
    }
    public override string ToString() {
      string s = "Dafny.Aws.Crypto_Compile.CreateMrkAwareDiscoveryMultiKeyringInput.CreateMrkAwareDiscoveryMultiKeyringInput";
      s += "(";
      s += Dafny.Helpers.ToString(this.regions);
      s += ", ";
      s += Dafny.Helpers.ToString(this.discoveryFilter);
      s += ", ";
      s += Dafny.Helpers.ToString(this.grantTokens);
      s += ", ";
      s += Dafny.Helpers.ToString(this.clientSupplier);
      s += ")";
      return s;
    }
    private static readonly CreateMrkAwareDiscoveryMultiKeyringInput theDefault = create(Dafny.Sequence<Dafny.ISequence<char>>.Empty, Wrappers_Compile.Option<Dafny.Aws.Crypto.DiscoveryFilter>.Default(), Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<char>>>.Default(), (Dafny.Aws.Crypto.IClientSupplier)null);
    public static CreateMrkAwareDiscoveryMultiKeyringInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<Dafny.Aws.Crypto.CreateMrkAwareDiscoveryMultiKeyringInput> _TYPE = new Dafny.TypeDescriptor<Dafny.Aws.Crypto.CreateMrkAwareDiscoveryMultiKeyringInput>(Dafny.Aws.Crypto.CreateMrkAwareDiscoveryMultiKeyringInput.Default());
    public static Dafny.TypeDescriptor<Dafny.Aws.Crypto.CreateMrkAwareDiscoveryMultiKeyringInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static CreateMrkAwareDiscoveryMultiKeyringInput create(Dafny.ISequence<Dafny.ISequence<char>> regions, Wrappers_Compile.Option<Dafny.Aws.Crypto.DiscoveryFilter> discoveryFilter, Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<char>>> grantTokens, Dafny.Aws.Crypto.IClientSupplier clientSupplier) {
      return new CreateMrkAwareDiscoveryMultiKeyringInput(regions, discoveryFilter, grantTokens, clientSupplier);
    }
    public bool is_CreateMrkAwareDiscoveryMultiKeyringInput { get { return true; } }
    public Dafny.ISequence<Dafny.ISequence<char>> dtor_regions {
      get {
        return this.regions;
      }
    }
    public Wrappers_Compile.Option<Dafny.Aws.Crypto.DiscoveryFilter> dtor_discoveryFilter {
      get {
        return this.discoveryFilter;
      }
    }
    public Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<char>>> dtor_grantTokens {
      get {
        return this.grantTokens;
      }
    }
    public Dafny.Aws.Crypto.IClientSupplier dtor_clientSupplier {
      get {
        return this.clientSupplier;
      }
    }
  }

  public class CreateMultiKeyringInput {
    public readonly Dafny.Aws.Crypto.IKeyring generator;
    public readonly Wrappers_Compile.Option<Dafny.ISequence<Dafny.Aws.Crypto.IKeyring>> childKeyrings;
    public CreateMultiKeyringInput(Dafny.Aws.Crypto.IKeyring generator, Wrappers_Compile.Option<Dafny.ISequence<Dafny.Aws.Crypto.IKeyring>> childKeyrings) {
      this.generator = generator;
      this.childKeyrings = childKeyrings;
    }
    public override bool Equals(object other) {
      var oth = other as Dafny.Aws.Crypto.CreateMultiKeyringInput;
      return oth != null && this.generator == oth.generator && object.Equals(this.childKeyrings, oth.childKeyrings);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.generator));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.childKeyrings));
      return (int) hash;
    }
    public override string ToString() {
      string s = "Dafny.Aws.Crypto_Compile.CreateMultiKeyringInput.CreateMultiKeyringInput";
      s += "(";
      s += Dafny.Helpers.ToString(this.generator);
      s += ", ";
      s += Dafny.Helpers.ToString(this.childKeyrings);
      s += ")";
      return s;
    }
    private static readonly CreateMultiKeyringInput theDefault = create((Dafny.Aws.Crypto.IKeyring)null, Wrappers_Compile.Option<Dafny.ISequence<Dafny.Aws.Crypto.IKeyring>>.Default());
    public static CreateMultiKeyringInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<Dafny.Aws.Crypto.CreateMultiKeyringInput> _TYPE = new Dafny.TypeDescriptor<Dafny.Aws.Crypto.CreateMultiKeyringInput>(Dafny.Aws.Crypto.CreateMultiKeyringInput.Default());
    public static Dafny.TypeDescriptor<Dafny.Aws.Crypto.CreateMultiKeyringInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static CreateMultiKeyringInput create(Dafny.Aws.Crypto.IKeyring generator, Wrappers_Compile.Option<Dafny.ISequence<Dafny.Aws.Crypto.IKeyring>> childKeyrings) {
      return new CreateMultiKeyringInput(generator, childKeyrings);
    }
    public bool is_CreateMultiKeyringInput { get { return true; } }
    public Dafny.Aws.Crypto.IKeyring dtor_generator {
      get {
        return this.generator;
      }
    }
    public Wrappers_Compile.Option<Dafny.ISequence<Dafny.Aws.Crypto.IKeyring>> dtor_childKeyrings {
      get {
        return this.childKeyrings;
      }
    }
  }

  public class CreateRawAesKeyringInput {
    public readonly Dafny.ISequence<char> keyNamespace;
    public readonly Dafny.ISequence<char> keyName;
    public readonly Dafny.ISequence<byte> wrappingKey;
    public readonly Dafny.Aws.Crypto.AesWrappingAlg wrappingAlg;
    public CreateRawAesKeyringInput(Dafny.ISequence<char> keyNamespace, Dafny.ISequence<char> keyName, Dafny.ISequence<byte> wrappingKey, Dafny.Aws.Crypto.AesWrappingAlg wrappingAlg) {
      this.keyNamespace = keyNamespace;
      this.keyName = keyName;
      this.wrappingKey = wrappingKey;
      this.wrappingAlg = wrappingAlg;
    }
    public override bool Equals(object other) {
      var oth = other as Dafny.Aws.Crypto.CreateRawAesKeyringInput;
      return oth != null && object.Equals(this.keyNamespace, oth.keyNamespace) && object.Equals(this.keyName, oth.keyName) && object.Equals(this.wrappingKey, oth.wrappingKey) && object.Equals(this.wrappingAlg, oth.wrappingAlg);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.keyNamespace));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.keyName));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.wrappingKey));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.wrappingAlg));
      return (int) hash;
    }
    public override string ToString() {
      string s = "Dafny.Aws.Crypto_Compile.CreateRawAesKeyringInput.CreateRawAesKeyringInput";
      s += "(";
      s += Dafny.Helpers.ToString(this.keyNamespace);
      s += ", ";
      s += Dafny.Helpers.ToString(this.keyName);
      s += ", ";
      s += Dafny.Helpers.ToString(this.wrappingKey);
      s += ", ";
      s += Dafny.Helpers.ToString(this.wrappingAlg);
      s += ")";
      return s;
    }
    private static readonly CreateRawAesKeyringInput theDefault = create(Dafny.Sequence<char>.Empty, Dafny.Sequence<char>.Empty, Dafny.Sequence<byte>.Empty, Dafny.Aws.Crypto.AesWrappingAlg.Default());
    public static CreateRawAesKeyringInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<Dafny.Aws.Crypto.CreateRawAesKeyringInput> _TYPE = new Dafny.TypeDescriptor<Dafny.Aws.Crypto.CreateRawAesKeyringInput>(Dafny.Aws.Crypto.CreateRawAesKeyringInput.Default());
    public static Dafny.TypeDescriptor<Dafny.Aws.Crypto.CreateRawAesKeyringInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static CreateRawAesKeyringInput create(Dafny.ISequence<char> keyNamespace, Dafny.ISequence<char> keyName, Dafny.ISequence<byte> wrappingKey, Dafny.Aws.Crypto.AesWrappingAlg wrappingAlg) {
      return new CreateRawAesKeyringInput(keyNamespace, keyName, wrappingKey, wrappingAlg);
    }
    public bool is_CreateRawAesKeyringInput { get { return true; } }
    public Dafny.ISequence<char> dtor_keyNamespace {
      get {
        return this.keyNamespace;
      }
    }
    public Dafny.ISequence<char> dtor_keyName {
      get {
        return this.keyName;
      }
    }
    public Dafny.ISequence<byte> dtor_wrappingKey {
      get {
        return this.wrappingKey;
      }
    }
    public Dafny.Aws.Crypto.AesWrappingAlg dtor_wrappingAlg {
      get {
        return this.wrappingAlg;
      }
    }
  }

  public class CreateRawRsaKeyringInput {
    public readonly Dafny.ISequence<char> keyNamespace;
    public readonly Dafny.ISequence<char> keyName;
    public readonly Dafny.Aws.Crypto.PaddingScheme paddingScheme;
    public readonly Wrappers_Compile.Option<Dafny.ISequence<byte>> publicKey;
    public readonly Wrappers_Compile.Option<Dafny.ISequence<byte>> privateKey;
    public CreateRawRsaKeyringInput(Dafny.ISequence<char> keyNamespace, Dafny.ISequence<char> keyName, Dafny.Aws.Crypto.PaddingScheme paddingScheme, Wrappers_Compile.Option<Dafny.ISequence<byte>> publicKey, Wrappers_Compile.Option<Dafny.ISequence<byte>> privateKey) {
      this.keyNamespace = keyNamespace;
      this.keyName = keyName;
      this.paddingScheme = paddingScheme;
      this.publicKey = publicKey;
      this.privateKey = privateKey;
    }
    public override bool Equals(object other) {
      var oth = other as Dafny.Aws.Crypto.CreateRawRsaKeyringInput;
      return oth != null && object.Equals(this.keyNamespace, oth.keyNamespace) && object.Equals(this.keyName, oth.keyName) && object.Equals(this.paddingScheme, oth.paddingScheme) && object.Equals(this.publicKey, oth.publicKey) && object.Equals(this.privateKey, oth.privateKey);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.keyNamespace));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.keyName));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.paddingScheme));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.publicKey));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.privateKey));
      return (int) hash;
    }
    public override string ToString() {
      string s = "Dafny.Aws.Crypto_Compile.CreateRawRsaKeyringInput.CreateRawRsaKeyringInput";
      s += "(";
      s += Dafny.Helpers.ToString(this.keyNamespace);
      s += ", ";
      s += Dafny.Helpers.ToString(this.keyName);
      s += ", ";
      s += Dafny.Helpers.ToString(this.paddingScheme);
      s += ", ";
      s += Dafny.Helpers.ToString(this.publicKey);
      s += ", ";
      s += Dafny.Helpers.ToString(this.privateKey);
      s += ")";
      return s;
    }
    private static readonly CreateRawRsaKeyringInput theDefault = create(Dafny.Sequence<char>.Empty, Dafny.Sequence<char>.Empty, Dafny.Aws.Crypto.PaddingScheme.Default(), Wrappers_Compile.Option<Dafny.ISequence<byte>>.Default(), Wrappers_Compile.Option<Dafny.ISequence<byte>>.Default());
    public static CreateRawRsaKeyringInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<Dafny.Aws.Crypto.CreateRawRsaKeyringInput> _TYPE = new Dafny.TypeDescriptor<Dafny.Aws.Crypto.CreateRawRsaKeyringInput>(Dafny.Aws.Crypto.CreateRawRsaKeyringInput.Default());
    public static Dafny.TypeDescriptor<Dafny.Aws.Crypto.CreateRawRsaKeyringInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static CreateRawRsaKeyringInput create(Dafny.ISequence<char> keyNamespace, Dafny.ISequence<char> keyName, Dafny.Aws.Crypto.PaddingScheme paddingScheme, Wrappers_Compile.Option<Dafny.ISequence<byte>> publicKey, Wrappers_Compile.Option<Dafny.ISequence<byte>> privateKey) {
      return new CreateRawRsaKeyringInput(keyNamespace, keyName, paddingScheme, publicKey, privateKey);
    }
    public bool is_CreateRawRsaKeyringInput { get { return true; } }
    public Dafny.ISequence<char> dtor_keyNamespace {
      get {
        return this.keyNamespace;
      }
    }
    public Dafny.ISequence<char> dtor_keyName {
      get {
        return this.keyName;
      }
    }
    public Dafny.Aws.Crypto.PaddingScheme dtor_paddingScheme {
      get {
        return this.paddingScheme;
      }
    }
    public Wrappers_Compile.Option<Dafny.ISequence<byte>> dtor_publicKey {
      get {
        return this.publicKey;
      }
    }
    public Wrappers_Compile.Option<Dafny.ISequence<byte>> dtor_privateKey {
      get {
        return this.privateKey;
      }
    }
  }

  public class CreateDefaultCryptographicMaterialsManagerInput {
    public readonly Dafny.Aws.Crypto.IKeyring keyring;
    public CreateDefaultCryptographicMaterialsManagerInput(Dafny.Aws.Crypto.IKeyring keyring) {
      this.keyring = keyring;
    }
    public override bool Equals(object other) {
      var oth = other as Dafny.Aws.Crypto.CreateDefaultCryptographicMaterialsManagerInput;
      return oth != null && this.keyring == oth.keyring;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.keyring));
      return (int) hash;
    }
    public override string ToString() {
      string s = "Dafny.Aws.Crypto_Compile.CreateDefaultCryptographicMaterialsManagerInput.CreateDefaultCryptographicMaterialsManagerInput";
      s += "(";
      s += Dafny.Helpers.ToString(this.keyring);
      s += ")";
      return s;
    }
    private static readonly CreateDefaultCryptographicMaterialsManagerInput theDefault = create(default(Dafny.Aws.Crypto.IKeyring));
    public static CreateDefaultCryptographicMaterialsManagerInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<Dafny.Aws.Crypto.CreateDefaultCryptographicMaterialsManagerInput> _TYPE = new Dafny.TypeDescriptor<Dafny.Aws.Crypto.CreateDefaultCryptographicMaterialsManagerInput>(Dafny.Aws.Crypto.CreateDefaultCryptographicMaterialsManagerInput.Default());
    public static Dafny.TypeDescriptor<Dafny.Aws.Crypto.CreateDefaultCryptographicMaterialsManagerInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static CreateDefaultCryptographicMaterialsManagerInput create(Dafny.Aws.Crypto.IKeyring keyring) {
      return new CreateDefaultCryptographicMaterialsManagerInput(keyring);
    }
    public bool is_CreateDefaultCryptographicMaterialsManagerInput { get { return true; } }
    public Dafny.Aws.Crypto.IKeyring dtor_keyring {
      get {
        return this.keyring;
      }
    }
  }

  public class CreateCachingCryptographicMaterialsManagerInput {
    public readonly Dafny.Aws.Crypto.ICryptoMaterialsCache cache;
    public readonly int cacheLimitTtl;
    public readonly Dafny.Aws.Crypto.IKeyring keyring;
    public readonly Dafny.Aws.Crypto.ICryptographicMaterialsManager materialsManager;
    public readonly Wrappers_Compile.Option<Dafny.ISequence<char>> partitionId;
    public readonly Wrappers_Compile.Option<long> limitBytes;
    public readonly Wrappers_Compile.Option<long> limitMessages;
    public CreateCachingCryptographicMaterialsManagerInput(Dafny.Aws.Crypto.ICryptoMaterialsCache cache, int cacheLimitTtl, Dafny.Aws.Crypto.IKeyring keyring, Dafny.Aws.Crypto.ICryptographicMaterialsManager materialsManager, Wrappers_Compile.Option<Dafny.ISequence<char>> partitionId, Wrappers_Compile.Option<long> limitBytes, Wrappers_Compile.Option<long> limitMessages) {
      this.cache = cache;
      this.cacheLimitTtl = cacheLimitTtl;
      this.keyring = keyring;
      this.materialsManager = materialsManager;
      this.partitionId = partitionId;
      this.limitBytes = limitBytes;
      this.limitMessages = limitMessages;
    }
    public override bool Equals(object other) {
      var oth = other as Dafny.Aws.Crypto.CreateCachingCryptographicMaterialsManagerInput;
      return oth != null && this.cache == oth.cache && this.cacheLimitTtl == oth.cacheLimitTtl && this.keyring == oth.keyring && this.materialsManager == oth.materialsManager && object.Equals(this.partitionId, oth.partitionId) && object.Equals(this.limitBytes, oth.limitBytes) && object.Equals(this.limitMessages, oth.limitMessages);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.cache));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.cacheLimitTtl));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.keyring));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.materialsManager));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.partitionId));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.limitBytes));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.limitMessages));
      return (int) hash;
    }
    public override string ToString() {
      string s = "Dafny.Aws.Crypto_Compile.CreateCachingCryptographicMaterialsManagerInput.CreateCachingCryptographicMaterialsManagerInput";
      s += "(";
      s += Dafny.Helpers.ToString(this.cache);
      s += ", ";
      s += Dafny.Helpers.ToString(this.cacheLimitTtl);
      s += ", ";
      s += Dafny.Helpers.ToString(this.keyring);
      s += ", ";
      s += Dafny.Helpers.ToString(this.materialsManager);
      s += ", ";
      s += Dafny.Helpers.ToString(this.partitionId);
      s += ", ";
      s += Dafny.Helpers.ToString(this.limitBytes);
      s += ", ";
      s += Dafny.Helpers.ToString(this.limitMessages);
      s += ")";
      return s;
    }
    private static readonly CreateCachingCryptographicMaterialsManagerInput theDefault = create(default(Dafny.Aws.Crypto.ICryptoMaterialsCache), 0, (Dafny.Aws.Crypto.IKeyring)null, (Dafny.Aws.Crypto.ICryptographicMaterialsManager)null, Wrappers_Compile.Option<Dafny.ISequence<char>>.Default(), Wrappers_Compile.Option<long>.Default(), Wrappers_Compile.Option<long>.Default());
    public static CreateCachingCryptographicMaterialsManagerInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<Dafny.Aws.Crypto.CreateCachingCryptographicMaterialsManagerInput> _TYPE = new Dafny.TypeDescriptor<Dafny.Aws.Crypto.CreateCachingCryptographicMaterialsManagerInput>(Dafny.Aws.Crypto.CreateCachingCryptographicMaterialsManagerInput.Default());
    public static Dafny.TypeDescriptor<Dafny.Aws.Crypto.CreateCachingCryptographicMaterialsManagerInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static CreateCachingCryptographicMaterialsManagerInput create(Dafny.Aws.Crypto.ICryptoMaterialsCache cache, int cacheLimitTtl, Dafny.Aws.Crypto.IKeyring keyring, Dafny.Aws.Crypto.ICryptographicMaterialsManager materialsManager, Wrappers_Compile.Option<Dafny.ISequence<char>> partitionId, Wrappers_Compile.Option<long> limitBytes, Wrappers_Compile.Option<long> limitMessages) {
      return new CreateCachingCryptographicMaterialsManagerInput(cache, cacheLimitTtl, keyring, materialsManager, partitionId, limitBytes, limitMessages);
    }
    public bool is_CreateCachingCryptographicMaterialsManagerInput { get { return true; } }
    public Dafny.Aws.Crypto.ICryptoMaterialsCache dtor_cache {
      get {
        return this.cache;
      }
    }
    public int dtor_cacheLimitTtl {
      get {
        return this.cacheLimitTtl;
      }
    }
    public Dafny.Aws.Crypto.IKeyring dtor_keyring {
      get {
        return this.keyring;
      }
    }
    public Dafny.Aws.Crypto.ICryptographicMaterialsManager dtor_materialsManager {
      get {
        return this.materialsManager;
      }
    }
    public Wrappers_Compile.Option<Dafny.ISequence<char>> dtor_partitionId {
      get {
        return this.partitionId;
      }
    }
    public Wrappers_Compile.Option<long> dtor_limitBytes {
      get {
        return this.limitBytes;
      }
    }
    public Wrappers_Compile.Option<long> dtor_limitMessages {
      get {
        return this.limitMessages;
      }
    }
  }

  public class CreateLocalCryptoMaterialsCacheInput {
    public readonly int entryCapacity;
    public readonly Wrappers_Compile.Option<int> entryPruningTailSize;
    public CreateLocalCryptoMaterialsCacheInput(int entryCapacity, Wrappers_Compile.Option<int> entryPruningTailSize) {
      this.entryCapacity = entryCapacity;
      this.entryPruningTailSize = entryPruningTailSize;
    }
    public override bool Equals(object other) {
      var oth = other as Dafny.Aws.Crypto.CreateLocalCryptoMaterialsCacheInput;
      return oth != null && this.entryCapacity == oth.entryCapacity && object.Equals(this.entryPruningTailSize, oth.entryPruningTailSize);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.entryCapacity));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.entryPruningTailSize));
      return (int) hash;
    }
    public override string ToString() {
      string s = "Dafny.Aws.Crypto_Compile.CreateLocalCryptoMaterialsCacheInput.CreateLocalCryptoMaterialsCacheInput";
      s += "(";
      s += Dafny.Helpers.ToString(this.entryCapacity);
      s += ", ";
      s += Dafny.Helpers.ToString(this.entryPruningTailSize);
      s += ")";
      return s;
    }
    private static readonly CreateLocalCryptoMaterialsCacheInput theDefault = create(0, Wrappers_Compile.Option<int>.Default());
    public static CreateLocalCryptoMaterialsCacheInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<Dafny.Aws.Crypto.CreateLocalCryptoMaterialsCacheInput> _TYPE = new Dafny.TypeDescriptor<Dafny.Aws.Crypto.CreateLocalCryptoMaterialsCacheInput>(Dafny.Aws.Crypto.CreateLocalCryptoMaterialsCacheInput.Default());
    public static Dafny.TypeDescriptor<Dafny.Aws.Crypto.CreateLocalCryptoMaterialsCacheInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static CreateLocalCryptoMaterialsCacheInput create(int entryCapacity, Wrappers_Compile.Option<int> entryPruningTailSize) {
      return new CreateLocalCryptoMaterialsCacheInput(entryCapacity, entryPruningTailSize);
    }
    public bool is_CreateLocalCryptoMaterialsCacheInput { get { return true; } }
    public int dtor_entryCapacity {
      get {
        return this.entryCapacity;
      }
    }
    public Wrappers_Compile.Option<int> dtor_entryPruningTailSize {
      get {
        return this.entryPruningTailSize;
      }
    }
  }

  public interface IAwsCryptographicMaterialsProviderClient {
    Dafny.Aws.Crypto.IKeyring CreateRawAesKeyring(Dafny.Aws.Crypto.CreateRawAesKeyringInput input);
    Dafny.Aws.Crypto.ICryptographicMaterialsManager CreateDefaultCryptographicMaterialsManager(Dafny.Aws.Crypto.CreateDefaultCryptographicMaterialsManagerInput input);
  }
  public class _Companion_IAwsCryptographicMaterialsProviderClient {
  }

} // end of namespace Dafny.Aws.Crypto
namespace Dafny.Aws.Esdk {




  public class EncryptInput {
    public readonly Dafny.ISequence<byte> plaintext;
    public readonly Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext;
    public readonly Dafny.Aws.Crypto.ICryptographicMaterialsManager materialsManager;
    public readonly Wrappers_Compile.Option<Dafny.Aws.Crypto.AlgorithmSuiteId> algorithmSuiteId;
    public EncryptInput(Dafny.ISequence<byte> plaintext, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext, Dafny.Aws.Crypto.ICryptographicMaterialsManager materialsManager, Wrappers_Compile.Option<Dafny.Aws.Crypto.AlgorithmSuiteId> algorithmSuiteId) {
      this.plaintext = plaintext;
      this.encryptionContext = encryptionContext;
      this.materialsManager = materialsManager;
      this.algorithmSuiteId = algorithmSuiteId;
    }
    public override bool Equals(object other) {
      var oth = other as Dafny.Aws.Esdk.EncryptInput;
      return oth != null && object.Equals(this.plaintext, oth.plaintext) && object.Equals(this.encryptionContext, oth.encryptionContext) && this.materialsManager == oth.materialsManager && object.Equals(this.algorithmSuiteId, oth.algorithmSuiteId);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.plaintext));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.encryptionContext));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.materialsManager));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.algorithmSuiteId));
      return (int) hash;
    }
    public override string ToString() {
      string s = "Dafny.Aws.Esdk_Compile.EncryptInput.EncryptInput";
      s += "(";
      s += Dafny.Helpers.ToString(this.plaintext);
      s += ", ";
      s += Dafny.Helpers.ToString(this.encryptionContext);
      s += ", ";
      s += Dafny.Helpers.ToString(this.materialsManager);
      s += ", ";
      s += Dafny.Helpers.ToString(this.algorithmSuiteId);
      s += ")";
      return s;
    }
    private static readonly EncryptInput theDefault = create(Dafny.Sequence<byte>.Empty, Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Empty, default(Dafny.Aws.Crypto.ICryptographicMaterialsManager), Wrappers_Compile.Option<Dafny.Aws.Crypto.AlgorithmSuiteId>.Default());
    public static EncryptInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<Dafny.Aws.Esdk.EncryptInput> _TYPE = new Dafny.TypeDescriptor<Dafny.Aws.Esdk.EncryptInput>(Dafny.Aws.Esdk.EncryptInput.Default());
    public static Dafny.TypeDescriptor<Dafny.Aws.Esdk.EncryptInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static EncryptInput create(Dafny.ISequence<byte> plaintext, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext, Dafny.Aws.Crypto.ICryptographicMaterialsManager materialsManager, Wrappers_Compile.Option<Dafny.Aws.Crypto.AlgorithmSuiteId> algorithmSuiteId) {
      return new EncryptInput(plaintext, encryptionContext, materialsManager, algorithmSuiteId);
    }
    public bool is_EncryptInput { get { return true; } }
    public Dafny.ISequence<byte> dtor_plaintext {
      get {
        return this.plaintext;
      }
    }
    public Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> dtor_encryptionContext {
      get {
        return this.encryptionContext;
      }
    }
    public Dafny.Aws.Crypto.ICryptographicMaterialsManager dtor_materialsManager {
      get {
        return this.materialsManager;
      }
    }
    public Wrappers_Compile.Option<Dafny.Aws.Crypto.AlgorithmSuiteId> dtor_algorithmSuiteId {
      get {
        return this.algorithmSuiteId;
      }
    }
  }

  public class EncryptOutput {
    public readonly Dafny.ISequence<byte> ciphertext;
    public EncryptOutput(Dafny.ISequence<byte> ciphertext) {
      this.ciphertext = ciphertext;
    }
    public override bool Equals(object other) {
      var oth = other as Dafny.Aws.Esdk.EncryptOutput;
      return oth != null && object.Equals(this.ciphertext, oth.ciphertext);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.ciphertext));
      return (int) hash;
    }
    public override string ToString() {
      string s = "Dafny.Aws.Esdk_Compile.EncryptOutput.EncryptOutput";
      s += "(";
      s += Dafny.Helpers.ToString(this.ciphertext);
      s += ")";
      return s;
    }
    private static readonly EncryptOutput theDefault = create(Dafny.Sequence<byte>.Empty);
    public static EncryptOutput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<Dafny.Aws.Esdk.EncryptOutput> _TYPE = new Dafny.TypeDescriptor<Dafny.Aws.Esdk.EncryptOutput>(Dafny.Aws.Esdk.EncryptOutput.Default());
    public static Dafny.TypeDescriptor<Dafny.Aws.Esdk.EncryptOutput> _TypeDescriptor() {
      return _TYPE;
    }
    public static EncryptOutput create(Dafny.ISequence<byte> ciphertext) {
      return new EncryptOutput(ciphertext);
    }
    public bool is_EncryptOutput { get { return true; } }
    public Dafny.ISequence<byte> dtor_ciphertext {
      get {
        return this.ciphertext;
      }
    }
  }

  public class DecryptInput {
    public readonly Dafny.ISequence<byte> ciphertext;
    public readonly Dafny.Aws.Crypto.ICryptographicMaterialsManager materialsManager;
    public DecryptInput(Dafny.ISequence<byte> ciphertext, Dafny.Aws.Crypto.ICryptographicMaterialsManager materialsManager) {
      this.ciphertext = ciphertext;
      this.materialsManager = materialsManager;
    }
    public override bool Equals(object other) {
      var oth = other as Dafny.Aws.Esdk.DecryptInput;
      return oth != null && object.Equals(this.ciphertext, oth.ciphertext) && this.materialsManager == oth.materialsManager;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.ciphertext));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.materialsManager));
      return (int) hash;
    }
    public override string ToString() {
      string s = "Dafny.Aws.Esdk_Compile.DecryptInput.DecryptInput";
      s += "(";
      s += Dafny.Helpers.ToString(this.ciphertext);
      s += ", ";
      s += Dafny.Helpers.ToString(this.materialsManager);
      s += ")";
      return s;
    }
    private static readonly DecryptInput theDefault = create(Dafny.Sequence<byte>.Empty, default(Dafny.Aws.Crypto.ICryptographicMaterialsManager));
    public static DecryptInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<Dafny.Aws.Esdk.DecryptInput> _TYPE = new Dafny.TypeDescriptor<Dafny.Aws.Esdk.DecryptInput>(Dafny.Aws.Esdk.DecryptInput.Default());
    public static Dafny.TypeDescriptor<Dafny.Aws.Esdk.DecryptInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static DecryptInput create(Dafny.ISequence<byte> ciphertext, Dafny.Aws.Crypto.ICryptographicMaterialsManager materialsManager) {
      return new DecryptInput(ciphertext, materialsManager);
    }
    public bool is_DecryptInput { get { return true; } }
    public Dafny.ISequence<byte> dtor_ciphertext {
      get {
        return this.ciphertext;
      }
    }
    public Dafny.Aws.Crypto.ICryptographicMaterialsManager dtor_materialsManager {
      get {
        return this.materialsManager;
      }
    }
  }

  public class DecryptOutput {
    public readonly Dafny.ISequence<byte> plaintext;
    public DecryptOutput(Dafny.ISequence<byte> plaintext) {
      this.plaintext = plaintext;
    }
    public override bool Equals(object other) {
      var oth = other as Dafny.Aws.Esdk.DecryptOutput;
      return oth != null && object.Equals(this.plaintext, oth.plaintext);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.plaintext));
      return (int) hash;
    }
    public override string ToString() {
      string s = "Dafny.Aws.Esdk_Compile.DecryptOutput.DecryptOutput";
      s += "(";
      s += Dafny.Helpers.ToString(this.plaintext);
      s += ")";
      return s;
    }
    private static readonly DecryptOutput theDefault = create(Dafny.Sequence<byte>.Empty);
    public static DecryptOutput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<Dafny.Aws.Esdk.DecryptOutput> _TYPE = new Dafny.TypeDescriptor<Dafny.Aws.Esdk.DecryptOutput>(Dafny.Aws.Esdk.DecryptOutput.Default());
    public static Dafny.TypeDescriptor<Dafny.Aws.Esdk.DecryptOutput> _TypeDescriptor() {
      return _TYPE;
    }
    public static DecryptOutput create(Dafny.ISequence<byte> plaintext) {
      return new DecryptOutput(plaintext);
    }
    public bool is_DecryptOutput { get { return true; } }
    public Dafny.ISequence<byte> dtor_plaintext {
      get {
        return this.plaintext;
      }
    }
  }

  public interface IAwsEncryptionSdkClient {
    Wrappers_Compile.Result<Dafny.Aws.Esdk.EncryptOutput, Dafny.ISequence<char>> Encrypt(Dafny.Aws.Esdk.EncryptInput input);
    Wrappers_Compile.Result<Dafny.Aws.Esdk.DecryptOutput, Dafny.ISequence<char>> Decrypt(Dafny.Aws.Esdk.DecryptInput input);
  }
  public class _Companion_IAwsEncryptionSdkClient {
  }

} // end of namespace Dafny.Aws.Esdk
namespace Dafny.Aws {



} // end of namespace Dafny.Aws
namespace Math_Compile {

  public partial class __default {
    public static BigInteger Min(BigInteger a, BigInteger b)
    {
      if ((a) < (b)) {
        return a;
      } else {
        return b;
      }
    }
    public static BigInteger Max(BigInteger a, BigInteger b)
    {
      if ((a) < (b)) {
        return b;
      } else {
        return a;
      }
    }
  }
} // end of namespace Math_Compile
namespace Seq_Compile {



  public partial class __default {
    public static __T First<__T>(Dafny.ISequence<__T> s) {
      return (s).Select(BigInteger.Zero);
    }
    public static Dafny.ISequence<__T> DropFirst<__T>(Dafny.ISequence<__T> s) {
      return (s).Drop(BigInteger.One);
    }
    public static __T Last<__T>(Dafny.ISequence<__T> s) {
      return (s).Select((new BigInteger((s).Count)) - (BigInteger.One));
    }
    public static Dafny.ISequence<__T> DropLast<__T>(Dafny.ISequence<__T> s) {
      return (s).Take((new BigInteger((s).Count)) - (BigInteger.One));
    }
    public static __T[] ToArray<__T>(Dafny.ISequence<__T> s)
    {
      __T[] a = new __T[0];
      __T[] _nw4 = new __T[Dafny.Helpers.ToIntChecked(Dafny.Helpers.ToIntChecked(new BigInteger((s).Count), "C# arrays may not be larger than the max 32-bit integer"),"C# array size must not be larger than max 32-bit int")];
      Func<BigInteger, __T> _arrayinit1 = Dafny.Helpers.Id<Func<Dafny.ISequence<__T>, Func<BigInteger, __T>>>((_17948_s) => ((System.Func<BigInteger, __T>)((_17949_i) => {
        return (_17948_s).Select(_17949_i);
      })))(s);
      for (var _arrayinit_01 = 0; _arrayinit_01 < new BigInteger(_nw4.Length); _arrayinit_01++) {
        _nw4[(int)(_arrayinit_01)] = _arrayinit1(_arrayinit_01);
      }
      a = _nw4;
      return a;
    }
    public static Dafny.ISet<__T> ToSet<__T>(Dafny.ISequence<__T> s) {
      return Dafny.Helpers.Id<Func<Dafny.ISequence<__T>, Dafny.ISet<__T>>>((_17950_s) => ((System.Func<Dafny.ISet<__T>>)(() => {
        var _coll0 = new System.Collections.Generic.List<__T>();
        foreach (__T _compr_0 in (_17950_s).Elements) {
          __T _17951_x = (__T)_compr_0;
          if ((_17950_s).Contains((_17951_x))) {
            _coll0.Add(_17951_x);
          }
        }
        return Dafny.Set<__T>.FromCollection(_coll0);
      }))())(s);
    }
    public static BigInteger IndexOf<__T>(Dafny.ISequence<__T> s, __T v)
    {
      BigInteger _17952___accumulator = BigInteger.Zero;
    TAIL_CALL_START: ;
      if (object.Equals((s).Select(BigInteger.Zero), v)) {
        return (BigInteger.Zero) + (_17952___accumulator);
      } else {
        _17952___accumulator = (_17952___accumulator) + (BigInteger.One);
        Dafny.ISequence<__T> _in11 = (s).Drop(BigInteger.One);
        __T _in12 = v;
        s = _in11;
        v = _in12;
        goto TAIL_CALL_START;
      }
    }
    public static Wrappers_Compile.Option<BigInteger> IndexOfOption<__T>(Dafny.ISequence<__T> s, __T v)
    {
      if ((new BigInteger((s).Count)).Sign == 0) {
        return @Wrappers_Compile.Option<BigInteger>.create_None();
      } else if (object.Equals((s).Select(BigInteger.Zero), v)) {
        return @Wrappers_Compile.Option<BigInteger>.create_Some(BigInteger.Zero);
      } else {
        Wrappers_Compile.Option<BigInteger> _17953_o_k = Seq_Compile.__default.IndexOfOption<__T>((s).Drop(BigInteger.One), v);
        if ((_17953_o_k).is_Some) {
          return @Wrappers_Compile.Option<BigInteger>.create_Some(((_17953_o_k).dtor_value) + (BigInteger.One));
        } else {
          return @Wrappers_Compile.Option<BigInteger>.create_None();
        }
      }
    }
    public static BigInteger LastIndexOf<__T>(Dafny.ISequence<__T> s, __T v)
    {
    TAIL_CALL_START: ;
      if (object.Equals((s).Select((new BigInteger((s).Count)) - (BigInteger.One)), v)) {
        return (new BigInteger((s).Count)) - (BigInteger.One);
      } else {
        Dafny.ISequence<__T> _in13 = (s).Take((new BigInteger((s).Count)) - (BigInteger.One));
        __T _in14 = v;
        s = _in13;
        v = _in14;
        goto TAIL_CALL_START;
      }
    }
    public static Wrappers_Compile.Option<BigInteger> LastIndexOfOption<__T>(Dafny.ISequence<__T> s, __T v)
    {
    TAIL_CALL_START: ;
      if ((new BigInteger((s).Count)).Sign == 0) {
        return @Wrappers_Compile.Option<BigInteger>.create_None();
      } else if (object.Equals((s).Select((new BigInteger((s).Count)) - (BigInteger.One)), v)) {
        return @Wrappers_Compile.Option<BigInteger>.create_Some((new BigInteger((s).Count)) - (BigInteger.One));
      } else {
        Dafny.ISequence<__T> _in15 = (s).Take((new BigInteger((s).Count)) - (BigInteger.One));
        __T _in16 = v;
        s = _in15;
        v = _in16;
        goto TAIL_CALL_START;
      }
    }
    public static Dafny.ISequence<__T> Remove<__T>(Dafny.ISequence<__T> s, BigInteger pos)
    {
      return Dafny.Sequence<__T>.Concat((s).Take(pos), (s).Drop((pos) + (BigInteger.One)));
    }
    public static Dafny.ISequence<__T> RemoveValue<__T>(Dafny.ISequence<__T> s, __T v)
    {
      if (!(s).Contains((v))) {
        return s;
      } else {
        BigInteger _17954_i = Seq_Compile.__default.IndexOf<__T>(s, v);
        return Dafny.Sequence<__T>.Concat((s).Take(_17954_i), (s).Drop((_17954_i) + (BigInteger.One)));
      }
    }
    public static Dafny.ISequence<__T> Insert<__T>(Dafny.ISequence<__T> s, __T a, BigInteger pos)
    {
      return Dafny.Sequence<__T>.Concat(Dafny.Sequence<__T>.Concat((s).Take(pos), Dafny.Sequence<__T>.FromElements(a)), (s).Drop(pos));
    }
    public static Dafny.ISequence<__T> Reverse<__T>(Dafny.ISequence<__T> s) {
      Dafny.ISequence<__T> _17955___accumulator = Dafny.Sequence<__T>.FromElements();
    TAIL_CALL_START: ;
      if ((s).Equals((Dafny.Sequence<__T>.FromElements()))) {
        return Dafny.Sequence<__T>.Concat(_17955___accumulator, Dafny.Sequence<__T>.FromElements());
      } else {
        _17955___accumulator = Dafny.Sequence<__T>.Concat(_17955___accumulator, Dafny.Sequence<__T>.FromElements((s).Select((new BigInteger((s).Count)) - (BigInteger.One))));
        Dafny.ISequence<__T> _in17 = (s).Subsequence(BigInteger.Zero, (new BigInteger((s).Count)) - (BigInteger.One));
        s = _in17;
        goto TAIL_CALL_START;
      }
    }
    public static Dafny.ISequence<__T> Repeat<__T>(__T v, BigInteger length)
    {
      Dafny.ISequence<__T> _17956___accumulator = Dafny.Sequence<__T>.FromElements();
    TAIL_CALL_START: ;
      if ((length).Sign == 0) {
        return Dafny.Sequence<__T>.Concat(_17956___accumulator, Dafny.Sequence<__T>.FromElements());
      } else {
        _17956___accumulator = Dafny.Sequence<__T>.Concat(_17956___accumulator, Dafny.Sequence<__T>.FromElements(v));
        __T _in18 = v;
        BigInteger _in19 = (length) - (BigInteger.One);
        v = _in18;
        length = _in19;
        goto TAIL_CALL_START;
      }
    }
    public static _System.Tuple2<Dafny.ISequence<__A>, Dafny.ISequence<__B>> Unzip<__A, __B>(Dafny.ISequence<_System.Tuple2<__A, __B>> s) {
      if ((new BigInteger((s).Count)).Sign == 0) {
        return @_System.Tuple2<Dafny.ISequence<__A>, Dafny.ISequence<__B>>.create(Dafny.Sequence<__A>.FromElements(), Dafny.Sequence<__B>.FromElements());
      } else {
        _System.Tuple2<Dafny.ISequence<__A>, Dafny.ISequence<__B>> _let_tmp_rhs0 = Seq_Compile.__default.Unzip<__A, __B>(Seq_Compile.__default.DropLast<_System.Tuple2<__A, __B>>(s));
        Dafny.ISequence<__A> _17957_a = ((_System.Tuple2<Dafny.ISequence<__A>, Dafny.ISequence<__B>>)_let_tmp_rhs0)._0;
        Dafny.ISequence<__B> _17958_b = ((_System.Tuple2<Dafny.ISequence<__A>, Dafny.ISequence<__B>>)_let_tmp_rhs0)._1;
        return @_System.Tuple2<Dafny.ISequence<__A>, Dafny.ISequence<__B>>.create(Dafny.Sequence<__A>.Concat(_17957_a, Dafny.Sequence<__A>.FromElements((Seq_Compile.__default.Last<_System.Tuple2<__A, __B>>(s)).dtor__0)), Dafny.Sequence<__B>.Concat(_17958_b, Dafny.Sequence<__B>.FromElements((Seq_Compile.__default.Last<_System.Tuple2<__A, __B>>(s)).dtor__1)));
      }
    }
    public static Dafny.ISequence<_System.Tuple2<__A, __B>> Zip<__A, __B>(Dafny.ISequence<__A> a, Dafny.ISequence<__B> b)
    {
      Dafny.ISequence<_System.Tuple2<__A, __B>> _17959___accumulator = Dafny.Sequence<_System.Tuple2<__A, __B>>.FromElements();
    TAIL_CALL_START: ;
      if ((new BigInteger((a).Count)).Sign == 0) {
        return Dafny.Sequence<_System.Tuple2<__A, __B>>.Concat(Dafny.Sequence<_System.Tuple2<__A, __B>>.FromElements(), _17959___accumulator);
      } else {
        _17959___accumulator = Dafny.Sequence<_System.Tuple2<__A, __B>>.Concat(Dafny.Sequence<_System.Tuple2<__A, __B>>.FromElements(@_System.Tuple2<__A, __B>.create(Seq_Compile.__default.Last<__A>(a), Seq_Compile.__default.Last<__B>(b))), _17959___accumulator);
        Dafny.ISequence<__A> _in20 = Seq_Compile.__default.DropLast<__A>(a);
        Dafny.ISequence<__B> _in21 = Seq_Compile.__default.DropLast<__B>(b);
        a = _in20;
        b = _in21;
        goto TAIL_CALL_START;
      }
    }
    public static BigInteger Max(Dafny.ISequence<BigInteger> s) {
      if ((new BigInteger((s).Count)) == (BigInteger.One)) {
        return (s).Select(BigInteger.Zero);
      } else {
        return Math_Compile.__default.Max((s).Select(BigInteger.Zero), Seq_Compile.__default.Max((s).Drop(BigInteger.One)));
      }
    }
    public static BigInteger Min(Dafny.ISequence<BigInteger> s) {
      if ((new BigInteger((s).Count)) == (BigInteger.One)) {
        return (s).Select(BigInteger.Zero);
      } else {
        return Math_Compile.__default.Min((s).Select(BigInteger.Zero), Seq_Compile.__default.Min((s).Drop(BigInteger.One)));
      }
    }
    public static Dafny.ISequence<__T> Flatten<__T>(Dafny.ISequence<Dafny.ISequence<__T>> s) {
      Dafny.ISequence<__T> _17960___accumulator = Dafny.Sequence<__T>.FromElements();
    TAIL_CALL_START: ;
      if ((new BigInteger((s).Count)).Sign == 0) {
        return Dafny.Sequence<__T>.Concat(_17960___accumulator, Dafny.Sequence<__T>.FromElements());
      } else {
        _17960___accumulator = Dafny.Sequence<__T>.Concat(_17960___accumulator, (s).Select(BigInteger.Zero));
        Dafny.ISequence<Dafny.ISequence<__T>> _in22 = (s).Drop(BigInteger.One);
        s = _in22;
        goto TAIL_CALL_START;
      }
    }
    public static Dafny.ISequence<__T> FlattenReverse<__T>(Dafny.ISequence<Dafny.ISequence<__T>> s) {
      Dafny.ISequence<__T> _17961___accumulator = Dafny.Sequence<__T>.FromElements();
    TAIL_CALL_START: ;
      if ((new BigInteger((s).Count)).Sign == 0) {
        return Dafny.Sequence<__T>.Concat(Dafny.Sequence<__T>.FromElements(), _17961___accumulator);
      } else {
        _17961___accumulator = Dafny.Sequence<__T>.Concat(Seq_Compile.__default.Last<Dafny.ISequence<__T>>(s), _17961___accumulator);
        Dafny.ISequence<Dafny.ISequence<__T>> _in23 = Seq_Compile.__default.DropLast<Dafny.ISequence<__T>>(s);
        s = _in23;
        goto TAIL_CALL_START;
      }
    }
    public static Dafny.ISequence<__R> Map<__T, __R>(Func<__T, __R> f, Dafny.ISequence<__T> s)
    {
      Dafny.ISequence<__R> _17962___accumulator = Dafny.Sequence<__R>.FromElements();
    TAIL_CALL_START: ;
      if ((new BigInteger((s).Count)).Sign == 0) {
        return Dafny.Sequence<__R>.Concat(_17962___accumulator, Dafny.Sequence<__R>.FromElements());
      } else {
        _17962___accumulator = Dafny.Sequence<__R>.Concat(_17962___accumulator, Dafny.Sequence<__R>.FromElements(Dafny.Helpers.Id<Func<__T, __R>>(f)((s).Select(BigInteger.Zero))));
        Func<__T, __R> _in24 = f;
        Dafny.ISequence<__T> _in25 = (s).Drop(BigInteger.One);
        f = _in24;
        s = _in25;
        goto TAIL_CALL_START;
      }
    }
    public static Wrappers_Compile.Result<Dafny.ISequence<__R>, __E> MapWithResult<__T, __R, __E>(Func<__T, Wrappers_Compile.Result<__R, __E>> f, Dafny.ISequence<__T> s)
    {
      if ((new BigInteger((s).Count)).Sign == 0) {
        return @Wrappers_Compile.Result<Dafny.ISequence<__R>, __E>.create_Success(Dafny.Sequence<__R>.FromElements());
      } else {
        Wrappers_Compile.Result<__R, __E> _17963_valueOrError0 = Dafny.Helpers.Id<Func<__T, Wrappers_Compile.Result<__R, __E>>>(f)((s).Select(BigInteger.Zero));
        if ((_17963_valueOrError0).IsFailure()) {
          return (_17963_valueOrError0).PropagateFailure<Dafny.ISequence<__R>>();
        } else {
          __R _17964_head = (_17963_valueOrError0).Extract();
          Wrappers_Compile.Result<Dafny.ISequence<__R>, __E> _17965_valueOrError1 = Seq_Compile.__default.MapWithResult<__T, __R, __E>(f, (s).Drop(BigInteger.One));
          if ((_17965_valueOrError1).IsFailure()) {
            return (_17965_valueOrError1).PropagateFailure<Dafny.ISequence<__R>>();
          } else {
            Dafny.ISequence<__R> _17966_tail = (_17965_valueOrError1).Extract();
            return @Wrappers_Compile.Result<Dafny.ISequence<__R>, __E>.create_Success(Dafny.Sequence<__R>.Concat(Dafny.Sequence<__R>.FromElements(_17964_head), _17966_tail));
          }
        }
      }
    }
    public static Dafny.ISequence<__T> Filter<__T>(Func<__T, bool> f, Dafny.ISequence<__T> s)
    {
      Dafny.ISequence<__T> _17967___accumulator = Dafny.Sequence<__T>.FromElements();
    TAIL_CALL_START: ;
      if ((new BigInteger((s).Count)).Sign == 0) {
        return Dafny.Sequence<__T>.Concat(_17967___accumulator, Dafny.Sequence<__T>.FromElements());
      } else {
        _17967___accumulator = Dafny.Sequence<__T>.Concat(_17967___accumulator, ((Dafny.Helpers.Id<Func<__T, bool>>(f)((s).Select(BigInteger.Zero))) ? (Dafny.Sequence<__T>.FromElements((s).Select(BigInteger.Zero))) : (Dafny.Sequence<__T>.FromElements())));
        Func<__T, bool> _in26 = f;
        Dafny.ISequence<__T> _in27 = (s).Drop(BigInteger.One);
        f = _in26;
        s = _in27;
        goto TAIL_CALL_START;
      }
    }
    public static __A FoldLeft<__A, __T>(Func<__A, __T, __A> f, __A init, Dafny.ISequence<__T> s)
    {
    TAIL_CALL_START: ;
      if ((new BigInteger((s).Count)).Sign == 0) {
        return init;
      } else {
        Func<__A, __T, __A> _in28 = f;
        __A _in29 = Dafny.Helpers.Id<Func<__A, __T, __A>>(f)(init, (s).Select(BigInteger.Zero));
        Dafny.ISequence<__T> _in30 = (s).Drop(BigInteger.One);
        f = _in28;
        init = _in29;
        s = _in30;
        goto TAIL_CALL_START;
      }
    }
    public static __A FoldRight<__A, __T>(Func<__T, __A, __A> f, Dafny.ISequence<__T> s, __A init)
    {
      if ((new BigInteger((s).Count)).Sign == 0) {
        return init;
      } else {
        return Dafny.Helpers.Id<Func<__T, __A, __A>>(f)((s).Select(BigInteger.Zero), Seq_Compile.__default.FoldRight<__A, __T>(f, (s).Drop(BigInteger.One), init));
      }
    }
  }
} // end of namespace Seq_Compile
namespace AwsKmsArnParsing_Compile {





  public class AwsResource {
    public readonly Dafny.ISequence<char> resourceType;
    public readonly Dafny.ISequence<char> @value;
    public AwsResource(Dafny.ISequence<char> resourceType, Dafny.ISequence<char> @value) {
      this.resourceType = resourceType;
      this.@value = @value;
    }
    public override bool Equals(object other) {
      var oth = other as AwsKmsArnParsing_Compile.AwsResource;
      return oth != null && object.Equals(this.resourceType, oth.resourceType) && object.Equals(this.@value, oth.@value);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.resourceType));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.@value));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsKmsArnParsing_Compile.AwsResource.AwsResource";
      s += "(";
      s += Dafny.Helpers.ToString(this.resourceType);
      s += ", ";
      s += Dafny.Helpers.ToString(this.@value);
      s += ")";
      return s;
    }
    private static readonly AwsResource theDefault = create(Dafny.Sequence<char>.Empty, Dafny.Sequence<char>.Empty);
    public static AwsResource Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<AwsKmsArnParsing_Compile.AwsResource> _TYPE = new Dafny.TypeDescriptor<AwsKmsArnParsing_Compile.AwsResource>(AwsKmsArnParsing_Compile.AwsResource.Default());
    public static Dafny.TypeDescriptor<AwsKmsArnParsing_Compile.AwsResource> _TypeDescriptor() {
      return _TYPE;
    }
    public static AwsResource create(Dafny.ISequence<char> resourceType, Dafny.ISequence<char> @value) {
      return new AwsResource(resourceType, @value);
    }
    public bool is_AwsResource { get { return true; } }
    public Dafny.ISequence<char> dtor_resourceType {
      get {
        return this.resourceType;
      }
    }
    public Dafny.ISequence<char> dtor_value {
      get {
        return this.@value;
      }
    }
    public bool Valid() {
      return (true) && ((new BigInteger(((this).dtor_value).Count)).Sign == 1);
    }
    public Dafny.ISequence<char> _ToString() {
      return Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat((this).dtor_resourceType, Dafny.Sequence<char>.FromString("/")), (this).dtor_value);
    }
  }

  public class AwsArn {
    public readonly Dafny.ISequence<char> arnLiteral;
    public readonly Dafny.ISequence<char> partition;
    public readonly Dafny.ISequence<char> service;
    public readonly Dafny.ISequence<char> region;
    public readonly Dafny.ISequence<char> account;
    public readonly AwsKmsArnParsing_Compile.AwsResource resource;
    public AwsArn(Dafny.ISequence<char> arnLiteral, Dafny.ISequence<char> partition, Dafny.ISequence<char> service, Dafny.ISequence<char> region, Dafny.ISequence<char> account, AwsKmsArnParsing_Compile.AwsResource resource) {
      this.arnLiteral = arnLiteral;
      this.partition = partition;
      this.service = service;
      this.region = region;
      this.account = account;
      this.resource = resource;
    }
    public override bool Equals(object other) {
      var oth = other as AwsKmsArnParsing_Compile.AwsArn;
      return oth != null && object.Equals(this.arnLiteral, oth.arnLiteral) && object.Equals(this.partition, oth.partition) && object.Equals(this.service, oth.service) && object.Equals(this.region, oth.region) && object.Equals(this.account, oth.account) && object.Equals(this.resource, oth.resource);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.arnLiteral));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.partition));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.service));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.region));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.account));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.resource));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsKmsArnParsing_Compile.AwsArn.AwsArn";
      s += "(";
      s += Dafny.Helpers.ToString(this.arnLiteral);
      s += ", ";
      s += Dafny.Helpers.ToString(this.partition);
      s += ", ";
      s += Dafny.Helpers.ToString(this.service);
      s += ", ";
      s += Dafny.Helpers.ToString(this.region);
      s += ", ";
      s += Dafny.Helpers.ToString(this.account);
      s += ", ";
      s += Dafny.Helpers.ToString(this.resource);
      s += ")";
      return s;
    }
    private static readonly AwsArn theDefault = create(Dafny.Sequence<char>.Empty, Dafny.Sequence<char>.Empty, Dafny.Sequence<char>.Empty, Dafny.Sequence<char>.Empty, Dafny.Sequence<char>.Empty, AwsKmsArnParsing_Compile.AwsResource.Default());
    public static AwsArn Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<AwsKmsArnParsing_Compile.AwsArn> _TYPE = new Dafny.TypeDescriptor<AwsKmsArnParsing_Compile.AwsArn>(AwsKmsArnParsing_Compile.AwsArn.Default());
    public static Dafny.TypeDescriptor<AwsKmsArnParsing_Compile.AwsArn> _TypeDescriptor() {
      return _TYPE;
    }
    public static AwsArn create(Dafny.ISequence<char> arnLiteral, Dafny.ISequence<char> partition, Dafny.ISequence<char> service, Dafny.ISequence<char> region, Dafny.ISequence<char> account, AwsKmsArnParsing_Compile.AwsResource resource) {
      return new AwsArn(arnLiteral, partition, service, region, account, resource);
    }
    public bool is_AwsArn { get { return true; } }
    public Dafny.ISequence<char> dtor_arnLiteral {
      get {
        return this.arnLiteral;
      }
    }
    public Dafny.ISequence<char> dtor_partition {
      get {
        return this.partition;
      }
    }
    public Dafny.ISequence<char> dtor_service {
      get {
        return this.service;
      }
    }
    public Dafny.ISequence<char> dtor_region {
      get {
        return this.region;
      }
    }
    public Dafny.ISequence<char> dtor_account {
      get {
        return this.account;
      }
    }
    public AwsKmsArnParsing_Compile.AwsResource dtor_resource {
      get {
        return this.resource;
      }
    }
    public bool Valid() {
      return (((((((this).dtor_arnLiteral).Equals((Dafny.Sequence<char>.FromString("arn")))) && ((new BigInteger(((this).dtor_partition).Count)).Sign == 1)) && ((new BigInteger(((this).dtor_service).Count)).Sign == 1)) && ((new BigInteger(((this).dtor_region).Count)).Sign == 1)) && ((new BigInteger(((this).dtor_account).Count)).Sign == 1)) && (((this).dtor_resource).Valid());
    }
    public Dafny.ISequence<char> _ToString() {
      return (this).ToArnString(@Wrappers_Compile.Option<Dafny.ISequence<char>>.create_None());
    }
    public Dafny.ISequence<char> ToArnString(Wrappers_Compile.Option<Dafny.ISequence<char>> customRegion) {
      var _this = this;
    TAIL_CALL_START: ;
      Wrappers_Compile.Option<Dafny.ISequence<char>> _source11 = customRegion;
      if (_source11.is_None) {
        var _in31 = _this;
        Wrappers_Compile.Option<Dafny.ISequence<char>> _in32 = @Wrappers_Compile.Option<Dafny.ISequence<char>>.create_Some((_this).dtor_region);
        _this = _in31;
        customRegion = _in32;
        goto TAIL_CALL_START;
      } else {
        Dafny.ISequence<char> _17968___mcc_h0 = ((Wrappers_Compile.Option_Some<Dafny.ISequence<char>>)_source11).@value;
        Dafny.ISequence<char> _17969_customRegion = _17968___mcc_h0;
        return StandardLibrary_Compile.__default.Join<char>(Dafny.Sequence<Dafny.ISequence<char>>.FromElements((_this).dtor_arnLiteral, (_this).dtor_partition, (_this).dtor_service, _17969_customRegion, (_this).dtor_account, ((_this).dtor_resource)._ToString()), Dafny.Sequence<char>.FromString(":"));
      }
    }
  }

  public partial class AwsKmsArn {
    private static readonly Dafny.TypeDescriptor<AwsKmsArnParsing_Compile.AwsArn> _TYPE = new Dafny.TypeDescriptor<AwsKmsArnParsing_Compile.AwsArn>(AwsKmsArnParsing_Compile.AwsArn.Default());
    public static Dafny.TypeDescriptor<AwsKmsArnParsing_Compile.AwsArn> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public partial class AwsKmsResource {
    private static readonly Dafny.TypeDescriptor<AwsKmsArnParsing_Compile.AwsResource> _TYPE = new Dafny.TypeDescriptor<AwsKmsArnParsing_Compile.AwsResource>(AwsKmsArnParsing_Compile.AwsResource.Default());
    public static Dafny.TypeDescriptor<AwsKmsArnParsing_Compile.AwsResource> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public abstract class AwsKmsIdentifier {
    public AwsKmsIdentifier() { }
    private static readonly AwsKmsIdentifier theDefault = create_AwsKmsArnIdentifier(AwsKmsArnParsing_Compile.AwsArn.Default());
    public static AwsKmsIdentifier Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<AwsKmsArnParsing_Compile.AwsKmsIdentifier> _TYPE = new Dafny.TypeDescriptor<AwsKmsArnParsing_Compile.AwsKmsIdentifier>(AwsKmsArnParsing_Compile.AwsKmsIdentifier.Default());
    public static Dafny.TypeDescriptor<AwsKmsArnParsing_Compile.AwsKmsIdentifier> _TypeDescriptor() {
      return _TYPE;
    }
    public static AwsKmsIdentifier create_AwsKmsArnIdentifier(AwsKmsArnParsing_Compile.AwsArn a) {
      return new AwsKmsIdentifier_AwsKmsArnIdentifier(a);
    }
    public static AwsKmsIdentifier create_AwsKmsRawResourceIdentifier(AwsKmsArnParsing_Compile.AwsResource r) {
      return new AwsKmsIdentifier_AwsKmsRawResourceIdentifier(r);
    }
    public bool is_AwsKmsArnIdentifier { get { return this is AwsKmsIdentifier_AwsKmsArnIdentifier; } }
    public bool is_AwsKmsRawResourceIdentifier { get { return this is AwsKmsIdentifier_AwsKmsRawResourceIdentifier; } }
    public AwsKmsArnParsing_Compile.AwsArn dtor_a {
      get {
        var d = this;
        return ((AwsKmsIdentifier_AwsKmsArnIdentifier)d).a; 
      }
    }
    public AwsKmsArnParsing_Compile.AwsResource dtor_r {
      get {
        var d = this;
        return ((AwsKmsIdentifier_AwsKmsRawResourceIdentifier)d).r; 
      }
    }
    public Dafny.ISequence<char> _ToString() {
      AwsKmsArnParsing_Compile.AwsKmsIdentifier _source12 = this;
      if (_source12.is_AwsKmsArnIdentifier) {
        AwsKmsArnParsing_Compile.AwsArn _17970___mcc_h0 = ((AwsKmsArnParsing_Compile.AwsKmsIdentifier_AwsKmsArnIdentifier)_source12).a;
        AwsKmsArnParsing_Compile.AwsArn _17971_a = _17970___mcc_h0;
        return (_17971_a)._ToString();
      } else {
        AwsKmsArnParsing_Compile.AwsResource _17972___mcc_h1 = ((AwsKmsArnParsing_Compile.AwsKmsIdentifier_AwsKmsRawResourceIdentifier)_source12).r;
        AwsKmsArnParsing_Compile.AwsResource _17973_r = _17972___mcc_h1;
        return (_17973_r)._ToString();
      }
    }
  }
  public class AwsKmsIdentifier_AwsKmsArnIdentifier : AwsKmsIdentifier {
    public readonly AwsKmsArnParsing_Compile.AwsArn a;
    public AwsKmsIdentifier_AwsKmsArnIdentifier(AwsKmsArnParsing_Compile.AwsArn a) {
      this.a = a;
    }
    public override bool Equals(object other) {
      var oth = other as AwsKmsArnParsing_Compile.AwsKmsIdentifier_AwsKmsArnIdentifier;
      return oth != null && object.Equals(this.a, oth.a);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.a));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsKmsArnParsing_Compile.AwsKmsIdentifier.AwsKmsArnIdentifier";
      s += "(";
      s += Dafny.Helpers.ToString(this.a);
      s += ")";
      return s;
    }
  }
  public class AwsKmsIdentifier_AwsKmsRawResourceIdentifier : AwsKmsIdentifier {
    public readonly AwsKmsArnParsing_Compile.AwsResource r;
    public AwsKmsIdentifier_AwsKmsRawResourceIdentifier(AwsKmsArnParsing_Compile.AwsResource r) {
      this.r = r;
    }
    public override bool Equals(object other) {
      var oth = other as AwsKmsArnParsing_Compile.AwsKmsIdentifier_AwsKmsRawResourceIdentifier;
      return oth != null && object.Equals(this.r, oth.r);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.r));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsKmsArnParsing_Compile.AwsKmsIdentifier.AwsKmsRawResourceIdentifier";
      s += "(";
      s += Dafny.Helpers.ToString(this.r);
      s += ")";
      return s;
    }
  }

  public partial class AwsKmsIdentifierString {
    private static readonly Dafny.TypeDescriptor<Dafny.ISequence<char>> _TYPE = new Dafny.TypeDescriptor<Dafny.ISequence<char>>(Dafny.Sequence<char>.Empty);
    public static Dafny.TypeDescriptor<Dafny.ISequence<char>> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public partial class __default {
    public static bool ValidAwsKmsResource(AwsKmsArnParsing_Compile.AwsResource resource) {
      return ((resource).Valid()) && ((((resource).dtor_resourceType).Equals((Dafny.Sequence<char>.FromString("key")))) || (((resource).dtor_resourceType).Equals((Dafny.Sequence<char>.FromString("alias")))));
    }
    public static bool ValidAwsKmsArn(AwsKmsArnParsing_Compile.AwsArn arn) {
      return (((arn).Valid()) && (((arn).dtor_service).Equals((Dafny.Sequence<char>.FromString("kms"))))) && (AwsKmsArnParsing_Compile.__default.ValidAwsKmsResource((arn).dtor_resource));
    }
    public static Wrappers_Compile.Result<AwsKmsArnParsing_Compile.AwsResource, Dafny.ISequence<char>> ParseAwsKmsRawResources(Dafny.ISequence<char> identifier) {
      Dafny.ISequence<Dafny.ISequence<char>> _17974_info = StandardLibrary_Compile.__default.Split<char>(identifier, '/');
      Wrappers_Compile.Outcome<Dafny.ISequence<char>> _17975_valueOrError0 = Wrappers_Compile.__default.Need<Dafny.ISequence<char>>(!((_17974_info).Select(BigInteger.Zero)).Equals((Dafny.Sequence<char>.FromString("key"))), Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Malformed raw key id: "), identifier));
      if ((_17975_valueOrError0).IsFailure()) {
        return (_17975_valueOrError0).PropagateFailure<AwsKmsArnParsing_Compile.AwsResource>();
      } else if ((new BigInteger((_17974_info).Count)) == (BigInteger.One)) {
        return AwsKmsArnParsing_Compile.__default.ParseAwsKmsResources(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("key/"), identifier));
      } else {
        return AwsKmsArnParsing_Compile.__default.ParseAwsKmsResources(identifier);
      }
    }
    public static Wrappers_Compile.Result<AwsKmsArnParsing_Compile.AwsResource, Dafny.ISequence<char>> ParseAwsKmsResources(Dafny.ISequence<char> identifier) {
      Dafny.ISequence<Dafny.ISequence<char>> _17976_info = StandardLibrary_Compile.__default.Split<char>(identifier, '/');
      Wrappers_Compile.Outcome<Dafny.ISequence<char>> _17977_valueOrError0 = Wrappers_Compile.__default.Need<Dafny.ISequence<char>>((new BigInteger((_17976_info).Count)) > (BigInteger.One), Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Malformed resource: "), identifier));
      if ((_17977_valueOrError0).IsFailure()) {
        return (_17977_valueOrError0).PropagateFailure<AwsKmsArnParsing_Compile.AwsResource>();
      } else {
        Dafny.ISequence<char> _17978_resourceType = (_17976_info).Select(BigInteger.Zero);
        Dafny.ISequence<char> _17979_value = StandardLibrary_Compile.__default.Join<char>((_17976_info).Drop(BigInteger.One), Dafny.Sequence<char>.FromString("/"));
        AwsKmsArnParsing_Compile.AwsResource _17980_resource = @AwsKmsArnParsing_Compile.AwsResource.create(_17978_resourceType, _17979_value);
        Wrappers_Compile.Outcome<Dafny.ISequence<char>> _17981_valueOrError1 = Wrappers_Compile.__default.Need<Dafny.ISequence<char>>(AwsKmsArnParsing_Compile.__default.ValidAwsKmsResource(_17980_resource), Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Malformed resource: "), identifier));
        if ((_17981_valueOrError1).IsFailure()) {
          return (_17981_valueOrError1).PropagateFailure<AwsKmsArnParsing_Compile.AwsResource>();
        } else {
          return @Wrappers_Compile.Result<AwsKmsArnParsing_Compile.AwsResource, Dafny.ISequence<char>>.create_Success(_17980_resource);
        }
      }
    }
    public static Wrappers_Compile.Result<AwsKmsArnParsing_Compile.AwsArn, Dafny.ISequence<char>> ParseAwsKmsArn(Dafny.ISequence<char> identifier) {
      Dafny.ISequence<Dafny.ISequence<char>> _17982_components = StandardLibrary_Compile.__default.Split<char>(identifier, ':');
      Wrappers_Compile.Outcome<Dafny.ISequence<char>> _17983_valueOrError0 = Wrappers_Compile.__default.Need<Dafny.ISequence<char>>((new BigInteger(6)) == (new BigInteger((_17982_components).Count)), Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Malformed arn: "), identifier));
      if ((_17983_valueOrError0).IsFailure()) {
        return (_17983_valueOrError0).PropagateFailure<AwsKmsArnParsing_Compile.AwsArn>();
      } else {
        Wrappers_Compile.Result<AwsKmsArnParsing_Compile.AwsResource, Dafny.ISequence<char>> _17984_valueOrError1 = AwsKmsArnParsing_Compile.__default.ParseAwsKmsResources((_17982_components).Select(new BigInteger(5)));
        if ((_17984_valueOrError1).IsFailure()) {
          return (_17984_valueOrError1).PropagateFailure<AwsKmsArnParsing_Compile.AwsArn>();
        } else {
          AwsKmsArnParsing_Compile.AwsResource _17985_resource = (_17984_valueOrError1).Extract();
          AwsKmsArnParsing_Compile.AwsArn _17986_arn = @AwsKmsArnParsing_Compile.AwsArn.create((_17982_components).Select(BigInteger.Zero), (_17982_components).Select(BigInteger.One), (_17982_components).Select(new BigInteger(2)), (_17982_components).Select(new BigInteger(3)), (_17982_components).Select(new BigInteger(4)), _17985_resource);
          Wrappers_Compile.Outcome<Dafny.ISequence<char>> _17987_valueOrError2 = Wrappers_Compile.__default.Need<Dafny.ISequence<char>>(AwsKmsArnParsing_Compile.__default.ValidAwsKmsArn(_17986_arn), Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Malformed Arn:"), identifier));
          if ((_17987_valueOrError2).IsFailure()) {
            return (_17987_valueOrError2).PropagateFailure<AwsKmsArnParsing_Compile.AwsArn>();
          } else {
            return @Wrappers_Compile.Result<AwsKmsArnParsing_Compile.AwsArn, Dafny.ISequence<char>>.create_Success(_17986_arn);
          }
        }
      }
    }
    public static Wrappers_Compile.Result<AwsKmsArnParsing_Compile.AwsKmsIdentifier, Dafny.ISequence<char>> ParseAwsKmsIdentifier(Dafny.ISequence<char> identifier) {
      if (Dafny.Sequence<char>.IsPrefixOf(Dafny.Sequence<char>.FromString("arn:"), identifier)) {
        Wrappers_Compile.Result<AwsKmsArnParsing_Compile.AwsArn, Dafny.ISequence<char>> _17988_valueOrError0 = AwsKmsArnParsing_Compile.__default.ParseAwsKmsArn(identifier);
        if ((_17988_valueOrError0).IsFailure()) {
          return (_17988_valueOrError0).PropagateFailure<AwsKmsArnParsing_Compile.AwsKmsIdentifier>();
        } else {
          AwsKmsArnParsing_Compile.AwsArn _17989_arn = (_17988_valueOrError0).Extract();
          return @Wrappers_Compile.Result<AwsKmsArnParsing_Compile.AwsKmsIdentifier, Dafny.ISequence<char>>.create_Success(@AwsKmsArnParsing_Compile.AwsKmsIdentifier.create_AwsKmsArnIdentifier(_17989_arn));
        }
      } else {
        Wrappers_Compile.Result<AwsKmsArnParsing_Compile.AwsResource, Dafny.ISequence<char>> _17990_valueOrError1 = AwsKmsArnParsing_Compile.__default.ParseAwsKmsRawResources(identifier);
        if ((_17990_valueOrError1).IsFailure()) {
          return (_17990_valueOrError1).PropagateFailure<AwsKmsArnParsing_Compile.AwsKmsIdentifier>();
        } else {
          AwsKmsArnParsing_Compile.AwsResource _17991_r = (_17990_valueOrError1).Extract();
          return @Wrappers_Compile.Result<AwsKmsArnParsing_Compile.AwsKmsIdentifier, Dafny.ISequence<char>>.create_Success(@AwsKmsArnParsing_Compile.AwsKmsIdentifier.create_AwsKmsRawResourceIdentifier(_17991_r));
        }
      }
    }
    public static bool IsMultiRegionAwsKmsArn(AwsKmsArnParsing_Compile.AwsArn arn) {
      return AwsKmsArnParsing_Compile.__default.IsMultiRegionAwsKmsResource((arn).dtor_resource);
    }
    public static bool IsMultiRegionAwsKmsIdentifier(AwsKmsArnParsing_Compile.AwsKmsIdentifier identifier) {
      AwsKmsArnParsing_Compile.AwsKmsIdentifier _source13 = identifier;
      if (_source13.is_AwsKmsArnIdentifier) {
        AwsKmsArnParsing_Compile.AwsArn _17992___mcc_h0 = ((AwsKmsArnParsing_Compile.AwsKmsIdentifier_AwsKmsArnIdentifier)_source13).a;
        AwsKmsArnParsing_Compile.AwsArn _17993_arn = _17992___mcc_h0;
        return AwsKmsArnParsing_Compile.__default.IsMultiRegionAwsKmsArn(_17993_arn);
      } else {
        AwsKmsArnParsing_Compile.AwsResource _17994___mcc_h1 = ((AwsKmsArnParsing_Compile.AwsKmsIdentifier_AwsKmsRawResourceIdentifier)_source13).r;
        AwsKmsArnParsing_Compile.AwsResource _17995_r = _17994___mcc_h1;
        return AwsKmsArnParsing_Compile.__default.IsMultiRegionAwsKmsResource(_17995_r);
      }
    }
    public static bool IsMultiRegionAwsKmsResource(AwsKmsArnParsing_Compile.AwsResource resource) {
      return (((resource).dtor_resourceType).Equals((Dafny.Sequence<char>.FromString("key")))) && (Dafny.Sequence<char>.IsPrefixOf(Dafny.Sequence<char>.FromString("mrk-"), (resource).dtor_value));
    }
    public static Wrappers_Compile.Option<Dafny.ISequence<char>> GetRegion(AwsKmsArnParsing_Compile.AwsKmsIdentifier identifier) {
      AwsKmsArnParsing_Compile.AwsKmsIdentifier _source14 = identifier;
      if (_source14.is_AwsKmsArnIdentifier) {
        AwsKmsArnParsing_Compile.AwsArn _17996___mcc_h0 = ((AwsKmsArnParsing_Compile.AwsKmsIdentifier_AwsKmsArnIdentifier)_source14).a;
        AwsKmsArnParsing_Compile.AwsArn _17997_a = _17996___mcc_h0;
        return @Wrappers_Compile.Option<Dafny.ISequence<char>>.create_Some((_17997_a).dtor_region);
      } else {
        AwsKmsArnParsing_Compile.AwsResource _17998___mcc_h1 = ((AwsKmsArnParsing_Compile.AwsKmsIdentifier_AwsKmsRawResourceIdentifier)_source14).r;
        return @Wrappers_Compile.Option<Dafny.ISequence<char>>.create_None();
      }
    }
    public static BigInteger MAX__AWS__KMS__IDENTIFIER__LENGTH { get {
      return new BigInteger(2048);
    } }
  }
} // end of namespace AwsKmsArnParsing_Compile
namespace Sets {


} // end of namespace Sets
namespace EncryptionContext {








  public partial class __default {
    public static bool Serializable(Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext) {
      return (EncryptionContext.__default.SerializableKVPairs(encryptionContext)) && ((EncryptionContext.__default.Length(encryptionContext)) < (StandardLibrary_mUInt_Compile.__default.UINT16__LIMIT));
    }
    public static bool SerializableKVPairs(Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext) {
      return ((new BigInteger((encryptionContext).Count)) < (StandardLibrary_mUInt_Compile.__default.UINT16__LIMIT)) && (Dafny.Helpers.Id<Func<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, bool>>((_17999_encryptionContext) => Dafny.Helpers.Quantifier<Dafny.ISequence<byte>>(((_17999_encryptionContext).Keys).Elements, true, (((_18000_key) => {
        return !(((_17999_encryptionContext).Keys).Contains((_18000_key))) || (EncryptionContext.__default.SerializableKVPair(@_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.create(_18000_key, Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Select(_17999_encryptionContext,_18000_key))));
      }))))(encryptionContext));
    }
    public static bool SerializableKVPair(_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>> kvPair) {
      return ((((new BigInteger(((kvPair).dtor__0).Count)) < (StandardLibrary_mUInt_Compile.__default.UINT16__LIMIT)) && ((new BigInteger(((kvPair).dtor__1).Count)) < (StandardLibrary_mUInt_Compile.__default.UINT16__LIMIT))) && (UTF8.__default.ValidUTF8Seq((kvPair).dtor__0))) && (UTF8.__default.ValidUTF8Seq((kvPair).dtor__1));
    }
    public static BigInteger Length(Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext) {
      if ((new BigInteger((encryptionContext).Count)).Sign == 0) {
        return BigInteger.Zero;
      } else {
        Dafny.ISequence<Dafny.ISequence<byte>> _18001_keys = StandardLibrary_Compile.__default.SetToOrderedSequence<byte>((encryptionContext).Keys, StandardLibrary_mUInt_Compile.__default.UInt8Less);
        Dafny.ISequence<_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>> _18002_kvPairs = ((System.Func<Dafny.ISequence<_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>>>) (() => {
          BigInteger dim1 = new BigInteger((_18001_keys).Count);
          var arr1 = new _System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>[Dafny.Helpers.ToIntChecked(dim1,"C# array size must not be larger than max 32-bit int")];
          for (int i1 = 0; i1 < dim1; i1++) {
            var _18003_i = (BigInteger) i1;
            arr1[(int)(_18003_i)] = @_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.create((_18001_keys).Select(_18003_i), Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Select(encryptionContext,(_18001_keys).Select(_18003_i)));
          }
          return Dafny.Sequence<_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>>.FromArray(arr1);
        }))();
        return (new BigInteger(2)) + (EncryptionContext.__default.LinearLength(_18002_kvPairs, BigInteger.Zero, new BigInteger((_18002_kvPairs).Count)));
      }
    }
    public static BigInteger LinearLength(Dafny.ISequence<_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>> kvPairs, BigInteger lo, BigInteger hi)
    {
      if ((lo) == (hi)) {
        return BigInteger.Zero;
      } else {
        return ((((EncryptionContext.__default.LinearLength(kvPairs, lo, (hi) - (BigInteger.One))) + (new BigInteger(2))) + (new BigInteger((((kvPairs).Select((hi) - (BigInteger.One))).dtor__0).Count))) + (new BigInteger(2))) + (new BigInteger((((kvPairs).Select((hi) - (BigInteger.One))).dtor__1).Count));
      }
    }
    public static BigInteger ComputeLength(Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext)
    {
      BigInteger res = BigInteger.Zero;
      if ((new BigInteger((encryptionContext).Count)).Sign == 0) {
        res = BigInteger.Zero;
        return res;
      }
      Dafny.ISequence<Dafny.ISequence<byte>> _18004_keys;
      Dafny.ISequence<Dafny.ISequence<byte>> _out13;
      _out13 = Sets.__default.SetToOrderedSequence<byte>((encryptionContext).Keys, StandardLibrary_mUInt_Compile.__default.UInt8Less);
      _18004_keys = _out13;
      Dafny.ISequence<_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>> _18005_kvPairs;
      _18005_kvPairs = ((System.Func<Dafny.ISequence<_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>>>) (() => {
        BigInteger dim2 = new BigInteger((_18004_keys).Count);
        var arr2 = new _System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>[Dafny.Helpers.ToIntChecked(dim2,"C# array size must not be larger than max 32-bit int")];
        for (int i2 = 0; i2 < dim2; i2++) {
          var _18006_i = (BigInteger) i2;
          arr2[(int)(_18006_i)] = @_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.create((_18004_keys).Select(_18006_i), Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Select(encryptionContext,(_18004_keys).Select(_18006_i)));
        }
        return Dafny.Sequence<_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>>.FromArray(arr2);
      }))();
      BigInteger _18007_len;
      _18007_len = new BigInteger(2);
      BigInteger _18008_i;
      _18008_i = BigInteger.Zero;
      while ((_18008_i) < (new BigInteger((_18005_kvPairs).Count))) {
        _System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>> _18009_kvPair;
        _18009_kvPair = (_18005_kvPairs).Select(_18008_i);
        _18007_len = (((_18007_len) + (new BigInteger(4))) + (new BigInteger(((_18009_kvPair).dtor__0).Count))) + (new BigInteger(((_18009_kvPair).dtor__1).Count));
        _18008_i = (_18008_i) + (BigInteger.One);
      }
      res = _18007_len;
      return res;
      return res;
    }
    public static bool CheckSerializable(Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext)
    {
      bool res = false;
      if ((new BigInteger((encryptionContext).Count)).Sign == 0) {
        res = true;
        return res;
      } else if ((new BigInteger((encryptionContext).Count)) >= (StandardLibrary_mUInt_Compile.__default.UINT16__LIMIT)) {
        res = false;
        return res;
      }
      Dafny.ISequence<Dafny.ISequence<byte>> _18010_keys;
      Dafny.ISequence<Dafny.ISequence<byte>> _out14;
      _out14 = Sets.__default.SetToOrderedSequence<byte>((encryptionContext).Keys, StandardLibrary_mUInt_Compile.__default.UInt8Less);
      _18010_keys = _out14;
      Dafny.ISequence<_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>> _18011_kvPairs;
      _18011_kvPairs = ((System.Func<Dafny.ISequence<_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>>>) (() => {
        BigInteger dim3 = new BigInteger((_18010_keys).Count);
        var arr3 = new _System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>[Dafny.Helpers.ToIntChecked(dim3,"C# array size must not be larger than max 32-bit int")];
        for (int i3 = 0; i3 < dim3; i3++) {
          var _18012_i = (BigInteger) i3;
          arr3[(int)(_18012_i)] = @_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.create((_18010_keys).Select(_18012_i), Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Select(encryptionContext,(_18010_keys).Select(_18012_i)));
        }
        return Dafny.Sequence<_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>>.FromArray(arr3);
      }))();
      BigInteger _18013_kvPairsLen;
      _18013_kvPairsLen = new BigInteger(2);
      BigInteger _18014_i;
      _18014_i = BigInteger.Zero;
      while ((_18014_i) < (new BigInteger((_18011_kvPairs).Count))) {
        _System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>> _18015_kvPair;
        _18015_kvPair = (_18011_kvPairs).Select(_18014_i);
        _18013_kvPairsLen = (((_18013_kvPairsLen) + (new BigInteger(4))) + (new BigInteger(((_18015_kvPair).dtor__0).Count))) + (new BigInteger(((_18015_kvPair).dtor__1).Count));
        if (!(((new BigInteger(((_18015_kvPair).dtor__0).Count)) < (StandardLibrary_mUInt_Compile.__default.UINT16__LIMIT)) && ((new BigInteger(((_18015_kvPair).dtor__1).Count)) < (StandardLibrary_mUInt_Compile.__default.UINT16__LIMIT)))) {
          res = false;
          return res;
        } else if ((_18013_kvPairsLen) >= (StandardLibrary_mUInt_Compile.__default.UINT16__LIMIT)) {
          res = false;
          return res;
        }
        _18014_i = (_18014_i) + (BigInteger.One);
      }
      res = true;
      return res;
      return res;
    }
  }
} // end of namespace EncryptionContext
namespace KMSUtils {









  public partial class GrantTokens {
    private static readonly Dafny.TypeDescriptor<Dafny.ISequence<Dafny.ISequence<char>>> _TYPE = new Dafny.TypeDescriptor<Dafny.ISequence<Dafny.ISequence<char>>>(Dafny.Sequence<Dafny.ISequence<char>>.Empty);
    public static Dafny.TypeDescriptor<Dafny.ISequence<Dafny.ISequence<char>>> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public partial class GrantToken {
    private static readonly Dafny.TypeDescriptor<Dafny.ISequence<char>> _TYPE = new Dafny.TypeDescriptor<Dafny.ISequence<char>>(Dafny.Sequence<char>.Empty);
    public static Dafny.TypeDescriptor<Dafny.ISequence<char>> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public class ResponseMetadata {
    public readonly Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>> metadata;
    public readonly Dafny.ISequence<char> requestID;
    public ResponseMetadata(Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>> metadata, Dafny.ISequence<char> requestID) {
      this.metadata = metadata;
      this.requestID = requestID;
    }
    public override bool Equals(object other) {
      var oth = other as KMSUtils.ResponseMetadata;
      return oth != null && object.Equals(this.metadata, oth.metadata) && object.Equals(this.requestID, oth.requestID);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.metadata));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.requestID));
      return (int) hash;
    }
    public override string ToString() {
      string s = "KMSUtils_Compile.ResponseMetadata.ResponseMetadata";
      s += "(";
      s += Dafny.Helpers.ToString(this.metadata);
      s += ", ";
      s += Dafny.Helpers.ToString(this.requestID);
      s += ")";
      return s;
    }
    private static readonly ResponseMetadata theDefault = create(Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<char>>.Empty, Dafny.Sequence<char>.Empty);
    public static ResponseMetadata Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<KMSUtils.ResponseMetadata> _TYPE = new Dafny.TypeDescriptor<KMSUtils.ResponseMetadata>(KMSUtils.ResponseMetadata.Default());
    public static Dafny.TypeDescriptor<KMSUtils.ResponseMetadata> _TypeDescriptor() {
      return _TYPE;
    }
    public static ResponseMetadata create(Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>> metadata, Dafny.ISequence<char> requestID) {
      return new ResponseMetadata(metadata, requestID);
    }
    public bool is_ResponseMetadata { get { return true; } }
    public Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>> dtor_metadata {
      get {
        return this.metadata;
      }
    }
    public Dafny.ISequence<char> dtor_requestID {
      get {
        return this.requestID;
      }
    }
  }


  public class GenerateDataKeyRequest {
    public readonly Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext;
    public readonly Dafny.ISequence<Dafny.ISequence<char>> grantTokens;
    public readonly Dafny.ISequence<char> keyID;
    public readonly int numberOfBytes;
    public GenerateDataKeyRequest(Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext, Dafny.ISequence<Dafny.ISequence<char>> grantTokens, Dafny.ISequence<char> keyID, int numberOfBytes) {
      this.encryptionContext = encryptionContext;
      this.grantTokens = grantTokens;
      this.keyID = keyID;
      this.numberOfBytes = numberOfBytes;
    }
    public override bool Equals(object other) {
      var oth = other as KMSUtils.GenerateDataKeyRequest;
      return oth != null && object.Equals(this.encryptionContext, oth.encryptionContext) && object.Equals(this.grantTokens, oth.grantTokens) && object.Equals(this.keyID, oth.keyID) && this.numberOfBytes == oth.numberOfBytes;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.encryptionContext));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.grantTokens));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.keyID));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.numberOfBytes));
      return (int) hash;
    }
    public override string ToString() {
      string s = "KMSUtils_Compile.GenerateDataKeyRequest.GenerateDataKeyRequest";
      s += "(";
      s += Dafny.Helpers.ToString(this.encryptionContext);
      s += ", ";
      s += Dafny.Helpers.ToString(this.grantTokens);
      s += ", ";
      s += Dafny.Helpers.ToString(this.keyID);
      s += ", ";
      s += Dafny.Helpers.ToString(this.numberOfBytes);
      s += ")";
      return s;
    }
    private static readonly GenerateDataKeyRequest theDefault = create(Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Empty, Dafny.Sequence<Dafny.ISequence<char>>.Empty, Dafny.Sequence<char>.Empty, 0);
    public static GenerateDataKeyRequest Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<KMSUtils.GenerateDataKeyRequest> _TYPE = new Dafny.TypeDescriptor<KMSUtils.GenerateDataKeyRequest>(KMSUtils.GenerateDataKeyRequest.Default());
    public static Dafny.TypeDescriptor<KMSUtils.GenerateDataKeyRequest> _TypeDescriptor() {
      return _TYPE;
    }
    public static GenerateDataKeyRequest create(Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext, Dafny.ISequence<Dafny.ISequence<char>> grantTokens, Dafny.ISequence<char> keyID, int numberOfBytes) {
      return new GenerateDataKeyRequest(encryptionContext, grantTokens, keyID, numberOfBytes);
    }
    public bool is_GenerateDataKeyRequest { get { return true; } }
    public Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> dtor_encryptionContext {
      get {
        return this.encryptionContext;
      }
    }
    public Dafny.ISequence<Dafny.ISequence<char>> dtor_grantTokens {
      get {
        return this.grantTokens;
      }
    }
    public Dafny.ISequence<char> dtor_keyID {
      get {
        return this.keyID;
      }
    }
    public int dtor_numberOfBytes {
      get {
        return this.numberOfBytes;
      }
    }
  }

  public class GenerateDataKeyResponse {
    public readonly Dafny.ISequence<byte> ciphertextBlob;
    public readonly Dafny.ISequence<char> keyID;
    public readonly Dafny.ISequence<byte> plaintext;
    public GenerateDataKeyResponse(Dafny.ISequence<byte> ciphertextBlob, Dafny.ISequence<char> keyID, Dafny.ISequence<byte> plaintext) {
      this.ciphertextBlob = ciphertextBlob;
      this.keyID = keyID;
      this.plaintext = plaintext;
    }
    public override bool Equals(object other) {
      var oth = other as KMSUtils.GenerateDataKeyResponse;
      return oth != null && object.Equals(this.ciphertextBlob, oth.ciphertextBlob) && object.Equals(this.keyID, oth.keyID) && object.Equals(this.plaintext, oth.plaintext);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.ciphertextBlob));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.keyID));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.plaintext));
      return (int) hash;
    }
    public override string ToString() {
      string s = "KMSUtils_Compile.GenerateDataKeyResponse.GenerateDataKeyResponse";
      s += "(";
      s += Dafny.Helpers.ToString(this.ciphertextBlob);
      s += ", ";
      s += Dafny.Helpers.ToString(this.keyID);
      s += ", ";
      s += Dafny.Helpers.ToString(this.plaintext);
      s += ")";
      return s;
    }
    private static readonly GenerateDataKeyResponse theDefault = create(Dafny.Sequence<byte>.Empty, Dafny.Sequence<char>.Empty, Dafny.Sequence<byte>.Empty);
    public static GenerateDataKeyResponse Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<KMSUtils.GenerateDataKeyResponse> _TYPE = new Dafny.TypeDescriptor<KMSUtils.GenerateDataKeyResponse>(KMSUtils.GenerateDataKeyResponse.Default());
    public static Dafny.TypeDescriptor<KMSUtils.GenerateDataKeyResponse> _TypeDescriptor() {
      return _TYPE;
    }
    public static GenerateDataKeyResponse create(Dafny.ISequence<byte> ciphertextBlob, Dafny.ISequence<char> keyID, Dafny.ISequence<byte> plaintext) {
      return new GenerateDataKeyResponse(ciphertextBlob, keyID, plaintext);
    }
    public bool is_GenerateDataKeyResponse { get { return true; } }
    public Dafny.ISequence<byte> dtor_ciphertextBlob {
      get {
        return this.ciphertextBlob;
      }
    }
    public Dafny.ISequence<char> dtor_keyID {
      get {
        return this.keyID;
      }
    }
    public Dafny.ISequence<byte> dtor_plaintext {
      get {
        return this.plaintext;
      }
    }
    public bool IsWellFormed() {
      return ((new BigInteger(((this).dtor_keyID).Count)) < (StandardLibrary_mUInt_Compile.__default.UINT16__LIMIT)) && ((new BigInteger(((this).dtor_ciphertextBlob).Count)) < (StandardLibrary_mUInt_Compile.__default.UINT16__LIMIT));
    }
  }

  public class EncryptRequest {
    public readonly Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext;
    public readonly Dafny.ISequence<Dafny.ISequence<char>> grantTokens;
    public readonly Dafny.ISequence<char> keyID;
    public readonly Dafny.ISequence<byte> plaintext;
    public EncryptRequest(Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext, Dafny.ISequence<Dafny.ISequence<char>> grantTokens, Dafny.ISequence<char> keyID, Dafny.ISequence<byte> plaintext) {
      this.encryptionContext = encryptionContext;
      this.grantTokens = grantTokens;
      this.keyID = keyID;
      this.plaintext = plaintext;
    }
    public override bool Equals(object other) {
      var oth = other as KMSUtils.EncryptRequest;
      return oth != null && object.Equals(this.encryptionContext, oth.encryptionContext) && object.Equals(this.grantTokens, oth.grantTokens) && object.Equals(this.keyID, oth.keyID) && object.Equals(this.plaintext, oth.plaintext);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.encryptionContext));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.grantTokens));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.keyID));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.plaintext));
      return (int) hash;
    }
    public override string ToString() {
      string s = "KMSUtils_Compile.EncryptRequest.EncryptRequest";
      s += "(";
      s += Dafny.Helpers.ToString(this.encryptionContext);
      s += ", ";
      s += Dafny.Helpers.ToString(this.grantTokens);
      s += ", ";
      s += Dafny.Helpers.ToString(this.keyID);
      s += ", ";
      s += Dafny.Helpers.ToString(this.plaintext);
      s += ")";
      return s;
    }
    private static readonly EncryptRequest theDefault = create(Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Empty, Dafny.Sequence<Dafny.ISequence<char>>.Empty, Dafny.Sequence<char>.Empty, Dafny.Sequence<byte>.Empty);
    public static EncryptRequest Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<KMSUtils.EncryptRequest> _TYPE = new Dafny.TypeDescriptor<KMSUtils.EncryptRequest>(KMSUtils.EncryptRequest.Default());
    public static Dafny.TypeDescriptor<KMSUtils.EncryptRequest> _TypeDescriptor() {
      return _TYPE;
    }
    public static EncryptRequest create(Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext, Dafny.ISequence<Dafny.ISequence<char>> grantTokens, Dafny.ISequence<char> keyID, Dafny.ISequence<byte> plaintext) {
      return new EncryptRequest(encryptionContext, grantTokens, keyID, plaintext);
    }
    public bool is_EncryptRequest { get { return true; } }
    public Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> dtor_encryptionContext {
      get {
        return this.encryptionContext;
      }
    }
    public Dafny.ISequence<Dafny.ISequence<char>> dtor_grantTokens {
      get {
        return this.grantTokens;
      }
    }
    public Dafny.ISequence<char> dtor_keyID {
      get {
        return this.keyID;
      }
    }
    public Dafny.ISequence<byte> dtor_plaintext {
      get {
        return this.plaintext;
      }
    }
  }

  public class EncryptResponse {
    public readonly Dafny.ISequence<byte> ciphertextBlob;
    public readonly BigInteger contentLength;
    public readonly BigInteger httpStatusCode;
    public readonly Dafny.ISequence<char> keyID;
    public readonly KMSUtils.ResponseMetadata responseMetadata;
    public EncryptResponse(Dafny.ISequence<byte> ciphertextBlob, BigInteger contentLength, BigInteger httpStatusCode, Dafny.ISequence<char> keyID, KMSUtils.ResponseMetadata responseMetadata) {
      this.ciphertextBlob = ciphertextBlob;
      this.contentLength = contentLength;
      this.httpStatusCode = httpStatusCode;
      this.keyID = keyID;
      this.responseMetadata = responseMetadata;
    }
    public override bool Equals(object other) {
      var oth = other as KMSUtils.EncryptResponse;
      return oth != null && object.Equals(this.ciphertextBlob, oth.ciphertextBlob) && this.contentLength == oth.contentLength && this.httpStatusCode == oth.httpStatusCode && object.Equals(this.keyID, oth.keyID) && object.Equals(this.responseMetadata, oth.responseMetadata);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.ciphertextBlob));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.contentLength));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.httpStatusCode));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.keyID));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.responseMetadata));
      return (int) hash;
    }
    public override string ToString() {
      string s = "KMSUtils_Compile.EncryptResponse.EncryptResponse";
      s += "(";
      s += Dafny.Helpers.ToString(this.ciphertextBlob);
      s += ", ";
      s += Dafny.Helpers.ToString(this.contentLength);
      s += ", ";
      s += Dafny.Helpers.ToString(this.httpStatusCode);
      s += ", ";
      s += Dafny.Helpers.ToString(this.keyID);
      s += ", ";
      s += Dafny.Helpers.ToString(this.responseMetadata);
      s += ")";
      return s;
    }
    private static readonly EncryptResponse theDefault = create(Dafny.Sequence<byte>.Empty, BigInteger.Zero, BigInteger.Zero, Dafny.Sequence<char>.Empty, KMSUtils.ResponseMetadata.Default());
    public static EncryptResponse Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<KMSUtils.EncryptResponse> _TYPE = new Dafny.TypeDescriptor<KMSUtils.EncryptResponse>(KMSUtils.EncryptResponse.Default());
    public static Dafny.TypeDescriptor<KMSUtils.EncryptResponse> _TypeDescriptor() {
      return _TYPE;
    }
    public static EncryptResponse create(Dafny.ISequence<byte> ciphertextBlob, BigInteger contentLength, BigInteger httpStatusCode, Dafny.ISequence<char> keyID, KMSUtils.ResponseMetadata responseMetadata) {
      return new EncryptResponse(ciphertextBlob, contentLength, httpStatusCode, keyID, responseMetadata);
    }
    public bool is_EncryptResponse { get { return true; } }
    public Dafny.ISequence<byte> dtor_ciphertextBlob {
      get {
        return this.ciphertextBlob;
      }
    }
    public BigInteger dtor_contentLength {
      get {
        return this.contentLength;
      }
    }
    public BigInteger dtor_httpStatusCode {
      get {
        return this.httpStatusCode;
      }
    }
    public Dafny.ISequence<char> dtor_keyID {
      get {
        return this.keyID;
      }
    }
    public KMSUtils.ResponseMetadata dtor_responseMetadata {
      get {
        return this.responseMetadata;
      }
    }
    public bool IsWellFormed() {
      return ((new BigInteger(((this).dtor_keyID).Count)) < (StandardLibrary_mUInt_Compile.__default.UINT16__LIMIT)) && ((new BigInteger(((this).dtor_ciphertextBlob).Count)) < (StandardLibrary_mUInt_Compile.__default.UINT16__LIMIT));
    }
  }

  public class DecryptRequest {
    public readonly Dafny.ISequence<char> keyId;
    public readonly Dafny.ISequence<byte> ciphertextBlob;
    public readonly Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext;
    public readonly Dafny.ISequence<Dafny.ISequence<char>> grantTokens;
    public DecryptRequest(Dafny.ISequence<char> keyId, Dafny.ISequence<byte> ciphertextBlob, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext, Dafny.ISequence<Dafny.ISequence<char>> grantTokens) {
      this.keyId = keyId;
      this.ciphertextBlob = ciphertextBlob;
      this.encryptionContext = encryptionContext;
      this.grantTokens = grantTokens;
    }
    public override bool Equals(object other) {
      var oth = other as KMSUtils.DecryptRequest;
      return oth != null && object.Equals(this.keyId, oth.keyId) && object.Equals(this.ciphertextBlob, oth.ciphertextBlob) && object.Equals(this.encryptionContext, oth.encryptionContext) && object.Equals(this.grantTokens, oth.grantTokens);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.keyId));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.ciphertextBlob));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.encryptionContext));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.grantTokens));
      return (int) hash;
    }
    public override string ToString() {
      string s = "KMSUtils_Compile.DecryptRequest.DecryptRequest";
      s += "(";
      s += Dafny.Helpers.ToString(this.keyId);
      s += ", ";
      s += Dafny.Helpers.ToString(this.ciphertextBlob);
      s += ", ";
      s += Dafny.Helpers.ToString(this.encryptionContext);
      s += ", ";
      s += Dafny.Helpers.ToString(this.grantTokens);
      s += ")";
      return s;
    }
    private static readonly DecryptRequest theDefault = create(Dafny.Sequence<char>.Empty, Dafny.Sequence<byte>.Empty, Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Empty, Dafny.Sequence<Dafny.ISequence<char>>.Empty);
    public static DecryptRequest Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<KMSUtils.DecryptRequest> _TYPE = new Dafny.TypeDescriptor<KMSUtils.DecryptRequest>(KMSUtils.DecryptRequest.Default());
    public static Dafny.TypeDescriptor<KMSUtils.DecryptRequest> _TypeDescriptor() {
      return _TYPE;
    }
    public static DecryptRequest create(Dafny.ISequence<char> keyId, Dafny.ISequence<byte> ciphertextBlob, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext, Dafny.ISequence<Dafny.ISequence<char>> grantTokens) {
      return new DecryptRequest(keyId, ciphertextBlob, encryptionContext, grantTokens);
    }
    public bool is_DecryptRequest { get { return true; } }
    public Dafny.ISequence<char> dtor_keyId {
      get {
        return this.keyId;
      }
    }
    public Dafny.ISequence<byte> dtor_ciphertextBlob {
      get {
        return this.ciphertextBlob;
      }
    }
    public Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> dtor_encryptionContext {
      get {
        return this.encryptionContext;
      }
    }
    public Dafny.ISequence<Dafny.ISequence<char>> dtor_grantTokens {
      get {
        return this.grantTokens;
      }
    }
  }

  public class DecryptResponse {
    public readonly BigInteger contentLength;
    public readonly BigInteger httpStatusCode;
    public readonly Dafny.ISequence<char> keyID;
    public readonly Dafny.ISequence<byte> plaintext;
    public readonly KMSUtils.ResponseMetadata responseMetadata;
    public DecryptResponse(BigInteger contentLength, BigInteger httpStatusCode, Dafny.ISequence<char> keyID, Dafny.ISequence<byte> plaintext, KMSUtils.ResponseMetadata responseMetadata) {
      this.contentLength = contentLength;
      this.httpStatusCode = httpStatusCode;
      this.keyID = keyID;
      this.plaintext = plaintext;
      this.responseMetadata = responseMetadata;
    }
    public override bool Equals(object other) {
      var oth = other as KMSUtils.DecryptResponse;
      return oth != null && this.contentLength == oth.contentLength && this.httpStatusCode == oth.httpStatusCode && object.Equals(this.keyID, oth.keyID) && object.Equals(this.plaintext, oth.plaintext) && object.Equals(this.responseMetadata, oth.responseMetadata);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.contentLength));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.httpStatusCode));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.keyID));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.plaintext));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.responseMetadata));
      return (int) hash;
    }
    public override string ToString() {
      string s = "KMSUtils_Compile.DecryptResponse.DecryptResponse";
      s += "(";
      s += Dafny.Helpers.ToString(this.contentLength);
      s += ", ";
      s += Dafny.Helpers.ToString(this.httpStatusCode);
      s += ", ";
      s += Dafny.Helpers.ToString(this.keyID);
      s += ", ";
      s += Dafny.Helpers.ToString(this.plaintext);
      s += ", ";
      s += Dafny.Helpers.ToString(this.responseMetadata);
      s += ")";
      return s;
    }
    private static readonly DecryptResponse theDefault = create(BigInteger.Zero, BigInteger.Zero, Dafny.Sequence<char>.Empty, Dafny.Sequence<byte>.Empty, KMSUtils.ResponseMetadata.Default());
    public static DecryptResponse Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<KMSUtils.DecryptResponse> _TYPE = new Dafny.TypeDescriptor<KMSUtils.DecryptResponse>(KMSUtils.DecryptResponse.Default());
    public static Dafny.TypeDescriptor<KMSUtils.DecryptResponse> _TypeDescriptor() {
      return _TYPE;
    }
    public static DecryptResponse create(BigInteger contentLength, BigInteger httpStatusCode, Dafny.ISequence<char> keyID, Dafny.ISequence<byte> plaintext, KMSUtils.ResponseMetadata responseMetadata) {
      return new DecryptResponse(contentLength, httpStatusCode, keyID, plaintext, responseMetadata);
    }
    public bool is_DecryptResponse { get { return true; } }
    public BigInteger dtor_contentLength {
      get {
        return this.contentLength;
      }
    }
    public BigInteger dtor_httpStatusCode {
      get {
        return this.httpStatusCode;
      }
    }
    public Dafny.ISequence<char> dtor_keyID {
      get {
        return this.keyID;
      }
    }
    public Dafny.ISequence<byte> dtor_plaintext {
      get {
        return this.plaintext;
      }
    }
    public KMSUtils.ResponseMetadata dtor_responseMetadata {
      get {
        return this.responseMetadata;
      }
    }
  }

  public interface DafnyAWSKMSClientSupplier {
    Wrappers_Compile.Result<Amazon.KeyManagementService.IAmazonKeyManagementService, Dafny.ISequence<char>> GetClient(Wrappers_Compile.Option<Dafny.ISequence<char>> region);
  }
  public class _Companion_DafnyAWSKMSClientSupplier {
  }

  public partial class BaseClientSupplier : KMSUtils.DafnyAWSKMSClientSupplier {
    public BaseClientSupplier() {
    }
    public void __ctor()
    {
    }
    public Wrappers_Compile.Result<Amazon.KeyManagementService.IAmazonKeyManagementService, Dafny.ISequence<char>> GetClient(Wrappers_Compile.Option<Dafny.ISequence<char>> region)
    {
      Wrappers_Compile.Result<Amazon.KeyManagementService.IAmazonKeyManagementService, Dafny.ISequence<char>> res = default(Wrappers_Compile.Result<Amazon.KeyManagementService.IAmazonKeyManagementService, Dafny.ISequence<char>>);
      Wrappers_Compile.Result<Amazon.KeyManagementService.IAmazonKeyManagementService, Dafny.ISequence<char>> _18016_resClient;
      Wrappers_Compile.Result<Amazon.KeyManagementService.IAmazonKeyManagementService, Dafny.ISequence<char>> _out15;
      _out15 = KMSUtils.ClientHelper.GetDefaultAWSKMSServiceClientExtern(region);
      _18016_resClient = _out15;
      res = _18016_resClient;
      return res;
      return res;
    }
  }

  public partial class __default {
    public static BigInteger MAX__GRANT__TOKENS { get {
      return new BigInteger(10);
    } }
  }
} // end of namespace KMSUtils
namespace AlgorithmSuite {







  public partial class ID {
    public static System.Collections.Generic.IEnumerable<ushort> IntegerRange(BigInteger lo, BigInteger hi) {
      for (var j = lo; j < hi; j++) { yield return (ushort)j; }
    }
    public static readonly ushort Witness = (ushort)(20);
    private static readonly Dafny.TypeDescriptor<ushort> _TYPE = new Dafny.TypeDescriptor<ushort>(AlgorithmSuite.ID.Witness);
    public static Dafny.TypeDescriptor<ushort> _TypeDescriptor() {
      return _TYPE;
    }
    public static EncryptionSuites.EncryptionSuite EncryptionSuite(ushort _this) {
      return (Dafny.Map<ushort, AlgorithmSuite.AlgSuite>.Select(AlgorithmSuite.__default.Suite,_this)).dtor_algorithm;
    }
    public static BigInteger KeyLength(ushort _this) {
      return new BigInteger(((Dafny.Map<ushort, AlgorithmSuite.AlgSuite>.Select(AlgorithmSuite.__default.Suite,_this)).dtor_algorithm).dtor_keyLen);
    }
    public static bool ContainsIdentityKDF(ushort _this) {
      return object.Equals((Dafny.Map<ushort, AlgorithmSuite.AlgSuite>.Select(AlgorithmSuite.__default.Suite,_this)).dtor_hkdf, @KeyDerivationAlgorithms.KeyDerivationAlgorithm.create_IDENTITY());
    }
    public static BigInteger KDFInputKeyLength(ushort _this) {
      KeyDerivationAlgorithms.KeyDerivationAlgorithm _source15 = (Dafny.Map<ushort, AlgorithmSuite.AlgSuite>.Select(AlgorithmSuite.__default.Suite,_this)).dtor_hkdf;
      if (_source15.is_HKDF__WITH__SHA__384) {
        return new BigInteger(((Dafny.Map<ushort, AlgorithmSuite.AlgSuite>.Select(AlgorithmSuite.__default.Suite,_this)).dtor_algorithm).dtor_keyLen);
      } else if (_source15.is_HKDF__WITH__SHA__256) {
        return new BigInteger(((Dafny.Map<ushort, AlgorithmSuite.AlgSuite>.Select(AlgorithmSuite.__default.Suite,_this)).dtor_algorithm).dtor_keyLen);
      } else {
        return new BigInteger(((Dafny.Map<ushort, AlgorithmSuite.AlgSuite>.Select(AlgorithmSuite.__default.Suite,_this)).dtor_algorithm).dtor_keyLen);
      }
    }
    public static BigInteger IVLength(ushort _this) {
      return new BigInteger(((Dafny.Map<ushort, AlgorithmSuite.AlgSuite>.Select(AlgorithmSuite.__default.Suite,_this)).dtor_algorithm).dtor_ivLen);
    }
    public static BigInteger TagLength(ushort _this) {
      return new BigInteger(((Dafny.Map<ushort, AlgorithmSuite.AlgSuite>.Select(AlgorithmSuite.__default.Suite,_this)).dtor_algorithm).dtor_tagLen);
    }
    public static Wrappers_Compile.Option<Signature.ECDSAParams> SignatureType(ushort _this) {
      return (Dafny.Map<ushort, AlgorithmSuite.AlgSuite>.Select(AlgorithmSuite.__default.Suite,_this)).dtor_sign;
    }
    public static bool ValidPlaintextDataKey(ushort _this, Dafny.ISequence<byte> plaintextDataKey) {
      return (new BigInteger((plaintextDataKey).Count)) == (AlgorithmSuite.ID.KDFInputKeyLength(_this));
    }
  }

  public class AlgSuite {
    public readonly EncryptionSuites.EncryptionSuite algorithm;
    public readonly KeyDerivationAlgorithms.KeyDerivationAlgorithm hkdf;
    public readonly Wrappers_Compile.Option<Signature.ECDSAParams> sign;
    public AlgSuite(EncryptionSuites.EncryptionSuite algorithm, KeyDerivationAlgorithms.KeyDerivationAlgorithm hkdf, Wrappers_Compile.Option<Signature.ECDSAParams> sign) {
      this.algorithm = algorithm;
      this.hkdf = hkdf;
      this.sign = sign;
    }
    public override bool Equals(object other) {
      var oth = other as AlgorithmSuite.AlgSuite;
      return oth != null && object.Equals(this.algorithm, oth.algorithm) && object.Equals(this.hkdf, oth.hkdf) && object.Equals(this.sign, oth.sign);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.algorithm));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.hkdf));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.sign));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AlgorithmSuite_Compile.AlgSuite.AlgSuite";
      s += "(";
      s += Dafny.Helpers.ToString(this.algorithm);
      s += ", ";
      s += Dafny.Helpers.ToString(this.hkdf);
      s += ", ";
      s += Dafny.Helpers.ToString(this.sign);
      s += ")";
      return s;
    }
    private static readonly AlgSuite theDefault = create(EncryptionSuites.EncryptionSuite.Default(), KeyDerivationAlgorithms.KeyDerivationAlgorithm.Default(), Wrappers_Compile.Option<Signature.ECDSAParams>.Default());
    public static AlgSuite Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<AlgorithmSuite.AlgSuite> _TYPE = new Dafny.TypeDescriptor<AlgorithmSuite.AlgSuite>(AlgorithmSuite.AlgSuite.Default());
    public static Dafny.TypeDescriptor<AlgorithmSuite.AlgSuite> _TypeDescriptor() {
      return _TYPE;
    }
    public static AlgSuite create(EncryptionSuites.EncryptionSuite algorithm, KeyDerivationAlgorithms.KeyDerivationAlgorithm hkdf, Wrappers_Compile.Option<Signature.ECDSAParams> sign) {
      return new AlgSuite(algorithm, hkdf, sign);
    }
    public bool is_AlgSuite { get { return true; } }
    public EncryptionSuites.EncryptionSuite dtor_algorithm {
      get {
        return this.algorithm;
      }
    }
    public KeyDerivationAlgorithms.KeyDerivationAlgorithm dtor_hkdf {
      get {
        return this.hkdf;
      }
    }
    public Wrappers_Compile.Option<Signature.ECDSAParams> dtor_sign {
      get {
        return this.sign;
      }
    }
  }

  public partial class __default {
    public static ushort PolymorphIDToInternalID(Dafny.Aws.Crypto.AlgorithmSuiteId input) {
      if (object.Equals(input, @Dafny.Aws.Crypto.AlgorithmSuiteId.create_ALG__AES__128__GCM__IV12__TAG16__NO__KDF())) {
        return AlgorithmSuite.__default.AES__128__GCM__IV12__TAG16__IDENTITY__NO__SIGNATURE__ALG;
      } else if (object.Equals(input, @Dafny.Aws.Crypto.AlgorithmSuiteId.create_ALG__AES__192__GCM__IV12__TAG16__NO__KDF())) {
        return AlgorithmSuite.__default.AES__192__GCM__IV12__TAG16__IDENTITY__NO__SIGNATURE__ALG;
      } else if (object.Equals(input, @Dafny.Aws.Crypto.AlgorithmSuiteId.create_ALG__AES__256__GCM__IV12__TAG16__NO__KDF())) {
        return AlgorithmSuite.__default.AES__256__GCM__IV12__TAG16__IDENTITY__NO__SIGNATURE__ALG;
      } else if (object.Equals(input, @Dafny.Aws.Crypto.AlgorithmSuiteId.create_ALG__AES__128__GCM__IV12__TAG16__HKDF__SHA256())) {
        return AlgorithmSuite.__default.AES__128__GCM__IV12__TAG16__HKDF__SHA256__NO__SIGNATURE__ALG;
      } else if (object.Equals(input, @Dafny.Aws.Crypto.AlgorithmSuiteId.create_ALG__AES__192__GCM__IV12__TAG16__HKDF__SHA256())) {
        return AlgorithmSuite.__default.AES__192__GCM__IV12__TAG16__HKDF__SHA256__NO__SIGNATURE__ALG;
      } else if (object.Equals(input, @Dafny.Aws.Crypto.AlgorithmSuiteId.create_ALG__AES__256__GCM__IV12__TAG16__HKDF__SHA256())) {
        return AlgorithmSuite.__default.AES__256__GCM__IV12__TAG16__HKDF__SHA256__NO__SIGNATURE__ALG;
      } else if (object.Equals(input, @Dafny.Aws.Crypto.AlgorithmSuiteId.create_ALG__AES__128__GCM__IV12__TAG16__HKDF__SHA256__ECDSA__P256())) {
        return AlgorithmSuite.__default.AES__128__GCM__IV12__TAG16__HKDF__SHA256__ECDSA__P256;
      } else if (object.Equals(input, @Dafny.Aws.Crypto.AlgorithmSuiteId.create_ALG__AES__192__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384())) {
        return AlgorithmSuite.__default.AES__192__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384;
      } else {
        return AlgorithmSuite.__default.AES__256__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384;
      }
    }
    public static Dafny.Aws.Crypto.AlgorithmSuiteId InternalIDToPolymorphID(ushort input) {
      if ((input) == (AlgorithmSuite.__default.AES__128__GCM__IV12__TAG16__IDENTITY__NO__SIGNATURE__ALG)) {
        return @Dafny.Aws.Crypto.AlgorithmSuiteId.create_ALG__AES__128__GCM__IV12__TAG16__NO__KDF();
      } else if ((input) == (AlgorithmSuite.__default.AES__192__GCM__IV12__TAG16__IDENTITY__NO__SIGNATURE__ALG)) {
        return @Dafny.Aws.Crypto.AlgorithmSuiteId.create_ALG__AES__192__GCM__IV12__TAG16__NO__KDF();
      } else if ((input) == (AlgorithmSuite.__default.AES__256__GCM__IV12__TAG16__IDENTITY__NO__SIGNATURE__ALG)) {
        return @Dafny.Aws.Crypto.AlgorithmSuiteId.create_ALG__AES__256__GCM__IV12__TAG16__NO__KDF();
      } else if ((input) == (AlgorithmSuite.__default.AES__128__GCM__IV12__TAG16__HKDF__SHA256__NO__SIGNATURE__ALG)) {
        return @Dafny.Aws.Crypto.AlgorithmSuiteId.create_ALG__AES__128__GCM__IV12__TAG16__HKDF__SHA256();
      } else if ((input) == (AlgorithmSuite.__default.AES__192__GCM__IV12__TAG16__HKDF__SHA256__NO__SIGNATURE__ALG)) {
        return @Dafny.Aws.Crypto.AlgorithmSuiteId.create_ALG__AES__192__GCM__IV12__TAG16__HKDF__SHA256();
      } else if ((input) == (AlgorithmSuite.__default.AES__256__GCM__IV12__TAG16__HKDF__SHA256__NO__SIGNATURE__ALG)) {
        return @Dafny.Aws.Crypto.AlgorithmSuiteId.create_ALG__AES__256__GCM__IV12__TAG16__HKDF__SHA256();
      } else if ((input) == (AlgorithmSuite.__default.AES__128__GCM__IV12__TAG16__HKDF__SHA256__ECDSA__P256)) {
        return @Dafny.Aws.Crypto.AlgorithmSuiteId.create_ALG__AES__128__GCM__IV12__TAG16__HKDF__SHA256__ECDSA__P256();
      } else if ((input) == (AlgorithmSuite.__default.AES__192__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384)) {
        return @Dafny.Aws.Crypto.AlgorithmSuiteId.create_ALG__AES__192__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384();
      } else {
        return @Dafny.Aws.Crypto.AlgorithmSuiteId.create_ALG__AES__256__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384();
      }
    }
    public static Dafny.ISet<ushort> VALID__IDS { get {
      return Dafny.Set<ushort>.FromElements(888, 838, 532, 376, 326, 276, 120, 70, 20);
    } }
    public static ushort AES__256__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384 { get {
      return 888;
    } }
    public static ushort AES__192__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384 { get {
      return 838;
    } }
    public static ushort AES__128__GCM__IV12__TAG16__HKDF__SHA256__ECDSA__P256 { get {
      return 532;
    } }
    public static ushort AES__256__GCM__IV12__TAG16__HKDF__SHA256__NO__SIGNATURE__ALG { get {
      return 376;
    } }
    public static ushort AES__192__GCM__IV12__TAG16__HKDF__SHA256__NO__SIGNATURE__ALG { get {
      return 326;
    } }
    public static ushort AES__128__GCM__IV12__TAG16__HKDF__SHA256__NO__SIGNATURE__ALG { get {
      return 276;
    } }
    public static ushort AES__256__GCM__IV12__TAG16__IDENTITY__NO__SIGNATURE__ALG { get {
      return 120;
    } }
    public static ushort AES__192__GCM__IV12__TAG16__IDENTITY__NO__SIGNATURE__ALG { get {
      return 70;
    } }
    public static ushort AES__128__GCM__IV12__TAG16__IDENTITY__NO__SIGNATURE__ALG { get {
      return 20;
    } }
    public static Dafny.IMap<ushort,AlgorithmSuite.AlgSuite> Suite { get {
      return Dafny.Map<ushort, AlgorithmSuite.AlgSuite>.FromElements(new Dafny.Pair<ushort,AlgorithmSuite.AlgSuite>(AlgorithmSuite.__default.AES__256__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384,@AlgorithmSuite.AlgSuite.create(EncryptionSuites.__default.AES__GCM__256, @KeyDerivationAlgorithms.KeyDerivationAlgorithm.create_HKDF__WITH__SHA__384(), @Wrappers_Compile.Option<Signature.ECDSAParams>.create_Some(@Signature.ECDSAParams.create_ECDSA__P384()))), new Dafny.Pair<ushort,AlgorithmSuite.AlgSuite>(AlgorithmSuite.__default.AES__192__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384,@AlgorithmSuite.AlgSuite.create(EncryptionSuites.__default.AES__GCM__192, @KeyDerivationAlgorithms.KeyDerivationAlgorithm.create_HKDF__WITH__SHA__384(), @Wrappers_Compile.Option<Signature.ECDSAParams>.create_Some(@Signature.ECDSAParams.create_ECDSA__P384()))), new Dafny.Pair<ushort,AlgorithmSuite.AlgSuite>(AlgorithmSuite.__default.AES__128__GCM__IV12__TAG16__HKDF__SHA256__ECDSA__P256,@AlgorithmSuite.AlgSuite.create(EncryptionSuites.__default.AES__GCM__128, @KeyDerivationAlgorithms.KeyDerivationAlgorithm.create_HKDF__WITH__SHA__256(), @Wrappers_Compile.Option<Signature.ECDSAParams>.create_Some(@Signature.ECDSAParams.create_ECDSA__P256()))), new Dafny.Pair<ushort,AlgorithmSuite.AlgSuite>(AlgorithmSuite.__default.AES__256__GCM__IV12__TAG16__HKDF__SHA256__NO__SIGNATURE__ALG,@AlgorithmSuite.AlgSuite.create(EncryptionSuites.__default.AES__GCM__256, @KeyDerivationAlgorithms.KeyDerivationAlgorithm.create_HKDF__WITH__SHA__256(), @Wrappers_Compile.Option<Signature.ECDSAParams>.create_None())), new Dafny.Pair<ushort,AlgorithmSuite.AlgSuite>(AlgorithmSuite.__default.AES__192__GCM__IV12__TAG16__HKDF__SHA256__NO__SIGNATURE__ALG,@AlgorithmSuite.AlgSuite.create(EncryptionSuites.__default.AES__GCM__192, @KeyDerivationAlgorithms.KeyDerivationAlgorithm.create_HKDF__WITH__SHA__256(), @Wrappers_Compile.Option<Signature.ECDSAParams>.create_None())), new Dafny.Pair<ushort,AlgorithmSuite.AlgSuite>(AlgorithmSuite.__default.AES__128__GCM__IV12__TAG16__HKDF__SHA256__NO__SIGNATURE__ALG,@AlgorithmSuite.AlgSuite.create(EncryptionSuites.__default.AES__GCM__128, @KeyDerivationAlgorithms.KeyDerivationAlgorithm.create_HKDF__WITH__SHA__256(), @Wrappers_Compile.Option<Signature.ECDSAParams>.create_None())), new Dafny.Pair<ushort,AlgorithmSuite.AlgSuite>(AlgorithmSuite.__default.AES__256__GCM__IV12__TAG16__IDENTITY__NO__SIGNATURE__ALG,@AlgorithmSuite.AlgSuite.create(EncryptionSuites.__default.AES__GCM__256, @KeyDerivationAlgorithms.KeyDerivationAlgorithm.create_IDENTITY(), @Wrappers_Compile.Option<Signature.ECDSAParams>.create_None())), new Dafny.Pair<ushort,AlgorithmSuite.AlgSuite>(AlgorithmSuite.__default.AES__192__GCM__IV12__TAG16__IDENTITY__NO__SIGNATURE__ALG,@AlgorithmSuite.AlgSuite.create(EncryptionSuites.__default.AES__GCM__192, @KeyDerivationAlgorithms.KeyDerivationAlgorithm.create_IDENTITY(), @Wrappers_Compile.Option<Signature.ECDSAParams>.create_None())), new Dafny.Pair<ushort,AlgorithmSuite.AlgSuite>(AlgorithmSuite.__default.AES__128__GCM__IV12__TAG16__IDENTITY__NO__SIGNATURE__ALG,@AlgorithmSuite.AlgSuite.create(EncryptionSuites.__default.AES__GCM__128, @KeyDerivationAlgorithms.KeyDerivationAlgorithm.create_IDENTITY(), @Wrappers_Compile.Option<Signature.ECDSAParams>.create_None())));
    } }
  }
} // end of namespace AlgorithmSuite
namespace Materials {







  public class EncryptedDataKey {
    public readonly Dafny.ISequence<byte> providerID;
    public readonly Dafny.ISequence<byte> providerInfo;
    public readonly Dafny.ISequence<byte> ciphertext;
    public EncryptedDataKey(Dafny.ISequence<byte> providerID, Dafny.ISequence<byte> providerInfo, Dafny.ISequence<byte> ciphertext) {
      this.providerID = providerID;
      this.providerInfo = providerInfo;
      this.ciphertext = ciphertext;
    }
    public override bool Equals(object other) {
      var oth = other as Materials.EncryptedDataKey;
      return oth != null && object.Equals(this.providerID, oth.providerID) && object.Equals(this.providerInfo, oth.providerInfo) && object.Equals(this.ciphertext, oth.ciphertext);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.providerID));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.providerInfo));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.ciphertext));
      return (int) hash;
    }
    public override string ToString() {
      string s = "Materials_Compile.EncryptedDataKey.EncryptedDataKey";
      s += "(";
      s += Dafny.Helpers.ToString(this.providerID);
      s += ", ";
      s += Dafny.Helpers.ToString(this.providerInfo);
      s += ", ";
      s += Dafny.Helpers.ToString(this.ciphertext);
      s += ")";
      return s;
    }
    private static readonly EncryptedDataKey theDefault = create(UTF8.ValidUTF8Bytes.Default(), Dafny.Sequence<byte>.Empty, Dafny.Sequence<byte>.Empty);
    public static EncryptedDataKey Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<Materials.EncryptedDataKey> _TYPE = new Dafny.TypeDescriptor<Materials.EncryptedDataKey>(Materials.EncryptedDataKey.Default());
    public static Dafny.TypeDescriptor<Materials.EncryptedDataKey> _TypeDescriptor() {
      return _TYPE;
    }
    public static EncryptedDataKey create(Dafny.ISequence<byte> providerID, Dafny.ISequence<byte> providerInfo, Dafny.ISequence<byte> ciphertext) {
      return new EncryptedDataKey(providerID, providerInfo, ciphertext);
    }
    public bool is_EncryptedDataKey { get { return true; } }
    public Dafny.ISequence<byte> dtor_providerID {
      get {
        return this.providerID;
      }
    }
    public Dafny.ISequence<byte> dtor_providerInfo {
      get {
        return this.providerInfo;
      }
    }
    public Dafny.ISequence<byte> dtor_ciphertext {
      get {
        return this.ciphertext;
      }
    }
    public static Materials.EncryptedDataKey ValidWitness() {
      return @Materials.EncryptedDataKey.create(Dafny.Sequence<byte>.FromElements(), Dafny.Sequence<byte>.FromElements(), Dafny.Sequence<byte>.FromElements());
    }
  }

  public partial class ValidEncryptedDataKey {
    private static readonly Materials.EncryptedDataKey Witness = Materials.EncryptedDataKey.ValidWitness();
    public static Materials.EncryptedDataKey Default() {
      return Witness;
    }
    private static readonly Dafny.TypeDescriptor<Materials.EncryptedDataKey> _TYPE = new Dafny.TypeDescriptor<Materials.EncryptedDataKey>(Materials.ValidEncryptedDataKey.Default());
    public static Dafny.TypeDescriptor<Materials.EncryptedDataKey> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public class EncryptionMaterials {
    public readonly Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext;
    public readonly ushort algorithmSuiteID;
    public readonly Wrappers_Compile.Option<Dafny.ISequence<byte>> plaintextDataKey;
    public readonly Dafny.ISequence<Materials.EncryptedDataKey> encryptedDataKeys;
    public readonly Wrappers_Compile.Option<Dafny.ISequence<byte>> signingKey;
    public EncryptionMaterials(Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext, ushort algorithmSuiteID, Wrappers_Compile.Option<Dafny.ISequence<byte>> plaintextDataKey, Dafny.ISequence<Materials.EncryptedDataKey> encryptedDataKeys, Wrappers_Compile.Option<Dafny.ISequence<byte>> signingKey) {
      this.encryptionContext = encryptionContext;
      this.algorithmSuiteID = algorithmSuiteID;
      this.plaintextDataKey = plaintextDataKey;
      this.encryptedDataKeys = encryptedDataKeys;
      this.signingKey = signingKey;
    }
    public override bool Equals(object other) {
      var oth = other as Materials.EncryptionMaterials;
      return oth != null && object.Equals(this.encryptionContext, oth.encryptionContext) && this.algorithmSuiteID == oth.algorithmSuiteID && object.Equals(this.plaintextDataKey, oth.plaintextDataKey) && object.Equals(this.encryptedDataKeys, oth.encryptedDataKeys) && object.Equals(this.signingKey, oth.signingKey);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.encryptionContext));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.algorithmSuiteID));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.plaintextDataKey));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.encryptedDataKeys));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.signingKey));
      return (int) hash;
    }
    public override string ToString() {
      string s = "Materials_Compile.EncryptionMaterials.EncryptionMaterials";
      s += "(";
      s += Dafny.Helpers.ToString(this.encryptionContext);
      s += ", ";
      s += Dafny.Helpers.ToString(this.algorithmSuiteID);
      s += ", ";
      s += Dafny.Helpers.ToString(this.plaintextDataKey);
      s += ", ";
      s += Dafny.Helpers.ToString(this.encryptedDataKeys);
      s += ", ";
      s += Dafny.Helpers.ToString(this.signingKey);
      s += ")";
      return s;
    }
    private static readonly EncryptionMaterials theDefault = create(Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Empty, AlgorithmSuite.ID.Witness, Wrappers_Compile.Option<Dafny.ISequence<byte>>.Default(), Dafny.Sequence<Materials.EncryptedDataKey>.Empty, Wrappers_Compile.Option<Dafny.ISequence<byte>>.Default());
    public static EncryptionMaterials Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<Materials.EncryptionMaterials> _TYPE = new Dafny.TypeDescriptor<Materials.EncryptionMaterials>(Materials.EncryptionMaterials.Default());
    public static Dafny.TypeDescriptor<Materials.EncryptionMaterials> _TypeDescriptor() {
      return _TYPE;
    }
    public static EncryptionMaterials create(Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext, ushort algorithmSuiteID, Wrappers_Compile.Option<Dafny.ISequence<byte>> plaintextDataKey, Dafny.ISequence<Materials.EncryptedDataKey> encryptedDataKeys, Wrappers_Compile.Option<Dafny.ISequence<byte>> signingKey) {
      return new EncryptionMaterials(encryptionContext, algorithmSuiteID, plaintextDataKey, encryptedDataKeys, signingKey);
    }
    public bool is_EncryptionMaterials { get { return true; } }
    public Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> dtor_encryptionContext {
      get {
        return this.encryptionContext;
      }
    }
    public ushort dtor_algorithmSuiteID {
      get {
        return this.algorithmSuiteID;
      }
    }
    public Wrappers_Compile.Option<Dafny.ISequence<byte>> dtor_plaintextDataKey {
      get {
        return this.plaintextDataKey;
      }
    }
    public Dafny.ISequence<Materials.EncryptedDataKey> dtor_encryptedDataKeys {
      get {
        return this.encryptedDataKeys;
      }
    }
    public Wrappers_Compile.Option<Dafny.ISequence<byte>> dtor_signingKey {
      get {
        return this.signingKey;
      }
    }
    public static Materials.EncryptionMaterials ValidWitness() {
      return @Materials.EncryptionMaterials.create(Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.FromElements(), AlgorithmSuite.__default.AES__256__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384, @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_None(), Dafny.Sequence<Materials.EncryptedDataKey>.FromElements(), @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(((System.Func<Dafny.ISequence<byte>>) (() => {
  BigInteger dim4 = new BigInteger(32);
  var arr4 = new byte[Dafny.Helpers.ToIntChecked(dim4,"C# array size must not be larger than max 32-bit int")];
  for (int i4 = 0; i4 < dim4; i4++) {
    var _18017_i = (BigInteger) i4;
    arr4[(int)(_18017_i)] = 0;
  }
  return Dafny.Sequence<byte>.FromArray(arr4);
}))()));
    }
    public static Materials.EncryptionMaterials WithoutDataKeys(Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext, ushort algorithmSuiteID, Wrappers_Compile.Option<Dafny.ISequence<byte>> signingKey)
    {
      Materials.EncryptionMaterials _18018_m = @Materials.EncryptionMaterials.create(encryptionContext, algorithmSuiteID, @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_None(), Dafny.Sequence<Materials.EncryptedDataKey>.FromElements(), signingKey);
      return _18018_m;
    }
    public Materials.EncryptionMaterials WithKeys(Wrappers_Compile.Option<Dafny.ISequence<byte>> newPlaintextDataKey, Dafny.ISequence<Materials.EncryptedDataKey> newEncryptedDataKeys)
    {
      Materials.EncryptionMaterials _18019_r = Dafny.Helpers.Let<Materials.EncryptionMaterials, Materials.EncryptionMaterials>(this, _pat_let1_0 => Dafny.Helpers.Let<Materials.EncryptionMaterials, Materials.EncryptionMaterials>(_pat_let1_0, _18020_dt__update__tmp_h0 => Dafny.Helpers.Let<Dafny.ISequence<Materials.EncryptedDataKey>, Materials.EncryptionMaterials>(Dafny.Sequence<Materials.EncryptedDataKey>.Concat((this).dtor_encryptedDataKeys, newEncryptedDataKeys), _pat_let2_0 => Dafny.Helpers.Let<Dafny.ISequence<Materials.EncryptedDataKey>, Materials.EncryptionMaterials>(_pat_let2_0, _18021_dt__update_hencryptedDataKeys_h0 => Dafny.Helpers.Let<Wrappers_Compile.Option<Dafny.ISequence<byte>>, Materials.EncryptionMaterials>(newPlaintextDataKey, _pat_let3_0 => Dafny.Helpers.Let<Wrappers_Compile.Option<Dafny.ISequence<byte>>, Materials.EncryptionMaterials>(_pat_let3_0, _18022_dt__update_hplaintextDataKey_h0 => @Materials.EncryptionMaterials.create((_18020_dt__update__tmp_h0).dtor_encryptionContext, (_18020_dt__update__tmp_h0).dtor_algorithmSuiteID, _18022_dt__update_hplaintextDataKey_h0, _18021_dt__update_hencryptedDataKeys_h0, (_18020_dt__update__tmp_h0).dtor_signingKey)))))));
      return _18019_r;
    }
  }

  public partial class ValidEncryptionMaterials {
    private static readonly Materials.EncryptionMaterials Witness = Materials.EncryptionMaterials.ValidWitness();
    public static Materials.EncryptionMaterials Default() {
      return Witness;
    }
    private static readonly Dafny.TypeDescriptor<Materials.EncryptionMaterials> _TYPE = new Dafny.TypeDescriptor<Materials.EncryptionMaterials>(Materials.ValidEncryptionMaterials.Default());
    public static Dafny.TypeDescriptor<Materials.EncryptionMaterials> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public partial class EmptyEncryptionMaterials {
    private static readonly Dafny.TypeDescriptor<Materials.EncryptionMaterials> _TYPE = new Dafny.TypeDescriptor<Materials.EncryptionMaterials>(Materials.EncryptionMaterials.Default());
    public static Dafny.TypeDescriptor<Materials.EncryptionMaterials> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public partial class UseableEncryptionMaterials {
    private static readonly Dafny.TypeDescriptor<Materials.EncryptionMaterials> _TYPE = new Dafny.TypeDescriptor<Materials.EncryptionMaterials>(Materials.EncryptionMaterials.Default());
    public static Dafny.TypeDescriptor<Materials.EncryptionMaterials> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public class DecryptionMaterials {
    public readonly ushort algorithmSuiteID;
    public readonly Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext;
    public readonly Wrappers_Compile.Option<Dafny.ISequence<byte>> plaintextDataKey;
    public readonly Wrappers_Compile.Option<Dafny.ISequence<byte>> verificationKey;
    public DecryptionMaterials(ushort algorithmSuiteID, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext, Wrappers_Compile.Option<Dafny.ISequence<byte>> plaintextDataKey, Wrappers_Compile.Option<Dafny.ISequence<byte>> verificationKey) {
      this.algorithmSuiteID = algorithmSuiteID;
      this.encryptionContext = encryptionContext;
      this.plaintextDataKey = plaintextDataKey;
      this.verificationKey = verificationKey;
    }
    public override bool Equals(object other) {
      var oth = other as Materials.DecryptionMaterials;
      return oth != null && this.algorithmSuiteID == oth.algorithmSuiteID && object.Equals(this.encryptionContext, oth.encryptionContext) && object.Equals(this.plaintextDataKey, oth.plaintextDataKey) && object.Equals(this.verificationKey, oth.verificationKey);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.algorithmSuiteID));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.encryptionContext));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.plaintextDataKey));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.verificationKey));
      return (int) hash;
    }
    public override string ToString() {
      string s = "Materials_Compile.DecryptionMaterials.DecryptionMaterials";
      s += "(";
      s += Dafny.Helpers.ToString(this.algorithmSuiteID);
      s += ", ";
      s += Dafny.Helpers.ToString(this.encryptionContext);
      s += ", ";
      s += Dafny.Helpers.ToString(this.plaintextDataKey);
      s += ", ";
      s += Dafny.Helpers.ToString(this.verificationKey);
      s += ")";
      return s;
    }
    private static readonly DecryptionMaterials theDefault = create(AlgorithmSuite.ID.Witness, Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Empty, Wrappers_Compile.Option<Dafny.ISequence<byte>>.Default(), Wrappers_Compile.Option<Dafny.ISequence<byte>>.Default());
    public static DecryptionMaterials Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<Materials.DecryptionMaterials> _TYPE = new Dafny.TypeDescriptor<Materials.DecryptionMaterials>(Materials.DecryptionMaterials.Default());
    public static Dafny.TypeDescriptor<Materials.DecryptionMaterials> _TypeDescriptor() {
      return _TYPE;
    }
    public static DecryptionMaterials create(ushort algorithmSuiteID, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext, Wrappers_Compile.Option<Dafny.ISequence<byte>> plaintextDataKey, Wrappers_Compile.Option<Dafny.ISequence<byte>> verificationKey) {
      return new DecryptionMaterials(algorithmSuiteID, encryptionContext, plaintextDataKey, verificationKey);
    }
    public bool is_DecryptionMaterials { get { return true; } }
    public ushort dtor_algorithmSuiteID {
      get {
        return this.algorithmSuiteID;
      }
    }
    public Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> dtor_encryptionContext {
      get {
        return this.encryptionContext;
      }
    }
    public Wrappers_Compile.Option<Dafny.ISequence<byte>> dtor_plaintextDataKey {
      get {
        return this.plaintextDataKey;
      }
    }
    public Wrappers_Compile.Option<Dafny.ISequence<byte>> dtor_verificationKey {
      get {
        return this.verificationKey;
      }
    }
    public static Materials.DecryptionMaterials ValidWitness() {
      return @Materials.DecryptionMaterials.create(AlgorithmSuite.__default.AES__256__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384, Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.FromElements(), @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(((System.Func<Dafny.ISequence<byte>>) (() => {
  BigInteger dim5 = new BigInteger(32);
  var arr5 = new byte[Dafny.Helpers.ToIntChecked(dim5,"C# array size must not be larger than max 32-bit int")];
  for (int i5 = 0; i5 < dim5; i5++) {
    var _18023_i = (BigInteger) i5;
    arr5[(int)(_18023_i)] = 0;
  }
  return Dafny.Sequence<byte>.FromArray(arr5);
}))()), @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(((System.Func<Dafny.ISequence<byte>>) (() => {
  BigInteger dim6 = new BigInteger(32);
  var arr6 = new byte[Dafny.Helpers.ToIntChecked(dim6,"C# array size must not be larger than max 32-bit int")];
  for (int i6 = 0; i6 < dim6; i6++) {
    var _18024_i = (BigInteger) i6;
    arr6[(int)(_18024_i)] = 0;
  }
  return Dafny.Sequence<byte>.FromArray(arr6);
}))()));
    }
    public static Materials.DecryptionMaterials WithoutPlaintextDataKey(Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext, ushort algorithmSuiteID, Wrappers_Compile.Option<Dafny.ISequence<byte>> verificationKey)
    {
      Materials.DecryptionMaterials _18025_m = @Materials.DecryptionMaterials.create(algorithmSuiteID, encryptionContext, @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_None(), verificationKey);
      return _18025_m;
    }
    public Materials.DecryptionMaterials WithPlaintextDataKey(Dafny.ISequence<byte> plaintextDataKey) {
      Materials.DecryptionMaterials _18026_m = Dafny.Helpers.Let<Materials.DecryptionMaterials, Materials.DecryptionMaterials>(this, _pat_let4_0 => Dafny.Helpers.Let<Materials.DecryptionMaterials, Materials.DecryptionMaterials>(_pat_let4_0, _18027_dt__update__tmp_h0 => Dafny.Helpers.Let<Wrappers_Compile.Option<Dafny.ISequence<byte>>, Materials.DecryptionMaterials>(@Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(plaintextDataKey), _pat_let5_0 => Dafny.Helpers.Let<Wrappers_Compile.Option<Dafny.ISequence<byte>>, Materials.DecryptionMaterials>(_pat_let5_0, _18028_dt__update_hplaintextDataKey_h0 => @Materials.DecryptionMaterials.create((_18027_dt__update__tmp_h0).dtor_algorithmSuiteID, (_18027_dt__update__tmp_h0).dtor_encryptionContext, _18028_dt__update_hplaintextDataKey_h0, (_18027_dt__update__tmp_h0).dtor_verificationKey)))));
      return _18026_m;
    }
  }

  public partial class PendingDecryptionMaterials {
    private static readonly Dafny.TypeDescriptor<Materials.DecryptionMaterials> _TYPE = new Dafny.TypeDescriptor<Materials.DecryptionMaterials>(Materials.DecryptionMaterials.Default());
    public static Dafny.TypeDescriptor<Materials.DecryptionMaterials> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public partial class CompleteDecryptionMaterials {
    private static readonly Dafny.TypeDescriptor<Materials.DecryptionMaterials> _TYPE = new Dafny.TypeDescriptor<Materials.DecryptionMaterials>(Materials.DecryptionMaterials.Default());
    public static Dafny.TypeDescriptor<Materials.DecryptionMaterials> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public partial class ValidDecryptionMaterials {
    private static readonly Materials.DecryptionMaterials Witness = Materials.DecryptionMaterials.ValidWitness();
    public static Materials.DecryptionMaterials Default() {
      return Witness;
    }
    private static readonly Dafny.TypeDescriptor<Materials.DecryptionMaterials> _TYPE = new Dafny.TypeDescriptor<Materials.DecryptionMaterials>(Materials.ValidDecryptionMaterials.Default());
    public static Dafny.TypeDescriptor<Materials.DecryptionMaterials> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public class EncryptionMaterialsRequest {
    public readonly Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext;
    public readonly Wrappers_Compile.Option<ushort> algorithmSuiteID;
    public readonly Wrappers_Compile.Option<BigInteger> plaintextLength;
    public EncryptionMaterialsRequest(Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext, Wrappers_Compile.Option<ushort> algorithmSuiteID, Wrappers_Compile.Option<BigInteger> plaintextLength) {
      this.encryptionContext = encryptionContext;
      this.algorithmSuiteID = algorithmSuiteID;
      this.plaintextLength = plaintextLength;
    }
    public override bool Equals(object other) {
      var oth = other as Materials.EncryptionMaterialsRequest;
      return oth != null && object.Equals(this.encryptionContext, oth.encryptionContext) && object.Equals(this.algorithmSuiteID, oth.algorithmSuiteID) && object.Equals(this.plaintextLength, oth.plaintextLength);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.encryptionContext));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.algorithmSuiteID));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.plaintextLength));
      return (int) hash;
    }
    public override string ToString() {
      string s = "Materials_Compile.EncryptionMaterialsRequest.EncryptionMaterialsRequest";
      s += "(";
      s += Dafny.Helpers.ToString(this.encryptionContext);
      s += ", ";
      s += Dafny.Helpers.ToString(this.algorithmSuiteID);
      s += ", ";
      s += Dafny.Helpers.ToString(this.plaintextLength);
      s += ")";
      return s;
    }
    private static readonly EncryptionMaterialsRequest theDefault = create(Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Empty, Wrappers_Compile.Option<ushort>.Default(), Wrappers_Compile.Option<BigInteger>.Default());
    public static EncryptionMaterialsRequest Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<Materials.EncryptionMaterialsRequest> _TYPE = new Dafny.TypeDescriptor<Materials.EncryptionMaterialsRequest>(Materials.EncryptionMaterialsRequest.Default());
    public static Dafny.TypeDescriptor<Materials.EncryptionMaterialsRequest> _TypeDescriptor() {
      return _TYPE;
    }
    public static EncryptionMaterialsRequest create(Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext, Wrappers_Compile.Option<ushort> algorithmSuiteID, Wrappers_Compile.Option<BigInteger> plaintextLength) {
      return new EncryptionMaterialsRequest(encryptionContext, algorithmSuiteID, plaintextLength);
    }
    public bool is_EncryptionMaterialsRequest { get { return true; } }
    public Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> dtor_encryptionContext {
      get {
        return this.encryptionContext;
      }
    }
    public Wrappers_Compile.Option<ushort> dtor_algorithmSuiteID {
      get {
        return this.algorithmSuiteID;
      }
    }
    public Wrappers_Compile.Option<BigInteger> dtor_plaintextLength {
      get {
        return this.plaintextLength;
      }
    }
  }

  public class DecryptionMaterialsRequest {
    public readonly ushort algorithmSuiteID;
    public readonly Dafny.ISequence<Materials.EncryptedDataKey> encryptedDataKeys;
    public readonly Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext;
    public DecryptionMaterialsRequest(ushort algorithmSuiteID, Dafny.ISequence<Materials.EncryptedDataKey> encryptedDataKeys, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext) {
      this.algorithmSuiteID = algorithmSuiteID;
      this.encryptedDataKeys = encryptedDataKeys;
      this.encryptionContext = encryptionContext;
    }
    public override bool Equals(object other) {
      var oth = other as Materials.DecryptionMaterialsRequest;
      return oth != null && this.algorithmSuiteID == oth.algorithmSuiteID && object.Equals(this.encryptedDataKeys, oth.encryptedDataKeys) && object.Equals(this.encryptionContext, oth.encryptionContext);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.algorithmSuiteID));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.encryptedDataKeys));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.encryptionContext));
      return (int) hash;
    }
    public override string ToString() {
      string s = "Materials_Compile.DecryptionMaterialsRequest.DecryptionMaterialsRequest";
      s += "(";
      s += Dafny.Helpers.ToString(this.algorithmSuiteID);
      s += ", ";
      s += Dafny.Helpers.ToString(this.encryptedDataKeys);
      s += ", ";
      s += Dafny.Helpers.ToString(this.encryptionContext);
      s += ")";
      return s;
    }
    private static readonly DecryptionMaterialsRequest theDefault = create(AlgorithmSuite.ID.Witness, Dafny.Sequence<Materials.EncryptedDataKey>.Empty, Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Empty);
    public static DecryptionMaterialsRequest Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<Materials.DecryptionMaterialsRequest> _TYPE = new Dafny.TypeDescriptor<Materials.DecryptionMaterialsRequest>(Materials.DecryptionMaterialsRequest.Default());
    public static Dafny.TypeDescriptor<Materials.DecryptionMaterialsRequest> _TypeDescriptor() {
      return _TYPE;
    }
    public static DecryptionMaterialsRequest create(ushort algorithmSuiteID, Dafny.ISequence<Materials.EncryptedDataKey> encryptedDataKeys, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext) {
      return new DecryptionMaterialsRequest(algorithmSuiteID, encryptedDataKeys, encryptionContext);
    }
    public bool is_DecryptionMaterialsRequest { get { return true; } }
    public ushort dtor_algorithmSuiteID {
      get {
        return this.algorithmSuiteID;
      }
    }
    public Dafny.ISequence<Materials.EncryptedDataKey> dtor_encryptedDataKeys {
      get {
        return this.encryptedDataKeys;
      }
    }
    public Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> dtor_encryptionContext {
      get {
        return this.encryptionContext;
      }
    }
    public static Materials.DecryptionMaterialsRequest ValidWitness() {
      return @Materials.DecryptionMaterialsRequest.create(AlgorithmSuite.__default.AES__256__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384, Dafny.Sequence<Materials.EncryptedDataKey>.FromElements(Materials.EncryptedDataKey.ValidWitness()), Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.FromElements());
    }
  }

  public partial class ValidDecryptionMaterialsRequest {
    private static readonly Materials.DecryptionMaterialsRequest Witness = Materials.DecryptionMaterialsRequest.ValidWitness();
    public static Materials.DecryptionMaterialsRequest Default() {
      return Witness;
    }
    private static readonly Dafny.TypeDescriptor<Materials.DecryptionMaterialsRequest> _TYPE = new Dafny.TypeDescriptor<Materials.DecryptionMaterialsRequest>(Materials.ValidDecryptionMaterialsRequest.Default());
    public static Dafny.TypeDescriptor<Materials.DecryptionMaterialsRequest> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public partial class __default {
    public static Dafny.ISequence<byte> EC__PUBLIC__KEY__FIELD { get {
      Dafny.ISequence<byte> _18029_s = Dafny.Sequence<byte>.FromElements(97, 119, 115, 45, 99, 114, 121, 112, 116, 111, 45, 112, 117, 98, 108, 105, 99, 45, 107, 101, 121);
      return _18029_s;
    } }
    public static Dafny.ISet<Dafny.ISequence<byte>> RESERVED__KEY__VALUES { get {
      return Dafny.Set<Dafny.ISequence<byte>>.FromElements(Materials.__default.EC__PUBLIC__KEY__FIELD);
    } }
  }
} // end of namespace Materials
namespace Base64_Compile {



  public partial class index {
    public static System.Collections.Generic.IEnumerable<byte> IntegerRange(BigInteger lo, BigInteger hi) {
      for (var j = lo; j < hi; j++) { yield return (byte)j; }
    }
    private static readonly Dafny.TypeDescriptor<byte> _TYPE = new Dafny.TypeDescriptor<byte>(0);
    public static Dafny.TypeDescriptor<byte> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public partial class uint24 {
    public static System.Collections.Generic.IEnumerable<uint> IntegerRange(BigInteger lo, BigInteger hi) {
      for (var j = lo; j < hi; j++) { yield return (uint)j; }
    }
    private static readonly Dafny.TypeDescriptor<uint> _TYPE = new Dafny.TypeDescriptor<uint>(0);
    public static Dafny.TypeDescriptor<uint> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public partial class __default {
    public static bool IsBase64Char(char c) {
      return (((((c) == ('+')) || ((c) == ('/'))) || ((('0') <= (c)) && ((c) <= ('9')))) || ((('A') <= (c)) && ((c) <= ('Z')))) || ((('a') <= (c)) && ((c) <= ('z')));
    }
    public static bool IsUnpaddedBase64String(Dafny.ISequence<char> s) {
      return ((Dafny.Helpers.EuclideanModulus(new BigInteger((s).Count), new BigInteger(4))).Sign == 0) && (Dafny.Helpers.Id<Func<Dafny.ISequence<char>, bool>>((_18030_s) => Dafny.Helpers.Quantifier<char>((_18030_s).UniqueElements, true, (((_18031_k) => {
        return !((_18030_s).Contains((_18031_k))) || (Base64_Compile.__default.IsBase64Char(_18031_k));
      }))))(s));
    }
    public static char IndexToChar(byte i) {
      if ((i) == (63)) {
        return '/';
      } else if ((i) == (62)) {
        return '+';
      } else if (((52) <= (i)) && ((i) <= (61))) {
        return (char)((byte)((i) - (4)));
      } else if (((26) <= (i)) && ((i) <= (51))) {
        return (char)(((char)(i)) + ((char)(new BigInteger(71))));
      } else {
        return (char)(((char)(i)) + ((char)(new BigInteger(65))));
      }
    }
    public static byte CharToIndex(char c) {
      if ((c) == ('/')) {
        return 63;
      } else if ((c) == ('+')) {
        return 62;
      } else if ((('0') <= (c)) && ((c) <= ('9'))) {
        return (byte)((char)((c) + ((char)(new BigInteger(4)))));
      } else if ((('a') <= (c)) && ((c) <= ('z'))) {
        return (byte)((char)((c) - ((char)(new BigInteger(71)))));
      } else {
        return (byte)((char)((c) - ((char)(new BigInteger(65)))));
      }
    }
    public static Dafny.ISequence<byte> UInt24ToSeq(uint x) {
      byte _18032_b0 = (byte)((x) / (65536U));
      uint _18033_x0 = (x) - (((uint)(_18032_b0)) * (65536U));
      byte _18034_b1 = (byte)((_18033_x0) / (256U));
      byte _18035_b2 = (byte)((_18033_x0) % (256U));
      return Dafny.Sequence<byte>.FromElements(_18032_b0, _18034_b1, _18035_b2);
    }
    public static uint SeqToUInt24(Dafny.ISequence<byte> s) {
      return ((((uint)((s).Select(BigInteger.Zero))) * (65536U)) + (((uint)((s).Select(BigInteger.One))) * (256U))) + ((uint)((s).Select(new BigInteger(2))));
    }
    public static Dafny.ISequence<byte> UInt24ToIndexSeq(uint x) {
      byte _18036_b0 = (byte)((x) / (262144U));
      uint _18037_x0 = (x) - (((uint)(_18036_b0)) * (262144U));
      byte _18038_b1 = (byte)((_18037_x0) / (4096U));
      uint _18039_x1 = (_18037_x0) - (((uint)(_18038_b1)) * (4096U));
      byte _18040_b2 = (byte)((_18039_x1) / (64U));
      byte _18041_b3 = (byte)((_18039_x1) % (64U));
      return Dafny.Sequence<byte>.FromElements(_18036_b0, _18038_b1, _18040_b2, _18041_b3);
    }
    public static uint IndexSeqToUInt24(Dafny.ISequence<byte> s) {
      return (((((uint)((s).Select(BigInteger.Zero))) * (262144U)) + (((uint)((s).Select(BigInteger.One))) * (4096U))) + (((uint)((s).Select(new BigInteger(2)))) * (64U))) + ((uint)((s).Select(new BigInteger(3))));
    }
    public static Dafny.ISequence<byte> DecodeBlock(Dafny.ISequence<byte> s) {
      return Base64_Compile.__default.UInt24ToSeq(Base64_Compile.__default.IndexSeqToUInt24(s));
    }
    public static Dafny.ISequence<byte> EncodeBlock(Dafny.ISequence<byte> s) {
      return Base64_Compile.__default.UInt24ToIndexSeq(Base64_Compile.__default.SeqToUInt24(s));
    }
    public static Dafny.ISequence<byte> DecodeRecursively(Dafny.ISequence<byte> s) {
      Dafny.ISequence<byte> _18042___accumulator = Dafny.Sequence<byte>.FromElements();
    TAIL_CALL_START: ;
      if ((new BigInteger((s).Count)).Sign == 0) {
        return Dafny.Sequence<byte>.Concat(_18042___accumulator, Dafny.Sequence<byte>.FromElements());
      } else {
        _18042___accumulator = Dafny.Sequence<byte>.Concat(_18042___accumulator, Base64_Compile.__default.DecodeBlock((s).Take(new BigInteger(4))));
        Dafny.ISequence<byte> _in33 = (s).Drop(new BigInteger(4));
        s = _in33;
        goto TAIL_CALL_START;
      }
    }
    public static Dafny.ISequence<byte> EncodeRecursively(Dafny.ISequence<byte> b) {
      Dafny.ISequence<byte> _18043___accumulator = Dafny.Sequence<byte>.FromElements();
    TAIL_CALL_START: ;
      if ((new BigInteger((b).Count)).Sign == 0) {
        return Dafny.Sequence<byte>.Concat(_18043___accumulator, Dafny.Sequence<byte>.FromElements());
      } else {
        _18043___accumulator = Dafny.Sequence<byte>.Concat(_18043___accumulator, Base64_Compile.__default.EncodeBlock((b).Take(new BigInteger(3))));
        Dafny.ISequence<byte> _in34 = (b).Drop(new BigInteger(3));
        b = _in34;
        goto TAIL_CALL_START;
      }
    }
    public static Dafny.ISequence<byte> FromCharsToIndices(Dafny.ISequence<char> s) {
      return ((System.Func<Dafny.ISequence<byte>>) (() => {
        BigInteger dim7 = new BigInteger((s).Count);
        var arr7 = new byte[Dafny.Helpers.ToIntChecked(dim7,"C# array size must not be larger than max 32-bit int")];
        for (int i7 = 0; i7 < dim7; i7++) {
          var _18044_i = (BigInteger) i7;
          arr7[(int)(_18044_i)] = Base64_Compile.__default.CharToIndex((s).Select(_18044_i));
        }
        return Dafny.Sequence<byte>.FromArray(arr7);
      }))();
    }
    public static Dafny.ISequence<char> FromIndicesToChars(Dafny.ISequence<byte> b) {
      return ((System.Func<Dafny.ISequence<char>>) (() => {
        BigInteger dim8 = new BigInteger((b).Count);
        var arr8 = new char[Dafny.Helpers.ToIntChecked(dim8,"C# array size must not be larger than max 32-bit int")];
        for (int i8 = 0; i8 < dim8; i8++) {
          var _18045_i = (BigInteger) i8;
          arr8[(int)(_18045_i)] = Base64_Compile.__default.IndexToChar((b).Select(_18045_i));
        }
        return Dafny.Sequence<char>.FromArray(arr8);
      }))();
    }
    public static Dafny.ISequence<byte> DecodeUnpadded(Dafny.ISequence<char> s) {
      return Base64_Compile.__default.DecodeRecursively(Base64_Compile.__default.FromCharsToIndices(s));
    }
    public static Dafny.ISequence<char> EncodeUnpadded(Dafny.ISequence<byte> b) {
      return Base64_Compile.__default.FromIndicesToChars(Base64_Compile.__default.EncodeRecursively(b));
    }
    public static bool Is1Padding(Dafny.ISequence<char> s) {
      return ((((((new BigInteger((s).Count)) == (new BigInteger(4))) && (Base64_Compile.__default.IsBase64Char((s).Select(BigInteger.Zero)))) && (Base64_Compile.__default.IsBase64Char((s).Select(BigInteger.One)))) && (Base64_Compile.__default.IsBase64Char((s).Select(new BigInteger(2))))) && (((byte)((Base64_Compile.__default.CharToIndex((s).Select(new BigInteger(2)))) % (4))) == (0))) && (((s).Select(new BigInteger(3))) == ('='));
    }
    public static Dafny.ISequence<byte> Decode1Padding(Dafny.ISequence<char> s) {
      Dafny.ISequence<byte> _18046_d = Base64_Compile.__default.DecodeBlock(Dafny.Sequence<byte>.FromElements(Base64_Compile.__default.CharToIndex((s).Select(BigInteger.Zero)), Base64_Compile.__default.CharToIndex((s).Select(BigInteger.One)), Base64_Compile.__default.CharToIndex((s).Select(new BigInteger(2))), 0));
      return Dafny.Sequence<byte>.FromElements((_18046_d).Select(BigInteger.Zero), (_18046_d).Select(BigInteger.One));
    }
    public static Dafny.ISequence<char> Encode1Padding(Dafny.ISequence<byte> b) {
      Dafny.ISequence<byte> _18047_e = Base64_Compile.__default.EncodeBlock(Dafny.Sequence<byte>.FromElements((b).Select(BigInteger.Zero), (b).Select(BigInteger.One), 0));
      return Dafny.Sequence<char>.FromElements(Base64_Compile.__default.IndexToChar((_18047_e).Select(BigInteger.Zero)), Base64_Compile.__default.IndexToChar((_18047_e).Select(BigInteger.One)), Base64_Compile.__default.IndexToChar((_18047_e).Select(new BigInteger(2))), '=');
    }
    public static bool Is2Padding(Dafny.ISequence<char> s) {
      return ((((((new BigInteger((s).Count)) == (new BigInteger(4))) && (Base64_Compile.__default.IsBase64Char((s).Select(BigInteger.Zero)))) && (Base64_Compile.__default.IsBase64Char((s).Select(BigInteger.One)))) && (((byte)((Base64_Compile.__default.CharToIndex((s).Select(BigInteger.One))) % (16))) == (0))) && (((s).Select(new BigInteger(2))) == ('='))) && (((s).Select(new BigInteger(3))) == ('='));
    }
    public static Dafny.ISequence<byte> Decode2Padding(Dafny.ISequence<char> s) {
      Dafny.ISequence<byte> _18048_d = Base64_Compile.__default.DecodeBlock(Dafny.Sequence<byte>.FromElements(Base64_Compile.__default.CharToIndex((s).Select(BigInteger.Zero)), Base64_Compile.__default.CharToIndex((s).Select(BigInteger.One)), 0, 0));
      return Dafny.Sequence<byte>.FromElements((_18048_d).Select(BigInteger.Zero));
    }
    public static Dafny.ISequence<char> Encode2Padding(Dafny.ISequence<byte> b) {
      Dafny.ISequence<byte> _18049_e = Base64_Compile.__default.EncodeBlock(Dafny.Sequence<byte>.FromElements((b).Select(BigInteger.Zero), 0, 0));
      return Dafny.Sequence<char>.FromElements(Base64_Compile.__default.IndexToChar((_18049_e).Select(BigInteger.Zero)), Base64_Compile.__default.IndexToChar((_18049_e).Select(BigInteger.One)), '=', '=');
    }
    public static bool IsBase64String(Dafny.ISequence<char> s) {
      BigInteger _18050_finalBlockStart = (new BigInteger((s).Count)) - (new BigInteger(4));
      return ((Dafny.Helpers.EuclideanModulus(new BigInteger((s).Count), new BigInteger(4))).Sign == 0) && ((Base64_Compile.__default.IsUnpaddedBase64String(s)) || ((Base64_Compile.__default.IsUnpaddedBase64String((s).Take(_18050_finalBlockStart))) && ((Base64_Compile.__default.Is1Padding((s).Drop(_18050_finalBlockStart))) || (Base64_Compile.__default.Is2Padding((s).Drop(_18050_finalBlockStart))))));
    }
    public static Dafny.ISequence<byte> DecodeValid(Dafny.ISequence<char> s) {
      if ((s).Equals((Dafny.Sequence<char>.FromElements()))) {
        return Dafny.Sequence<byte>.FromElements();
      } else {
        BigInteger _18051_finalBlockStart = (new BigInteger((s).Count)) - (new BigInteger(4));
        Dafny.ISequence<char> _18052_prefix = (s).Take(_18051_finalBlockStart);
        Dafny.ISequence<char> _18053_suffix = (s).Drop(_18051_finalBlockStart);
        if (Base64_Compile.__default.Is1Padding(_18053_suffix)) {
          return Dafny.Sequence<byte>.Concat(Base64_Compile.__default.DecodeUnpadded(_18052_prefix), Base64_Compile.__default.Decode1Padding(_18053_suffix));
        } else if (Base64_Compile.__default.Is2Padding(_18053_suffix)) {
          return Dafny.Sequence<byte>.Concat(Base64_Compile.__default.DecodeUnpadded(_18052_prefix), Base64_Compile.__default.Decode2Padding(_18053_suffix));
        } else {
          return Base64_Compile.__default.DecodeUnpadded(s);
        }
      }
    }
    public static Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> Decode(Dafny.ISequence<char> s) {
      if (Base64_Compile.__default.IsBase64String(s)) {
        return @Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.create_Success(Base64_Compile.__default.DecodeValid(s));
      } else {
        return @Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("The encoding is malformed"));
      }
    }
    public static Dafny.ISequence<char> Encode(Dafny.ISequence<byte> b) {
      if ((Dafny.Helpers.EuclideanModulus(new BigInteger((b).Count), new BigInteger(3))).Sign == 0) {
        return Base64_Compile.__default.EncodeUnpadded(b);
      } else if ((Dafny.Helpers.EuclideanModulus(new BigInteger((b).Count), new BigInteger(3))) == (BigInteger.One)) {
        return Dafny.Sequence<char>.Concat(Base64_Compile.__default.EncodeUnpadded((b).Take((new BigInteger((b).Count)) - (BigInteger.One))), Base64_Compile.__default.Encode2Padding((b).Drop((new BigInteger((b).Count)) - (BigInteger.One))));
      } else {
        return Dafny.Sequence<char>.Concat(Base64_Compile.__default.EncodeUnpadded((b).Take((new BigInteger((b).Count)) - (new BigInteger(2)))), Base64_Compile.__default.Encode1Padding((b).Drop((new BigInteger((b).Count)) - (new BigInteger(2)))));
      }
    }
  }
} // end of namespace Base64_Compile
namespace MessageHeader {










  public class Header {
    public readonly MessageHeader.HeaderBody body;
    public readonly MessageHeader.HeaderAuthentication auth;
    public Header(MessageHeader.HeaderBody body, MessageHeader.HeaderAuthentication auth) {
      this.body = body;
      this.auth = auth;
    }
    public override bool Equals(object other) {
      var oth = other as MessageHeader.Header;
      return oth != null && object.Equals(this.body, oth.body) && object.Equals(this.auth, oth.auth);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.body));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.auth));
      return (int) hash;
    }
    public override string ToString() {
      string s = "MessageHeader_Compile.Header.Header";
      s += "(";
      s += Dafny.Helpers.ToString(this.body);
      s += ", ";
      s += Dafny.Helpers.ToString(this.auth);
      s += ")";
      return s;
    }
    private static readonly Header theDefault = create(MessageHeader.HeaderBody.Default(), MessageHeader.HeaderAuthentication.Default());
    public static Header Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<MessageHeader.Header> _TYPE = new Dafny.TypeDescriptor<MessageHeader.Header>(MessageHeader.Header.Default());
    public static Dafny.TypeDescriptor<MessageHeader.Header> _TypeDescriptor() {
      return _TYPE;
    }
    public static Header create(MessageHeader.HeaderBody body, MessageHeader.HeaderAuthentication auth) {
      return new Header(body, auth);
    }
    public bool is_Header { get { return true; } }
    public MessageHeader.HeaderBody dtor_body {
      get {
        return this.body;
      }
    }
    public MessageHeader.HeaderAuthentication dtor_auth {
      get {
        return this.auth;
      }
    }
  }

  public partial class Version {
    private static readonly byte Witness = MessageHeader.__default.VERSION__1;
    public static byte Default() {
      return Witness;
    }
    private static readonly Dafny.TypeDescriptor<byte> _TYPE = new Dafny.TypeDescriptor<byte>(MessageHeader.Version.Default());
    public static Dafny.TypeDescriptor<byte> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public partial class Type {
    private static readonly byte Witness = MessageHeader.__default.TYPE__CUSTOMER__AED;
    public static byte Default() {
      return Witness;
    }
    private static readonly Dafny.TypeDescriptor<byte> _TYPE = new Dafny.TypeDescriptor<byte>(MessageHeader.Type.Default());
    public static Dafny.TypeDescriptor<byte> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public partial class MessageID {
    private static readonly Dafny.ISequence<byte> Witness = Dafny.Sequence<byte>.FromElements(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    public static Dafny.ISequence<byte> Default() {
      return Witness;
    }
    private static readonly Dafny.TypeDescriptor<Dafny.ISequence<byte>> _TYPE = new Dafny.TypeDescriptor<Dafny.ISequence<byte>>(MessageHeader.MessageID.Default());
    public static Dafny.TypeDescriptor<Dafny.ISequence<byte>> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public abstract class ContentType {
    public ContentType() { }
    private static readonly ContentType theDefault = create_NonFramed();
    public static ContentType Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<MessageHeader.ContentType> _TYPE = new Dafny.TypeDescriptor<MessageHeader.ContentType>(MessageHeader.ContentType.Default());
    public static Dafny.TypeDescriptor<MessageHeader.ContentType> _TypeDescriptor() {
      return _TYPE;
    }
    public static ContentType create_NonFramed() {
      return new ContentType_NonFramed();
    }
    public static ContentType create_Framed() {
      return new ContentType_Framed();
    }
    public bool is_NonFramed { get { return this is ContentType_NonFramed; } }
    public bool is_Framed { get { return this is ContentType_Framed; } }
    public static System.Collections.Generic.IEnumerable<ContentType> AllSingletonConstructors {
      get {
        yield return ContentType.create_NonFramed();
        yield return ContentType.create_Framed();
      }
    }
  }
  public class ContentType_NonFramed : ContentType {
    public ContentType_NonFramed() {
    }
    public override bool Equals(object other) {
      var oth = other as MessageHeader.ContentType_NonFramed;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      return (int) hash;
    }
    public override string ToString() {
      string s = "MessageHeader_Compile.ContentType.NonFramed";
      return s;
    }
  }
  public class ContentType_Framed : ContentType {
    public ContentType_Framed() {
    }
    public override bool Equals(object other) {
      var oth = other as MessageHeader.ContentType_Framed;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      return (int) hash;
    }
    public override string ToString() {
      string s = "MessageHeader_Compile.ContentType.Framed";
      return s;
    }
  }

  public class EncryptedDataKeys {
    public readonly Dafny.ISequence<Dafny.Aws.Crypto.EncryptedDataKey> entries;
    public EncryptedDataKeys(Dafny.ISequence<Dafny.Aws.Crypto.EncryptedDataKey> entries) {
      this.entries = entries;
    }
    public override bool Equals(object other) {
      var oth = other as MessageHeader.EncryptedDataKeys;
      return oth != null && object.Equals(this.entries, oth.entries);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.entries));
      return (int) hash;
    }
    public override string ToString() {
      string s = "MessageHeader_Compile.EncryptedDataKeys.EncryptedDataKeys";
      s += "(";
      s += Dafny.Helpers.ToString(this.entries);
      s += ")";
      return s;
    }
    private static readonly EncryptedDataKeys theDefault = create(Dafny.Sequence<Dafny.Aws.Crypto.EncryptedDataKey>.Empty);
    public static EncryptedDataKeys Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<MessageHeader.EncryptedDataKeys> _TYPE = new Dafny.TypeDescriptor<MessageHeader.EncryptedDataKeys>(MessageHeader.EncryptedDataKeys.Default());
    public static Dafny.TypeDescriptor<MessageHeader.EncryptedDataKeys> _TypeDescriptor() {
      return _TYPE;
    }
    public static EncryptedDataKeys create(Dafny.ISequence<Dafny.Aws.Crypto.EncryptedDataKey> entries) {
      return new EncryptedDataKeys(entries);
    }
    public bool is_EncryptedDataKeys { get { return true; } }
    public Dafny.ISequence<Dafny.Aws.Crypto.EncryptedDataKey> dtor_entries {
      get {
        return this.entries;
      }
    }
  }

  public class HeaderBody {
    public readonly byte version;
    public readonly byte typ;
    public readonly ushort algorithmSuiteID;
    public readonly Dafny.ISequence<byte> messageID;
    public readonly Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> aad;
    public readonly MessageHeader.EncryptedDataKeys encryptedDataKeys;
    public readonly MessageHeader.ContentType contentType;
    public readonly byte ivLength;
    public readonly uint frameLength;
    public HeaderBody(byte version, byte typ, ushort algorithmSuiteID, Dafny.ISequence<byte> messageID, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> aad, MessageHeader.EncryptedDataKeys encryptedDataKeys, MessageHeader.ContentType contentType, byte ivLength, uint frameLength) {
      this.version = version;
      this.typ = typ;
      this.algorithmSuiteID = algorithmSuiteID;
      this.messageID = messageID;
      this.aad = aad;
      this.encryptedDataKeys = encryptedDataKeys;
      this.contentType = contentType;
      this.ivLength = ivLength;
      this.frameLength = frameLength;
    }
    public override bool Equals(object other) {
      var oth = other as MessageHeader.HeaderBody;
      return oth != null && this.version == oth.version && this.typ == oth.typ && this.algorithmSuiteID == oth.algorithmSuiteID && object.Equals(this.messageID, oth.messageID) && object.Equals(this.aad, oth.aad) && object.Equals(this.encryptedDataKeys, oth.encryptedDataKeys) && object.Equals(this.contentType, oth.contentType) && this.ivLength == oth.ivLength && this.frameLength == oth.frameLength;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.version));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.typ));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.algorithmSuiteID));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.messageID));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.aad));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.encryptedDataKeys));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.contentType));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.ivLength));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.frameLength));
      return (int) hash;
    }
    public override string ToString() {
      string s = "MessageHeader_Compile.HeaderBody.HeaderBody";
      s += "(";
      s += Dafny.Helpers.ToString(this.version);
      s += ", ";
      s += Dafny.Helpers.ToString(this.typ);
      s += ", ";
      s += Dafny.Helpers.ToString(this.algorithmSuiteID);
      s += ", ";
      s += Dafny.Helpers.ToString(this.messageID);
      s += ", ";
      s += Dafny.Helpers.ToString(this.aad);
      s += ", ";
      s += Dafny.Helpers.ToString(this.encryptedDataKeys);
      s += ", ";
      s += Dafny.Helpers.ToString(this.contentType);
      s += ", ";
      s += Dafny.Helpers.ToString(this.ivLength);
      s += ", ";
      s += Dafny.Helpers.ToString(this.frameLength);
      s += ")";
      return s;
    }
    private static readonly HeaderBody theDefault = create(MessageHeader.Version.Default(), MessageHeader.Type.Default(), AlgorithmSuite.ID.Witness, MessageHeader.MessageID.Default(), Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Empty, MessageHeader.EncryptedDataKeys.Default(), MessageHeader.ContentType.Default(), 0, 0);
    public static HeaderBody Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<MessageHeader.HeaderBody> _TYPE = new Dafny.TypeDescriptor<MessageHeader.HeaderBody>(MessageHeader.HeaderBody.Default());
    public static Dafny.TypeDescriptor<MessageHeader.HeaderBody> _TypeDescriptor() {
      return _TYPE;
    }
    public static HeaderBody create(byte version, byte typ, ushort algorithmSuiteID, Dafny.ISequence<byte> messageID, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> aad, MessageHeader.EncryptedDataKeys encryptedDataKeys, MessageHeader.ContentType contentType, byte ivLength, uint frameLength) {
      return new HeaderBody(version, typ, algorithmSuiteID, messageID, aad, encryptedDataKeys, contentType, ivLength, frameLength);
    }
    public bool is_HeaderBody { get { return true; } }
    public byte dtor_version {
      get {
        return this.version;
      }
    }
    public byte dtor_typ {
      get {
        return this.typ;
      }
    }
    public ushort dtor_algorithmSuiteID {
      get {
        return this.algorithmSuiteID;
      }
    }
    public Dafny.ISequence<byte> dtor_messageID {
      get {
        return this.messageID;
      }
    }
    public Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> dtor_aad {
      get {
        return this.aad;
      }
    }
    public MessageHeader.EncryptedDataKeys dtor_encryptedDataKeys {
      get {
        return this.encryptedDataKeys;
      }
    }
    public MessageHeader.ContentType dtor_contentType {
      get {
        return this.contentType;
      }
    }
    public byte dtor_ivLength {
      get {
        return this.ivLength;
      }
    }
    public uint dtor_frameLength {
      get {
        return this.frameLength;
      }
    }
  }

  public class HeaderAuthentication {
    public readonly Dafny.ISequence<byte> iv;
    public readonly Dafny.ISequence<byte> authenticationTag;
    public HeaderAuthentication(Dafny.ISequence<byte> iv, Dafny.ISequence<byte> authenticationTag) {
      this.iv = iv;
      this.authenticationTag = authenticationTag;
    }
    public override bool Equals(object other) {
      var oth = other as MessageHeader.HeaderAuthentication;
      return oth != null && object.Equals(this.iv, oth.iv) && object.Equals(this.authenticationTag, oth.authenticationTag);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.iv));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.authenticationTag));
      return (int) hash;
    }
    public override string ToString() {
      string s = "MessageHeader_Compile.HeaderAuthentication.HeaderAuthentication";
      s += "(";
      s += Dafny.Helpers.ToString(this.iv);
      s += ", ";
      s += Dafny.Helpers.ToString(this.authenticationTag);
      s += ")";
      return s;
    }
    private static readonly HeaderAuthentication theDefault = create(Dafny.Sequence<byte>.Empty, Dafny.Sequence<byte>.Empty);
    public static HeaderAuthentication Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<MessageHeader.HeaderAuthentication> _TYPE = new Dafny.TypeDescriptor<MessageHeader.HeaderAuthentication>(MessageHeader.HeaderAuthentication.Default());
    public static Dafny.TypeDescriptor<MessageHeader.HeaderAuthentication> _TypeDescriptor() {
      return _TYPE;
    }
    public static HeaderAuthentication create(Dafny.ISequence<byte> iv, Dafny.ISequence<byte> authenticationTag) {
      return new HeaderAuthentication(iv, authenticationTag);
    }
    public bool is_HeaderAuthentication { get { return true; } }
    public Dafny.ISequence<byte> dtor_iv {
      get {
        return this.iv;
      }
    }
    public Dafny.ISequence<byte> dtor_authenticationTag {
      get {
        return this.authenticationTag;
      }
    }
  }

  public partial class __default {
    public static byte ContentTypeToUInt8(MessageHeader.ContentType contentType) {
      MessageHeader.ContentType _source16 = contentType;
      if (_source16.is_NonFramed) {
        return 1;
      } else {
        return 2;
      }
    }
    public static Wrappers_Compile.Option<MessageHeader.ContentType> UInt8ToContentType(byte x) {
      if ((x) == (1)) {
        return @Wrappers_Compile.Option<MessageHeader.ContentType>.create_Some(@MessageHeader.ContentType.create_NonFramed());
      } else if ((x) == (2)) {
        return @Wrappers_Compile.Option<MessageHeader.ContentType>.create_Some(@MessageHeader.ContentType.create_Framed());
      } else {
        return @Wrappers_Compile.Option<MessageHeader.ContentType>.create_None();
      }
    }
    public static Dafny.ISequence<byte> EDKEntryToSeq(Dafny.Aws.Crypto.EncryptedDataKey edk) {
      return Dafny.Sequence<byte>.Concat(Dafny.Sequence<byte>.Concat(Dafny.Sequence<byte>.Concat(Dafny.Sequence<byte>.Concat(Dafny.Sequence<byte>.Concat(StandardLibrary_mUInt_Compile.__default.UInt16ToSeq((ushort)((edk).dtor_keyProviderId).Count), (edk).dtor_keyProviderId), StandardLibrary_mUInt_Compile.__default.UInt16ToSeq((ushort)((edk).dtor_keyProviderInfo).Count)), (edk).dtor_keyProviderInfo), StandardLibrary_mUInt_Compile.__default.UInt16ToSeq((ushort)((edk).dtor_ciphertext).Count)), (edk).dtor_ciphertext);
    }
    public static byte VERSION__1 { get {
      return 1;
    } }
    public static byte TYPE__CUSTOMER__AED { get {
      return 128;
    } }
    public static BigInteger MESSAGE__ID__LEN { get {
      return new BigInteger(16);
    } }
    public static Dafny.ISequence<byte> Reserved { get {
      return Dafny.Sequence<byte>.FromElements(0, 0, 0, 0);
    } }
  }
} // end of namespace MessageHeader
namespace Streams_Compile {



  public partial class SeqReader<T> {
    public SeqReader() {
      this.pos = BigInteger.Zero;
      this._data = Dafny.Sequence<T>.Empty;
    }
    public BigInteger pos;public void __ctor(Dafny.ISequence<T> s)
    {
      (this)._data = s;
      (this).pos = BigInteger.Zero;
    }
    public Dafny.ISequence<T> ReadElements(BigInteger n)
    {
      Dafny.ISequence<T> elems = Dafny.Sequence<T>.Empty;
      elems = (((this).data).Drop(this.pos)).Take(n);
      (this).pos = (this.pos) + (n);
      elems = elems;
      return elems;
      return elems;
    }
    public Wrappers_Compile.Result<Dafny.ISequence<T>, Dafny.ISequence<char>> ReadExact(BigInteger n)
    {
      Wrappers_Compile.Result<Dafny.ISequence<T>, Dafny.ISequence<char>> res = Wrappers_Compile.Result<Dafny.ISequence<T>, Dafny.ISequence<char>>.Default(Dafny.Sequence<T>.Empty);
      if ((n) > ((new BigInteger(((this).data).Count)) - (this.pos))) {
        res = @Wrappers_Compile.Result<Dafny.ISequence<T>, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("IO Error: Not enough elements left on stream."));
        return res;
      } else {
        Dafny.ISequence<T> _18054_elements;
        Dafny.ISequence<T> _out16;
        _out16 = (this).ReadElements(n);
        _18054_elements = _out16;
        res = @Wrappers_Compile.Result<Dafny.ISequence<T>, Dafny.ISequence<char>>.create_Success(_18054_elements);
        return res;
      }
      return res;
    }
    public Dafny.ISequence<T> _data;public Dafny.ISequence<T> data { get {
      return this._data;
    } }
  }

  public partial class ByteReader {
    public ByteReader() {
      this._reader = default(Streams_Compile.SeqReader<byte>);
    }
    public void __ctor(Dafny.ISequence<byte> s)
    {
      Streams_Compile.SeqReader<byte> _18055_mr;
      Streams_Compile.SeqReader<byte> _nw5 = new Streams_Compile.SeqReader<byte>();
      _nw5.__ctor(s);
      _18055_mr = _nw5;
      (this)._reader = _18055_mr;
    }
    public Wrappers_Compile.Result<byte, Dafny.ISequence<char>> ReadByte()
    {
      Wrappers_Compile.Result<byte, Dafny.ISequence<char>> res = Wrappers_Compile.Result<byte, Dafny.ISequence<char>>.Default(0);
      Dafny.ISequence<byte> _18056_bytes = Dafny.Sequence<byte>.Empty;
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18057_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out17;
      _out17 = ((this).reader).ReadExact(BigInteger.One);
      _18057_valueOrError0 = _out17;
      if ((_18057_valueOrError0).IsFailure()) {
        res = (_18057_valueOrError0).PropagateFailure<byte>();
        return res;
      }
      _18056_bytes = (_18057_valueOrError0).Extract();
      res = @Wrappers_Compile.Result<byte, Dafny.ISequence<char>>.create_Success((_18056_bytes).Select(BigInteger.Zero));
      return res;
      return res;
    }
    public Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> ReadBytes(BigInteger n)
    {
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> res = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      Dafny.ISequence<byte> _18058_bytes = Dafny.Sequence<byte>.Empty;
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18059_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out18;
      _out18 = ((this).reader).ReadExact(n);
      _18059_valueOrError0 = _out18;
      if ((_18059_valueOrError0).IsFailure()) {
        res = (_18059_valueOrError0).PropagateFailure<Dafny.ISequence<byte>>();
        return res;
      }
      _18058_bytes = (_18059_valueOrError0).Extract();
      res = @Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.create_Success(_18058_bytes);
      return res;
      return res;
    }
    public Wrappers_Compile.Result<ushort, Dafny.ISequence<char>> ReadUInt16()
    {
      Wrappers_Compile.Result<ushort, Dafny.ISequence<char>> res = Wrappers_Compile.Result<ushort, Dafny.ISequence<char>>.Default(0);
      Dafny.ISequence<byte> _18060_bytes = Dafny.Sequence<byte>.Empty;
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18061_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out19;
      _out19 = ((this).reader).ReadExact(new BigInteger(2));
      _18061_valueOrError0 = _out19;
      if ((_18061_valueOrError0).IsFailure()) {
        res = (_18061_valueOrError0).PropagateFailure<ushort>();
        return res;
      }
      _18060_bytes = (_18061_valueOrError0).Extract();
      ushort _18062_n;
      _18062_n = StandardLibrary_mUInt_Compile.__default.SeqToUInt16(_18060_bytes);
      res = @Wrappers_Compile.Result<ushort, Dafny.ISequence<char>>.create_Success(_18062_n);
      return res;
      return res;
    }
    public Wrappers_Compile.Result<uint, Dafny.ISequence<char>> ReadUInt32()
    {
      Wrappers_Compile.Result<uint, Dafny.ISequence<char>> res = Wrappers_Compile.Result<uint, Dafny.ISequence<char>>.Default(0);
      Dafny.ISequence<byte> _18063_bytes = Dafny.Sequence<byte>.Empty;
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18064_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out20;
      _out20 = ((this).reader).ReadExact(new BigInteger(4));
      _18064_valueOrError0 = _out20;
      if ((_18064_valueOrError0).IsFailure()) {
        res = (_18064_valueOrError0).PropagateFailure<uint>();
        return res;
      }
      _18063_bytes = (_18064_valueOrError0).Extract();
      uint _18065_n;
      _18065_n = StandardLibrary_mUInt_Compile.__default.SeqToUInt32(_18063_bytes);
      res = @Wrappers_Compile.Result<uint, Dafny.ISequence<char>>.create_Success(_18065_n);
      return res;
      return res;
    }
    public Wrappers_Compile.Result<ulong, Dafny.ISequence<char>> ReadUInt64()
    {
      Wrappers_Compile.Result<ulong, Dafny.ISequence<char>> res = Wrappers_Compile.Result<ulong, Dafny.ISequence<char>>.Default(0);
      Dafny.ISequence<byte> _18066_bytes = Dafny.Sequence<byte>.Empty;
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18067_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out21;
      _out21 = ((this).reader).ReadExact(new BigInteger(8));
      _18067_valueOrError0 = _out21;
      if ((_18067_valueOrError0).IsFailure()) {
        res = (_18067_valueOrError0).PropagateFailure<ulong>();
        return res;
      }
      _18066_bytes = (_18067_valueOrError0).Extract();
      ulong _18068_n;
      _18068_n = StandardLibrary_mUInt_Compile.__default.SeqToUInt64(_18066_bytes);
      res = @Wrappers_Compile.Result<ulong, Dafny.ISequence<char>>.create_Success(_18068_n);
      return res;
      return res;
    }
    public bool IsDoneReading()
    {
      bool b = false;
      b = (new BigInteger((((this).reader).data).Count)) == ((this).reader.pos);
      return b;
      return b;
    }
    public BigInteger GetSizeRead()
    {
      BigInteger n = BigInteger.Zero;
      n = (this).reader.pos;
      return n;
      return n;
    }
    public Streams_Compile.SeqReader<byte> _reader;public Streams_Compile.SeqReader<byte> reader { get {
      return this._reader;
    } }
  }

  public partial class SeqWriter<T> {
    public SeqWriter() {
      this.data = Dafny.Sequence<T>.Empty;
    }
    public Dafny.ISequence<T> data;public void __ctor()
    {
      (this).data = Dafny.Sequence<T>.FromElements();
    }
    public BigInteger WriteElements(Dafny.ISequence<T> elems)
    {
      BigInteger n = BigInteger.Zero;
      (this).data = Dafny.Sequence<T>.Concat(this.data, elems);
      n = new BigInteger((elems).Count);
      return n;
      return n;
    }
  }

  public partial class ByteWriter {
    public ByteWriter() {
      this._writer = default(Streams_Compile.SeqWriter<byte>);
    }
    public void __ctor()
    {
      Streams_Compile.SeqWriter<byte> _18069_mw;
      Streams_Compile.SeqWriter<byte> _nw6 = new Streams_Compile.SeqWriter<byte>();
      _nw6.__ctor();
      _18069_mw = _nw6;
      (this)._writer = _18069_mw;
    }
    public BigInteger WriteByte(byte n)
    {
      BigInteger r = BigInteger.Zero;
      BigInteger _out22;
      _out22 = ((this).writer).WriteElements(Dafny.Sequence<byte>.FromElements(n));
      r = _out22;
      return r;
    }
    public BigInteger WriteBytes(Dafny.ISequence<byte> s)
    {
      BigInteger r = BigInteger.Zero;
      BigInteger _out23;
      _out23 = ((this).writer).WriteElements(s);
      r = _out23;
      return r;
    }
    public BigInteger WriteUInt16(ushort n)
    {
      BigInteger r = BigInteger.Zero;
      BigInteger _out24;
      _out24 = ((this).writer).WriteElements(StandardLibrary_mUInt_Compile.__default.UInt16ToSeq(n));
      r = _out24;
      return r;
    }
    public BigInteger WriteUInt32(uint n)
    {
      BigInteger r = BigInteger.Zero;
      BigInteger _out25;
      _out25 = ((this).writer).WriteElements(StandardLibrary_mUInt_Compile.__default.UInt32ToSeq(n));
      r = _out25;
      return r;
    }
    public Dafny.ISequence<byte> GetDataWritten() {
      return (this).writer.data;
    }
    public BigInteger GetSizeWritten() {
      return new BigInteger(((this).writer.data).Count);
    }
    public Streams_Compile.SeqWriter<byte> _writer;public Streams_Compile.SeqWriter<byte> writer { get {
      return this._writer;
    } }
  }

} // end of namespace Streams_Compile
namespace Deserialize_Compile {












  public class DeserializeHeaderResult {
    public readonly MessageHeader.Header header;
    public DeserializeHeaderResult(MessageHeader.Header header) {
      this.header = header;
    }
    public override bool Equals(object other) {
      var oth = other as Deserialize_Compile.DeserializeHeaderResult;
      return oth != null && object.Equals(this.header, oth.header);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.header));
      return (int) hash;
    }
    public override string ToString() {
      string s = "Deserialize_Compile.DeserializeHeaderResult.DeserializeHeaderResult";
      s += "(";
      s += Dafny.Helpers.ToString(this.header);
      s += ")";
      return s;
    }
    private static readonly DeserializeHeaderResult theDefault = create(MessageHeader.Header.Default());
    public static DeserializeHeaderResult Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<Deserialize_Compile.DeserializeHeaderResult> _TYPE = new Dafny.TypeDescriptor<Deserialize_Compile.DeserializeHeaderResult>(Deserialize_Compile.DeserializeHeaderResult.Default());
    public static Dafny.TypeDescriptor<Deserialize_Compile.DeserializeHeaderResult> _TypeDescriptor() {
      return _TYPE;
    }
    public static DeserializeHeaderResult create(MessageHeader.Header header) {
      return new DeserializeHeaderResult(header);
    }
    public bool is_DeserializeHeaderResult { get { return true; } }
    public MessageHeader.Header dtor_header {
      get {
        return this.header;
      }
    }
  }

  public partial class __default {
    public static Wrappers_Compile.Result<Deserialize_Compile.DeserializeHeaderResult, Dafny.ISequence<char>> DeserializeHeader(Streams_Compile.ByteReader rd)
    {
      Wrappers_Compile.Result<Deserialize_Compile.DeserializeHeaderResult, Dafny.ISequence<char>> res = Wrappers_Compile.Result<Deserialize_Compile.DeserializeHeaderResult, Dafny.ISequence<char>>.Default(Deserialize_Compile.DeserializeHeaderResult.Default());
      MessageHeader.HeaderBody _18070_hb = MessageHeader.HeaderBody.Default();
      Wrappers_Compile.Result<MessageHeader.HeaderBody, Dafny.ISequence<char>> _18071_valueOrError0 = Wrappers_Compile.Result<MessageHeader.HeaderBody, Dafny.ISequence<char>>.Default(MessageHeader.HeaderBody.Default());
      Wrappers_Compile.Result<MessageHeader.HeaderBody, Dafny.ISequence<char>> _out26;
      _out26 = Deserialize_Compile.__default.DeserializeHeaderBody(rd);
      _18071_valueOrError0 = _out26;
      if ((_18071_valueOrError0).IsFailure()) {
        res = (_18071_valueOrError0).PropagateFailure<Deserialize_Compile.DeserializeHeaderResult>();
        return res;
      }
      _18070_hb = (_18071_valueOrError0).Extract();
      MessageHeader.HeaderAuthentication _18072_auth = MessageHeader.HeaderAuthentication.Default();
      Wrappers_Compile.Result<MessageHeader.HeaderAuthentication, Dafny.ISequence<char>> _18073_valueOrError1 = Wrappers_Compile.Result<MessageHeader.HeaderAuthentication, Dafny.ISequence<char>>.Default(MessageHeader.HeaderAuthentication.Default());
      Wrappers_Compile.Result<MessageHeader.HeaderAuthentication, Dafny.ISequence<char>> _out27;
      _out27 = Deserialize_Compile.__default.DeserializeHeaderAuthentication(rd, (_18070_hb).dtor_algorithmSuiteID);
      _18073_valueOrError1 = _out27;
      if ((_18073_valueOrError1).IsFailure()) {
        res = (_18073_valueOrError1).PropagateFailure<Deserialize_Compile.DeserializeHeaderResult>();
        return res;
      }
      _18072_auth = (_18073_valueOrError1).Extract();
      res = @Wrappers_Compile.Result<Deserialize_Compile.DeserializeHeaderResult, Dafny.ISequence<char>>.create_Success(@Deserialize_Compile.DeserializeHeaderResult.create(@MessageHeader.Header.create(_18070_hb, _18072_auth)));
      return res;
      return res;
    }
    public static Wrappers_Compile.Result<MessageHeader.HeaderBody, Dafny.ISequence<char>> DeserializeHeaderBody(Streams_Compile.ByteReader rd)
    {
      Wrappers_Compile.Result<MessageHeader.HeaderBody, Dafny.ISequence<char>> ret = Wrappers_Compile.Result<MessageHeader.HeaderBody, Dafny.ISequence<char>>.Default(MessageHeader.HeaderBody.Default());
      byte _18074_version = MessageHeader.Version.Default();
      Wrappers_Compile.Result<byte, Dafny.ISequence<char>> _18075_valueOrError0 = Wrappers_Compile.Result<byte, Dafny.ISequence<char>>.Default(MessageHeader.Version.Default());
      Wrappers_Compile.Result<byte, Dafny.ISequence<char>> _out28;
      _out28 = Deserialize_Compile.__default.DeserializeVersion(rd);
      _18075_valueOrError0 = _out28;
      if ((_18075_valueOrError0).IsFailure()) {
        ret = (_18075_valueOrError0).PropagateFailure<MessageHeader.HeaderBody>();
        return ret;
      }
      _18074_version = (_18075_valueOrError0).Extract();
      byte _18076_typ = MessageHeader.Type.Default();
      Wrappers_Compile.Result<byte, Dafny.ISequence<char>> _18077_valueOrError1 = Wrappers_Compile.Result<byte, Dafny.ISequence<char>>.Default(MessageHeader.Type.Default());
      Wrappers_Compile.Result<byte, Dafny.ISequence<char>> _out29;
      _out29 = Deserialize_Compile.__default.DeserializeType(rd);
      _18077_valueOrError1 = _out29;
      if ((_18077_valueOrError1).IsFailure()) {
        ret = (_18077_valueOrError1).PropagateFailure<MessageHeader.HeaderBody>();
        return ret;
      }
      _18076_typ = (_18077_valueOrError1).Extract();
      ushort _18078_algorithmSuiteID = AlgorithmSuite.ID.Witness;
      Wrappers_Compile.Result<ushort, Dafny.ISequence<char>> _18079_valueOrError2 = Wrappers_Compile.Result<ushort, Dafny.ISequence<char>>.Default(AlgorithmSuite.ID.Witness);
      Wrappers_Compile.Result<ushort, Dafny.ISequence<char>> _out30;
      _out30 = Deserialize_Compile.__default.DeserializeAlgorithmSuiteID(rd);
      _18079_valueOrError2 = _out30;
      if ((_18079_valueOrError2).IsFailure()) {
        ret = (_18079_valueOrError2).PropagateFailure<MessageHeader.HeaderBody>();
        return ret;
      }
      _18078_algorithmSuiteID = (_18079_valueOrError2).Extract();
      Dafny.ISequence<byte> _18080_messageID = MessageHeader.MessageID.Default();
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18081_valueOrError3 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(MessageHeader.MessageID.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out31;
      _out31 = Deserialize_Compile.__default.DeserializeMsgID(rd);
      _18081_valueOrError3 = _out31;
      if ((_18081_valueOrError3).IsFailure()) {
        ret = (_18081_valueOrError3).PropagateFailure<MessageHeader.HeaderBody>();
        return ret;
      }
      _18080_messageID = (_18081_valueOrError3).Extract();
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _18082_aad = Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Empty;
      Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, Dafny.ISequence<char>> _18083_valueOrError4 = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, Dafny.ISequence<char>>.Default(Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Empty);
      Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, Dafny.ISequence<char>> _out32;
      _out32 = Deserialize_Compile.__default.DeserializeAAD(rd);
      _18083_valueOrError4 = _out32;
      if ((_18083_valueOrError4).IsFailure()) {
        ret = (_18083_valueOrError4).PropagateFailure<MessageHeader.HeaderBody>();
        return ret;
      }
      _18082_aad = (_18083_valueOrError4).Extract();
      MessageHeader.EncryptedDataKeys _18084_encryptedDataKeys = MessageHeader.EncryptedDataKeys.Default();
      Wrappers_Compile.Result<MessageHeader.EncryptedDataKeys, Dafny.ISequence<char>> _18085_valueOrError5 = Wrappers_Compile.Result<MessageHeader.EncryptedDataKeys, Dafny.ISequence<char>>.Default(MessageHeader.EncryptedDataKeys.Default());
      Wrappers_Compile.Result<MessageHeader.EncryptedDataKeys, Dafny.ISequence<char>> _out33;
      _out33 = Deserialize_Compile.__default.DeserializeEncryptedDataKeys(rd);
      _18085_valueOrError5 = _out33;
      if ((_18085_valueOrError5).IsFailure()) {
        ret = (_18085_valueOrError5).PropagateFailure<MessageHeader.HeaderBody>();
        return ret;
      }
      _18084_encryptedDataKeys = (_18085_valueOrError5).Extract();
      MessageHeader.ContentType _18086_contentType = MessageHeader.ContentType.Default();
      Wrappers_Compile.Result<MessageHeader.ContentType, Dafny.ISequence<char>> _18087_valueOrError6 = Wrappers_Compile.Result<MessageHeader.ContentType, Dafny.ISequence<char>>.Default(MessageHeader.ContentType.Default());
      Wrappers_Compile.Result<MessageHeader.ContentType, Dafny.ISequence<char>> _out34;
      _out34 = Deserialize_Compile.__default.DeserializeContentType(rd);
      _18087_valueOrError6 = _out34;
      if ((_18087_valueOrError6).IsFailure()) {
        ret = (_18087_valueOrError6).PropagateFailure<MessageHeader.HeaderBody>();
        return ret;
      }
      _18086_contentType = (_18087_valueOrError6).Extract();
      Dafny.ISequence<byte> _18088___v2 = Dafny.Sequence<byte>.Empty;
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18089_valueOrError7 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out35;
      _out35 = Deserialize_Compile.__default.DeserializeReserved(rd);
      _18089_valueOrError7 = _out35;
      if ((_18089_valueOrError7).IsFailure()) {
        ret = (_18089_valueOrError7).PropagateFailure<MessageHeader.HeaderBody>();
        return ret;
      }
      _18088___v2 = (_18089_valueOrError7).Extract();
      byte _18090_ivLength = 0;
      Wrappers_Compile.Result<byte, Dafny.ISequence<char>> _18091_valueOrError8 = Wrappers_Compile.Result<byte, Dafny.ISequence<char>>.Default(0);
      Wrappers_Compile.Result<byte, Dafny.ISequence<char>> _out36;
      _out36 = (rd).ReadByte();
      _18091_valueOrError8 = _out36;
      if ((_18091_valueOrError8).IsFailure()) {
        ret = (_18091_valueOrError8).PropagateFailure<MessageHeader.HeaderBody>();
        return ret;
      }
      _18090_ivLength = (_18091_valueOrError8).Extract();
      uint _18092_frameLength = 0;
      Wrappers_Compile.Result<uint, Dafny.ISequence<char>> _18093_valueOrError9 = Wrappers_Compile.Result<uint, Dafny.ISequence<char>>.Default(0);
      Wrappers_Compile.Result<uint, Dafny.ISequence<char>> _out37;
      _out37 = (rd).ReadUInt32();
      _18093_valueOrError9 = _out37;
      if ((_18093_valueOrError9).IsFailure()) {
        ret = (_18093_valueOrError9).PropagateFailure<MessageHeader.HeaderBody>();
        return ret;
      }
      _18092_frameLength = (_18093_valueOrError9).Extract();
      if ((new BigInteger(_18090_ivLength)) != (AlgorithmSuite.ID.IVLength(_18078_algorithmSuiteID))) {
        ret = @Wrappers_Compile.Result<MessageHeader.HeaderBody, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Deserialization Error: Incorrect IV length."));
        return ret;
      }
      if (((_18086_contentType).is_NonFramed) && ((_18092_frameLength) != (0U))) {
        ret = @Wrappers_Compile.Result<MessageHeader.HeaderBody, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Deserialization Error: Frame length must be 0 when content type is non-framed."));
        return ret;
      } else if (((_18086_contentType).is_Framed) && ((_18092_frameLength) == (0U))) {
        ret = @Wrappers_Compile.Result<MessageHeader.HeaderBody, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Deserialization Error: Frame length must be non-0 when content type is framed."));
        return ret;
      }
      MessageHeader.HeaderBody _18094_hb;
      _18094_hb = @MessageHeader.HeaderBody.create(_18074_version, _18076_typ, _18078_algorithmSuiteID, _18080_messageID, _18082_aad, _18084_encryptedDataKeys, _18086_contentType, _18090_ivLength, _18092_frameLength);
      ret = @Wrappers_Compile.Result<MessageHeader.HeaderBody, Dafny.ISequence<char>>.create_Success(_18094_hb);
      return ret;
      return ret;
    }
    public static Wrappers_Compile.Result<MessageHeader.HeaderAuthentication, Dafny.ISequence<char>> DeserializeHeaderAuthentication(Streams_Compile.ByteReader rd, ushort algorithmSuiteID)
    {
      Wrappers_Compile.Result<MessageHeader.HeaderAuthentication, Dafny.ISequence<char>> ret = Wrappers_Compile.Result<MessageHeader.HeaderAuthentication, Dafny.ISequence<char>>.Default(MessageHeader.HeaderAuthentication.Default());
      Dafny.ISequence<byte> _18095_iv = Dafny.Sequence<byte>.Empty;
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18096_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out38;
      _out38 = (rd).ReadBytes(AlgorithmSuite.ID.IVLength(algorithmSuiteID));
      _18096_valueOrError0 = _out38;
      if ((_18096_valueOrError0).IsFailure()) {
        ret = (_18096_valueOrError0).PropagateFailure<MessageHeader.HeaderAuthentication>();
        return ret;
      }
      _18095_iv = (_18096_valueOrError0).Extract();
      Dafny.ISequence<byte> _18097_authenticationTag = Dafny.Sequence<byte>.Empty;
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18098_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out39;
      _out39 = (rd).ReadBytes(AlgorithmSuite.ID.TagLength(algorithmSuiteID));
      _18098_valueOrError1 = _out39;
      if ((_18098_valueOrError1).IsFailure()) {
        ret = (_18098_valueOrError1).PropagateFailure<MessageHeader.HeaderAuthentication>();
        return ret;
      }
      _18097_authenticationTag = (_18098_valueOrError1).Extract();
      ret = @Wrappers_Compile.Result<MessageHeader.HeaderAuthentication, Dafny.ISequence<char>>.create_Success(@MessageHeader.HeaderAuthentication.create(_18095_iv, _18097_authenticationTag));
      return ret;
      return ret;
    }
    public static Wrappers_Compile.Result<byte, Dafny.ISequence<char>> DeserializeVersion(Streams_Compile.ByteReader rd)
    {
      Wrappers_Compile.Result<byte, Dafny.ISequence<char>> ret = Wrappers_Compile.Result<byte, Dafny.ISequence<char>>.Default(MessageHeader.Version.Default());
      byte _18099_version = 0;
      Wrappers_Compile.Result<byte, Dafny.ISequence<char>> _18100_valueOrError0 = Wrappers_Compile.Result<byte, Dafny.ISequence<char>>.Default(0);
      Wrappers_Compile.Result<byte, Dafny.ISequence<char>> _out40;
      _out40 = (rd).ReadByte();
      _18100_valueOrError0 = _out40;
      if ((_18100_valueOrError0).IsFailure()) {
        ret = (_18100_valueOrError0).PropagateFailure<byte>();
        return ret;
      }
      _18099_version = (_18100_valueOrError0).Extract();
      if ((_18099_version) == (MessageHeader.__default.VERSION__1)) {
        ret = @Wrappers_Compile.Result<byte, Dafny.ISequence<char>>.create_Success(_18099_version);
        return ret;
      } else {
        ret = @Wrappers_Compile.Result<byte, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Deserialization Error: Version not supported."));
        return ret;
      }
      return ret;
    }
    public static Wrappers_Compile.Result<byte, Dafny.ISequence<char>> DeserializeType(Streams_Compile.ByteReader rd)
    {
      Wrappers_Compile.Result<byte, Dafny.ISequence<char>> ret = Wrappers_Compile.Result<byte, Dafny.ISequence<char>>.Default(MessageHeader.Type.Default());
      byte _18101_typ = 0;
      Wrappers_Compile.Result<byte, Dafny.ISequence<char>> _18102_valueOrError0 = Wrappers_Compile.Result<byte, Dafny.ISequence<char>>.Default(0);
      Wrappers_Compile.Result<byte, Dafny.ISequence<char>> _out41;
      _out41 = (rd).ReadByte();
      _18102_valueOrError0 = _out41;
      if ((_18102_valueOrError0).IsFailure()) {
        ret = (_18102_valueOrError0).PropagateFailure<byte>();
        return ret;
      }
      _18101_typ = (_18102_valueOrError0).Extract();
      if ((_18101_typ) == (MessageHeader.__default.TYPE__CUSTOMER__AED)) {
        ret = @Wrappers_Compile.Result<byte, Dafny.ISequence<char>>.create_Success(_18101_typ);
        return ret;
      } else {
        ret = @Wrappers_Compile.Result<byte, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Deserialization Error: Type not supported."));
        return ret;
      }
      return ret;
    }
    public static Wrappers_Compile.Result<ushort, Dafny.ISequence<char>> DeserializeAlgorithmSuiteID(Streams_Compile.ByteReader rd)
    {
      Wrappers_Compile.Result<ushort, Dafny.ISequence<char>> ret = Wrappers_Compile.Result<ushort, Dafny.ISequence<char>>.Default(AlgorithmSuite.ID.Witness);
      ushort _18103_algorithmSuiteID = 0;
      Wrappers_Compile.Result<ushort, Dafny.ISequence<char>> _18104_valueOrError0 = Wrappers_Compile.Result<ushort, Dafny.ISequence<char>>.Default(0);
      Wrappers_Compile.Result<ushort, Dafny.ISequence<char>> _out42;
      _out42 = (rd).ReadUInt16();
      _18104_valueOrError0 = _out42;
      if ((_18104_valueOrError0).IsFailure()) {
        ret = (_18104_valueOrError0).PropagateFailure<ushort>();
        return ret;
      }
      _18103_algorithmSuiteID = (_18104_valueOrError0).Extract();
      if ((AlgorithmSuite.__default.VALID__IDS).Contains((_18103_algorithmSuiteID))) {
        ret = @Wrappers_Compile.Result<ushort, Dafny.ISequence<char>>.create_Success((ushort)(_18103_algorithmSuiteID));
        return ret;
      } else {
        ret = @Wrappers_Compile.Result<ushort, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Deserialization Error: Algorithm suite not supported."));
        return ret;
      }
      return ret;
    }
    public static Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> DeserializeMsgID(Streams_Compile.ByteReader rd)
    {
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> ret = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(MessageHeader.MessageID.Default());
      Dafny.ISequence<byte> _18105_msgID = Dafny.Sequence<byte>.Empty;
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18106_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out43;
      _out43 = (rd).ReadBytes(MessageHeader.__default.MESSAGE__ID__LEN);
      _18106_valueOrError0 = _out43;
      if ((_18106_valueOrError0).IsFailure()) {
        ret = (_18106_valueOrError0).PropagateFailure<Dafny.ISequence<byte>>();
        return ret;
      }
      _18105_msgID = (_18106_valueOrError0).Extract();
      ret = @Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.create_Success(_18105_msgID);
      return ret;
      return ret;
    }
    public static Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> DeserializeUTF8(Streams_Compile.ByteReader rd, BigInteger n)
    {
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> ret = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Dafny.ISequence<byte> _18107_bytes = Dafny.Sequence<byte>.Empty;
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18108_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out44;
      _out44 = (rd).ReadBytes(n);
      _18108_valueOrError0 = _out44;
      if ((_18108_valueOrError0).IsFailure()) {
        ret = (_18108_valueOrError0).PropagateFailure<Dafny.ISequence<byte>>();
        return ret;
      }
      _18107_bytes = (_18108_valueOrError0).Extract();
      if (UTF8.__default.ValidUTF8Seq(_18107_bytes)) {
        Dafny.ISequence<byte> _18109_utf8;
        _18109_utf8 = _18107_bytes;
        ret = @Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.create_Success(_18109_utf8);
        return ret;
      } else {
        ret = @Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Deserialization Error: Not a valid UTF8 string."));
        return ret;
      }
      return ret;
    }
    public static Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, Dafny.ISequence<char>> DeserializeAAD(Streams_Compile.ByteReader rd)
    {
      Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, Dafny.ISequence<char>> ret = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, Dafny.ISequence<char>>.Default(Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Empty);
      ushort _18110_kvPairsLength = 0;
      Wrappers_Compile.Result<ushort, Dafny.ISequence<char>> _18111_valueOrError0 = Wrappers_Compile.Result<ushort, Dafny.ISequence<char>>.Default(0);
      Wrappers_Compile.Result<ushort, Dafny.ISequence<char>> _out45;
      _out45 = (rd).ReadUInt16();
      _18111_valueOrError0 = _out45;
      if ((_18111_valueOrError0).IsFailure()) {
        ret = (_18111_valueOrError0).PropagateFailure<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>>();
        return ret;
      }
      _18110_kvPairsLength = (_18111_valueOrError0).Extract();
      if ((_18110_kvPairsLength) == (0)) {
        ret = @Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, Dafny.ISequence<char>>.create_Success(Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.FromElements());
        return ret;
      } else if ((_18110_kvPairsLength) < (2)) {
        ret = @Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Deserialization Error: The number of bytes in encryption context exceeds the given length."));
        return ret;
      }
      BigInteger _18112_totalBytesRead;
      _18112_totalBytesRead = BigInteger.Zero;
      ushort _18113_kvPairsCount = 0;
      Wrappers_Compile.Result<ushort, Dafny.ISequence<char>> _18114_valueOrError1 = Wrappers_Compile.Result<ushort, Dafny.ISequence<char>>.Default(0);
      Wrappers_Compile.Result<ushort, Dafny.ISequence<char>> _out46;
      _out46 = (rd).ReadUInt16();
      _18114_valueOrError1 = _out46;
      if ((_18114_valueOrError1).IsFailure()) {
        ret = (_18114_valueOrError1).PropagateFailure<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>>();
        return ret;
      }
      _18113_kvPairsCount = (_18114_valueOrError1).Extract();
      _18112_totalBytesRead = (_18112_totalBytesRead) + (new BigInteger(2));
      if ((_18113_kvPairsCount) == (0)) {
        ret = @Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Deserialization Error: Key value pairs count is 0."));
        return ret;
      }
      Dafny.ISequence<_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>> _18115_kvPairs;
      _18115_kvPairs = Dafny.Sequence<_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>>.FromElements();
      ushort _18116_i;
      _18116_i = 0;
      while ((_18116_i) < (_18113_kvPairsCount)) {
        ushort _18117_keyLength = 0;
        Wrappers_Compile.Result<ushort, Dafny.ISequence<char>> _18118_valueOrError2 = Wrappers_Compile.Result<ushort, Dafny.ISequence<char>>.Default(0);
        Wrappers_Compile.Result<ushort, Dafny.ISequence<char>> _out47;
        _out47 = (rd).ReadUInt16();
        _18118_valueOrError2 = _out47;
        if ((_18118_valueOrError2).IsFailure()) {
          ret = (_18118_valueOrError2).PropagateFailure<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>>();
          return ret;
        }
        _18117_keyLength = (_18118_valueOrError2).Extract();
        _18112_totalBytesRead = (_18112_totalBytesRead) + (new BigInteger(2));
        Dafny.ISequence<byte> _18119_key = UTF8.ValidUTF8Bytes.Default();
        Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18120_valueOrError3 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
        Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out48;
        _out48 = Deserialize_Compile.__default.DeserializeUTF8(rd, new BigInteger(_18117_keyLength));
        _18120_valueOrError3 = _out48;
        if ((_18120_valueOrError3).IsFailure()) {
          ret = (_18120_valueOrError3).PropagateFailure<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>>();
          return ret;
        }
        _18119_key = (_18120_valueOrError3).Extract();
        _18112_totalBytesRead = (_18112_totalBytesRead) + (new BigInteger((_18119_key).Count));
        ushort _18121_valueLength = 0;
        Wrappers_Compile.Result<ushort, Dafny.ISequence<char>> _18122_valueOrError4 = Wrappers_Compile.Result<ushort, Dafny.ISequence<char>>.Default(0);
        Wrappers_Compile.Result<ushort, Dafny.ISequence<char>> _out49;
        _out49 = (rd).ReadUInt16();
        _18122_valueOrError4 = _out49;
        if ((_18122_valueOrError4).IsFailure()) {
          ret = (_18122_valueOrError4).PropagateFailure<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>>();
          return ret;
        }
        _18121_valueLength = (_18122_valueOrError4).Extract();
        _18112_totalBytesRead = (_18112_totalBytesRead) + (new BigInteger(2));
        if ((new BigInteger(_18110_kvPairsLength)) < ((_18112_totalBytesRead) + (new BigInteger(_18121_valueLength)))) {
          ret = @Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Deserialization Error: The number of bytes in encryption context exceeds the given length."));
          return ret;
        }
        Dafny.ISequence<byte> _18123_value = UTF8.ValidUTF8Bytes.Default();
        Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18124_valueOrError5 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
        Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out50;
        _out50 = Deserialize_Compile.__default.DeserializeUTF8(rd, new BigInteger(_18121_valueLength));
        _18124_valueOrError5 = _out50;
        if ((_18124_valueOrError5).IsFailure()) {
          ret = (_18124_valueOrError5).PropagateFailure<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>>();
          return ret;
        }
        _18123_value = (_18124_valueOrError5).Extract();
        _18112_totalBytesRead = (_18112_totalBytesRead) + (new BigInteger((_18123_value).Count));
        Wrappers_Compile.Option<Dafny.ISequence<_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>>> _18125_opt;
        Wrappers_Compile.Option<Dafny.ISequence<_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>>> _out51;
        _out51 = Deserialize_Compile.__default.InsertNewEntry(_18115_kvPairs, _18119_key, _18123_value);
        _18125_opt = _out51;
        Wrappers_Compile.Option<Dafny.ISequence<_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>>> _source17 = _18125_opt;
        if (_source17.is_None) {
          {
            ret = @Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Deserialization Error: Duplicate key."));
            return ret;
          }
        } else {
          Dafny.ISequence<_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>> _18126___mcc_h2 = ((Wrappers_Compile.Option_Some<Dafny.ISequence<_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>>>)_source17).@value;
          {
            Dafny.ISequence<_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>> _18127_kvPairs__ = _18126___mcc_h2;
            _18115_kvPairs = _18127_kvPairs__;
          }
        }
        _18116_i = (ushort)((_18116_i) + (1));
      }
      if ((new BigInteger(_18110_kvPairsLength)) != (_18112_totalBytesRead)) {
        ret = @Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Deserialization Error: Bytes actually read differs from bytes supposed to be read."));
        return ret;
      }
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _18128_encryptionContext;
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _out52;
      _out52 = EncryptionContext.__default.LinearToMap(_18115_kvPairs);
      _18128_encryptionContext = _out52;
      bool _18129_isValid;
      bool _out53;
      _out53 = EncryptionContext.__default.CheckSerializable(_18128_encryptionContext);
      _18129_isValid = _out53;
      if ((!(_18129_isValid)) || ((new BigInteger((_18115_kvPairs).Count)) != (new BigInteger((_18128_encryptionContext).Count)))) {
        ret = @Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Deserialization Error: Failed to parse encryption context."));
        return ret;
      }
      ret = @Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, Dafny.ISequence<char>>.create_Success(_18128_encryptionContext);
      return ret;
      return ret;
    }
    public static Wrappers_Compile.Option<Dafny.ISequence<_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>>> InsertNewEntry(Dafny.ISequence<_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>> kvPairs, Dafny.ISequence<byte> key, Dafny.ISequence<byte> @value)
    {
      Wrappers_Compile.Option<Dafny.ISequence<_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>>> res = Wrappers_Compile.Option<Dafny.ISequence<_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>>>.Default();
      BigInteger _18130_n;
      _18130_n = new BigInteger((kvPairs).Count);
      while (((_18130_n).Sign == 1) && (StandardLibrary_Compile.__default.LexicographicLessOrEqual<byte>(key, ((kvPairs).Select((_18130_n) - (BigInteger.One))).dtor__0, StandardLibrary_mUInt_Compile.__default.UInt8Less))) {
        _18130_n = (_18130_n) - (BigInteger.One);
      }
      if (((!(kvPairs).Equals((Dafny.Sequence<_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>>.FromElements()))) && (StandardLibrary_Compile.__default.LexicographicLessOrEqual<byte>(key, ((kvPairs).Select((new BigInteger((kvPairs).Count)) - (BigInteger.One))).dtor__0, StandardLibrary_mUInt_Compile.__default.UInt8Less))) && ((((kvPairs).Select(_18130_n)).dtor__0).Equals((key)))) {
        Wrappers_Compile.Option<Dafny.ISequence<_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>>> _rhs0 = @Wrappers_Compile.Option<Dafny.ISequence<_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>>>.create_None();
        res = _rhs0;
        return res;
      } else {
        Dafny.ISequence<_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>> _18131_kvPairs_k;
        _18131_kvPairs_k = Dafny.Sequence<_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>>.Concat(Dafny.Sequence<_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>>.Concat((kvPairs).Take(_18130_n), Dafny.Sequence<_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>>.FromElements(@_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.create(key, @value))), (kvPairs).Drop(_18130_n));
        Wrappers_Compile.Option<Dafny.ISequence<_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>>> _rhs1 = @Wrappers_Compile.Option<Dafny.ISequence<_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>>>.create_Some(_18131_kvPairs_k);
        res = _rhs1;
        return res;
      }
      return res;
    }
    public static Wrappers_Compile.Result<MessageHeader.EncryptedDataKeys, Dafny.ISequence<char>> DeserializeEncryptedDataKeys(Streams_Compile.ByteReader rd)
    {
      Wrappers_Compile.Result<MessageHeader.EncryptedDataKeys, Dafny.ISequence<char>> ret = Wrappers_Compile.Result<MessageHeader.EncryptedDataKeys, Dafny.ISequence<char>>.Default(MessageHeader.EncryptedDataKeys.Default());
      ushort _18132_edkCount = 0;
      Wrappers_Compile.Result<ushort, Dafny.ISequence<char>> _18133_valueOrError0 = Wrappers_Compile.Result<ushort, Dafny.ISequence<char>>.Default(0);
      Wrappers_Compile.Result<ushort, Dafny.ISequence<char>> _out54;
      _out54 = (rd).ReadUInt16();
      _18133_valueOrError0 = _out54;
      if ((_18133_valueOrError0).IsFailure()) {
        ret = (_18133_valueOrError0).PropagateFailure<MessageHeader.EncryptedDataKeys>();
        return ret;
      }
      _18132_edkCount = (_18133_valueOrError0).Extract();
      if ((_18132_edkCount) == (0)) {
        ret = @Wrappers_Compile.Result<MessageHeader.EncryptedDataKeys, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Deserialization Error: Encrypted data key count is 0."));
        return ret;
      }
      Dafny.ISequence<Dafny.Aws.Crypto.EncryptedDataKey> _18134_edkEntries;
      _18134_edkEntries = Dafny.Sequence<Dafny.Aws.Crypto.EncryptedDataKey>.FromElements();
      ushort _18135_i;
      _18135_i = 0;
      while ((_18135_i) < (_18132_edkCount)) {
        ushort _18136_providerIdLength = 0;
        Wrappers_Compile.Result<ushort, Dafny.ISequence<char>> _18137_valueOrError1 = Wrappers_Compile.Result<ushort, Dafny.ISequence<char>>.Default(0);
        Wrappers_Compile.Result<ushort, Dafny.ISequence<char>> _out55;
        _out55 = (rd).ReadUInt16();
        _18137_valueOrError1 = _out55;
        if ((_18137_valueOrError1).IsFailure()) {
          ret = (_18137_valueOrError1).PropagateFailure<MessageHeader.EncryptedDataKeys>();
          return ret;
        }
        _18136_providerIdLength = (_18137_valueOrError1).Extract();
        Dafny.ISequence<byte> _18138_str = UTF8.ValidUTF8Bytes.Default();
        Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18139_valueOrError2 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
        Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out56;
        _out56 = Deserialize_Compile.__default.DeserializeUTF8(rd, new BigInteger(_18136_providerIdLength));
        _18139_valueOrError2 = _out56;
        if ((_18139_valueOrError2).IsFailure()) {
          ret = (_18139_valueOrError2).PropagateFailure<MessageHeader.EncryptedDataKeys>();
          return ret;
        }
        _18138_str = (_18139_valueOrError2).Extract();
        Dafny.ISequence<byte> _18140_providerId;
        _18140_providerId = _18138_str;
        ushort _18141_providerInfoLength = 0;
        Wrappers_Compile.Result<ushort, Dafny.ISequence<char>> _18142_valueOrError3 = Wrappers_Compile.Result<ushort, Dafny.ISequence<char>>.Default(0);
        Wrappers_Compile.Result<ushort, Dafny.ISequence<char>> _out57;
        _out57 = (rd).ReadUInt16();
        _18142_valueOrError3 = _out57;
        if ((_18142_valueOrError3).IsFailure()) {
          ret = (_18142_valueOrError3).PropagateFailure<MessageHeader.EncryptedDataKeys>();
          return ret;
        }
        _18141_providerInfoLength = (_18142_valueOrError3).Extract();
        Dafny.ISequence<byte> _18143_providerInfo = Dafny.Sequence<byte>.Empty;
        Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18144_valueOrError4 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
        Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out58;
        _out58 = (rd).ReadBytes(new BigInteger(_18141_providerInfoLength));
        _18144_valueOrError4 = _out58;
        if ((_18144_valueOrError4).IsFailure()) {
          ret = (_18144_valueOrError4).PropagateFailure<MessageHeader.EncryptedDataKeys>();
          return ret;
        }
        _18143_providerInfo = (_18144_valueOrError4).Extract();
        ushort _18145_ciphertextLength = 0;
        Wrappers_Compile.Result<ushort, Dafny.ISequence<char>> _18146_valueOrError5 = Wrappers_Compile.Result<ushort, Dafny.ISequence<char>>.Default(0);
        Wrappers_Compile.Result<ushort, Dafny.ISequence<char>> _out59;
        _out59 = (rd).ReadUInt16();
        _18146_valueOrError5 = _out59;
        if ((_18146_valueOrError5).IsFailure()) {
          ret = (_18146_valueOrError5).PropagateFailure<MessageHeader.EncryptedDataKeys>();
          return ret;
        }
        _18145_ciphertextLength = (_18146_valueOrError5).Extract();
        Dafny.ISequence<byte> _18147_ciphertext = Dafny.Sequence<byte>.Empty;
        Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18148_valueOrError6 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
        Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out60;
        _out60 = (rd).ReadBytes(new BigInteger(_18145_ciphertextLength));
        _18148_valueOrError6 = _out60;
        if ((_18148_valueOrError6).IsFailure()) {
          ret = (_18148_valueOrError6).PropagateFailure<MessageHeader.EncryptedDataKeys>();
          return ret;
        }
        _18147_ciphertext = (_18148_valueOrError6).Extract();
        _18134_edkEntries = Dafny.Sequence<Dafny.Aws.Crypto.EncryptedDataKey>.Concat(_18134_edkEntries, Dafny.Sequence<Dafny.Aws.Crypto.EncryptedDataKey>.FromElements(@Dafny.Aws.Crypto.EncryptedDataKey.create(_18140_providerId, _18143_providerInfo, _18147_ciphertext)));
        _18135_i = (ushort)((_18135_i) + (1));
      }
      MessageHeader.EncryptedDataKeys _18149_edks;
      _18149_edks = @MessageHeader.EncryptedDataKeys.create(_18134_edkEntries);
      ret = @Wrappers_Compile.Result<MessageHeader.EncryptedDataKeys, Dafny.ISequence<char>>.create_Success(_18149_edks);
      return ret;
      return ret;
    }
    public static Wrappers_Compile.Result<MessageHeader.ContentType, Dafny.ISequence<char>> DeserializeContentType(Streams_Compile.ByteReader rd)
    {
      Wrappers_Compile.Result<MessageHeader.ContentType, Dafny.ISequence<char>> ret = Wrappers_Compile.Result<MessageHeader.ContentType, Dafny.ISequence<char>>.Default(MessageHeader.ContentType.Default());
      byte _18150_byte = 0;
      Wrappers_Compile.Result<byte, Dafny.ISequence<char>> _18151_valueOrError0 = Wrappers_Compile.Result<byte, Dafny.ISequence<char>>.Default(0);
      Wrappers_Compile.Result<byte, Dafny.ISequence<char>> _out61;
      _out61 = (rd).ReadByte();
      _18151_valueOrError0 = _out61;
      if ((_18151_valueOrError0).IsFailure()) {
        ret = (_18151_valueOrError0).PropagateFailure<MessageHeader.ContentType>();
        return ret;
      }
      _18150_byte = (_18151_valueOrError0).Extract();
      Wrappers_Compile.Option<MessageHeader.ContentType> _source18 = MessageHeader.__default.UInt8ToContentType(_18150_byte);
      if (_source18.is_None) {
        {
          ret = @Wrappers_Compile.Result<MessageHeader.ContentType, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Deserialization Error: Content type not supported."));
          return ret;
        }
      } else {
        MessageHeader.ContentType _18152___mcc_h2 = ((Wrappers_Compile.Option_Some<MessageHeader.ContentType>)_source18).@value;
        {
          MessageHeader.ContentType _18153_contentType = _18152___mcc_h2;
          ret = @Wrappers_Compile.Result<MessageHeader.ContentType, Dafny.ISequence<char>>.create_Success(_18153_contentType);
          return ret;
        }
      }
      return ret;
    }
    public static Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> DeserializeReserved(Streams_Compile.ByteReader rd)
    {
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> ret = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      Dafny.ISequence<byte> _18154_reserved = Dafny.Sequence<byte>.Empty;
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18155_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out62;
      _out62 = (rd).ReadBytes(new BigInteger(4));
      _18155_valueOrError0 = _out62;
      if ((_18155_valueOrError0).IsFailure()) {
        ret = (_18155_valueOrError0).PropagateFailure<Dafny.ISequence<byte>>();
        return ret;
      }
      _18154_reserved = (_18155_valueOrError0).Extract();
      if ((_18154_reserved).Equals((MessageHeader.__default.Reserved))) {
        ret = @Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.create_Success(_18154_reserved);
        return ret;
      } else {
        ret = @Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Deserialization Error: Reserved fields must be 0."));
        return ret;
      }
      return ret;
    }
  }
} // end of namespace Deserialize_Compile
namespace DefaultCMMDef {












  public partial class DefaultCMM : Dafny.Aws.Crypto.ICryptographicMaterialsManager {
    public DefaultCMM() {
      this._keyring = default(Dafny.Aws.Crypto.IKeyring);
    }
    public void OfKeyring(Dafny.Aws.Crypto.IKeyring k)
    {
      (this)._keyring = k;
    }
    public Wrappers_Compile.Result<Dafny.Aws.Crypto.GetEncryptionMaterialsOutput, Dafny.ISequence<char>> GetEncryptionMaterials(Dafny.Aws.Crypto.GetEncryptionMaterialsInput input)
    {
      Wrappers_Compile.Result<Dafny.Aws.Crypto.GetEncryptionMaterialsOutput, Dafny.ISequence<char>> res = Wrappers_Compile.Result<Dafny.Aws.Crypto.GetEncryptionMaterialsOutput, Dafny.ISequence<char>>.Default(Dafny.Aws.Crypto.GetEncryptionMaterialsOutput.Default());
      Dafny.ISequence<byte> _18156_reservedField;
      _18156_reservedField = Materials.__default.EC__PUBLIC__KEY__FIELD;
      if ((((input).dtor_encryptionContext).Keys).Contains((_18156_reservedField))) {
        res = @Wrappers_Compile.Result<Dafny.Aws.Crypto.GetEncryptionMaterialsOutput, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Reserved Field found in EncryptionContext keys."));
        return res;
      }
      ushort _18157_id;
      _18157_id = AlgorithmSuite.__default.AES__256__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384;
      if (((input).dtor_algorithmSuiteId).is_Some) {
        _18157_id = AlgorithmSuite.__default.PolymorphIDToInternalID(((input).dtor_algorithmSuiteId).dtor_value);
      }
      Wrappers_Compile.Option<Dafny.ISequence<byte>> _18158_enc__sk;
      _18158_enc__sk = @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_None();
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _18159_enc__ctx;
      _18159_enc__ctx = (input).dtor_encryptionContext;
      Wrappers_Compile.Option<Signature.ECDSAParams> _source19 = AlgorithmSuite.ID.SignatureType(_18157_id);
      if (_source19.is_None) {
      } else {
        Signature.ECDSAParams _18160___mcc_h1 = ((Wrappers_Compile.Option_Some<Signature.ECDSAParams>)_source19).@value;
        {
          Signature.ECDSAParams _18161_param = _18160___mcc_h1;
          Signature.SignatureKeyPair _18162_signatureKeys = Signature.SignatureKeyPair.Default();
          Wrappers_Compile.Result<Signature.SignatureKeyPair, Dafny.ISequence<char>> _18163_valueOrError0 = Wrappers_Compile.Result<Signature.SignatureKeyPair, Dafny.ISequence<char>>.Default(Signature.SignatureKeyPair.Default());
          Wrappers_Compile.Result<Signature.SignatureKeyPair, Dafny.ISequence<char>> _out63;
          _out63 = Signature.__default.KeyGen(_18161_param);
          _18163_valueOrError0 = _out63;
          if ((_18163_valueOrError0).IsFailure()) {
            res = (_18163_valueOrError0).PropagateFailure<Dafny.Aws.Crypto.GetEncryptionMaterialsOutput>();
            return res;
          }
          _18162_signatureKeys = (_18163_valueOrError0).Extract();
          _18158_enc__sk = @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some((_18162_signatureKeys).dtor_signingKey);
          Dafny.ISequence<byte> _18164_enc__vk = UTF8.ValidUTF8Bytes.Default();
          Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18165_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
          Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out64;
          _out64 = UTF8.__default.Encode(Base64_Compile.__default.Encode((_18162_signatureKeys).dtor_verificationKey));
          _18165_valueOrError1 = _out64;
          if ((_18165_valueOrError1).IsFailure()) {
            res = (_18165_valueOrError1).PropagateFailure<Dafny.Aws.Crypto.GetEncryptionMaterialsOutput>();
            return res;
          }
          _18164_enc__vk = (_18165_valueOrError1).Extract();
          _18159_enc__ctx = Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Update(_18159_enc__ctx,_18156_reservedField, _18164_enc__vk);
        }
      }
      bool _18166_validAAD;
      bool _out65;
      _out65 = EncryptionContext.__default.CheckSerializable(_18159_enc__ctx);
      _18166_validAAD = _out65;
      if (!(_18166_validAAD)) {
        res = @Wrappers_Compile.Result<Dafny.Aws.Crypto.GetEncryptionMaterialsOutput, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Invalid Encryption Context"));
        return res;
      }
      Dafny.Aws.Crypto.EncryptionMaterials _18167_materials;
      _18167_materials = @Dafny.Aws.Crypto.EncryptionMaterials.create(AlgorithmSuite.__default.InternalIDToPolymorphID(_18157_id), _18159_enc__ctx, Dafny.Sequence<Dafny.Aws.Crypto.EncryptedDataKey>.FromElements(), @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_None(), _18158_enc__sk);
      Dafny.Aws.Crypto.OnEncryptOutput _18168_result = Dafny.Aws.Crypto.OnEncryptOutput.Default();
      Wrappers_Compile.Result<Dafny.Aws.Crypto.OnEncryptOutput, Dafny.ISequence<char>> _18169_valueOrError2 = Wrappers_Compile.Result<Dafny.Aws.Crypto.OnEncryptOutput, Dafny.ISequence<char>>.Default(Dafny.Aws.Crypto.OnEncryptOutput.Default());
      Wrappers_Compile.Result<Dafny.Aws.Crypto.OnEncryptOutput, Dafny.ISequence<char>> _out66;
      _out66 = ((this).keyring).OnEncrypt(@Dafny.Aws.Crypto.OnEncryptInput.create(_18167_materials));
      _18169_valueOrError2 = _out66;
      if ((_18169_valueOrError2).IsFailure()) {
        res = (_18169_valueOrError2).PropagateFailure<Dafny.Aws.Crypto.GetEncryptionMaterialsOutput>();
        return res;
      }
      _18168_result = (_18169_valueOrError2).Extract();
      if (((((_18168_result).dtor_materials).dtor_plaintextDataKey).is_None) || ((new BigInteger((((_18168_result).dtor_materials).dtor_encryptedDataKeys).Count)).Sign == 0)) {
        res = @Wrappers_Compile.Result<Dafny.Aws.Crypto.GetEncryptionMaterialsOutput, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Could not retrieve materials required for encryption"));
        return res;
      }
      Wrappers_Compile.Outcome<Dafny.ISequence<char>> _18170_valueOrError3 = Wrappers_Compile.Outcome<Dafny.ISequence<char>>.Default();
      _18170_valueOrError3 = Wrappers_Compile.__default.Need<Dafny.ISequence<char>>((this).OnEncryptResultValid(input, _18168_result), Dafny.Sequence<char>.FromString("Keyring returned an invalid response"));
      if ((_18170_valueOrError3).IsFailure()) {
        res = (_18170_valueOrError3).PropagateFailure<Dafny.Aws.Crypto.GetEncryptionMaterialsOutput>();
        return res;
      }
      res = @Wrappers_Compile.Result<Dafny.Aws.Crypto.GetEncryptionMaterialsOutput, Dafny.ISequence<char>>.create_Success(@Dafny.Aws.Crypto.GetEncryptionMaterialsOutput.create((_18168_result).dtor_materials));
      return res;
      return res;
    }
    public Wrappers_Compile.Result<Dafny.Aws.Crypto.DecryptMaterialsOutput, Dafny.ISequence<char>> DecryptMaterials(Dafny.Aws.Crypto.DecryptMaterialsInput input)
    {
      Wrappers_Compile.Result<Dafny.Aws.Crypto.DecryptMaterialsOutput, Dafny.ISequence<char>> res = Wrappers_Compile.Result<Dafny.Aws.Crypto.DecryptMaterialsOutput, Dafny.ISequence<char>>.Default(Dafny.Aws.Crypto.DecryptMaterialsOutput.Default());
      Wrappers_Compile.Option<Dafny.ISequence<byte>> _18171_vkey;
      _18171_vkey = @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_None();
      ushort _18172_algID;
      _18172_algID = AlgorithmSuite.__default.PolymorphIDToInternalID((input).dtor_algorithmSuiteId);
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _18173_encCtx;
      _18173_encCtx = (input).dtor_encryptionContext;
      if ((AlgorithmSuite.ID.SignatureType(_18172_algID)).is_Some) {
        Dafny.ISequence<byte> _18174_reservedField;
        _18174_reservedField = Materials.__default.EC__PUBLIC__KEY__FIELD;
        if (!(_18173_encCtx).Contains((_18174_reservedField))) {
          res = @Wrappers_Compile.Result<Dafny.Aws.Crypto.DecryptMaterialsOutput, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Could not get materials required for decryption."));
          return res;
        }
        Dafny.ISequence<byte> _18175_encodedVKey;
        _18175_encodedVKey = Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Select(_18173_encCtx,_18174_reservedField);
        Dafny.ISequence<char> _18176_utf8Decoded = Dafny.Sequence<char>.Empty;
        Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>> _18177_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.Default(Dafny.Sequence<char>.Empty);
        Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>> _out67;
        _out67 = UTF8.__default.Decode(_18175_encodedVKey);
        _18177_valueOrError0 = _out67;
        if ((_18177_valueOrError0).IsFailure()) {
          res = (_18177_valueOrError0).PropagateFailure<Dafny.Aws.Crypto.DecryptMaterialsOutput>();
          return res;
        }
        _18176_utf8Decoded = (_18177_valueOrError0).Extract();
        Dafny.ISequence<byte> _18178_base64Decoded = Dafny.Sequence<byte>.Empty;
        Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18179_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
        _18179_valueOrError1 = Base64_Compile.__default.Decode(_18176_utf8Decoded);
        if ((_18179_valueOrError1).IsFailure()) {
          res = (_18179_valueOrError1).PropagateFailure<Dafny.Aws.Crypto.DecryptMaterialsOutput>();
          return res;
        }
        _18178_base64Decoded = (_18179_valueOrError1).Extract();
        _18171_vkey = @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(_18178_base64Decoded);
      }
      Dafny.Aws.Crypto.DecryptionMaterials _18180_materials;
      _18180_materials = @Dafny.Aws.Crypto.DecryptionMaterials.create((input).dtor_algorithmSuiteId, _18173_encCtx, @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_None(), _18171_vkey);
      Dafny.Aws.Crypto.OnDecryptOutput _18181_result = Dafny.Aws.Crypto.OnDecryptOutput.Default();
      Wrappers_Compile.Result<Dafny.Aws.Crypto.OnDecryptOutput, Dafny.ISequence<char>> _18182_valueOrError2 = Wrappers_Compile.Result<Dafny.Aws.Crypto.OnDecryptOutput, Dafny.ISequence<char>>.Default(Dafny.Aws.Crypto.OnDecryptOutput.Default());
      Wrappers_Compile.Result<Dafny.Aws.Crypto.OnDecryptOutput, Dafny.ISequence<char>> _out68;
      _out68 = ((this).keyring).OnDecrypt(@Dafny.Aws.Crypto.OnDecryptInput.create(_18180_materials, (input).dtor_encryptedDataKeys));
      _18182_valueOrError2 = _out68;
      if ((_18182_valueOrError2).IsFailure()) {
        res = (_18182_valueOrError2).PropagateFailure<Dafny.Aws.Crypto.DecryptMaterialsOutput>();
        return res;
      }
      _18181_result = (_18182_valueOrError2).Extract();
      if ((((_18181_result).dtor_materials).dtor_plaintextDataKey).is_None) {
        res = @Wrappers_Compile.Result<Dafny.Aws.Crypto.DecryptMaterialsOutput, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Keyring.OnDecrypt failed to decrypt the plaintext data key."));
        return res;
      }
      res = @Wrappers_Compile.Result<Dafny.Aws.Crypto.DecryptMaterialsOutput, Dafny.ISequence<char>>.create_Success(@Dafny.Aws.Crypto.DecryptMaterialsOutput.create((_18181_result).dtor_materials));
      return res;
      return res;
    }
    public bool OnEncryptResultValid(Dafny.Aws.Crypto.GetEncryptionMaterialsInput input, Dafny.Aws.Crypto.OnEncryptOutput result)
    {
      return ((((((result).dtor_materials).dtor_plaintextDataKey).is_Some) && (DefaultCMMDef.__default.Serializable((result).dtor_materials))) && (!((((input).dtor_algorithmSuiteId).is_None) || ((AlgorithmSuite.ID.SignatureType(AlgorithmSuite.__default.PolymorphIDToInternalID(((input).dtor_algorithmSuiteId).dtor_value))).is_Some)) || ((((result).dtor_materials).dtor_encryptionContext).Contains((Materials.__default.EC__PUBLIC__KEY__FIELD))))) && (((System.Func<Wrappers_Compile.Option<Dafny.Aws.Crypto.AlgorithmSuiteId>, bool>)((_source20) => {
        if (_source20.is_None) {
          return (AlgorithmSuite.__default.PolymorphIDToInternalID(((result).dtor_materials).dtor_algorithmSuiteId)) == (888);
        } else {
          Dafny.Aws.Crypto.AlgorithmSuiteId _18183___mcc_h0 = ((Wrappers_Compile.Option_Some<Dafny.Aws.Crypto.AlgorithmSuiteId>)_source20).@value;
          return Dafny.Helpers.Let<Dafny.Aws.Crypto.AlgorithmSuiteId, bool>(_18183___mcc_h0, _pat_let6_0 => Dafny.Helpers.Let<Dafny.Aws.Crypto.AlgorithmSuiteId, bool>(_pat_let6_0, _18184_id => object.Equals(((result).dtor_materials).dtor_algorithmSuiteId, _18184_id)));
        }
      }))((input).dtor_algorithmSuiteId));
    }
    public Dafny.Aws.Crypto.IKeyring _keyring;public Dafny.Aws.Crypto.IKeyring keyring { get {
      return this._keyring;
    } }
  }

  public partial class __default {
    public static bool Serializable(Dafny.Aws.Crypto.EncryptionMaterials mat) {
      return ((new BigInteger(((mat).dtor_encryptedDataKeys).Count)).Sign == 1) && (EncryptionContext.__default.Serializable((mat).dtor_encryptionContext));
    }
  }
} // end of namespace DefaultCMMDef
namespace Serialize_Compile {










  public partial class __default {
    public static Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>> SerializeHeaderBody(Streams_Compile.ByteWriter wr, MessageHeader.HeaderBody hb)
    {
      Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>> ret = Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>>.Default(BigInteger.Zero);
      BigInteger _18185_totalWritten;
      _18185_totalWritten = BigInteger.Zero;
      BigInteger _18186_len;
      BigInteger _out69;
      _out69 = (wr).WriteByte((byte)((hb).dtor_version));
      _18186_len = _out69;
      _18185_totalWritten = (_18185_totalWritten) + (_18186_len);
      BigInteger _out70;
      _out70 = (wr).WriteByte((byte)((hb).dtor_typ));
      _18186_len = _out70;
      _18185_totalWritten = (_18185_totalWritten) + (_18186_len);
      BigInteger _out71;
      _out71 = (wr).WriteUInt16((ushort)((hb).dtor_algorithmSuiteID));
      _18186_len = _out71;
      _18185_totalWritten = (_18185_totalWritten) + (_18186_len);
      BigInteger _out72;
      _out72 = (wr).WriteBytes((hb).dtor_messageID);
      _18186_len = _out72;
      _18185_totalWritten = (_18185_totalWritten) + (_18186_len);
      Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>> _18187_valueOrError0 = Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>>.Default(BigInteger.Zero);
      Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>> _out73;
      _out73 = Serialize_Compile.__default.SerializeAAD(wr, (hb).dtor_aad);
      _18187_valueOrError0 = _out73;
      if ((_18187_valueOrError0).IsFailure()) {
        ret = (_18187_valueOrError0).PropagateFailure<BigInteger>();
        return ret;
      }
      _18186_len = (_18187_valueOrError0).Extract();
      _18185_totalWritten = (_18185_totalWritten) + (_18186_len);
      BigInteger _out74;
      _out74 = Serialize_Compile.__default.SerializeEDKs(wr, (hb).dtor_encryptedDataKeys);
      _18186_len = _out74;
      _18185_totalWritten = (_18185_totalWritten) + (_18186_len);
      byte _18188_contentType;
      _18188_contentType = MessageHeader.__default.ContentTypeToUInt8((hb).dtor_contentType);
      BigInteger _out75;
      _out75 = (wr).WriteByte(_18188_contentType);
      _18186_len = _out75;
      _18185_totalWritten = (_18185_totalWritten) + (_18186_len);
      BigInteger _out76;
      _out76 = (wr).WriteBytes(MessageHeader.__default.Reserved);
      _18186_len = _out76;
      _18185_totalWritten = (_18185_totalWritten) + (_18186_len);
      BigInteger _out77;
      _out77 = (wr).WriteByte((hb).dtor_ivLength);
      _18186_len = _out77;
      _18185_totalWritten = (_18185_totalWritten) + (_18186_len);
      BigInteger _out78;
      _out78 = (wr).WriteUInt32((hb).dtor_frameLength);
      _18186_len = _out78;
      _18185_totalWritten = (_18185_totalWritten) + (_18186_len);
      ret = @Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>>.create_Success(_18185_totalWritten);
      return ret;
      return ret;
    }
    public static Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>> SerializeHeaderAuthentication(Streams_Compile.ByteWriter wr, MessageHeader.HeaderAuthentication ha)
    {
      Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>> ret = Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>>.Default(BigInteger.Zero);
      BigInteger _18189_m;
      BigInteger _out79;
      _out79 = (wr).WriteBytes((ha).dtor_iv);
      _18189_m = _out79;
      BigInteger _18190_n;
      BigInteger _out80;
      _out80 = (wr).WriteBytes((ha).dtor_authenticationTag);
      _18190_n = _out80;
      ret = @Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>>.create_Success((_18189_m) + (_18190_n));
      return ret;
      return ret;
    }
    public static Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>> SerializeAAD(Streams_Compile.ByteWriter wr, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> kvPairs)
    {
      Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>> ret = Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>>.Default(BigInteger.Zero);
      BigInteger _18191_totalWritten;
      _18191_totalWritten = BigInteger.Zero;
      BigInteger _18192_kvPairsLength;
      BigInteger _out81;
      _out81 = EncryptionContext.__default.ComputeLength(kvPairs);
      _18192_kvPairsLength = _out81;
      BigInteger _18193_len;
      BigInteger _out82;
      _out82 = (wr).WriteUInt16((ushort)(_18192_kvPairsLength));
      _18193_len = _out82;
      _18191_totalWritten = (_18191_totalWritten) + (_18193_len);
      Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>> _18194_valueOrError0 = Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>>.Default(BigInteger.Zero);
      Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>> _out83;
      _out83 = Serialize_Compile.__default.SerializeKVPairs(wr, kvPairs);
      _18194_valueOrError0 = _out83;
      if ((_18194_valueOrError0).IsFailure()) {
        ret = (_18194_valueOrError0).PropagateFailure<BigInteger>();
        return ret;
      }
      _18193_len = (_18194_valueOrError0).Extract();
      _18191_totalWritten = (_18191_totalWritten) + (_18193_len);
      ret = @Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>>.create_Success(_18191_totalWritten);
      return ret;
      return ret;
    }
    public static Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>> SerializeKVPairs(Streams_Compile.ByteWriter wr, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext)
    {
      Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>> ret = Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>>.Default(BigInteger.Zero);
      BigInteger _18195_newlyWritten;
      _18195_newlyWritten = BigInteger.Zero;
      if ((new BigInteger((encryptionContext).Count)).Sign == 0) {
        ret = @Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>>.create_Success(_18195_newlyWritten);
        return ret;
      }
      BigInteger _18196_len;
      BigInteger _out84;
      _out84 = (wr).WriteUInt16((ushort)(encryptionContext).Count);
      _18196_len = _out84;
      _18195_newlyWritten = (_18195_newlyWritten) + (_18196_len);
      Dafny.ISequence<Dafny.ISequence<byte>> _18197_keys;
      Dafny.ISequence<Dafny.ISequence<byte>> _out85;
      _out85 = Sets.__default.SetToOrderedSequence<byte>((encryptionContext).Keys, StandardLibrary_mUInt_Compile.__default.UInt8Less);
      _18197_keys = _out85;
      BigInteger _18198_j;
      _18198_j = BigInteger.Zero;
      while ((_18198_j) < (new BigInteger((_18197_keys).Count))) {
        Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>> _18199_valueOrError0 = Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>>.Default(BigInteger.Zero);
        Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>> _out86;
        _out86 = Serialize_Compile.__default.SerializeKVPair(wr, (_18197_keys).Select(_18198_j), Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Select(encryptionContext,(_18197_keys).Select(_18198_j)));
        _18199_valueOrError0 = _out86;
        if ((_18199_valueOrError0).IsFailure()) {
          ret = (_18199_valueOrError0).PropagateFailure<BigInteger>();
          return ret;
        }
        _18196_len = (_18199_valueOrError0).Extract();
        _18195_newlyWritten = (_18195_newlyWritten) + (_18196_len);
        _18198_j = (_18198_j) + (BigInteger.One);
      }
      ret = @Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>>.create_Success(_18195_newlyWritten);
      return ret;
      return ret;
    }
    public static Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>> SerializeKVPair(Streams_Compile.ByteWriter wr, Dafny.ISequence<byte> k, Dafny.ISequence<byte> v)
    {
      Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>> ret = Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>>.Default(BigInteger.Zero);
      BigInteger _18200_newlyWritten;
      _18200_newlyWritten = BigInteger.Zero;
      BigInteger _18201_len;
      BigInteger _out87;
      _out87 = (wr).WriteUInt16((ushort)(k).Count);
      _18201_len = _out87;
      _18200_newlyWritten = (_18200_newlyWritten) + (_18201_len);
      BigInteger _out88;
      _out88 = (wr).WriteBytes(k);
      _18201_len = _out88;
      _18200_newlyWritten = (_18200_newlyWritten) + (_18201_len);
      BigInteger _out89;
      _out89 = (wr).WriteUInt16((ushort)(v).Count);
      _18201_len = _out89;
      _18200_newlyWritten = (_18200_newlyWritten) + (_18201_len);
      BigInteger _out90;
      _out90 = (wr).WriteBytes(v);
      _18201_len = _out90;
      _18200_newlyWritten = (_18200_newlyWritten) + (_18201_len);
      ret = @Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>>.create_Success(_18200_newlyWritten);
      return ret;
      return ret;
    }
    public static BigInteger SerializeEDKs(Streams_Compile.ByteWriter wr, MessageHeader.EncryptedDataKeys encryptedDataKeys)
    {
      BigInteger ret = BigInteger.Zero;
      BigInteger _18202_totalWritten;
      _18202_totalWritten = BigInteger.Zero;
      BigInteger _18203_len;
      BigInteger _out91;
      _out91 = (wr).WriteUInt16((ushort)((encryptedDataKeys).dtor_entries).Count);
      _18203_len = _out91;
      _18202_totalWritten = (_18202_totalWritten) + (_18203_len);
      BigInteger _18204_j;
      _18204_j = BigInteger.Zero;
      while ((_18204_j) < (new BigInteger(((encryptedDataKeys).dtor_entries).Count))) {
        Dafny.Aws.Crypto.EncryptedDataKey _18205_entry;
        _18205_entry = ((encryptedDataKeys).dtor_entries).Select(_18204_j);
        BigInteger _out92;
        _out92 = (wr).WriteUInt16((ushort)((_18205_entry).dtor_keyProviderId).Count);
        _18203_len = _out92;
        _18202_totalWritten = (_18202_totalWritten) + (_18203_len);
        BigInteger _out93;
        _out93 = (wr).WriteBytes((_18205_entry).dtor_keyProviderId);
        _18203_len = _out93;
        _18202_totalWritten = (_18202_totalWritten) + (_18203_len);
        BigInteger _out94;
        _out94 = (wr).WriteUInt16((ushort)((_18205_entry).dtor_keyProviderInfo).Count);
        _18203_len = _out94;
        _18202_totalWritten = (_18202_totalWritten) + (_18203_len);
        BigInteger _out95;
        _out95 = (wr).WriteBytes((_18205_entry).dtor_keyProviderInfo);
        _18203_len = _out95;
        _18202_totalWritten = (_18202_totalWritten) + (_18203_len);
        BigInteger _out96;
        _out96 = (wr).WriteUInt16((ushort)((_18205_entry).dtor_ciphertext).Count);
        _18203_len = _out96;
        _18202_totalWritten = (_18202_totalWritten) + (_18203_len);
        BigInteger _out97;
        _out97 = (wr).WriteBytes((_18205_entry).dtor_ciphertext);
        _18203_len = _out97;
        _18202_totalWritten = (_18202_totalWritten) + (_18203_len);
        _18204_j = (_18204_j) + (BigInteger.One);
      }
      ret = _18202_totalWritten;
      return ret;
      return ret;
    }
  }
} // end of namespace Serialize_Compile
namespace RawAESKeyringDef {















  public partial class RawAESKeyring : Dafny.Aws.Crypto.IKeyring {
    public RawAESKeyring() {
      this._keyNamespace = UTF8.ValidUTF8Bytes.Default();
      this._keyName = UTF8.ValidUTF8Bytes.Default();
      this._wrappingKey = Dafny.Sequence<byte>.Empty;
      this._wrappingAlgorithm = EncryptionSuites.EncryptionSuite.Default();
    }
    public bool Valid() {
      return ((((new BigInteger(((this).wrappingKey).Count)) == (new BigInteger(((this).wrappingAlgorithm).dtor_keyLen))) && ((RawAESKeyringDef.__default.VALID__ALGORITHMS).Contains(((this).wrappingAlgorithm)))) && (((this).wrappingAlgorithm).Valid())) && ((new BigInteger(((this).keyNamespace).Count)) < (StandardLibrary_mUInt_Compile.__default.UINT16__LIMIT));
    }
    public bool ValidEncryptionMaterials(Dafny.Aws.Crypto.EncryptionMaterials mat) {
      return ((!((AlgorithmSuite.ID.SignatureType(AlgorithmSuite.__default.PolymorphIDToInternalID((mat).dtor_algorithmSuiteId))).is_Some) || (((mat).dtor_signingKey).is_Some)) && (!(((mat).dtor_plaintextDataKey).is_Some) || (AlgorithmSuite.ID.ValidPlaintextDataKey(AlgorithmSuite.__default.PolymorphIDToInternalID((mat).dtor_algorithmSuiteId), ((mat).dtor_plaintextDataKey).dtor_value)))) && (!(((mat).dtor_plaintextDataKey).is_None) || ((new BigInteger(((mat).dtor_encryptedDataKeys).Count)).Sign == 0));
    }
    public void __ctor(Dafny.ISequence<byte> @namespace, Dafny.ISequence<byte> name, Dafny.ISequence<byte> key, EncryptionSuites.EncryptionSuite wrappingAlg)
    {
      (this)._keyNamespace = @namespace;
      (this)._keyName = name;
      (this)._wrappingKey = key;
      (this)._wrappingAlgorithm = wrappingAlg;
    }
    public Dafny.ISequence<byte> SerializeProviderInfo(Dafny.ISequence<byte> iv) {
      return Dafny.Sequence<byte>.Concat(Dafny.Sequence<byte>.Concat(Dafny.Sequence<byte>.Concat((this).keyName, Dafny.Sequence<byte>.FromElements(0, 0, 0, (byte)((((this).wrappingAlgorithm).dtor_tagLen) * (8)))), Dafny.Sequence<byte>.FromElements(0, 0, 0, ((this).wrappingAlgorithm).dtor_ivLen)), iv);
    }
    public Wrappers_Compile.Result<Dafny.Aws.Crypto.OnEncryptOutput, Dafny.ISequence<char>> OnEncrypt(Dafny.Aws.Crypto.OnEncryptInput input)
    {
      Wrappers_Compile.Result<Dafny.Aws.Crypto.OnEncryptOutput, Dafny.ISequence<char>> res = Wrappers_Compile.Result<Dafny.Aws.Crypto.OnEncryptOutput, Dafny.ISequence<char>>.Default(Dafny.Aws.Crypto.OnEncryptOutput.Default());
      Wrappers_Compile.Outcome<Dafny.ISequence<char>> _18206_valueOrError0 = Wrappers_Compile.Outcome<Dafny.ISequence<char>>.Default();
      _18206_valueOrError0 = Wrappers_Compile.__default.Need<Dafny.ISequence<char>>((this).Valid(), Dafny.Sequence<char>.FromString("Keyring in invalid state"));
      if ((_18206_valueOrError0).IsFailure()) {
        res = (_18206_valueOrError0).PropagateFailure<Dafny.Aws.Crypto.OnEncryptOutput>();
        return res;
      }
      Wrappers_Compile.Outcome<Dafny.ISequence<char>> _18207_valueOrError1 = Wrappers_Compile.Outcome<Dafny.ISequence<char>>.Default();
      _18207_valueOrError1 = Wrappers_Compile.__default.Need<Dafny.ISequence<char>>((this).ValidEncryptionMaterials((input).dtor_materials), Dafny.Sequence<char>.FromString("input encryption materials invalid"));
      if ((_18207_valueOrError1).IsFailure()) {
        res = (_18207_valueOrError1).PropagateFailure<Dafny.Aws.Crypto.OnEncryptOutput>();
        return res;
      }
      bool _18208_valid;
      bool _out98;
      _out98 = EncryptionContext.__default.CheckSerializable(((input).dtor_materials).dtor_encryptionContext);
      _18208_valid = _out98;
      if (!(_18208_valid)) {
        res = @Wrappers_Compile.Result<Dafny.Aws.Crypto.OnEncryptOutput, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Unable to serialize encryption context"));
        return res;
      }
      Dafny.Aws.Crypto.EncryptionMaterials _18209_materialsWithDataKey;
      _18209_materialsWithDataKey = (input).dtor_materials;
      if (((_18209_materialsWithDataKey).dtor_plaintextDataKey).is_None) {
        Dafny.ISequence<byte> _18210_k = Dafny.Sequence<byte>.Empty;
        Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18211_valueOrError2 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
        Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out99;
        _out99 = Random_Compile.__default.GenerateBytes((int)(AlgorithmSuite.ID.KeyLength(AlgorithmSuite.__default.PolymorphIDToInternalID(((input).dtor_materials).dtor_algorithmSuiteId))));
        _18211_valueOrError2 = _out99;
        if ((_18211_valueOrError2).IsFailure()) {
          res = (_18211_valueOrError2).PropagateFailure<Dafny.Aws.Crypto.OnEncryptOutput>();
          return res;
        }
        _18210_k = (_18211_valueOrError2).Extract();
        _18209_materialsWithDataKey = @Dafny.Aws.Crypto.EncryptionMaterials.create((_18209_materialsWithDataKey).dtor_algorithmSuiteId, (_18209_materialsWithDataKey).dtor_encryptionContext, Dafny.Sequence<Dafny.Aws.Crypto.EncryptedDataKey>.FromElements(), @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(_18210_k), (_18209_materialsWithDataKey).dtor_signingKey);
      }
      Dafny.ISequence<byte> _18212_iv = Dafny.Sequence<byte>.Empty;
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18213_valueOrError3 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out100;
      _out100 = Random_Compile.__default.GenerateBytes((int)(((this).wrappingAlgorithm).dtor_ivLen));
      _18213_valueOrError3 = _out100;
      if ((_18213_valueOrError3).IsFailure()) {
        res = (_18213_valueOrError3).PropagateFailure<Dafny.Aws.Crypto.OnEncryptOutput>();
        return res;
      }
      _18212_iv = (_18213_valueOrError3).Extract();
      Dafny.ISequence<byte> _18214_providerInfo;
      _18214_providerInfo = (this).SerializeProviderInfo(_18212_iv);
      Streams_Compile.ByteWriter _18215_wr;
      Streams_Compile.ByteWriter _nw7 = new Streams_Compile.ByteWriter();
      _nw7.__ctor();
      _18215_wr = _nw7;
      BigInteger _18216___v0 = BigInteger.Zero;
      Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>> _18217_valueOrError4 = Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>>.Default(BigInteger.Zero);
      Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>> _out101;
      _out101 = Serialize_Compile.__default.SerializeKVPairs(_18215_wr, ((input).dtor_materials).dtor_encryptionContext);
      _18217_valueOrError4 = _out101;
      if ((_18217_valueOrError4).IsFailure()) {
        res = (_18217_valueOrError4).PropagateFailure<Dafny.Aws.Crypto.OnEncryptOutput>();
        return res;
      }
      _18216___v0 = (_18217_valueOrError4).Extract();
      Dafny.ISequence<byte> _18218_aad;
      _18218_aad = (_18215_wr).GetDataWritten();
      AESEncryption.EncryptionOutput _18219_encryptResult = AESEncryption.EncryptionOutput.Default();
      Wrappers_Compile.Result<AESEncryption.EncryptionOutput, Dafny.ISequence<char>> _18220_valueOrError5 = Wrappers_Compile.Result<AESEncryption.EncryptionOutput, Dafny.ISequence<char>>.Default(AESEncryption.EncryptionOutput.Default());
      Wrappers_Compile.Result<AESEncryption.EncryptionOutput, Dafny.ISequence<char>> _out102;
      _out102 = AESEncryption.__default.AESEncrypt((this).wrappingAlgorithm, _18212_iv, (this).wrappingKey, ((_18209_materialsWithDataKey).dtor_plaintextDataKey).dtor_value, _18218_aad);
      _18220_valueOrError5 = _out102;
      if ((_18220_valueOrError5).IsFailure()) {
        res = (_18220_valueOrError5).PropagateFailure<Dafny.Aws.Crypto.OnEncryptOutput>();
        return res;
      }
      _18219_encryptResult = (_18220_valueOrError5).Extract();
      Dafny.ISequence<byte> _18221_encryptedKey;
      _18221_encryptedKey = RawAESKeyringDef.__default.SerializeEDKCiphertext(_18219_encryptResult);
      if ((StandardLibrary_mUInt_Compile.__default.UINT16__LIMIT) <= (new BigInteger((_18214_providerInfo).Count))) {
        res = @Wrappers_Compile.Result<Dafny.Aws.Crypto.OnEncryptOutput, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Serialized provider info too long."));
        return res;
      }
      if ((StandardLibrary_mUInt_Compile.__default.UINT16__LIMIT) <= (new BigInteger((_18221_encryptedKey).Count))) {
        res = @Wrappers_Compile.Result<Dafny.Aws.Crypto.OnEncryptOutput, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Encrypted data key too long."));
        return res;
      }
      Dafny.Aws.Crypto.EncryptedDataKey _18222_edk;
      _18222_edk = @Dafny.Aws.Crypto.EncryptedDataKey.create((this).keyNamespace, _18214_providerInfo, _18221_encryptedKey);
      Dafny.ISequence<Dafny.Aws.Crypto.EncryptedDataKey> _18223_edks;
      _18223_edks = Dafny.Sequence<Dafny.Aws.Crypto.EncryptedDataKey>.Concat((_18209_materialsWithDataKey).dtor_encryptedDataKeys, Dafny.Sequence<Dafny.Aws.Crypto.EncryptedDataKey>.FromElements(_18222_edk));
      Dafny.Aws.Crypto.EncryptionMaterials _18224_r;
      _18224_r = @Dafny.Aws.Crypto.EncryptionMaterials.create((_18209_materialsWithDataKey).dtor_algorithmSuiteId, (_18209_materialsWithDataKey).dtor_encryptionContext, _18223_edks, (_18209_materialsWithDataKey).dtor_plaintextDataKey, (_18209_materialsWithDataKey).dtor_signingKey);
      res = @Wrappers_Compile.Result<Dafny.Aws.Crypto.OnEncryptOutput, Dafny.ISequence<char>>.create_Success(@Dafny.Aws.Crypto.OnEncryptOutput.create(_18224_r));
      return res;
    }
    public Wrappers_Compile.Result<Dafny.Aws.Crypto.OnDecryptOutput, Dafny.ISequence<char>> OnDecrypt(Dafny.Aws.Crypto.OnDecryptInput input)
    {
      Wrappers_Compile.Result<Dafny.Aws.Crypto.OnDecryptOutput, Dafny.ISequence<char>> res = Wrappers_Compile.Result<Dafny.Aws.Crypto.OnDecryptOutput, Dafny.ISequence<char>>.Default(Dafny.Aws.Crypto.OnDecryptOutput.Default());
      Wrappers_Compile.Outcome<Dafny.ISequence<char>> _18225_valueOrError0 = Wrappers_Compile.Outcome<Dafny.ISequence<char>>.Default();
      _18225_valueOrError0 = Wrappers_Compile.__default.Need<Dafny.ISequence<char>>((this).Valid(), Dafny.Sequence<char>.FromString("Keyring in invalid state"));
      if ((_18225_valueOrError0).IsFailure()) {
        res = (_18225_valueOrError0).PropagateFailure<Dafny.Aws.Crypto.OnDecryptOutput>();
        return res;
      }
      if ((((input).dtor_materials).dtor_plaintextDataKey).is_Some) {
        res = @Wrappers_Compile.Result<Dafny.Aws.Crypto.OnDecryptOutput, Dafny.ISequence<char>>.create_Success(@Dafny.Aws.Crypto.OnDecryptOutput.create((input).dtor_materials));
        return res;
      }
      BigInteger _18226_i;
      _18226_i = BigInteger.Zero;
      while ((_18226_i) < (new BigInteger(((input).dtor_encryptedDataKeys).Count))) {
        if ((this).ShouldDecryptEDK(((input).dtor_encryptedDataKeys).Select(_18226_i))) {
          bool _18227_valid;
          bool _out103;
          _out103 = EncryptionContext.__default.CheckSerializable(((input).dtor_materials).dtor_encryptionContext);
          _18227_valid = _out103;
          if (!(_18227_valid)) {
            res = @Wrappers_Compile.Result<Dafny.Aws.Crypto.OnDecryptOutput, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Unable to serialize encryption context"));
            return res;
          }
          Streams_Compile.ByteWriter _18228_wr;
          Streams_Compile.ByteWriter _nw8 = new Streams_Compile.ByteWriter();
          _nw8.__ctor();
          _18228_wr = _nw8;
          BigInteger _18229___v1 = BigInteger.Zero;
          Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>> _18230_valueOrError1 = Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>>.Default(BigInteger.Zero);
          Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>> _out104;
          _out104 = Serialize_Compile.__default.SerializeKVPairs(_18228_wr, ((input).dtor_materials).dtor_encryptionContext);
          _18230_valueOrError1 = _out104;
          if ((_18230_valueOrError1).IsFailure()) {
            res = (_18230_valueOrError1).PropagateFailure<Dafny.Aws.Crypto.OnDecryptOutput>();
            return res;
          }
          _18229___v1 = (_18230_valueOrError1).Extract();
          Dafny.ISequence<byte> _18231_aad;
          _18231_aad = (_18228_wr).GetDataWritten();
          Dafny.ISequence<byte> _18232_iv;
          _18232_iv = (this).GetIvFromProvInfo((((input).dtor_encryptedDataKeys).Select(_18226_i)).dtor_keyProviderInfo);
          AESEncryption.EncryptionOutput _18233_encryptionOutput;
          _18233_encryptionOutput = RawAESKeyringDef.__default.DeserializeEDKCiphertext((((input).dtor_encryptedDataKeys).Select(_18226_i)).dtor_ciphertext, new BigInteger(((this).wrappingAlgorithm).dtor_tagLen));
          Dafny.ISequence<byte> _18234_ptKey = Dafny.Sequence<byte>.Empty;
          Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18235_valueOrError2 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
          Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out105;
          _out105 = AESEncryption.__default.AESDecrypt((this).wrappingAlgorithm, (this).wrappingKey, (_18233_encryptionOutput).dtor_cipherText, (_18233_encryptionOutput).dtor_authTag, _18232_iv, _18231_aad);
          _18235_valueOrError2 = _out105;
          if ((_18235_valueOrError2).IsFailure()) {
            res = (_18235_valueOrError2).PropagateFailure<Dafny.Aws.Crypto.OnDecryptOutput>();
            return res;
          }
          _18234_ptKey = (_18235_valueOrError2).Extract();
          if (AlgorithmSuite.ID.ValidPlaintextDataKey(AlgorithmSuite.__default.PolymorphIDToInternalID(((input).dtor_materials).dtor_algorithmSuiteId), _18234_ptKey)) {
            Dafny.Aws.Crypto.DecryptionMaterials _18236_r;
            _18236_r = @Dafny.Aws.Crypto.DecryptionMaterials.create(((input).dtor_materials).dtor_algorithmSuiteId, ((input).dtor_materials).dtor_encryptionContext, @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(_18234_ptKey), ((input).dtor_materials).dtor_verificationKey);
            res = @Wrappers_Compile.Result<Dafny.Aws.Crypto.OnDecryptOutput, Dafny.ISequence<char>>.create_Success(@Dafny.Aws.Crypto.OnDecryptOutput.create(_18236_r));
            return res;
          } else {
            res = @Wrappers_Compile.Result<Dafny.Aws.Crypto.OnDecryptOutput, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Decryption failed: bad datakey length."));
            return res;
          }
        }
        _18226_i = (_18226_i) + (BigInteger.One);
      }
      res = @Wrappers_Compile.Result<Dafny.Aws.Crypto.OnDecryptOutput, Dafny.ISequence<char>>.create_Success(@Dafny.Aws.Crypto.OnDecryptOutput.create((input).dtor_materials));
      return res;
      return res;
    }
    public bool ShouldDecryptEDK(Dafny.Aws.Crypto.EncryptedDataKey edk) {
      return ((((edk).dtor_keyProviderId).Equals(((this).keyNamespace))) && ((this).ValidProviderInfo((edk).dtor_keyProviderInfo))) && ((new BigInteger(((this).wrappingAlgorithm).dtor_tagLen)) <= (new BigInteger(((edk).dtor_ciphertext).Count)));
    }
    public bool ValidProviderInfo(Dafny.ISequence<byte> info) {
      return ((((((new BigInteger((info).Count)) == ((((new BigInteger(((this).keyName).Count)) + (RawAESKeyringDef.__default.AUTH__TAG__LEN__LEN)) + (RawAESKeyringDef.__default.IV__LEN__LEN)) + (new BigInteger(((this).wrappingAlgorithm).dtor_ivLen)))) && (((info).Subsequence(BigInteger.Zero, new BigInteger(((this).keyName).Count))).Equals(((this).keyName)))) && ((StandardLibrary_mUInt_Compile.__default.SeqToUInt32((info).Subsequence(new BigInteger(((this).keyName).Count), (new BigInteger(((this).keyName).Count)) + (RawAESKeyringDef.__default.AUTH__TAG__LEN__LEN)))) == (128U))) && ((StandardLibrary_mUInt_Compile.__default.SeqToUInt32((info).Subsequence(new BigInteger(((this).keyName).Count), (new BigInteger(((this).keyName).Count)) + (RawAESKeyringDef.__default.AUTH__TAG__LEN__LEN)))) == (((uint)(((this).wrappingAlgorithm).dtor_tagLen)) * (8U)))) && ((StandardLibrary_mUInt_Compile.__default.SeqToUInt32((info).Subsequence((new BigInteger(((this).keyName).Count)) + (RawAESKeyringDef.__default.AUTH__TAG__LEN__LEN), ((new BigInteger(((this).keyName).Count)) + (RawAESKeyringDef.__default.AUTH__TAG__LEN__LEN)) + (RawAESKeyringDef.__default.IV__LEN__LEN)))) == ((uint)(((this).wrappingAlgorithm).dtor_ivLen)))) && ((StandardLibrary_mUInt_Compile.__default.SeqToUInt32((info).Subsequence((new BigInteger(((this).keyName).Count)) + (RawAESKeyringDef.__default.AUTH__TAG__LEN__LEN), ((new BigInteger(((this).keyName).Count)) + (RawAESKeyringDef.__default.AUTH__TAG__LEN__LEN)) + (RawAESKeyringDef.__default.IV__LEN__LEN)))) == (12U));
    }
    public Dafny.ISequence<byte> GetIvFromProvInfo(Dafny.ISequence<byte> info) {
      return (info).Drop(((new BigInteger(((this).keyName).Count)) + (RawAESKeyringDef.__default.AUTH__TAG__LEN__LEN)) + (RawAESKeyringDef.__default.IV__LEN__LEN));
    }
    public Dafny.ISequence<byte> _keyNamespace;public Dafny.ISequence<byte> keyNamespace { get {
      return this._keyNamespace;
    } }
    public Dafny.ISequence<byte> _keyName;public Dafny.ISequence<byte> keyName { get {
      return this._keyName;
    } }
    public Dafny.ISequence<byte> _wrappingKey;public Dafny.ISequence<byte> wrappingKey { get {
      return this._wrappingKey;
    } }
    public EncryptionSuites.EncryptionSuite _wrappingAlgorithm;public EncryptionSuites.EncryptionSuite wrappingAlgorithm { get {
      return this._wrappingAlgorithm;
    } }
  }

  public partial class __default {
    public static AESEncryption.EncryptionOutput DeserializeEDKCiphertext(Dafny.ISequence<byte> ciphertext, BigInteger tagLen)
    {
      BigInteger _18237_encryptedKeyLength = (new BigInteger((ciphertext).Count)) - (tagLen);
      return @AESEncryption.EncryptionOutput.create((ciphertext).Take(_18237_encryptedKeyLength), (ciphertext).Drop(_18237_encryptedKeyLength));
    }
    public static Dafny.ISequence<byte> SerializeEDKCiphertext(AESEncryption.EncryptionOutput encOutput) {
      return Dafny.Sequence<byte>.Concat((encOutput).dtor_cipherText, (encOutput).dtor_authTag);
    }
    public static Dafny.ISet<EncryptionSuites.EncryptionSuite> VALID__ALGORITHMS { get {
      return Dafny.Set<EncryptionSuites.EncryptionSuite>.FromElements(EncryptionSuites.__default.AES__GCM__128, EncryptionSuites.__default.AES__GCM__192, EncryptionSuites.__default.AES__GCM__256);
    } }
    public static BigInteger AUTH__TAG__LEN__LEN { get {
      return new BigInteger(4);
    } }
    public static BigInteger IV__LEN__LEN { get {
      return new BigInteger(4);
    } }
  }
} // end of namespace RawAESKeyringDef
namespace Dafny.Aws.Crypto.AwsCryptographicMaterialProvidersClient {










  public partial class AwsCryptographicMaterialProvidersClient : Dafny.Aws.Crypto.IAwsCryptographicMaterialsProviderClient {
    public AwsCryptographicMaterialProvidersClient() {
    }
    public void __ctor()
    {
    }
    public Dafny.Aws.Crypto.IKeyring CreateRawAesKeyring(Dafny.Aws.Crypto.CreateRawAesKeyringInput input)
    {
      Dafny.Aws.Crypto.IKeyring res = default(Dafny.Aws.Crypto.IKeyring);
      EncryptionSuites.EncryptionSuite _18238_wrappingAlg = EncryptionSuites.EncryptionSuite.Default();
      if (object.Equals((input).dtor_wrappingAlg, @Dafny.Aws.Crypto.AesWrappingAlg.create_ALG__AES128__GCM__IV12__TAG16())) {
        _18238_wrappingAlg = EncryptionSuites.__default.AES__GCM__128;
      } else if (object.Equals((input).dtor_wrappingAlg, @Dafny.Aws.Crypto.AesWrappingAlg.create_ALG__AES192__GCM__IV12__TAG16())) {
        _18238_wrappingAlg = EncryptionSuites.__default.AES__GCM__192;
      } else {
        _18238_wrappingAlg = EncryptionSuites.__default.AES__GCM__256;
      }
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18239_namespaceRes;
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out106;
      _out106 = UTF8.__default.Encode((input).dtor_keyNamespace);
      _18239_namespaceRes = _out106;
      Dafny.ISequence<byte> _18240_namespace = UTF8.ValidUTF8Bytes.Default();
      if ((_18239_namespaceRes).is_Success) {
        _18240_namespace = (_18239_namespaceRes).dtor_value;
      }
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18241_nameRes;
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out107;
      _out107 = UTF8.__default.Encode((input).dtor_keyName);
      _18241_nameRes = _out107;
      Dafny.ISequence<byte> _18242_name = UTF8.ValidUTF8Bytes.Default();
      if ((_18241_nameRes).is_Success) {
        _18242_name = (_18241_nameRes).dtor_value;
      }
      if (!((new BigInteger((_18240_namespace).Count)) < (StandardLibrary_mUInt_Compile.__default.UINT16__LIMIT))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/src/SDK/AwsCryptographicMaterialProviders.dfy(55,6): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!((((new BigInteger(((input).dtor_wrappingKey).Count)) == (new BigInteger(16))) || ((new BigInteger(((input).dtor_wrappingKey).Count)) == (new BigInteger(24)))) || ((new BigInteger(((input).dtor_wrappingKey).Count)) == (new BigInteger(32))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/src/SDK/AwsCryptographicMaterialProviders.dfy(56,6): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!((new BigInteger(((input).dtor_wrappingKey).Count)) == (new BigInteger((_18238_wrappingAlg).dtor_keyLen)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/src/SDK/AwsCryptographicMaterialProviders.dfy(57,6): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      RawAESKeyringDef.RawAESKeyring _nw9 = new RawAESKeyringDef.RawAESKeyring();
      _nw9.__ctor(_18240_namespace, _18242_name, (input).dtor_wrappingKey, _18238_wrappingAlg);
      res = _nw9;
      return res;
      return res;
    }
    public Dafny.Aws.Crypto.ICryptographicMaterialsManager CreateDefaultCryptographicMaterialsManager(Dafny.Aws.Crypto.CreateDefaultCryptographicMaterialsManagerInput input)
    {
      Dafny.Aws.Crypto.ICryptographicMaterialsManager res = default(Dafny.Aws.Crypto.ICryptographicMaterialsManager);
      DefaultCMMDef.DefaultCMM _nw10 = new DefaultCMMDef.DefaultCMM();
      _nw10.OfKeyring((input).dtor_keyring);
      res = _nw10;
      return res;
      return res;
    }
  }

} // end of namespace Dafny.Aws.Crypto.AwsCryptographicMaterialProvidersClient
namespace MessageBody_Compile {











  public abstract class BodyAADContent {
    public BodyAADContent() { }
    private static readonly BodyAADContent theDefault = create_AADRegularFrame();
    public static BodyAADContent Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<MessageBody_Compile.BodyAADContent> _TYPE = new Dafny.TypeDescriptor<MessageBody_Compile.BodyAADContent>(MessageBody_Compile.BodyAADContent.Default());
    public static Dafny.TypeDescriptor<MessageBody_Compile.BodyAADContent> _TypeDescriptor() {
      return _TYPE;
    }
    public static BodyAADContent create_AADRegularFrame() {
      return new BodyAADContent_AADRegularFrame();
    }
    public static BodyAADContent create_AADFinalFrame() {
      return new BodyAADContent_AADFinalFrame();
    }
    public static BodyAADContent create_AADSingleBlock() {
      return new BodyAADContent_AADSingleBlock();
    }
    public bool is_AADRegularFrame { get { return this is BodyAADContent_AADRegularFrame; } }
    public bool is_AADFinalFrame { get { return this is BodyAADContent_AADFinalFrame; } }
    public bool is_AADSingleBlock { get { return this is BodyAADContent_AADSingleBlock; } }
    public static System.Collections.Generic.IEnumerable<BodyAADContent> AllSingletonConstructors {
      get {
        yield return BodyAADContent.create_AADRegularFrame();
        yield return BodyAADContent.create_AADFinalFrame();
        yield return BodyAADContent.create_AADSingleBlock();
      }
    }
  }
  public class BodyAADContent_AADRegularFrame : BodyAADContent {
    public BodyAADContent_AADRegularFrame() {
    }
    public override bool Equals(object other) {
      var oth = other as MessageBody_Compile.BodyAADContent_AADRegularFrame;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      return (int) hash;
    }
    public override string ToString() {
      string s = "MessageBody_Compile.BodyAADContent.AADRegularFrame";
      return s;
    }
  }
  public class BodyAADContent_AADFinalFrame : BodyAADContent {
    public BodyAADContent_AADFinalFrame() {
    }
    public override bool Equals(object other) {
      var oth = other as MessageBody_Compile.BodyAADContent_AADFinalFrame;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      return (int) hash;
    }
    public override string ToString() {
      string s = "MessageBody_Compile.BodyAADContent.AADFinalFrame";
      return s;
    }
  }
  public class BodyAADContent_AADSingleBlock : BodyAADContent {
    public BodyAADContent_AADSingleBlock() {
    }
    public override bool Equals(object other) {
      var oth = other as MessageBody_Compile.BodyAADContent_AADSingleBlock;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 2;
      return (int) hash;
    }
    public override string ToString() {
      string s = "MessageBody_Compile.BodyAADContent.AADSingleBlock";
      return s;
    }
  }

  public abstract class Frame {
    public Frame() { }
    private static readonly Frame theDefault = create_RegularFrame(0, Dafny.Sequence<byte>.Empty, Dafny.Sequence<byte>.Empty, Dafny.Sequence<byte>.Empty);
    public static Frame Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<MessageBody_Compile.Frame> _TYPE = new Dafny.TypeDescriptor<MessageBody_Compile.Frame>(MessageBody_Compile.Frame.Default());
    public static Dafny.TypeDescriptor<MessageBody_Compile.Frame> _TypeDescriptor() {
      return _TYPE;
    }
    public static Frame create_RegularFrame(uint seqNum, Dafny.ISequence<byte> iv, Dafny.ISequence<byte> encContent, Dafny.ISequence<byte> authTag) {
      return new Frame_RegularFrame(seqNum, iv, encContent, authTag);
    }
    public static Frame create_FinalFrame(uint seqNum, Dafny.ISequence<byte> iv, Dafny.ISequence<byte> encContent, Dafny.ISequence<byte> authTag) {
      return new Frame_FinalFrame(seqNum, iv, encContent, authTag);
    }
    public bool is_RegularFrame { get { return this is Frame_RegularFrame; } }
    public bool is_FinalFrame { get { return this is Frame_FinalFrame; } }
    public uint dtor_seqNum {
      get {
        var d = this;
        if (d is Frame_RegularFrame) { return ((Frame_RegularFrame)d).seqNum; }
        return ((Frame_FinalFrame)d).seqNum; 
      }
    }
    public Dafny.ISequence<byte> dtor_iv {
      get {
        var d = this;
        if (d is Frame_RegularFrame) { return ((Frame_RegularFrame)d).iv; }
        return ((Frame_FinalFrame)d).iv; 
      }
    }
    public Dafny.ISequence<byte> dtor_encContent {
      get {
        var d = this;
        if (d is Frame_RegularFrame) { return ((Frame_RegularFrame)d).encContent; }
        return ((Frame_FinalFrame)d).encContent; 
      }
    }
    public Dafny.ISequence<byte> dtor_authTag {
      get {
        var d = this;
        if (d is Frame_RegularFrame) { return ((Frame_RegularFrame)d).authTag; }
        return ((Frame_FinalFrame)d).authTag; 
      }
    }
  }
  public class Frame_RegularFrame : Frame {
    public readonly uint seqNum;
    public readonly Dafny.ISequence<byte> iv;
    public readonly Dafny.ISequence<byte> encContent;
    public readonly Dafny.ISequence<byte> authTag;
    public Frame_RegularFrame(uint seqNum, Dafny.ISequence<byte> iv, Dafny.ISequence<byte> encContent, Dafny.ISequence<byte> authTag) {
      this.seqNum = seqNum;
      this.iv = iv;
      this.encContent = encContent;
      this.authTag = authTag;
    }
    public override bool Equals(object other) {
      var oth = other as MessageBody_Compile.Frame_RegularFrame;
      return oth != null && this.seqNum == oth.seqNum && object.Equals(this.iv, oth.iv) && object.Equals(this.encContent, oth.encContent) && object.Equals(this.authTag, oth.authTag);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.seqNum));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.iv));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.encContent));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.authTag));
      return (int) hash;
    }
    public override string ToString() {
      string s = "MessageBody_Compile.Frame.RegularFrame";
      s += "(";
      s += Dafny.Helpers.ToString(this.seqNum);
      s += ", ";
      s += Dafny.Helpers.ToString(this.iv);
      s += ", ";
      s += Dafny.Helpers.ToString(this.encContent);
      s += ", ";
      s += Dafny.Helpers.ToString(this.authTag);
      s += ")";
      return s;
    }
  }
  public class Frame_FinalFrame : Frame {
    public readonly uint seqNum;
    public readonly Dafny.ISequence<byte> iv;
    public readonly Dafny.ISequence<byte> encContent;
    public readonly Dafny.ISequence<byte> authTag;
    public Frame_FinalFrame(uint seqNum, Dafny.ISequence<byte> iv, Dafny.ISequence<byte> encContent, Dafny.ISequence<byte> authTag) {
      this.seqNum = seqNum;
      this.iv = iv;
      this.encContent = encContent;
      this.authTag = authTag;
    }
    public override bool Equals(object other) {
      var oth = other as MessageBody_Compile.Frame_FinalFrame;
      return oth != null && this.seqNum == oth.seqNum && object.Equals(this.iv, oth.iv) && object.Equals(this.encContent, oth.encContent) && object.Equals(this.authTag, oth.authTag);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.seqNum));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.iv));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.encContent));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.authTag));
      return (int) hash;
    }
    public override string ToString() {
      string s = "MessageBody_Compile.Frame.FinalFrame";
      s += "(";
      s += Dafny.Helpers.ToString(this.seqNum);
      s += ", ";
      s += Dafny.Helpers.ToString(this.iv);
      s += ", ";
      s += Dafny.Helpers.ToString(this.encContent);
      s += ", ";
      s += Dafny.Helpers.ToString(this.authTag);
      s += ")";
      return s;
    }
  }

  public class SeqWithGhostFrames {
    public readonly Dafny.ISequence<byte> sequence;
    public SeqWithGhostFrames(Dafny.ISequence<byte> sequence) {
      this.sequence = sequence;
    }
    public override bool Equals(object other) {
      var oth = other as MessageBody_Compile.SeqWithGhostFrames;
      return oth != null && object.Equals(this.sequence, oth.sequence);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.sequence));
      return (int) hash;
    }
    public override string ToString() {
      string s = "MessageBody_Compile.SeqWithGhostFrames.SeqWithGhostFrames";
      s += "(";
      s += Dafny.Helpers.ToString(this.sequence);
      s += ")";
      return s;
    }
    private static readonly SeqWithGhostFrames theDefault = create(Dafny.Sequence<byte>.Empty);
    public static SeqWithGhostFrames Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<MessageBody_Compile.SeqWithGhostFrames> _TYPE = new Dafny.TypeDescriptor<MessageBody_Compile.SeqWithGhostFrames>(MessageBody_Compile.SeqWithGhostFrames.Default());
    public static Dafny.TypeDescriptor<MessageBody_Compile.SeqWithGhostFrames> _TypeDescriptor() {
      return _TYPE;
    }
    public static SeqWithGhostFrames create(Dafny.ISequence<byte> sequence) {
      return new SeqWithGhostFrames(sequence);
    }
    public bool is_SeqWithGhostFrames { get { return true; } }
    public Dafny.ISequence<byte> dtor_sequence {
      get {
        return this.sequence;
      }
    }
  }

  public class FrameWithGhostSeq {
    public readonly MessageBody_Compile.Frame frame;
    public FrameWithGhostSeq(MessageBody_Compile.Frame frame) {
      this.frame = frame;
    }
    public override bool Equals(object other) {
      var oth = other as MessageBody_Compile.FrameWithGhostSeq;
      return oth != null && object.Equals(this.frame, oth.frame);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.frame));
      return (int) hash;
    }
    public override string ToString() {
      string s = "MessageBody_Compile.FrameWithGhostSeq.FrameWithGhostSeq";
      s += "(";
      s += Dafny.Helpers.ToString(this.frame);
      s += ")";
      return s;
    }
    private static readonly FrameWithGhostSeq theDefault = create(MessageBody_Compile.Frame.Default());
    public static FrameWithGhostSeq Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<MessageBody_Compile.FrameWithGhostSeq> _TYPE = new Dafny.TypeDescriptor<MessageBody_Compile.FrameWithGhostSeq>(MessageBody_Compile.FrameWithGhostSeq.Default());
    public static Dafny.TypeDescriptor<MessageBody_Compile.FrameWithGhostSeq> _TypeDescriptor() {
      return _TYPE;
    }
    public static FrameWithGhostSeq create(MessageBody_Compile.Frame frame) {
      return new FrameWithGhostSeq(frame);
    }
    public bool is_FrameWithGhostSeq { get { return true; } }
    public MessageBody_Compile.Frame dtor_frame {
      get {
        return this.frame;
      }
    }
  }

  public partial class __default {
    public static Dafny.ISequence<char> BodyAADContentTypeString(MessageBody_Compile.BodyAADContent bc) {
      MessageBody_Compile.BodyAADContent _source21 = bc;
      if (_source21.is_AADRegularFrame) {
        return MessageBody_Compile.__default.BODY__AAD__CONTENT__REGULAR__FRAME;
      } else if (_source21.is_AADFinalFrame) {
        return MessageBody_Compile.__default.BODY__AAD__CONTENT__FINAL__FRAME;
      } else {
        return MessageBody_Compile.__default.BODY__AAD__CONTENT__SINGLE__BLOCK;
      }
    }
    public static Dafny.ISequence<byte> IVSeq(ushort algorithmSuiteID, uint sequenceNumber)
    {
      return Dafny.Sequence<byte>.Concat(((System.Func<Dafny.ISequence<byte>>) (() => {
        BigInteger dim9 = (AlgorithmSuite.ID.IVLength(algorithmSuiteID)) - (new BigInteger(4));
        var arr9 = new byte[Dafny.Helpers.ToIntChecked(dim9,"C# array size must not be larger than max 32-bit int")];
        for (int i9 = 0; i9 < dim9; i9++) {
          var _18243___v0 = (BigInteger) i9;
          arr9[(int)(_18243___v0)] = 0;
        }
        return Dafny.Sequence<byte>.FromArray(arr9);
      }))(), StandardLibrary_mUInt_Compile.__default.UInt32ToSeq(sequenceNumber));
    }
    public static Wrappers_Compile.Result<MessageBody_Compile.SeqWithGhostFrames, Dafny.ISequence<char>> EncryptMessageBody(Dafny.ISequence<byte> plaintext, BigInteger frameLength, Dafny.ISequence<byte> messageID, Dafny.ISequence<byte> key, ushort algorithmSuiteID)
    {
      Wrappers_Compile.Result<MessageBody_Compile.SeqWithGhostFrames, Dafny.ISequence<char>> result = Wrappers_Compile.Result<MessageBody_Compile.SeqWithGhostFrames, Dafny.ISequence<char>>.Default(MessageBody_Compile.SeqWithGhostFrames.Default());
      Dafny.ISequence<byte> _18244_body;
      _18244_body = Dafny.Sequence<byte>.FromElements();
      BigInteger _18245_n;
      uint _18246_sequenceNumber;
      BigInteger _rhs2 = BigInteger.Zero;
      uint _rhs3 = MessageBody_Compile.__default.START__SEQUENCE__NUMBER;
      _18245_n = _rhs2;
      _18246_sequenceNumber = _rhs3;
      while (((_18245_n) + (frameLength)) < (new BigInteger((plaintext).Count))) {
        if ((_18246_sequenceNumber) == (MessageBody_Compile.__default.ENDFRAME__SEQUENCE__NUMBER)) {
          result = @Wrappers_Compile.Result<MessageBody_Compile.SeqWithGhostFrames, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("too many frames"));
          return result;
        }
        Dafny.ISequence<byte> _18247_plaintextFrame;
        _18247_plaintextFrame = (plaintext).Subsequence(_18245_n, (_18245_n) + (frameLength));
        Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18248_regularFrame;
        Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out108;
        _out108 = MessageBody_Compile.__default.EncryptRegularFrame(algorithmSuiteID, key, messageID, _18247_plaintextFrame, _18246_sequenceNumber);
        _18248_regularFrame = _out108;
        if ((_18248_regularFrame).IsFailure()) {
          result = (_18248_regularFrame).PropagateFailure<MessageBody_Compile.SeqWithGhostFrames>();
          return result;
        }
        _18244_body = Dafny.Sequence<byte>.Concat(_18244_body, (_18248_regularFrame).Extract());
        BigInteger _rhs4 = (_18245_n) + (frameLength);
        uint _rhs5 = (_18246_sequenceNumber) + (1U);
        _18245_n = _rhs4;
        _18246_sequenceNumber = _rhs5;
      }
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18249_finalFrameResult;
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out109;
      _out109 = MessageBody_Compile.__default.EncryptFinalFrame(algorithmSuiteID, key, frameLength, messageID, (plaintext).Drop(_18245_n), _18246_sequenceNumber);
      _18249_finalFrameResult = _out109;
      if ((_18249_finalFrameResult).IsFailure()) {
        result = (_18249_finalFrameResult).PropagateFailure<MessageBody_Compile.SeqWithGhostFrames>();
        return result;
      }
      Dafny.ISequence<byte> _18250_finalFrameSequence;
      _18250_finalFrameSequence = (_18249_finalFrameResult).Extract();
      _18244_body = Dafny.Sequence<byte>.Concat(_18244_body, _18250_finalFrameSequence);
      result = @Wrappers_Compile.Result<MessageBody_Compile.SeqWithGhostFrames, Dafny.ISequence<char>>.create_Success(@MessageBody_Compile.SeqWithGhostFrames.create(_18244_body));
      return result;
    }
    public static Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> EncryptRegularFrame(ushort algorithmSuiteID, Dafny.ISequence<byte> key, Dafny.ISequence<byte> messageID, Dafny.ISequence<byte> plaintext, uint sequenceNumber)
    {
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> res = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      Dafny.ISequence<byte> _18251_seqNumSeq;
      _18251_seqNumSeq = StandardLibrary_mUInt_Compile.__default.UInt32ToSeq(sequenceNumber);
      Dafny.ISequence<byte> _18252_unauthenticatedFrame;
      _18252_unauthenticatedFrame = _18251_seqNumSeq;
      Dafny.ISequence<byte> _18253_iv;
      _18253_iv = MessageBody_Compile.__default.IVSeq(algorithmSuiteID, sequenceNumber);
      Dafny.ISequence<byte> _18254_aad;
      Dafny.ISequence<byte> _out110;
      _out110 = MessageBody_Compile.__default.BodyAAD(messageID, @MessageBody_Compile.BodyAADContent.create_AADRegularFrame(), sequenceNumber, (ulong)(plaintext).LongCount);
      _18254_aad = _out110;
      Wrappers_Compile.Result<AESEncryption.EncryptionOutput, Dafny.ISequence<char>> _18255_encryptionOutputResult;
      Wrappers_Compile.Result<AESEncryption.EncryptionOutput, Dafny.ISequence<char>> _out111;
      _out111 = AESEncryption.__default.AESEncrypt(AlgorithmSuite.ID.EncryptionSuite(algorithmSuiteID), _18253_iv, key, plaintext, _18254_aad);
      _18255_encryptionOutputResult = _out111;
      if ((_18255_encryptionOutputResult).IsFailure()) {
        res = (_18255_encryptionOutputResult).PropagateFailure<Dafny.ISequence<byte>>();
        return res;
      }
      AESEncryption.EncryptionOutput _18256_encryptionOutput;
      _18256_encryptionOutput = (_18255_encryptionOutputResult).Extract();
      _18252_unauthenticatedFrame = Dafny.Sequence<byte>.Concat(_18252_unauthenticatedFrame, _18253_iv);
      _18252_unauthenticatedFrame = Dafny.Sequence<byte>.Concat(Dafny.Sequence<byte>.Concat(_18252_unauthenticatedFrame, (_18256_encryptionOutput).dtor_cipherText), (_18256_encryptionOutput).dtor_authTag);
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _rhs6 = @Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.create_Success(_18252_unauthenticatedFrame);
      res = _rhs6;
      return res;
      return res;
    }
    public static Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> EncryptFinalFrame(ushort algorithmSuiteID, Dafny.ISequence<byte> key, BigInteger frameLength, Dafny.ISequence<byte> messageID, Dafny.ISequence<byte> plaintext, uint sequenceNumber)
    {
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> res = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      Dafny.ISequence<byte> _18257_unauthenticatedFrame;
      _18257_unauthenticatedFrame = StandardLibrary_mUInt_Compile.__default.UInt32ToSeq(MessageBody_Compile.__default.ENDFRAME__SEQUENCE__NUMBER);
      Dafny.ISequence<byte> _18258_seqNumSeq;
      _18258_seqNumSeq = StandardLibrary_mUInt_Compile.__default.UInt32ToSeq(sequenceNumber);
      _18257_unauthenticatedFrame = Dafny.Sequence<byte>.Concat(_18257_unauthenticatedFrame, _18258_seqNumSeq);
      Dafny.ISequence<byte> _18259_iv;
      _18259_iv = MessageBody_Compile.__default.IVSeq(algorithmSuiteID, sequenceNumber);
      _18257_unauthenticatedFrame = Dafny.Sequence<byte>.Concat(_18257_unauthenticatedFrame, _18259_iv);
      _18257_unauthenticatedFrame = Dafny.Sequence<byte>.Concat(_18257_unauthenticatedFrame, StandardLibrary_mUInt_Compile.__default.UInt32ToSeq((uint)(plaintext).LongCount));
      Dafny.ISequence<byte> _18260_aad;
      Dafny.ISequence<byte> _out112;
      _out112 = MessageBody_Compile.__default.BodyAAD(messageID, @MessageBody_Compile.BodyAADContent.create_AADFinalFrame(), sequenceNumber, (ulong)(plaintext).LongCount);
      _18260_aad = _out112;
      Wrappers_Compile.Result<AESEncryption.EncryptionOutput, Dafny.ISequence<char>> _18261_encryptionOutputResult;
      Wrappers_Compile.Result<AESEncryption.EncryptionOutput, Dafny.ISequence<char>> _out113;
      _out113 = AESEncryption.__default.AESEncrypt(AlgorithmSuite.ID.EncryptionSuite(algorithmSuiteID), _18259_iv, key, plaintext, _18260_aad);
      _18261_encryptionOutputResult = _out113;
      if ((_18261_encryptionOutputResult).IsFailure()) {
        res = (_18261_encryptionOutputResult).PropagateFailure<Dafny.ISequence<byte>>();
        return res;
      }
      AESEncryption.EncryptionOutput _18262_encryptionOutput;
      _18262_encryptionOutput = (_18261_encryptionOutputResult).Extract();
      _18257_unauthenticatedFrame = Dafny.Sequence<byte>.Concat(Dafny.Sequence<byte>.Concat(_18257_unauthenticatedFrame, (_18262_encryptionOutput).dtor_cipherText), (_18262_encryptionOutput).dtor_authTag);
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _rhs7 = @Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.create_Success(_18257_unauthenticatedFrame);
      res = _rhs7;
      return res;
      return res;
    }
    public static Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> DecryptFramedMessageBody(Streams_Compile.ByteReader rd, ushort algorithmSuiteID, Dafny.ISequence<byte> key, BigInteger frameLength, Dafny.ISequence<byte> messageID)
    {
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> res = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      Dafny.ISequence<byte> _18263_plaintext;
      _18263_plaintext = Dafny.Sequence<byte>.FromElements();
      uint _18264_n;
      _18264_n = 1U;
      while (true) {
        MessageBody_Compile.FrameWithGhostSeq _18265_frameWithGhostSeq = MessageBody_Compile.FrameWithGhostSeq.Default();
        Wrappers_Compile.Result<MessageBody_Compile.FrameWithGhostSeq, Dafny.ISequence<char>> _18266_valueOrError0 = Wrappers_Compile.Result<MessageBody_Compile.FrameWithGhostSeq, Dafny.ISequence<char>>.Default(MessageBody_Compile.FrameWithGhostSeq.Default());
        Wrappers_Compile.Result<MessageBody_Compile.FrameWithGhostSeq, Dafny.ISequence<char>> _out114;
        _out114 = MessageBody_Compile.__default.DecryptFrame(rd, algorithmSuiteID, key, frameLength, messageID, _18264_n);
        _18266_valueOrError0 = _out114;
        if ((_18266_valueOrError0).IsFailure()) {
          res = (_18266_valueOrError0).PropagateFailure<Dafny.ISequence<byte>>();
          return res;
        }
        _18265_frameWithGhostSeq = (_18266_valueOrError0).Extract();
        MessageBody_Compile.Frame _18267_decryptedFrame;
        _18267_decryptedFrame = (_18265_frameWithGhostSeq).dtor_frame;
        _System.Tuple2<Dafny.ISequence<byte>, bool> _let_tmp_rhs1 = @_System.Tuple2<Dafny.ISequence<byte>, bool>.create((_18267_decryptedFrame).dtor_encContent, (_18267_decryptedFrame).is_FinalFrame);
        Dafny.ISequence<byte> _18268_decryptedFramePlaintext = ((_System.Tuple2<Dafny.ISequence<byte>, bool>)_let_tmp_rhs1)._0;
        bool _18269_final = ((_System.Tuple2<Dafny.ISequence<byte>, bool>)_let_tmp_rhs1)._1;
        _18263_plaintext = Dafny.Sequence<byte>.Concat(_18263_plaintext, _18268_decryptedFramePlaintext);
        if (_18269_final) {
          goto after_0;
        }
        _18264_n = (_18264_n) + (1U);
      }
    after_0: ;
      res = @Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.create_Success(_18263_plaintext);
      return res;
      return res;
    }
    public static Wrappers_Compile.Result<MessageBody_Compile.FrameWithGhostSeq, Dafny.ISequence<char>> DecryptFrame(Streams_Compile.ByteReader rd, ushort algorithmSuiteID, Dafny.ISequence<byte> key, BigInteger frameLength, Dafny.ISequence<byte> messageID, uint expectedSequenceNumber)
    {
      Wrappers_Compile.Result<MessageBody_Compile.FrameWithGhostSeq, Dafny.ISequence<char>> res = Wrappers_Compile.Result<MessageBody_Compile.FrameWithGhostSeq, Dafny.ISequence<char>>.Default(MessageBody_Compile.FrameWithGhostSeq.Default());
      bool _18270_final;
      _18270_final = false;
      uint _18271_sequenceNumber = 0;
      Wrappers_Compile.Result<uint, Dafny.ISequence<char>> _18272_valueOrError0 = Wrappers_Compile.Result<uint, Dafny.ISequence<char>>.Default(0);
      Wrappers_Compile.Result<uint, Dafny.ISequence<char>> _out115;
      _out115 = (rd).ReadUInt32();
      _18272_valueOrError0 = _out115;
      if ((_18272_valueOrError0).IsFailure()) {
        res = (_18272_valueOrError0).PropagateFailure<MessageBody_Compile.FrameWithGhostSeq>();
        return res;
      }
      _18271_sequenceNumber = (_18272_valueOrError0).Extract();
      if ((_18271_sequenceNumber) == (MessageBody_Compile.__default.ENDFRAME__SEQUENCE__NUMBER)) {
        _18270_final = true;
        Wrappers_Compile.Result<uint, Dafny.ISequence<char>> _18273_valueOrError1 = Wrappers_Compile.Result<uint, Dafny.ISequence<char>>.Default(0);
        Wrappers_Compile.Result<uint, Dafny.ISequence<char>> _out116;
        _out116 = (rd).ReadUInt32();
        _18273_valueOrError1 = _out116;
        if ((_18273_valueOrError1).IsFailure()) {
          res = (_18273_valueOrError1).PropagateFailure<MessageBody_Compile.FrameWithGhostSeq>();
          return res;
        }
        _18271_sequenceNumber = (_18273_valueOrError1).Extract();
      }
      if ((_18271_sequenceNumber) != (expectedSequenceNumber)) {
        res = @Wrappers_Compile.Result<MessageBody_Compile.FrameWithGhostSeq, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("unexpected frame sequence number"));
        return res;
      }
      Dafny.ISequence<byte> _18274_iv = Dafny.Sequence<byte>.Empty;
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18275_valueOrError2 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out117;
      _out117 = (rd).ReadBytes(AlgorithmSuite.ID.IVLength(algorithmSuiteID));
      _18275_valueOrError2 = _out117;
      if ((_18275_valueOrError2).IsFailure()) {
        res = (_18275_valueOrError2).PropagateFailure<MessageBody_Compile.FrameWithGhostSeq>();
        return res;
      }
      _18274_iv = (_18275_valueOrError2).Extract();
      uint _18276_len;
      _18276_len = (uint)(frameLength);
      if (_18270_final) {
        Wrappers_Compile.Result<uint, Dafny.ISequence<char>> _18277_valueOrError3 = Wrappers_Compile.Result<uint, Dafny.ISequence<char>>.Default(0);
        Wrappers_Compile.Result<uint, Dafny.ISequence<char>> _out118;
        _out118 = (rd).ReadUInt32();
        _18277_valueOrError3 = _out118;
        if ((_18277_valueOrError3).IsFailure()) {
          res = (_18277_valueOrError3).PropagateFailure<MessageBody_Compile.FrameWithGhostSeq>();
          return res;
        }
        _18276_len = (_18277_valueOrError3).Extract();
        if ((_18276_len) > ((uint)(frameLength))) {
          res = @Wrappers_Compile.Result<MessageBody_Compile.FrameWithGhostSeq, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Final frame too long"));
          return res;
        }
      }
      Dafny.ISequence<byte> _18278_aad;
      Dafny.ISequence<byte> _out119;
      _out119 = MessageBody_Compile.__default.BodyAAD(messageID, ((_18270_final) ? (@MessageBody_Compile.BodyAADContent.create_AADFinalFrame()) : (@MessageBody_Compile.BodyAADContent.create_AADRegularFrame())), _18271_sequenceNumber, (ulong)(_18276_len));
      _18278_aad = _out119;
      Dafny.ISequence<byte> _18279_ciphertext = Dafny.Sequence<byte>.Empty;
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18280_valueOrError4 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out120;
      _out120 = (rd).ReadBytes(new BigInteger(_18276_len));
      _18280_valueOrError4 = _out120;
      if ((_18280_valueOrError4).IsFailure()) {
        res = (_18280_valueOrError4).PropagateFailure<MessageBody_Compile.FrameWithGhostSeq>();
        return res;
      }
      _18279_ciphertext = (_18280_valueOrError4).Extract();
      Dafny.ISequence<byte> _18281_authTag = Dafny.Sequence<byte>.Empty;
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18282_valueOrError5 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out121;
      _out121 = (rd).ReadBytes(AlgorithmSuite.ID.TagLength(algorithmSuiteID));
      _18282_valueOrError5 = _out121;
      if ((_18282_valueOrError5).IsFailure()) {
        res = (_18282_valueOrError5).PropagateFailure<MessageBody_Compile.FrameWithGhostSeq>();
        return res;
      }
      _18281_authTag = (_18282_valueOrError5).Extract();
      Dafny.ISequence<byte> _18283_plaintext = Dafny.Sequence<byte>.Empty;
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18284_valueOrError6 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out122;
      _out122 = MessageBody_Compile.__default.Decrypt(_18279_ciphertext, _18281_authTag, algorithmSuiteID, _18274_iv, key, _18278_aad);
      _18284_valueOrError6 = _out122;
      if ((_18284_valueOrError6).IsFailure()) {
        res = (_18284_valueOrError6).PropagateFailure<MessageBody_Compile.FrameWithGhostSeq>();
        return res;
      }
      _18283_plaintext = (_18284_valueOrError6).Extract();
      MessageBody_Compile.Frame _18285_frame;
      _18285_frame = ((_18270_final) ? (@MessageBody_Compile.Frame.create_FinalFrame(_18271_sequenceNumber, _18274_iv, _18283_plaintext, _18281_authTag)) : (@MessageBody_Compile.Frame.create_RegularFrame(_18271_sequenceNumber, _18274_iv, _18283_plaintext, _18281_authTag)));
      res = @Wrappers_Compile.Result<MessageBody_Compile.FrameWithGhostSeq, Dafny.ISequence<char>>.create_Success(@MessageBody_Compile.FrameWithGhostSeq.create(_18285_frame));
      return res;
      return res;
    }
    public static Dafny.ISequence<byte> BodyAAD(Dafny.ISequence<byte> messageID, MessageBody_Compile.BodyAADContent bc, uint sequenceNumber, ulong length)
    {
      Dafny.ISequence<byte> aad = Dafny.Sequence<byte>.Empty;
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18286_contentAAD;
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out123;
      _out123 = UTF8.__default.Encode(MessageBody_Compile.__default.BodyAADContentTypeString(bc));
      _18286_contentAAD = _out123;
      aad = Dafny.Sequence<byte>.Concat(Dafny.Sequence<byte>.Concat(Dafny.Sequence<byte>.Concat(messageID, (_18286_contentAAD).dtor_value), StandardLibrary_mUInt_Compile.__default.UInt32ToSeq(sequenceNumber)), StandardLibrary_mUInt_Compile.__default.UInt64ToSeq(length));
      return aad;
    }
    public static Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> Decrypt(Dafny.ISequence<byte> ciphertext, Dafny.ISequence<byte> authTag, ushort algorithmSuiteID, Dafny.ISequence<byte> iv, Dafny.ISequence<byte> key, Dafny.ISequence<byte> aad)
    {
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> res = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      EncryptionSuites.EncryptionSuite _18287_encAlg;
      _18287_encAlg = AlgorithmSuite.ID.EncryptionSuite(algorithmSuiteID);
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out124;
      _out124 = AESEncryption.__default.AESDecrypt(_18287_encAlg, key, ciphertext, authTag, iv, aad);
      res = _out124;
      return res;
    }
    public static Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> DecryptNonFramedMessageBody(Streams_Compile.ByteReader rd, ushort algorithmSuiteID, Dafny.ISequence<byte> key, Dafny.ISequence<byte> messageID)
    {
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> res = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      Dafny.ISequence<byte> _18288_iv = Dafny.Sequence<byte>.Empty;
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18289_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out125;
      _out125 = (rd).ReadBytes(AlgorithmSuite.ID.IVLength(algorithmSuiteID));
      _18289_valueOrError0 = _out125;
      if ((_18289_valueOrError0).IsFailure()) {
        res = (_18289_valueOrError0).PropagateFailure<Dafny.ISequence<byte>>();
        return res;
      }
      _18288_iv = (_18289_valueOrError0).Extract();
      ulong _18290_contentLength = 0;
      Wrappers_Compile.Result<ulong, Dafny.ISequence<char>> _18291_valueOrError1 = Wrappers_Compile.Result<ulong, Dafny.ISequence<char>>.Default(0);
      Wrappers_Compile.Result<ulong, Dafny.ISequence<char>> _out126;
      _out126 = (rd).ReadUInt64();
      _18291_valueOrError1 = _out126;
      if ((_18291_valueOrError1).IsFailure()) {
        res = (_18291_valueOrError1).PropagateFailure<Dafny.ISequence<byte>>();
        return res;
      }
      _18290_contentLength = (_18291_valueOrError1).Extract();
      Dafny.ISequence<byte> _18292_ciphertext = Dafny.Sequence<byte>.Empty;
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18293_valueOrError2 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out127;
      _out127 = (rd).ReadBytes(new BigInteger(_18290_contentLength));
      _18293_valueOrError2 = _out127;
      if ((_18293_valueOrError2).IsFailure()) {
        res = (_18293_valueOrError2).PropagateFailure<Dafny.ISequence<byte>>();
        return res;
      }
      _18292_ciphertext = (_18293_valueOrError2).Extract();
      Dafny.ISequence<byte> _18294_authTag = Dafny.Sequence<byte>.Empty;
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18295_valueOrError3 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out128;
      _out128 = (rd).ReadBytes(AlgorithmSuite.ID.TagLength(algorithmSuiteID));
      _18295_valueOrError3 = _out128;
      if ((_18295_valueOrError3).IsFailure()) {
        res = (_18295_valueOrError3).PropagateFailure<Dafny.ISequence<byte>>();
        return res;
      }
      _18294_authTag = (_18295_valueOrError3).Extract();
      Dafny.ISequence<byte> _18296_aad;
      Dafny.ISequence<byte> _out129;
      _out129 = MessageBody_Compile.__default.BodyAAD(messageID, @MessageBody_Compile.BodyAADContent.create_AADSingleBlock(), MessageBody_Compile.__default.NONFRAMED__SEQUENCE__NUMBER, _18290_contentLength);
      _18296_aad = _out129;
      Dafny.ISequence<byte> _18297_plaintext = Dafny.Sequence<byte>.Empty;
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18298_valueOrError4 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out130;
      _out130 = MessageBody_Compile.__default.Decrypt(_18292_ciphertext, _18294_authTag, algorithmSuiteID, _18288_iv, key, _18296_aad);
      _18298_valueOrError4 = _out130;
      if ((_18298_valueOrError4).IsFailure()) {
        res = (_18298_valueOrError4).PropagateFailure<Dafny.ISequence<byte>>();
        return res;
      }
      _18297_plaintext = (_18298_valueOrError4).Extract();
      res = @Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.create_Success(_18297_plaintext);
      return res;
      return res;
    }
    public static uint START__SEQUENCE__NUMBER { get {
      return 1U;
    } }
    public static Dafny.ISequence<char> BODY__AAD__CONTENT__REGULAR__FRAME { get {
      return Dafny.Sequence<char>.FromString("AWSKMSEncryptionClient Frame");
    } }
    public static Dafny.ISequence<char> BODY__AAD__CONTENT__FINAL__FRAME { get {
      return Dafny.Sequence<char>.FromString("AWSKMSEncryptionClient Final Frame");
    } }
    public static Dafny.ISequence<char> BODY__AAD__CONTENT__SINGLE__BLOCK { get {
      return Dafny.Sequence<char>.FromString("AWSKMSEncryptionClient Single Block");
    } }
    public static uint ENDFRAME__SEQUENCE__NUMBER { get {
      return 4294967295U;
    } }
    public static uint NONFRAMED__SEQUENCE__NUMBER { get {
      return 1U;
    } }
  }
} // end of namespace MessageBody_Compile
namespace EncryptDecrypt {



















  public class EncryptRequest {
    public readonly Dafny.ISequence<byte> plaintext;
    public readonly Dafny.Aws.Crypto.ICryptographicMaterialsManager cmm;
    public readonly Dafny.Aws.Crypto.IKeyring keyring;
    public readonly BigInteger plaintextLength;
    public readonly Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext;
    public readonly Wrappers_Compile.Option<ushort> algorithmSuiteID;
    public readonly Wrappers_Compile.Option<uint> frameLength;
    public EncryptRequest(Dafny.ISequence<byte> plaintext, Dafny.Aws.Crypto.ICryptographicMaterialsManager cmm, Dafny.Aws.Crypto.IKeyring keyring, BigInteger plaintextLength, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext, Wrappers_Compile.Option<ushort> algorithmSuiteID, Wrappers_Compile.Option<uint> frameLength) {
      this.plaintext = plaintext;
      this.cmm = cmm;
      this.keyring = keyring;
      this.plaintextLength = plaintextLength;
      this.encryptionContext = encryptionContext;
      this.algorithmSuiteID = algorithmSuiteID;
      this.frameLength = frameLength;
    }
    public override bool Equals(object other) {
      var oth = other as EncryptDecrypt.EncryptRequest;
      return oth != null && object.Equals(this.plaintext, oth.plaintext) && this.cmm == oth.cmm && this.keyring == oth.keyring && this.plaintextLength == oth.plaintextLength && object.Equals(this.encryptionContext, oth.encryptionContext) && object.Equals(this.algorithmSuiteID, oth.algorithmSuiteID) && object.Equals(this.frameLength, oth.frameLength);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.plaintext));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.cmm));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.keyring));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.plaintextLength));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.encryptionContext));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.algorithmSuiteID));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.frameLength));
      return (int) hash;
    }
    public override string ToString() {
      string s = "EncryptDecrypt_Compile.EncryptRequest.EncryptRequest";
      s += "(";
      s += Dafny.Helpers.ToString(this.plaintext);
      s += ", ";
      s += Dafny.Helpers.ToString(this.cmm);
      s += ", ";
      s += Dafny.Helpers.ToString(this.keyring);
      s += ", ";
      s += Dafny.Helpers.ToString(this.plaintextLength);
      s += ", ";
      s += Dafny.Helpers.ToString(this.encryptionContext);
      s += ", ";
      s += Dafny.Helpers.ToString(this.algorithmSuiteID);
      s += ", ";
      s += Dafny.Helpers.ToString(this.frameLength);
      s += ")";
      return s;
    }
    private static readonly EncryptRequest theDefault = create(Dafny.Sequence<byte>.Empty, (Dafny.Aws.Crypto.ICryptographicMaterialsManager)null, (Dafny.Aws.Crypto.IKeyring)null, BigInteger.Zero, Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Empty, Wrappers_Compile.Option<ushort>.Default(), Wrappers_Compile.Option<uint>.Default());
    public static EncryptRequest Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<EncryptDecrypt.EncryptRequest> _TYPE = new Dafny.TypeDescriptor<EncryptDecrypt.EncryptRequest>(EncryptDecrypt.EncryptRequest.Default());
    public static Dafny.TypeDescriptor<EncryptDecrypt.EncryptRequest> _TypeDescriptor() {
      return _TYPE;
    }
    public static EncryptRequest create(Dafny.ISequence<byte> plaintext, Dafny.Aws.Crypto.ICryptographicMaterialsManager cmm, Dafny.Aws.Crypto.IKeyring keyring, BigInteger plaintextLength, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext, Wrappers_Compile.Option<ushort> algorithmSuiteID, Wrappers_Compile.Option<uint> frameLength) {
      return new EncryptRequest(plaintext, cmm, keyring, plaintextLength, encryptionContext, algorithmSuiteID, frameLength);
    }
    public bool is_EncryptRequest { get { return true; } }
    public Dafny.ISequence<byte> dtor_plaintext {
      get {
        return this.plaintext;
      }
    }
    public Dafny.Aws.Crypto.ICryptographicMaterialsManager dtor_cmm {
      get {
        return this.cmm;
      }
    }
    public Dafny.Aws.Crypto.IKeyring dtor_keyring {
      get {
        return this.keyring;
      }
    }
    public BigInteger dtor_plaintextLength {
      get {
        return this.plaintextLength;
      }
    }
    public Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> dtor_encryptionContext {
      get {
        return this.encryptionContext;
      }
    }
    public Wrappers_Compile.Option<ushort> dtor_algorithmSuiteID {
      get {
        return this.algorithmSuiteID;
      }
    }
    public Wrappers_Compile.Option<uint> dtor_frameLength {
      get {
        return this.frameLength;
      }
    }
    public static EncryptDecrypt.EncryptRequest WithCMM(Dafny.ISequence<byte> plaintext, Dafny.Aws.Crypto.ICryptographicMaterialsManager cmm)
    {
      return @EncryptDecrypt.EncryptRequest.create(plaintext, cmm, (Dafny.Aws.Crypto.IKeyring)null, new BigInteger((plaintext).Count), Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.FromElements(), @Wrappers_Compile.Option<ushort>.create_None(), @Wrappers_Compile.Option<uint>.create_None());
    }
    public static EncryptDecrypt.EncryptRequest WithKeyring(Dafny.ISequence<byte> plaintext, Dafny.Aws.Crypto.IKeyring keyring)
    {
      return @EncryptDecrypt.EncryptRequest.create(plaintext, (Dafny.Aws.Crypto.ICryptographicMaterialsManager)null, keyring, new BigInteger((plaintext).Count), Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.FromElements(), @Wrappers_Compile.Option<ushort>.create_None(), @Wrappers_Compile.Option<uint>.create_None());
    }
    public EncryptDecrypt.EncryptRequest SetEncryptionContext(Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext) {
      EncryptDecrypt.EncryptRequest _18299_dt__update__tmp_h0 = this;
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _18300_dt__update_hencryptionContext_h0 = encryptionContext;
      return @EncryptDecrypt.EncryptRequest.create((_18299_dt__update__tmp_h0).dtor_plaintext, (_18299_dt__update__tmp_h0).dtor_cmm, (_18299_dt__update__tmp_h0).dtor_keyring, (_18299_dt__update__tmp_h0).dtor_plaintextLength, _18300_dt__update_hencryptionContext_h0, (_18299_dt__update__tmp_h0).dtor_algorithmSuiteID, (_18299_dt__update__tmp_h0).dtor_frameLength);
    }
    public EncryptDecrypt.EncryptRequest SetAlgorithmSuiteID(ushort algorithmSuiteID) {
      EncryptDecrypt.EncryptRequest _18301_dt__update__tmp_h0 = this;
      Wrappers_Compile.Option<ushort> _18302_dt__update_halgorithmSuiteID_h0 = @Wrappers_Compile.Option<ushort>.create_Some(algorithmSuiteID);
      return @EncryptDecrypt.EncryptRequest.create((_18301_dt__update__tmp_h0).dtor_plaintext, (_18301_dt__update__tmp_h0).dtor_cmm, (_18301_dt__update__tmp_h0).dtor_keyring, (_18301_dt__update__tmp_h0).dtor_plaintextLength, (_18301_dt__update__tmp_h0).dtor_encryptionContext, _18302_dt__update_halgorithmSuiteID_h0, (_18301_dt__update__tmp_h0).dtor_frameLength);
    }
    public EncryptDecrypt.EncryptRequest SetFrameLength(uint frameLength) {
      EncryptDecrypt.EncryptRequest _18303_dt__update__tmp_h0 = this;
      Wrappers_Compile.Option<uint> _18304_dt__update_hframeLength_h0 = @Wrappers_Compile.Option<uint>.create_Some(frameLength);
      return @EncryptDecrypt.EncryptRequest.create((_18303_dt__update__tmp_h0).dtor_plaintext, (_18303_dt__update__tmp_h0).dtor_cmm, (_18303_dt__update__tmp_h0).dtor_keyring, (_18303_dt__update__tmp_h0).dtor_plaintextLength, (_18303_dt__update__tmp_h0).dtor_encryptionContext, (_18303_dt__update__tmp_h0).dtor_algorithmSuiteID, _18304_dt__update_hframeLength_h0);
    }
  }

  public class DecryptRequest {
    public readonly Dafny.ISequence<byte> message;
    public readonly Dafny.Aws.Crypto.ICryptographicMaterialsManager cmm;
    public readonly Dafny.Aws.Crypto.IKeyring keyring;
    public DecryptRequest(Dafny.ISequence<byte> message, Dafny.Aws.Crypto.ICryptographicMaterialsManager cmm, Dafny.Aws.Crypto.IKeyring keyring) {
      this.message = message;
      this.cmm = cmm;
      this.keyring = keyring;
    }
    public override bool Equals(object other) {
      var oth = other as EncryptDecrypt.DecryptRequest;
      return oth != null && object.Equals(this.message, oth.message) && this.cmm == oth.cmm && this.keyring == oth.keyring;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.message));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.cmm));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.keyring));
      return (int) hash;
    }
    public override string ToString() {
      string s = "EncryptDecrypt_Compile.DecryptRequest.DecryptRequest";
      s += "(";
      s += Dafny.Helpers.ToString(this.message);
      s += ", ";
      s += Dafny.Helpers.ToString(this.cmm);
      s += ", ";
      s += Dafny.Helpers.ToString(this.keyring);
      s += ")";
      return s;
    }
    private static readonly DecryptRequest theDefault = create(Dafny.Sequence<byte>.Empty, (Dafny.Aws.Crypto.ICryptographicMaterialsManager)null, (Dafny.Aws.Crypto.IKeyring)null);
    public static DecryptRequest Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<EncryptDecrypt.DecryptRequest> _TYPE = new Dafny.TypeDescriptor<EncryptDecrypt.DecryptRequest>(EncryptDecrypt.DecryptRequest.Default());
    public static Dafny.TypeDescriptor<EncryptDecrypt.DecryptRequest> _TypeDescriptor() {
      return _TYPE;
    }
    public static DecryptRequest create(Dafny.ISequence<byte> message, Dafny.Aws.Crypto.ICryptographicMaterialsManager cmm, Dafny.Aws.Crypto.IKeyring keyring) {
      return new DecryptRequest(message, cmm, keyring);
    }
    public bool is_DecryptRequest { get { return true; } }
    public Dafny.ISequence<byte> dtor_message {
      get {
        return this.message;
      }
    }
    public Dafny.Aws.Crypto.ICryptographicMaterialsManager dtor_cmm {
      get {
        return this.cmm;
      }
    }
    public Dafny.Aws.Crypto.IKeyring dtor_keyring {
      get {
        return this.keyring;
      }
    }
    public static EncryptDecrypt.DecryptRequest WithCMM(Dafny.ISequence<byte> message, Dafny.Aws.Crypto.ICryptographicMaterialsManager cmm)
    {
      return @EncryptDecrypt.DecryptRequest.create(message, cmm, (Dafny.Aws.Crypto.IKeyring)null);
    }
    public static EncryptDecrypt.DecryptRequest WithKeyring(Dafny.ISequence<byte> message, Dafny.Aws.Crypto.IKeyring keyring)
    {
      return @EncryptDecrypt.DecryptRequest.create(message, (Dafny.Aws.Crypto.ICryptographicMaterialsManager)null, keyring);
    }
  }

  public class DecryptResultWithVerificationInfo {
    public readonly Dafny.ISequence<byte> plaintext;
    public DecryptResultWithVerificationInfo(Dafny.ISequence<byte> plaintext) {
      this.plaintext = plaintext;
    }
    public override bool Equals(object other) {
      var oth = other as EncryptDecrypt.DecryptResultWithVerificationInfo;
      return oth != null && object.Equals(this.plaintext, oth.plaintext);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.plaintext));
      return (int) hash;
    }
    public override string ToString() {
      string s = "EncryptDecrypt_Compile.DecryptResultWithVerificationInfo.DecryptResultWithVerificationInfo";
      s += "(";
      s += Dafny.Helpers.ToString(this.plaintext);
      s += ")";
      return s;
    }
    private static readonly DecryptResultWithVerificationInfo theDefault = create(Dafny.Sequence<byte>.Empty);
    public static DecryptResultWithVerificationInfo Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<EncryptDecrypt.DecryptResultWithVerificationInfo> _TYPE = new Dafny.TypeDescriptor<EncryptDecrypt.DecryptResultWithVerificationInfo>(EncryptDecrypt.DecryptResultWithVerificationInfo.Default());
    public static Dafny.TypeDescriptor<EncryptDecrypt.DecryptResultWithVerificationInfo> _TypeDescriptor() {
      return _TYPE;
    }
    public static DecryptResultWithVerificationInfo create(Dafny.ISequence<byte> plaintext) {
      return new DecryptResultWithVerificationInfo(plaintext);
    }
    public bool is_DecryptResultWithVerificationInfo { get { return true; } }
    public Dafny.ISequence<byte> dtor_plaintext {
      get {
        return this.plaintext;
      }
    }
  }

  public partial class __default {
    public static Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> Encrypt(EncryptDecrypt.EncryptRequest request)
    {
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> res = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      if ((((request).dtor_cmm) != (object) ((Dafny.Aws.Crypto.ICryptographicMaterialsManager)null)) && (((request).dtor_keyring) != (object) ((Dafny.Aws.Crypto.IKeyring)null))) {
        res = @Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("EncryptRequest.keyring OR EncryptRequest.cmm must be set (not both)."));
        return res;
      } else if ((((request).dtor_cmm) == (object) ((Dafny.Aws.Crypto.ICryptographicMaterialsManager)null)) && (((request).dtor_keyring) == (object) ((Dafny.Aws.Crypto.IKeyring)null))) {
        res = @Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("EncryptRequest.cmm and EncryptRequest.keyring cannot both be null."));
        return res;
      } else if ((((request).dtor_algorithmSuiteID).is_Some) && (!(AlgorithmSuite.__default.VALID__IDS).Contains((((request).dtor_algorithmSuiteID).dtor_value)))) {
        res = @Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Invalid algorithmSuiteID."));
        return res;
      } else if ((((request).dtor_frameLength).is_Some) && ((((request).dtor_frameLength).dtor_value) == (0U))) {
        res = @Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Request frameLength must be > 0"));
        return res;
      }
      Dafny.Aws.Crypto.ICryptographicMaterialsManager _18305_cmm = default(Dafny.Aws.Crypto.ICryptographicMaterialsManager);
      if (((request).dtor_keyring) == (object) ((Dafny.Aws.Crypto.IKeyring)null)) {
        _18305_cmm = (request).dtor_cmm;
      } else {
        DefaultCMMDef.DefaultCMM _nw11 = new DefaultCMMDef.DefaultCMM();
        _nw11.OfKeyring((request).dtor_keyring);
        _18305_cmm = _nw11;
      }
      uint _18306_frameLength;
      _18306_frameLength = ((((request).dtor_frameLength).is_Some) ? (((request).dtor_frameLength).dtor_value) : (EncryptDecrypt.__default.DEFAULT__FRAME__LENGTH));
      Wrappers_Compile.Option<Dafny.Aws.Crypto.AlgorithmSuiteId> _18307_algorithmSuiteID;
      _18307_algorithmSuiteID = ((((request).dtor_algorithmSuiteID).is_Some) ? (@Wrappers_Compile.Option<Dafny.Aws.Crypto.AlgorithmSuiteId>.create_Some(AlgorithmSuite.__default.InternalIDToPolymorphID((ushort)(((request).dtor_algorithmSuiteID).dtor_value)))) : (@Wrappers_Compile.Option<Dafny.Aws.Crypto.AlgorithmSuiteId>.create_None()));
      if (!(((request).dtor_plaintextLength) < (StandardLibrary_mUInt_Compile.__default.INT64__MAX__LIMIT))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/src/SDK/EncryptDecrypt.dfy(203,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      Dafny.Aws.Crypto.GetEncryptionMaterialsInput _18308_encMatRequest;
      _18308_encMatRequest = @Dafny.Aws.Crypto.GetEncryptionMaterialsInput.create((request).dtor_encryptionContext, _18307_algorithmSuiteID, @Wrappers_Compile.Option<long>.create_Some((long)((request).dtor_plaintextLength)));
      Dafny.Aws.Crypto.GetEncryptionMaterialsOutput _18309_output = Dafny.Aws.Crypto.GetEncryptionMaterialsOutput.Default();
      Wrappers_Compile.Result<Dafny.Aws.Crypto.GetEncryptionMaterialsOutput, Dafny.ISequence<char>> _18310_valueOrError0 = Wrappers_Compile.Result<Dafny.Aws.Crypto.GetEncryptionMaterialsOutput, Dafny.ISequence<char>>.Default(Dafny.Aws.Crypto.GetEncryptionMaterialsOutput.Default());
      Wrappers_Compile.Result<Dafny.Aws.Crypto.GetEncryptionMaterialsOutput, Dafny.ISequence<char>> _out131;
      _out131 = (_18305_cmm).GetEncryptionMaterials(_18308_encMatRequest);
      _18310_valueOrError0 = _out131;
      if ((_18310_valueOrError0).IsFailure()) {
        res = (_18310_valueOrError0).PropagateFailure<Dafny.ISequence<byte>>();
        return res;
      }
      _18309_output = (_18310_valueOrError0).Extract();
      Dafny.Aws.Crypto.EncryptionMaterials _18311_encMat;
      _18311_encMat = (_18309_output).dtor_encryptionMaterials;
      if (!(((_18311_encMat).dtor_plaintextDataKey).is_Some)) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/src/SDK/EncryptDecrypt.dfy(214,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!(!(((_18307_algorithmSuiteID).is_None) || ((AlgorithmSuite.ID.SignatureType((ushort)(((request).dtor_algorithmSuiteID).dtor_value))).is_Some)) || (((_18311_encMat).dtor_encryptionContext).Contains((Materials.__default.EC__PUBLIC__KEY__FIELD))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/src/SDK/EncryptDecrypt.dfy(215,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!(DefaultCMMDef.__default.Serializable(_18311_encMat))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/src/SDK/EncryptDecrypt.dfy(217,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!(((System.Func<Wrappers_Compile.Option<ushort>, bool>)((_source22) => {
        if (_source22.is_None) {
          return (AlgorithmSuite.__default.PolymorphIDToInternalID((_18311_encMat).dtor_algorithmSuiteId)) == ((ushort)(888));
        } else {
          ushort _18312___mcc_h3 = ((Wrappers_Compile.Option_Some<ushort>)_source22).@value;
          return Dafny.Helpers.Let<ushort, bool>(_18312___mcc_h3, _pat_let7_0 => Dafny.Helpers.Let<ushort, bool>(_pat_let7_0, _18313_id => (AlgorithmSuite.__default.PolymorphIDToInternalID((_18311_encMat).dtor_algorithmSuiteId)) == ((ushort)(_18313_id))));
        }
      }))((request).dtor_algorithmSuiteID))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/src/SDK/EncryptDecrypt.dfy(218,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!((new BigInteger((((_18311_encMat).dtor_plaintextDataKey).dtor_value).Count)) == (AlgorithmSuite.ID.KDFInputKeyLength(AlgorithmSuite.__default.PolymorphIDToInternalID((_18311_encMat).dtor_algorithmSuiteId))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/src/SDK/EncryptDecrypt.dfy(222,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if ((StandardLibrary_mUInt_Compile.__default.UINT16__LIMIT) <= (new BigInteger(((_18311_encMat).dtor_encryptedDataKeys).Count))) {
        res = @Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Number of EDKs exceeds the allowed maximum."));
        return res;
      }
      Dafny.ISequence<byte> _18314_messageID = MessageHeader.MessageID.Default();
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18315_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out132;
      _out132 = Random_Compile.__default.GenerateBytes((int)(MessageHeader.__default.MESSAGE__ID__LEN));
      _18315_valueOrError1 = _out132;
      if ((_18315_valueOrError1).IsFailure()) {
        res = (_18315_valueOrError1).PropagateFailure<Dafny.ISequence<byte>>();
        return res;
      }
      _18314_messageID = (_18315_valueOrError1).Extract();
      Dafny.ISequence<byte> _18316_derivedDataKey;
      Dafny.ISequence<byte> _out133;
      _out133 = EncryptDecrypt.__default.DeriveKey(((_18311_encMat).dtor_plaintextDataKey).dtor_value, AlgorithmSuite.__default.PolymorphIDToInternalID((_18311_encMat).dtor_algorithmSuiteId), _18314_messageID);
      _18316_derivedDataKey = _out133;
      MessageHeader.HeaderBody _18317_headerBody;
      _18317_headerBody = @MessageHeader.HeaderBody.create(MessageHeader.__default.VERSION__1, MessageHeader.__default.TYPE__CUSTOMER__AED, AlgorithmSuite.__default.PolymorphIDToInternalID((_18311_encMat).dtor_algorithmSuiteId), _18314_messageID, (_18311_encMat).dtor_encryptionContext, @MessageHeader.EncryptedDataKeys.create((_18311_encMat).dtor_encryptedDataKeys), @MessageHeader.ContentType.create_Framed(), (byte)(AlgorithmSuite.ID.IVLength(AlgorithmSuite.__default.PolymorphIDToInternalID((_18311_encMat).dtor_algorithmSuiteId))), _18306_frameLength);
      Streams_Compile.ByteWriter _18318_wr;
      Streams_Compile.ByteWriter _nw12 = new Streams_Compile.ByteWriter();
      _nw12.__ctor();
      _18318_wr = _nw12;
      BigInteger _18319___v2 = BigInteger.Zero;
      Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>> _18320_valueOrError2 = Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>>.Default(BigInteger.Zero);
      Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>> _out134;
      _out134 = Serialize_Compile.__default.SerializeHeaderBody(_18318_wr, _18317_headerBody);
      _18320_valueOrError2 = _out134;
      if ((_18320_valueOrError2).IsFailure()) {
        res = (_18320_valueOrError2).PropagateFailure<Dafny.ISequence<byte>>();
        return res;
      }
      _18319___v2 = (_18320_valueOrError2).Extract();
      Dafny.ISequence<byte> _18321_unauthenticatedHeader;
      _18321_unauthenticatedHeader = (_18318_wr).GetDataWritten();
      Dafny.ISequence<byte> _18322_iv;
      _18322_iv = ((System.Func<Dafny.ISequence<byte>>) (() => {
        BigInteger dim10 = AlgorithmSuite.ID.IVLength(AlgorithmSuite.__default.PolymorphIDToInternalID((_18311_encMat).dtor_algorithmSuiteId));
        var arr10 = new byte[Dafny.Helpers.ToIntChecked(dim10,"C# array size must not be larger than max 32-bit int")];
        for (int i10 = 0; i10 < dim10; i10++) {
          var _18323___v3 = (BigInteger) i10;
          arr10[(int)(_18323___v3)] = 0;
        }
        return Dafny.Sequence<byte>.FromArray(arr10);
      }))();
      AESEncryption.EncryptionOutput _18324_encryptionOutput = AESEncryption.EncryptionOutput.Default();
      Wrappers_Compile.Result<AESEncryption.EncryptionOutput, Dafny.ISequence<char>> _18325_valueOrError3 = Wrappers_Compile.Result<AESEncryption.EncryptionOutput, Dafny.ISequence<char>>.Default(AESEncryption.EncryptionOutput.Default());
      Wrappers_Compile.Result<AESEncryption.EncryptionOutput, Dafny.ISequence<char>> _out135;
      _out135 = AESEncryption.AES_GCM.AESEncryptExtern(AlgorithmSuite.ID.EncryptionSuite(AlgorithmSuite.__default.PolymorphIDToInternalID((_18311_encMat).dtor_algorithmSuiteId)), _18322_iv, _18316_derivedDataKey, Dafny.Sequence<byte>.FromElements(), _18321_unauthenticatedHeader);
      _18325_valueOrError3 = _out135;
      if ((_18325_valueOrError3).IsFailure()) {
        res = (_18325_valueOrError3).PropagateFailure<Dafny.ISequence<byte>>();
        return res;
      }
      _18324_encryptionOutput = (_18325_valueOrError3).Extract();
      MessageHeader.HeaderAuthentication _18326_headerAuthentication;
      _18326_headerAuthentication = @MessageHeader.HeaderAuthentication.create(_18322_iv, (_18324_encryptionOutput).dtor_authTag);
      BigInteger _18327___v5 = BigInteger.Zero;
      Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>> _18328_valueOrError4 = Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>>.Default(BigInteger.Zero);
      Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>> _out136;
      _out136 = Serialize_Compile.__default.SerializeHeaderAuthentication(_18318_wr, _18326_headerAuthentication);
      _18328_valueOrError4 = _out136;
      if ((_18328_valueOrError4).IsFailure()) {
        res = (_18328_valueOrError4).PropagateFailure<Dafny.ISequence<byte>>();
        return res;
      }
      _18327___v5 = (_18328_valueOrError4).Extract();
      MessageBody_Compile.SeqWithGhostFrames _18329_seqWithGhostFrames = MessageBody_Compile.SeqWithGhostFrames.Default();
      Wrappers_Compile.Result<MessageBody_Compile.SeqWithGhostFrames, Dafny.ISequence<char>> _18330_valueOrError5 = Wrappers_Compile.Result<MessageBody_Compile.SeqWithGhostFrames, Dafny.ISequence<char>>.Default(MessageBody_Compile.SeqWithGhostFrames.Default());
      Wrappers_Compile.Result<MessageBody_Compile.SeqWithGhostFrames, Dafny.ISequence<char>> _out137;
      _out137 = MessageBody_Compile.__default.EncryptMessageBody((request).dtor_plaintext, new BigInteger(_18306_frameLength), _18314_messageID, _18316_derivedDataKey, AlgorithmSuite.__default.PolymorphIDToInternalID((_18311_encMat).dtor_algorithmSuiteId));
      _18330_valueOrError5 = _out137;
      if ((_18330_valueOrError5).IsFailure()) {
        res = (_18330_valueOrError5).PropagateFailure<Dafny.ISequence<byte>>();
        return res;
      }
      _18329_seqWithGhostFrames = (_18330_valueOrError5).Extract();
      Dafny.ISequence<byte> _18331_body;
      _18331_body = (_18329_seqWithGhostFrames).dtor_sequence;
      Dafny.ISequence<byte> _18332_msg;
      _18332_msg = Dafny.Sequence<byte>.Concat((_18318_wr).GetDataWritten(), _18331_body);
      if ((AlgorithmSuite.ID.SignatureType(AlgorithmSuite.__default.PolymorphIDToInternalID((_18311_encMat).dtor_algorithmSuiteId))).is_Some) {
        Signature.ECDSAParams _18333_ecdsaParams;
        _18333_ecdsaParams = (AlgorithmSuite.ID.SignatureType(AlgorithmSuite.__default.PolymorphIDToInternalID((_18311_encMat).dtor_algorithmSuiteId))).dtor_value;
        if (!(((_18311_encMat).dtor_signingKey).is_Some)) {
          throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/src/SDK/EncryptDecrypt.dfy(282,6): " + Dafny.Sequence<char>.FromString("expectation violation"));
        }
        Dafny.ISequence<byte> _18334_bytes = Dafny.Sequence<byte>.Empty;
        Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18335_valueOrError6 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
        Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out138;
        _out138 = Signature.ECDSA.Sign(_18333_ecdsaParams, ((_18311_encMat).dtor_signingKey).dtor_value, _18332_msg);
        _18335_valueOrError6 = _out138;
        if ((_18335_valueOrError6).IsFailure()) {
          res = (_18335_valueOrError6).PropagateFailure<Dafny.ISequence<byte>>();
          return res;
        }
        _18334_bytes = (_18335_valueOrError6).Extract();
        if ((new BigInteger((_18334_bytes).Count)) != (new BigInteger((_18333_ecdsaParams).SignatureLength()))) {
          res = @Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Malformed response from Sign()."));
          return res;
        }
        Dafny.ISequence<byte> _18336_signature;
        _18336_signature = Dafny.Sequence<byte>.Concat(StandardLibrary_mUInt_Compile.__default.UInt16ToSeq((ushort)(_18334_bytes).Count), _18334_bytes);
        _18332_msg = Dafny.Sequence<byte>.Concat(_18332_msg, _18336_signature);
        res = @Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.create_Success(_18332_msg);
        return res;
      } else {
        res = @Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.create_Success(_18332_msg);
        return res;
      }
      return res;
    }
    public static Dafny.ISequence<byte> DeriveKey(Dafny.ISequence<byte> plaintextDataKey, ushort algorithmSuiteID, Dafny.ISequence<byte> messageID)
    {
      Dafny.ISequence<byte> derivedDataKey = Dafny.Sequence<byte>.Empty;
      KeyDerivationAlgorithms.KeyDerivationAlgorithm _18337_algorithm;
      _18337_algorithm = (Dafny.Map<ushort, AlgorithmSuite.AlgSuite>.Select(AlgorithmSuite.__default.Suite,algorithmSuiteID)).dtor_hkdf;
      if (object.Equals(_18337_algorithm, @KeyDerivationAlgorithms.KeyDerivationAlgorithm.create_IDENTITY())) {
        derivedDataKey = plaintextDataKey;
        return derivedDataKey;
      }
      Dafny.ISequence<byte> _18338_infoSeq;
      _18338_infoSeq = Dafny.Sequence<byte>.Concat(StandardLibrary_mUInt_Compile.__default.UInt16ToSeq((ushort)(algorithmSuiteID)), messageID);
      BigInteger _18339_len;
      _18339_len = AlgorithmSuite.ID.KeyLength(algorithmSuiteID);
      Dafny.ISequence<byte> _18340_derivedKey;
      Dafny.ISequence<byte> _out139;
      _out139 = HKDF_Compile.__default.Hkdf(_18337_algorithm, @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_None(), plaintextDataKey, _18338_infoSeq, _18339_len);
      _18340_derivedKey = _out139;
      derivedDataKey = _18340_derivedKey;
      return derivedDataKey;
      return derivedDataKey;
    }
    public static Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> Decrypt(EncryptDecrypt.DecryptRequest request)
    {
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> res = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      EncryptDecrypt.DecryptResultWithVerificationInfo _18341_decryptWithVerificationInfo = EncryptDecrypt.DecryptResultWithVerificationInfo.Default();
      Wrappers_Compile.Result<EncryptDecrypt.DecryptResultWithVerificationInfo, Dafny.ISequence<char>> _18342_valueOrError0 = Wrappers_Compile.Result<EncryptDecrypt.DecryptResultWithVerificationInfo, Dafny.ISequence<char>>.Default(EncryptDecrypt.DecryptResultWithVerificationInfo.Default());
      Wrappers_Compile.Result<EncryptDecrypt.DecryptResultWithVerificationInfo, Dafny.ISequence<char>> _out140;
      _out140 = EncryptDecrypt.__default.DecryptWithVerificationInfo(request);
      _18342_valueOrError0 = _out140;
      if ((_18342_valueOrError0).IsFailure()) {
        res = (_18342_valueOrError0).PropagateFailure<Dafny.ISequence<byte>>();
        return res;
      }
      _18341_decryptWithVerificationInfo = (_18342_valueOrError0).Extract();
      res = @Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.create_Success((_18341_decryptWithVerificationInfo).dtor_plaintext);
      return res;
      return res;
    }
    public static Wrappers_Compile.Result<EncryptDecrypt.DecryptResultWithVerificationInfo, Dafny.ISequence<char>> DecryptWithVerificationInfo(EncryptDecrypt.DecryptRequest request)
    {
      Wrappers_Compile.Result<EncryptDecrypt.DecryptResultWithVerificationInfo, Dafny.ISequence<char>> res = Wrappers_Compile.Result<EncryptDecrypt.DecryptResultWithVerificationInfo, Dafny.ISequence<char>>.Default(EncryptDecrypt.DecryptResultWithVerificationInfo.Default());
      if ((((request).dtor_cmm) != (object) ((Dafny.Aws.Crypto.ICryptographicMaterialsManager)null)) && (((request).dtor_keyring) != (object) ((Dafny.Aws.Crypto.IKeyring)null))) {
        res = @Wrappers_Compile.Result<EncryptDecrypt.DecryptResultWithVerificationInfo, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("DecryptRequest.keyring OR DecryptRequest.cmm must be set (not both)."));
        return res;
      } else if ((((request).dtor_cmm) == (object) ((Dafny.Aws.Crypto.ICryptographicMaterialsManager)null)) && (((request).dtor_keyring) == (object) ((Dafny.Aws.Crypto.IKeyring)null))) {
        res = @Wrappers_Compile.Result<EncryptDecrypt.DecryptResultWithVerificationInfo, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("DecryptRequest.cmm and DecryptRequest.keyring cannot both be null."));
        return res;
      }
      Dafny.Aws.Crypto.ICryptographicMaterialsManager _18343_cmm = default(Dafny.Aws.Crypto.ICryptographicMaterialsManager);
      if (((request).dtor_keyring) == (object) ((Dafny.Aws.Crypto.IKeyring)null)) {
        _18343_cmm = (request).dtor_cmm;
      } else {
        DefaultCMMDef.DefaultCMM _nw13 = new DefaultCMMDef.DefaultCMM();
        _nw13.OfKeyring((request).dtor_keyring);
        _18343_cmm = _nw13;
      }
      Streams_Compile.ByteReader _18344_rd;
      Streams_Compile.ByteReader _nw14 = new Streams_Compile.ByteReader();
      _nw14.__ctor((request).dtor_message);
      _18344_rd = _nw14;
      Deserialize_Compile.DeserializeHeaderResult _18345_deserializeHeaderResult = Deserialize_Compile.DeserializeHeaderResult.Default();
      Wrappers_Compile.Result<Deserialize_Compile.DeserializeHeaderResult, Dafny.ISequence<char>> _18346_valueOrError0 = Wrappers_Compile.Result<Deserialize_Compile.DeserializeHeaderResult, Dafny.ISequence<char>>.Default(Deserialize_Compile.DeserializeHeaderResult.Default());
      Wrappers_Compile.Result<Deserialize_Compile.DeserializeHeaderResult, Dafny.ISequence<char>> _out141;
      _out141 = Deserialize_Compile.__default.DeserializeHeader(_18344_rd);
      _18346_valueOrError0 = _out141;
      if ((_18346_valueOrError0).IsFailure()) {
        res = (_18346_valueOrError0).PropagateFailure<EncryptDecrypt.DecryptResultWithVerificationInfo>();
        return res;
      }
      _18345_deserializeHeaderResult = (_18346_valueOrError0).Extract();
      MessageHeader.Header _18347_header;
      _18347_header = (_18345_deserializeHeaderResult).dtor_header;
      Dafny.Aws.Crypto.DecryptMaterialsInput _18348_decMatRequest;
      _18348_decMatRequest = @Dafny.Aws.Crypto.DecryptMaterialsInput.create(AlgorithmSuite.__default.InternalIDToPolymorphID(((_18347_header).dtor_body).dtor_algorithmSuiteID), (((_18347_header).dtor_body).dtor_encryptedDataKeys).dtor_entries, ((_18347_header).dtor_body).dtor_aad);
      Dafny.Aws.Crypto.DecryptMaterialsOutput _18349_output = Dafny.Aws.Crypto.DecryptMaterialsOutput.Default();
      Wrappers_Compile.Result<Dafny.Aws.Crypto.DecryptMaterialsOutput, Dafny.ISequence<char>> _18350_valueOrError1 = Wrappers_Compile.Result<Dafny.Aws.Crypto.DecryptMaterialsOutput, Dafny.ISequence<char>>.Default(Dafny.Aws.Crypto.DecryptMaterialsOutput.Default());
      Wrappers_Compile.Result<Dafny.Aws.Crypto.DecryptMaterialsOutput, Dafny.ISequence<char>> _out142;
      _out142 = (_18343_cmm).DecryptMaterials(_18348_decMatRequest);
      _18350_valueOrError1 = _out142;
      if ((_18350_valueOrError1).IsFailure()) {
        res = (_18350_valueOrError1).PropagateFailure<EncryptDecrypt.DecryptResultWithVerificationInfo>();
        return res;
      }
      _18349_output = (_18350_valueOrError1).Extract();
      Dafny.Aws.Crypto.DecryptionMaterials _18351_decMat;
      _18351_decMat = (_18349_output).dtor_decryptionMaterials;
      if (!(((_18351_decMat).dtor_plaintextDataKey).is_Some)) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/src/SDK/EncryptDecrypt.dfy(404,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!((new BigInteger((((_18351_decMat).dtor_plaintextDataKey).dtor_value).Count)) == (AlgorithmSuite.ID.KDFInputKeyLength(AlgorithmSuite.__default.PolymorphIDToInternalID((_18351_decMat).dtor_algorithmSuiteId))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/src/SDK/EncryptDecrypt.dfy(405,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      Dafny.ISequence<byte> _18352_decryptionKey;
      Dafny.ISequence<byte> _out143;
      _out143 = EncryptDecrypt.__default.DeriveKey(((_18351_decMat).dtor_plaintextDataKey).dtor_value, AlgorithmSuite.__default.PolymorphIDToInternalID((_18351_decMat).dtor_algorithmSuiteId), ((_18347_header).dtor_body).dtor_messageID);
      _18352_decryptionKey = _out143;
      Dafny.ISequence<byte> _18353_plaintext = Dafny.Sequence<byte>.Empty;
      MessageHeader.ContentType _source23 = ((_18347_header).dtor_body).dtor_contentType;
      if (_source23.is_NonFramed) {
        {
          Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18354_valueOrError2 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
          Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out144;
          _out144 = MessageBody_Compile.__default.DecryptNonFramedMessageBody(_18344_rd, AlgorithmSuite.__default.PolymorphIDToInternalID((_18351_decMat).dtor_algorithmSuiteId), _18352_decryptionKey, ((_18347_header).dtor_body).dtor_messageID);
          _18354_valueOrError2 = _out144;
          if ((_18354_valueOrError2).IsFailure()) {
            res = (_18354_valueOrError2).PropagateFailure<EncryptDecrypt.DecryptResultWithVerificationInfo>();
            return res;
          }
          _18353_plaintext = (_18354_valueOrError2).Extract();
        }
      } else {
        {
          Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18355_valueOrError3 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
          Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out145;
          _out145 = MessageBody_Compile.__default.DecryptFramedMessageBody(_18344_rd, AlgorithmSuite.__default.PolymorphIDToInternalID((_18351_decMat).dtor_algorithmSuiteId), _18352_decryptionKey, new BigInteger(((_18347_header).dtor_body).dtor_frameLength), ((_18347_header).dtor_body).dtor_messageID);
          _18355_valueOrError3 = _out145;
          if ((_18355_valueOrError3).IsFailure()) {
            res = (_18355_valueOrError3).PropagateFailure<EncryptDecrypt.DecryptResultWithVerificationInfo>();
            return res;
          }
          _18353_plaintext = (_18355_valueOrError3).Extract();
        }
      }
      if ((AlgorithmSuite.ID.SignatureType(AlgorithmSuite.__default.PolymorphIDToInternalID((_18351_decMat).dtor_algorithmSuiteId))).is_Some) {
        Wrappers_Compile.Result<_System.Tuple0, Dafny.ISequence<char>> _18356_verifyResult;
        Wrappers_Compile.Result<_System.Tuple0, Dafny.ISequence<char>> _out146;
        _out146 = EncryptDecrypt.__default.VerifySignature(_18344_rd, _18351_decMat);
        _18356_verifyResult = _out146;
        if ((_18356_verifyResult).is_Failure) {
          res = @Wrappers_Compile.Result<EncryptDecrypt.DecryptResultWithVerificationInfo, Dafny.ISequence<char>>.create_Failure((_18356_verifyResult).dtor_error);
          return res;
        }
      }
      bool _18357_isDone;
      bool _out147;
      _out147 = (_18344_rd).IsDoneReading();
      _18357_isDone = _out147;
      if (!(_18357_isDone)) {
        res = @Wrappers_Compile.Result<EncryptDecrypt.DecryptResultWithVerificationInfo, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("message contains additional bytes at end"));
        return res;
      }
      EncryptDecrypt.DecryptResultWithVerificationInfo _18358_decryptResultWithVerificationInfo;
      _18358_decryptResultWithVerificationInfo = @EncryptDecrypt.DecryptResultWithVerificationInfo.create(_18353_plaintext);
      res = @Wrappers_Compile.Result<EncryptDecrypt.DecryptResultWithVerificationInfo, Dafny.ISequence<char>>.create_Success(_18358_decryptResultWithVerificationInfo);
      return res;
      return res;
    }
    public static Wrappers_Compile.Result<_System.Tuple0, Dafny.ISequence<char>> VerifySignature(Streams_Compile.ByteReader rd, Dafny.Aws.Crypto.DecryptionMaterials decMat)
    {
      Wrappers_Compile.Result<_System.Tuple0, Dafny.ISequence<char>> res = Wrappers_Compile.Result<_System.Tuple0, Dafny.ISequence<char>>.Default(_System.Tuple0.Default());
      if (!((AlgorithmSuite.ID.SignatureType(AlgorithmSuite.__default.PolymorphIDToInternalID((decMat).dtor_algorithmSuiteId))).is_Some)) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/src/SDK/EncryptDecrypt.dfy(522,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      Signature.ECDSAParams _18359_ecdsaParams;
      _18359_ecdsaParams = (AlgorithmSuite.ID.SignatureType(AlgorithmSuite.__default.PolymorphIDToInternalID((decMat).dtor_algorithmSuiteId))).dtor_value;
      BigInteger _18360_usedCapacity;
      BigInteger _out148;
      _out148 = (rd).GetSizeRead();
      _18360_usedCapacity = _out148;
      Dafny.ISequence<byte> _18361_msg;
      _18361_msg = (((rd).reader).data).Take(_18360_usedCapacity);
      Wrappers_Compile.Result<ushort, Dafny.ISequence<char>> _18362_signatureLengthResult;
      Wrappers_Compile.Result<ushort, Dafny.ISequence<char>> _out149;
      _out149 = (rd).ReadUInt16();
      _18362_signatureLengthResult = _out149;
      if ((_18362_signatureLengthResult).is_Failure) {
        Wrappers_Compile.Result<_System.Tuple0, Dafny.ISequence<char>> _rhs8 = @Wrappers_Compile.Result<_System.Tuple0, Dafny.ISequence<char>>.create_Failure((_18362_signatureLengthResult).dtor_error);
        res = _rhs8;
        return res;
      }
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18363_sigResult;
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out150;
      _out150 = (rd).ReadBytes(new BigInteger((_18362_signatureLengthResult).dtor_value));
      _18363_sigResult = _out150;
      if ((_18363_sigResult).is_Failure) {
        Wrappers_Compile.Result<_System.Tuple0, Dafny.ISequence<char>> _rhs9 = @Wrappers_Compile.Result<_System.Tuple0, Dafny.ISequence<char>>.create_Failure((_18363_sigResult).dtor_error);
        res = _rhs9;
        return res;
      }
      if (!(((decMat).dtor_verificationKey).is_Some)) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/src/SDK/EncryptDecrypt.dfy(538,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      Wrappers_Compile.Result<bool, Dafny.ISequence<char>> _18364_signatureVerifiedResult;
      Wrappers_Compile.Result<bool, Dafny.ISequence<char>> _out151;
      _out151 = Signature.ECDSA.Verify(_18359_ecdsaParams, ((decMat).dtor_verificationKey).dtor_value, _18361_msg, (_18363_sigResult).dtor_value);
      _18364_signatureVerifiedResult = _out151;
      if ((_18364_signatureVerifiedResult).is_Failure) {
        Wrappers_Compile.Result<_System.Tuple0, Dafny.ISequence<char>> _rhs10 = @Wrappers_Compile.Result<_System.Tuple0, Dafny.ISequence<char>>.create_Failure((_18364_signatureVerifiedResult).dtor_error);
        res = _rhs10;
        return res;
      }
      if (!((_18364_signatureVerifiedResult).dtor_value)) {
        Wrappers_Compile.Result<_System.Tuple0, Dafny.ISequence<char>> _rhs11 = @Wrappers_Compile.Result<_System.Tuple0, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("signature not verified"));
        res = _rhs11;
        return res;
      }
      Wrappers_Compile.Result<_System.Tuple0, Dafny.ISequence<char>> _rhs12 = @Wrappers_Compile.Result<_System.Tuple0, Dafny.ISequence<char>>.create_Success(@_System.Tuple0.create());
      res = _rhs12;
      return res;
      return res;
    }
    public static uint DEFAULT__FRAME__LENGTH { get {
      return 4096U;
    } }
  }
} // end of namespace EncryptDecrypt
namespace Dafny.Aws.Esdk.AwsEncryptionSdkClient {








  public partial class AwsEncryptionSdkClient : Dafny.Aws.Esdk.IAwsEncryptionSdkClient {
    public AwsEncryptionSdkClient() {
    }
    public void __ctor()
    {
    }
    public Wrappers_Compile.Result<Dafny.Aws.Esdk.EncryptOutput, Dafny.ISequence<char>> Encrypt(Dafny.Aws.Esdk.EncryptInput input)
    {
      Wrappers_Compile.Result<Dafny.Aws.Esdk.EncryptOutput, Dafny.ISequence<char>> res = Wrappers_Compile.Result<Dafny.Aws.Esdk.EncryptOutput, Dafny.ISequence<char>>.Default(Dafny.Aws.Esdk.EncryptOutput.Default());
      EncryptDecrypt.EncryptRequest _18365_encryptRequest;
      _18365_encryptRequest = (EncryptDecrypt.EncryptRequest.WithCMM((input).dtor_plaintext, (input).dtor_materialsManager)).SetEncryptionContext((input).dtor_encryptionContext);
      Dafny.ISequence<byte> _18366_e = Dafny.Sequence<byte>.Empty;
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18367_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out152;
      _out152 = EncryptDecrypt.__default.Encrypt(_18365_encryptRequest);
      _18367_valueOrError0 = _out152;
      if (!(!((_18367_valueOrError0).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/src/SDK/AwsEncryptionSdk.dfy(30,18): " + _18367_valueOrError0);
      }
      _18366_e = (_18367_valueOrError0).Extract();
      res = @Wrappers_Compile.Result<Dafny.Aws.Esdk.EncryptOutput, Dafny.ISequence<char>>.create_Success(@Dafny.Aws.Esdk.EncryptOutput.create(_18366_e));
      return res;
      return res;
    }
    public Wrappers_Compile.Result<Dafny.Aws.Esdk.DecryptOutput, Dafny.ISequence<char>> Decrypt(Dafny.Aws.Esdk.DecryptInput input)
    {
      Wrappers_Compile.Result<Dafny.Aws.Esdk.DecryptOutput, Dafny.ISequence<char>> res = Wrappers_Compile.Result<Dafny.Aws.Esdk.DecryptOutput, Dafny.ISequence<char>>.Default(Dafny.Aws.Esdk.DecryptOutput.Default());
      EncryptDecrypt.DecryptRequest _18368_decryptRequest;
      _18368_decryptRequest = EncryptDecrypt.DecryptRequest.WithCMM((input).dtor_ciphertext, (input).dtor_materialsManager);
      Dafny.ISequence<byte> _18369_d = Dafny.Sequence<byte>.Empty;
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18370_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out153;
      _out153 = EncryptDecrypt.__default.Decrypt(_18368_decryptRequest);
      _18370_valueOrError0 = _out153;
      if (!(!((_18370_valueOrError0).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/src/SDK/AwsEncryptionSdk.dfy(37,18): " + _18370_valueOrError0);
      }
      _18369_d = (_18370_valueOrError0).Extract();
      res = @Wrappers_Compile.Result<Dafny.Aws.Esdk.DecryptOutput, Dafny.ISequence<char>>.create_Success(@Dafny.Aws.Esdk.DecryptOutput.create(_18369_d));
      return res;
      return res;
    }
  }

} // end of namespace Dafny.Aws.Esdk.AwsEncryptionSdkClient
namespace AwsKmsMrkAreUnique_Compile {





  public partial class __default {
    public static Wrappers_Compile.Result<_System.Tuple0, Dafny.ISequence<char>> AwsKmsMrkAreUnique(Dafny.ISequence<AwsKmsArnParsing_Compile.AwsKmsIdentifier> identifiers) {
      Dafny.ISequence<AwsKmsArnParsing_Compile.AwsKmsIdentifier> _18371_mrks = Seq_Compile.__default.Filter<AwsKmsArnParsing_Compile.AwsKmsIdentifier>(AwsKmsArnParsing_Compile.__default.IsMultiRegionAwsKmsIdentifier, identifiers);
      if ((new BigInteger((_18371_mrks).Count)).Sign == 0) {
        return @Wrappers_Compile.Result<_System.Tuple0, Dafny.ISequence<char>>.create_Success(@_System.Tuple0.create());
      } else {
        Dafny.ISequence<Dafny.ISequence<char>> _18372_mrkKeyIds = Seq_Compile.__default.Map<AwsKmsArnParsing_Compile.AwsKmsIdentifier, Dafny.ISequence<char>>(AwsKmsMrkAreUnique_Compile.__default.GetKeyId, _18371_mrks);
        Dafny.ISet<Dafny.ISequence<char>> _18373_setMrks = Seq_Compile.__default.ToSet<Dafny.ISequence<char>>(_18372_mrkKeyIds);
        if ((new BigInteger((_18372_mrkKeyIds).Count)) == (new BigInteger((_18373_setMrks).Count))) {
          return @Wrappers_Compile.Result<_System.Tuple0, Dafny.ISequence<char>>.create_Success(@_System.Tuple0.create());
        } else {
          Dafny.ISet<Dafny.ISequence<char>> _18374_duplicateMrkIds = Dafny.Helpers.Id<Func<Dafny.ISequence<Dafny.ISequence<char>>, Dafny.ISet<Dafny.ISequence<char>>>>((_18375_mrkKeyIds) => ((System.Func<Dafny.ISet<Dafny.ISequence<char>>>)(() => {
            var _coll1 = new System.Collections.Generic.List<Dafny.ISequence<char>>();
            foreach (Dafny.ISequence<char> _compr_1 in (_18375_mrkKeyIds).Elements) {
              Dafny.ISequence<char> _18376_x = (Dafny.ISequence<char>)_compr_1;
              if (((_18375_mrkKeyIds).Contains((_18376_x))) && (((Dafny.MultiSet<Dafny.ISequence<char>>.FromSeq(_18375_mrkKeyIds)).Select(_18376_x)) >= (BigInteger.One))) {
                _coll1.Add(_18376_x);
              }
            }
            return Dafny.Set<Dafny.ISequence<char>>.FromCollection(_coll1);
          }))())(_18372_mrkKeyIds);
          Func<AwsKmsArnParsing_Compile.AwsKmsIdentifier, bool> _18377_isDuplicate = Dafny.Helpers.Id<Func<Dafny.ISet<Dafny.ISequence<char>>, Func<AwsKmsArnParsing_Compile.AwsKmsIdentifier, bool>>>((_18378_duplicateMrkIds) => ((System.Func<AwsKmsArnParsing_Compile.AwsKmsIdentifier, bool>)((_18379_identifier) => {
            return (_18378_duplicateMrkIds).Contains((AwsKmsMrkAreUnique_Compile.__default.GetKeyId(_18379_identifier)));
          })))(_18374_duplicateMrkIds);
          Func<AwsKmsArnParsing_Compile.AwsKmsIdentifier, Dafny.ISequence<char>> _18380_identifierToString = ((System.Func<AwsKmsArnParsing_Compile.AwsKmsIdentifier, Dafny.ISequence<char>>)((_18381_i) => {
            return (_18381_i)._ToString();
          }));
          Dafny.ISequence<AwsKmsArnParsing_Compile.AwsKmsIdentifier> _18382_duplicateIdentifiers = Seq_Compile.__default.Filter<AwsKmsArnParsing_Compile.AwsKmsIdentifier>(_18377_isDuplicate, identifiers);
          Dafny.ISequence<Dafny.ISequence<char>> _18383_duplicates = Seq_Compile.__default.Map<AwsKmsArnParsing_Compile.AwsKmsIdentifier, Dafny.ISequence<char>>(_18380_identifierToString, _18382_duplicateIdentifiers);
          Wrappers_Compile.Outcome<Dafny.ISequence<char>> _18384_valueOrError0 = Wrappers_Compile.__default.Need<Dafny.ISequence<char>>((new BigInteger((_18383_duplicates).Count)).Sign == 1, Dafny.Sequence<char>.FromString("Impossible"));
          if ((_18384_valueOrError0).IsFailure()) {
            return (_18384_valueOrError0).PropagateFailure<_System.Tuple0>();
          } else {
            return @Wrappers_Compile.Result<_System.Tuple0, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Related multi-Region keys: "), StandardLibrary_Compile.__default.Join<char>(_18383_duplicates, Dafny.Sequence<char>.FromString(","))), Dafny.Sequence<char>.FromString("are not allowed.")));
          }
        }
      }
    }
    public static Dafny.ISequence<char> GetKeyId(AwsKmsArnParsing_Compile.AwsKmsIdentifier identifier) {
      AwsKmsArnParsing_Compile.AwsKmsIdentifier _source24 = identifier;
      if (_source24.is_AwsKmsArnIdentifier) {
        AwsKmsArnParsing_Compile.AwsArn _18385___mcc_h0 = ((AwsKmsArnParsing_Compile.AwsKmsIdentifier_AwsKmsArnIdentifier)_source24).a;
        AwsKmsArnParsing_Compile.AwsArn _18386_a = _18385___mcc_h0;
        return ((_18386_a).dtor_resource).dtor_value;
      } else {
        AwsKmsArnParsing_Compile.AwsResource _18387___mcc_h1 = ((AwsKmsArnParsing_Compile.AwsKmsIdentifier_AwsKmsRawResourceIdentifier)_source24).r;
        AwsKmsArnParsing_Compile.AwsResource _18388_i = _18387___mcc_h1;
        return (_18388_i).dtor_value;
      }
    }
  }
} // end of namespace AwsKmsMrkAreUnique_Compile
namespace Actions_Compile {


  public interface Action<A, R> {
    R Invoke(A a);
  }
  public class _Companion_Action<A, R> {
  }

  public interface ActionWithResult<A, R, E> : Actions_Compile.Action<A, Wrappers_Compile.Result<R, E>> {
  }
  public class _Companion_ActionWithResult<A, R, E> {
  }

  public partial class __default {
    public static Dafny.ISequence<__R> Map<__A, __R>(Actions_Compile.Action<__A, __R> action, Dafny.ISequence<__A> s)
    {
      Dafny.ISequence<__R> res = Dafny.Sequence<__R>.Empty;
      Dafny.ISequence<__R> _18389_rs;
      _18389_rs = Dafny.Sequence<__R>.FromElements();
      BigInteger _hi0 = new BigInteger((s).Count);
      for (BigInteger _18390_i = BigInteger.Zero; _18390_i < _hi0; _18390_i++) {
        __R _18391_r;
        __R _out154;
        _out154 = (action).Invoke((s).Select(_18390_i));
        _18391_r = _out154;
        _18389_rs = Dafny.Sequence<__R>.Concat(_18389_rs, Dafny.Sequence<__R>.FromElements(_18391_r));
      }
      res = _18389_rs;
      return res;
      return res;
    }
    public static Wrappers_Compile.Result<Dafny.ISequence<__R>, __E> MapWithResult<__A, __R, __E>(Dafny.TypeDescriptor<__R> _td___R, Actions_Compile.ActionWithResult<__A, __R, __E> action, Dafny.ISequence<__A> s)
    {
      Wrappers_Compile.Result<Dafny.ISequence<__R>, __E> res = Wrappers_Compile.Result<Dafny.ISequence<__R>, __E>.Default(Dafny.Sequence<__R>.Empty);
      Dafny.ISequence<__R> _18392_rs;
      _18392_rs = Dafny.Sequence<__R>.FromElements();
      BigInteger _hi1 = new BigInteger((s).Count);
      for (BigInteger _18393_i = BigInteger.Zero; _18393_i < _hi1; _18393_i++) {
        __R _18394_r = _td___R.Default();
        Wrappers_Compile.Result<__R, __E> _18395_valueOrError0 = Wrappers_Compile.Result<__R, __E>.Default(_td___R.Default());
        Wrappers_Compile.Result<__R, __E> _out155;
        _out155 = (action).Invoke((s).Select(_18393_i));
        _18395_valueOrError0 = _out155;
        if ((_18395_valueOrError0).IsFailure()) {
          res = (_18395_valueOrError0).PropagateFailure<Dafny.ISequence<__R>>();
          return res;
        }
        _18394_r = (_18395_valueOrError0).Extract();
        _18392_rs = Dafny.Sequence<__R>.Concat(_18392_rs, Dafny.Sequence<__R>.FromElements(_18394_r));
      }
      res = @Wrappers_Compile.Result<Dafny.ISequence<__R>, __E>.create_Success(_18392_rs);
      return res;
      return res;
    }
    public static Dafny.ISequence<__A> Filter<__A>(Actions_Compile.Action<__A, bool> action, Dafny.ISequence<__A> s)
    {
      Dafny.ISequence<__A> res = Dafny.Sequence<__A>.Empty;
      Dafny.ISequence<__A> _18396_rs;
      _18396_rs = Dafny.Sequence<__A>.FromElements();
      BigInteger _hi2 = new BigInteger((s).Count);
      for (BigInteger _18397_i = BigInteger.Zero; _18397_i < _hi2; _18397_i++) {
        bool _18398_r;
        bool _out156;
        _out156 = (action).Invoke((s).Select(_18397_i));
        _18398_r = _out156;
        if (_18398_r) {
          _18396_rs = Dafny.Sequence<__A>.Concat(_18396_rs, Dafny.Sequence<__A>.FromElements((s).Select(_18397_i)));
        }
      }
      res = _18396_rs;
      return res;
      return res;
    }
    public static Wrappers_Compile.Result<Dafny.ISequence<__A>, __E> FilterWithResult<__A, __E>(Actions_Compile.ActionWithResult<__A, bool, __E> action, Dafny.ISequence<__A> s)
    {
      Wrappers_Compile.Result<Dafny.ISequence<__A>, __E> res = Wrappers_Compile.Result<Dafny.ISequence<__A>, __E>.Default(Dafny.Sequence<__A>.Empty);
      Dafny.ISequence<__A> _18399_rs;
      _18399_rs = Dafny.Sequence<__A>.FromElements();
      BigInteger _hi3 = new BigInteger((s).Count);
      for (BigInteger _18400_i = BigInteger.Zero; _18400_i < _hi3; _18400_i++) {
        bool _18401_r = false;
        Wrappers_Compile.Result<bool, __E> _18402_valueOrError0 = Wrappers_Compile.Result<bool, __E>.Default(false);
        Wrappers_Compile.Result<bool, __E> _out157;
        _out157 = (action).Invoke((s).Select(_18400_i));
        _18402_valueOrError0 = _out157;
        if ((_18402_valueOrError0).IsFailure()) {
          res = (_18402_valueOrError0).PropagateFailure<Dafny.ISequence<__A>>();
          return res;
        }
        _18401_r = (_18402_valueOrError0).Extract();
        if (_18401_r) {
          _18399_rs = Dafny.Sequence<__A>.Concat(_18399_rs, Dafny.Sequence<__A>.FromElements((s).Select(_18400_i)));
        }
      }
      res = @Wrappers_Compile.Result<Dafny.ISequence<__A>, __E>.create_Success(_18399_rs);
      return res;
      return res;
    }
    public static Wrappers_Compile.Result<__B, Dafny.ISequence<__E>> ReduceToSuccess<__A, __B, __E>(Actions_Compile.ActionWithResult<__A, __B, __E> action, Dafny.ISequence<__A> s)
    {
      Wrappers_Compile.Result<__B, Dafny.ISequence<__E>> res = default(Wrappers_Compile.Result<__B, Dafny.ISequence<__E>>);
      Dafny.ISequence<__E> _18403_errors;
      _18403_errors = Dafny.Sequence<__E>.FromElements();
      BigInteger _hi4 = new BigInteger((s).Count);
      for (BigInteger _18404_i = BigInteger.Zero; _18404_i < _hi4; _18404_i++) {
        Wrappers_Compile.Result<__B, __E> _18405_attempt;
        Wrappers_Compile.Result<__B, __E> _out158;
        _out158 = (action).Invoke((s).Select(_18404_i));
        _18405_attempt = _out158;
        if ((_18405_attempt).is_Success) {
          res = @Wrappers_Compile.Result<__B, Dafny.ISequence<__E>>.create_Success((_18405_attempt).dtor_value);
          return res;
        } else {
          _18403_errors = Dafny.Sequence<__E>.Concat(_18403_errors, Dafny.Sequence<__E>.FromElements((_18405_attempt).dtor_error));
        }
      }
      res = @Wrappers_Compile.Result<__B, Dafny.ISequence<__E>>.create_Failure(_18403_errors);
      return res;
      return res;
    }
  }
} // end of namespace Actions_Compile
namespace Constants_Compile {


  public partial class __default {
    public static Dafny.ISequence<byte> PROVIDER__ID { get {
      Dafny.ISequence<byte> _18406_s = Dafny.Sequence<byte>.FromElements(97, 119, 115, 45, 107, 109, 115);
      return _18406_s;
    } }
  }
} // end of namespace Constants_Compile
namespace AwsKmsMrkMatchForDecrypt_Compile {





  public partial class __default {
    public static bool AwsKmsMrkMatchForDecrypt(AwsKmsArnParsing_Compile.AwsKmsIdentifier configuredAwsKmsIdentifier, AwsKmsArnParsing_Compile.AwsKmsIdentifier messageAwsKmsIdentifer)
    {
      if (object.Equals(configuredAwsKmsIdentifier, messageAwsKmsIdentifer)) {
        return true;
      } else {
        _System.Tuple2<AwsKmsArnParsing_Compile.AwsKmsIdentifier, AwsKmsArnParsing_Compile.AwsKmsIdentifier> _source25 = @_System.Tuple2<AwsKmsArnParsing_Compile.AwsKmsIdentifier, AwsKmsArnParsing_Compile.AwsKmsIdentifier>.create(messageAwsKmsIdentifer, configuredAwsKmsIdentifier);
        {
          AwsKmsArnParsing_Compile.AwsKmsIdentifier _18407___mcc_h0 = ((_System.Tuple2<AwsKmsArnParsing_Compile.AwsKmsIdentifier, AwsKmsArnParsing_Compile.AwsKmsIdentifier>)_source25)._0;
          AwsKmsArnParsing_Compile.AwsKmsIdentifier _18408___mcc_h1 = ((_System.Tuple2<AwsKmsArnParsing_Compile.AwsKmsIdentifier, AwsKmsArnParsing_Compile.AwsKmsIdentifier>)_source25)._1;
          AwsKmsArnParsing_Compile.AwsKmsIdentifier _source26 = _18407___mcc_h0;
          if (_source26.is_AwsKmsArnIdentifier) {
            AwsKmsArnParsing_Compile.AwsArn _18409___mcc_h2 = ((AwsKmsArnParsing_Compile.AwsKmsIdentifier_AwsKmsArnIdentifier)_source26).a;
            AwsKmsArnParsing_Compile.AwsKmsIdentifier _source27 = _18408___mcc_h1;
            if (_source27.is_AwsKmsArnIdentifier) {
              AwsKmsArnParsing_Compile.AwsArn _18410___mcc_h4 = ((AwsKmsArnParsing_Compile.AwsKmsIdentifier_AwsKmsArnIdentifier)_source27).a;
              AwsKmsArnParsing_Compile.AwsArn _18411_messageAwsKmsArn = _18410___mcc_h4;
              AwsKmsArnParsing_Compile.AwsArn _18412_configuredAwsKmsArn = _18409___mcc_h2;
              if ((!(AwsKmsArnParsing_Compile.__default.IsMultiRegionAwsKmsArn(_18412_configuredAwsKmsArn))) || (!(AwsKmsArnParsing_Compile.__default.IsMultiRegionAwsKmsArn(_18411_messageAwsKmsArn)))) {
                return false;
              } else {
                return (((((_18411_messageAwsKmsArn).dtor_partition).Equals(((_18412_configuredAwsKmsArn).dtor_partition))) && (((_18411_messageAwsKmsArn).dtor_service).Equals(((_18412_configuredAwsKmsArn).dtor_service)))) && (((_18411_messageAwsKmsArn).dtor_account).Equals(((_18412_configuredAwsKmsArn).dtor_account)))) && (object.Equals((_18411_messageAwsKmsArn).dtor_resource, (_18412_configuredAwsKmsArn).dtor_resource));
              }
            } else {
              AwsKmsArnParsing_Compile.AwsResource _18413___mcc_h6 = ((AwsKmsArnParsing_Compile.AwsKmsIdentifier_AwsKmsRawResourceIdentifier)_source27).r;
              return false;
            }
          } else {
            AwsKmsArnParsing_Compile.AwsResource _18414___mcc_h8 = ((AwsKmsArnParsing_Compile.AwsKmsIdentifier_AwsKmsRawResourceIdentifier)_source26).r;
            return false;
          }
        }
      }
    }
  }
} // end of namespace AwsKmsMrkMatchForDecrypt_Compile
namespace KeyringDefs {





  public interface Keyring {
    Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>> OnEncrypt(Materials.EncryptionMaterials materials);
    Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>> OnDecrypt(Materials.DecryptionMaterials materials, Dafny.ISequence<Materials.EncryptedDataKey> encryptedDataKeys);
  }
  public class _Companion_Keyring {
  }

} // end of namespace KeyringDefs
namespace AwsKmsMrkAwareSymmetricKeyringDef {














  public partial class AwsKmsMrkAwareSymmetricKeyring : KeyringDefs.Keyring {
    public AwsKmsMrkAwareSymmetricKeyring() {
      this._client = default(Amazon.KeyManagementService.IAmazonKeyManagementService);
      this._awsKmsKey = default(Dafny.ISequence<char>);
      this._awsKmsArn = default(AwsKmsArnParsing_Compile.AwsKmsIdentifier);
      this._grantTokens = Dafny.Sequence<Dafny.ISequence<char>>.Empty;
    }
    public void __ctor(Amazon.KeyManagementService.IAmazonKeyManagementService client, Dafny.ISequence<char> awsKmsKey, Dafny.ISequence<Dafny.ISequence<char>> grantTokens)
    {
      Wrappers_Compile.Result<AwsKmsArnParsing_Compile.AwsKmsIdentifier, Dafny.ISequence<char>> _18415_parsedAwsKmsId;
      _18415_parsedAwsKmsId = AwsKmsArnParsing_Compile.__default.ParseAwsKmsIdentifier(awsKmsKey);
      (this)._client = client;
      (this)._awsKmsKey = awsKmsKey;
      (this)._awsKmsArn = (_18415_parsedAwsKmsId).dtor_value;
      (this)._grantTokens = grantTokens;
    }
    public Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>> OnEncrypt(Materials.EncryptionMaterials materials)
    {
      Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>> res = Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>>.Default(Materials.ValidEncryptionMaterials.Default());
      if (((materials).dtor_plaintextDataKey).is_None) {
        KMSUtils.GenerateDataKeyRequest _18416_generatorRequest;
        _18416_generatorRequest = @KMSUtils.GenerateDataKeyRequest.create((materials).dtor_encryptionContext, (this).grantTokens, (this).awsKmsKey, (int)(AlgorithmSuite.ID.KDFInputKeyLength((materials).dtor_algorithmSuiteID)));
        Wrappers_Compile.Result<KMSUtils.GenerateDataKeyResponse, Dafny.ISequence<char>> _18417_maybeGenerateResponse;
        Wrappers_Compile.Result<KMSUtils.GenerateDataKeyResponse, Dafny.ISequence<char>> _out159;
        _out159 = KMSUtils.ClientHelper.GenerateDataKey((this).client, _18416_generatorRequest);
        _18417_maybeGenerateResponse = _out159;
        if ((_18417_maybeGenerateResponse).is_Failure) {
          res = @Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>>.create_Failure((_18417_maybeGenerateResponse).dtor_error);
          return res;
        }
        KMSUtils.GenerateDataKeyResponse _18418_generateResponse;
        _18418_generateResponse = (_18417_maybeGenerateResponse).dtor_value;
        Wrappers_Compile.Outcome<Dafny.ISequence<char>> _18419_valueOrError0 = Wrappers_Compile.Outcome<Dafny.ISequence<char>>.Default();
        _18419_valueOrError0 = Wrappers_Compile.__default.Need<Dafny.ISequence<char>>((_18418_generateResponse).IsWellFormed(), Dafny.Sequence<char>.FromString("Invalid response from KMS GenerateDataKey"));
        if ((_18419_valueOrError0).IsFailure()) {
          res = (_18419_valueOrError0).PropagateFailure<Materials.EncryptionMaterials>();
          return res;
        }
        Wrappers_Compile.Outcome<Dafny.ISequence<char>> _18420_valueOrError1 = Wrappers_Compile.Outcome<Dafny.ISequence<char>>.Default();
        _18420_valueOrError1 = Wrappers_Compile.__default.Need<Dafny.ISequence<char>>((AwsKmsArnParsing_Compile.__default.ParseAwsKmsIdentifier((_18418_generateResponse).dtor_keyID)).is_Success, Dafny.Sequence<char>.FromString("Invalid response from KMS GenerateDataKey:: Invalid Key Id"));
        if ((_18420_valueOrError1).IsFailure()) {
          res = (_18420_valueOrError1).PropagateFailure<Materials.EncryptionMaterials>();
          return res;
        }
        Wrappers_Compile.Outcome<Dafny.ISequence<char>> _18421_valueOrError2 = Wrappers_Compile.Outcome<Dafny.ISequence<char>>.Default();
        _18421_valueOrError2 = Wrappers_Compile.__default.Need<Dafny.ISequence<char>>(AlgorithmSuite.ID.ValidPlaintextDataKey((materials).dtor_algorithmSuiteID, (_18418_generateResponse).dtor_plaintext), Dafny.Sequence<char>.FromString("Invalid response from AWS KMS GenerateDataKey: Invalid data key"));
        if ((_18421_valueOrError2).IsFailure()) {
          res = (_18421_valueOrError2).PropagateFailure<Materials.EncryptionMaterials>();
          return res;
        }
        Dafny.ISequence<byte> _18422_providerInfo = UTF8.ValidUTF8Bytes.Default();
        Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18423_valueOrError3 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
        Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out160;
        _out160 = UTF8.__default.Encode((_18418_generateResponse).dtor_keyID);
        _18423_valueOrError3 = _out160;
        if ((_18423_valueOrError3).IsFailure()) {
          res = (_18423_valueOrError3).PropagateFailure<Materials.EncryptionMaterials>();
          return res;
        }
        _18422_providerInfo = (_18423_valueOrError3).Extract();
        Wrappers_Compile.Outcome<Dafny.ISequence<char>> _18424_valueOrError4 = Wrappers_Compile.Outcome<Dafny.ISequence<char>>.Default();
        _18424_valueOrError4 = Wrappers_Compile.__default.Need<Dafny.ISequence<char>>((new BigInteger((_18422_providerInfo).Count)) < (StandardLibrary_mUInt_Compile.__default.UINT16__LIMIT), Dafny.Sequence<char>.FromString("AWS KMS Key ID too long."));
        if ((_18424_valueOrError4).IsFailure()) {
          res = (_18424_valueOrError4).PropagateFailure<Materials.EncryptionMaterials>();
          return res;
        }
        Materials.EncryptedDataKey _18425_edk;
        _18425_edk = @Materials.EncryptedDataKey.create(Constants_Compile.__default.PROVIDER__ID, _18422_providerInfo, (_18418_generateResponse).dtor_ciphertextBlob);
        Dafny.ISequence<byte> _18426_plaintextDataKey;
        _18426_plaintextDataKey = (_18418_generateResponse).dtor_plaintext;
        Materials.EncryptionMaterials _18427_result;
        _18427_result = (materials).WithKeys(@Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(_18426_plaintextDataKey), Dafny.Sequence<Materials.EncryptedDataKey>.FromElements(_18425_edk));
        res = @Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>>.create_Success(_18427_result);
        return res;
      } else {
        KMSUtils.EncryptRequest _18428_encryptRequest;
        _18428_encryptRequest = @KMSUtils.EncryptRequest.create((materials).dtor_encryptionContext, (this).grantTokens, (this).awsKmsKey, ((materials).dtor_plaintextDataKey).dtor_value);
        Wrappers_Compile.Result<KMSUtils.EncryptResponse, Dafny.ISequence<char>> _18429_maybeEncryptResponse;
        Wrappers_Compile.Result<KMSUtils.EncryptResponse, Dafny.ISequence<char>> _out161;
        _out161 = KMSUtils.ClientHelper.Encrypt((this).client, _18428_encryptRequest);
        _18429_maybeEncryptResponse = _out161;
        if ((_18429_maybeEncryptResponse).is_Failure) {
          res = @Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>>.create_Failure((_18429_maybeEncryptResponse).dtor_error);
          return res;
        }
        KMSUtils.EncryptResponse _18430_encryptResponse;
        _18430_encryptResponse = (_18429_maybeEncryptResponse).dtor_value;
        Wrappers_Compile.Outcome<Dafny.ISequence<char>> _18431_valueOrError5 = Wrappers_Compile.Outcome<Dafny.ISequence<char>>.Default();
        _18431_valueOrError5 = Wrappers_Compile.__default.Need<Dafny.ISequence<char>>((_18430_encryptResponse).IsWellFormed(), Dafny.Sequence<char>.FromString("Invalid response from KMS Encrypt"));
        if ((_18431_valueOrError5).IsFailure()) {
          res = (_18431_valueOrError5).PropagateFailure<Materials.EncryptionMaterials>();
          return res;
        }
        Wrappers_Compile.Outcome<Dafny.ISequence<char>> _18432_valueOrError6 = Wrappers_Compile.Outcome<Dafny.ISequence<char>>.Default();
        _18432_valueOrError6 = Wrappers_Compile.__default.Need<Dafny.ISequence<char>>((AwsKmsArnParsing_Compile.__default.ParseAwsKmsIdentifier((_18430_encryptResponse).dtor_keyID)).is_Success, Dafny.Sequence<char>.FromString("Invalid response from AWS KMS Encrypt:: Invalid Key Id"));
        if ((_18432_valueOrError6).IsFailure()) {
          res = (_18432_valueOrError6).PropagateFailure<Materials.EncryptionMaterials>();
          return res;
        }
        Dafny.ISequence<byte> _18433_providerInfo = UTF8.ValidUTF8Bytes.Default();
        Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18434_valueOrError7 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
        Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out162;
        _out162 = UTF8.__default.Encode((_18430_encryptResponse).dtor_keyID);
        _18434_valueOrError7 = _out162;
        if ((_18434_valueOrError7).IsFailure()) {
          res = (_18434_valueOrError7).PropagateFailure<Materials.EncryptionMaterials>();
          return res;
        }
        _18433_providerInfo = (_18434_valueOrError7).Extract();
        Wrappers_Compile.Outcome<Dafny.ISequence<char>> _18435_valueOrError8 = Wrappers_Compile.Outcome<Dafny.ISequence<char>>.Default();
        _18435_valueOrError8 = Wrappers_Compile.__default.Need<Dafny.ISequence<char>>((new BigInteger((_18433_providerInfo).Count)) < (StandardLibrary_mUInt_Compile.__default.UINT16__LIMIT), Dafny.Sequence<char>.FromString("AWS KMS Key ID too long."));
        if ((_18435_valueOrError8).IsFailure()) {
          res = (_18435_valueOrError8).PropagateFailure<Materials.EncryptionMaterials>();
          return res;
        }
        Materials.EncryptedDataKey _18436_edk;
        _18436_edk = @Materials.EncryptedDataKey.create(Constants_Compile.__default.PROVIDER__ID, _18433_providerInfo, (_18430_encryptResponse).dtor_ciphertextBlob);
        Materials.EncryptionMaterials _18437_result;
        _18437_result = (materials).WithKeys((materials).dtor_plaintextDataKey, Dafny.Sequence<Materials.EncryptedDataKey>.FromElements(_18436_edk));
        res = @Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>>.create_Success(_18437_result);
        return res;
      }
      return res;
    }
    public Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>> OnDecrypt(Materials.DecryptionMaterials materials, Dafny.ISequence<Materials.EncryptedDataKey> encryptedDataKeys)
    {
      Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>> res = Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>.Default(Materials.ValidDecryptionMaterials.Default());
      if (((materials).dtor_plaintextDataKey).is_Some) {
        res = @Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>.create_Success(materials);
        return res;
      }
      AwsKmsMrkAwareSymmetricKeyringDef.OnDecryptEncryptedDataKeyFilter _18438_filter;
      AwsKmsMrkAwareSymmetricKeyringDef.OnDecryptEncryptedDataKeyFilter _nw15 = new AwsKmsMrkAwareSymmetricKeyringDef.OnDecryptEncryptedDataKeyFilter();
      _nw15.__ctor((this).awsKmsArn);
      _18438_filter = _nw15;
      Dafny.ISequence<Materials.EncryptedDataKey> _18439_edksToAttempt = Dafny.Sequence<Materials.EncryptedDataKey>.Empty;
      Wrappers_Compile.Result<Dafny.ISequence<Materials.EncryptedDataKey>, Dafny.ISequence<char>> _18440_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<Materials.EncryptedDataKey>, Dafny.ISequence<char>>.Default(Dafny.Sequence<Materials.EncryptedDataKey>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<Materials.EncryptedDataKey>, Dafny.ISequence<char>> _out163;
      _out163 = Actions_Compile.__default.FilterWithResult<Materials.EncryptedDataKey, Dafny.ISequence<char>>(_18438_filter, encryptedDataKeys);
      _18440_valueOrError0 = _out163;
      if ((_18440_valueOrError0).IsFailure()) {
        res = (_18440_valueOrError0).PropagateFailure<Materials.DecryptionMaterials>();
        return res;
      }
      _18439_edksToAttempt = (_18440_valueOrError0).Extract();
      AwsKmsMrkAwareSymmetricKeyringDef.DecryptSingleEncryptedDataKey _18441_decryptClosure;
      AwsKmsMrkAwareSymmetricKeyringDef.DecryptSingleEncryptedDataKey _nw16 = new AwsKmsMrkAwareSymmetricKeyringDef.DecryptSingleEncryptedDataKey();
      _nw16.__ctor(materials, (this).client, (this).awsKmsKey, (this).grantTokens);
      _18441_decryptClosure = _nw16;
      Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<Dafny.ISequence<char>>> _18442_outcome;
      Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<Dafny.ISequence<char>>> _out164;
      _out164 = Actions_Compile.__default.ReduceToSuccess<Materials.EncryptedDataKey, Materials.DecryptionMaterials, Dafny.ISequence<char>>(_18441_decryptClosure, _18439_edksToAttempt);
      _18442_outcome = _out164;
      res = ((System.Func<Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<Dafny.ISequence<char>>>, Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>>)((_source28) => {
        if (_source28.is_Success) {
          Materials.DecryptionMaterials _18443___mcc_h0 = ((Wrappers_Compile.Result_Success<Materials.DecryptionMaterials, Dafny.ISequence<Dafny.ISequence<char>>>)_source28).@value;
          return Dafny.Helpers.Let<Materials.DecryptionMaterials, Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>>(_18443___mcc_h0, _pat_let8_0 => Dafny.Helpers.Let<Materials.DecryptionMaterials, Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>>(_pat_let8_0, _18444_mat => @Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>.create_Success(_18444_mat)));
        } else {
          Dafny.ISequence<Dafny.ISequence<char>> _18445___mcc_h1 = ((Wrappers_Compile.Result_Failure<Materials.DecryptionMaterials, Dafny.ISequence<Dafny.ISequence<char>>>)_source28).error;
          return Dafny.Helpers.Let<Dafny.ISequence<Dafny.ISequence<char>>, Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>>(_18445___mcc_h1, _pat_let9_0 => Dafny.Helpers.Let<Dafny.ISequence<Dafny.ISequence<char>>, Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>>(_pat_let9_0, _18446_errors => (((new BigInteger((_18446_errors).Count)).Sign == 0) ? (@Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Unable to decrypt data key: No Encrypted Data Keys found to match."))) : (Dafny.Helpers.Let<Func<Dafny.ISequence<char>, Dafny.ISequence<char>, Dafny.ISequence<char>>, Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>>(((System.Func<Dafny.ISequence<char>, Dafny.ISequence<char>, Dafny.ISequence<char>>)((_18447_s, _18448_a) => {
            return Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(_18448_a, Dafny.Sequence<char>.FromString("\n")), _18447_s);
          })), _pat_let10_0 => Dafny.Helpers.Let<Func<Dafny.ISequence<char>, Dafny.ISequence<char>, Dafny.ISequence<char>>, Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>>(_pat_let10_0, _18449_concatString => Dafny.Helpers.Let<Dafny.ISequence<char>, Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>>(Seq_Compile.__default.FoldRight<Dafny.ISequence<char>, Dafny.ISequence<char>>(_18449_concatString, _18446_errors, Dafny.Sequence<char>.FromString("Unable to decrypt data key:\n")), _pat_let11_0 => Dafny.Helpers.Let<Dafny.ISequence<char>, Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>>(_pat_let11_0, _18450_error => @Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>.create_Failure(_18450_error)))))))));
        }
      }))(_18442_outcome);
      return res;
      return res;
    }
    public Amazon.KeyManagementService.IAmazonKeyManagementService _client;public Amazon.KeyManagementService.IAmazonKeyManagementService client { get {
      return this._client;
    } }
    public Dafny.ISequence<char> _awsKmsKey;public Dafny.ISequence<char> awsKmsKey { get {
      return this._awsKmsKey;
    } }
    public AwsKmsArnParsing_Compile.AwsKmsIdentifier _awsKmsArn;public AwsKmsArnParsing_Compile.AwsKmsIdentifier awsKmsArn { get {
      return this._awsKmsArn;
    } }
    public Dafny.ISequence<Dafny.ISequence<char>> _grantTokens;public Dafny.ISequence<Dafny.ISequence<char>> grantTokens { get {
      return this._grantTokens;
    } }
  }

  public partial class OnDecryptEncryptedDataKeyFilter : Actions_Compile.ActionWithResult<Materials.EncryptedDataKey, bool, Dafny.ISequence<char>>, Actions_Compile.Action<Materials.EncryptedDataKey, Wrappers_Compile.Result<bool, Dafny.ISequence<char>>> {
    public OnDecryptEncryptedDataKeyFilter() {
      this._awsKmsKey = default(AwsKmsArnParsing_Compile.AwsKmsIdentifier);
    }
    public void __ctor(AwsKmsArnParsing_Compile.AwsKmsIdentifier awsKmsKey)
    {
      (this)._awsKmsKey = awsKmsKey;
    }
    public Wrappers_Compile.Result<bool, Dafny.ISequence<char>> Invoke(Materials.EncryptedDataKey edk)
    {
      Wrappers_Compile.Result<bool, Dafny.ISequence<char>> res = Wrappers_Compile.Result<bool, Dafny.ISequence<char>>.Default(false);
      if (!((edk).dtor_providerID).Equals((Constants_Compile.__default.PROVIDER__ID))) {
        res = @Wrappers_Compile.Result<bool, Dafny.ISequence<char>>.create_Success(false);
        return res;
      }
      if (!(UTF8.__default.ValidUTF8Seq((edk).dtor_providerInfo))) {
        res = @Wrappers_Compile.Result<bool, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Invalid AWS KMS encoding, provider info is not UTF8."));
        return res;
      }
      Dafny.ISequence<char> _18451_keyId = Dafny.Sequence<char>.Empty;
      Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>> _18452_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.Default(Dafny.Sequence<char>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>> _out165;
      _out165 = UTF8.__default.Decode((edk).dtor_providerInfo);
      _18452_valueOrError0 = _out165;
      if ((_18452_valueOrError0).IsFailure()) {
        res = (_18452_valueOrError0).PropagateFailure<bool>();
        return res;
      }
      _18451_keyId = (_18452_valueOrError0).Extract();
      AwsKmsArnParsing_Compile.AwsArn _18453_arn = AwsKmsArnParsing_Compile.AwsArn.Default();
      Wrappers_Compile.Result<AwsKmsArnParsing_Compile.AwsArn, Dafny.ISequence<char>> _18454_valueOrError1 = Wrappers_Compile.Result<AwsKmsArnParsing_Compile.AwsArn, Dafny.ISequence<char>>.Default(AwsKmsArnParsing_Compile.AwsArn.Default());
      _18454_valueOrError1 = AwsKmsArnParsing_Compile.__default.ParseAwsKmsArn(_18451_keyId);
      if ((_18454_valueOrError1).IsFailure()) {
        res = (_18454_valueOrError1).PropagateFailure<bool>();
        return res;
      }
      _18453_arn = (_18454_valueOrError1).Extract();
      res = @Wrappers_Compile.Result<bool, Dafny.ISequence<char>>.create_Success(AwsKmsMrkMatchForDecrypt_Compile.__default.AwsKmsMrkMatchForDecrypt((this).awsKmsKey, @AwsKmsArnParsing_Compile.AwsKmsIdentifier.create_AwsKmsArnIdentifier(_18453_arn)));
      return res;
      return res;
    }
    public AwsKmsArnParsing_Compile.AwsKmsIdentifier _awsKmsKey;public AwsKmsArnParsing_Compile.AwsKmsIdentifier awsKmsKey { get {
      return this._awsKmsKey;
    } }
  }

  public partial class DecryptSingleEncryptedDataKey : Actions_Compile.ActionWithResult<Materials.EncryptedDataKey, Materials.DecryptionMaterials, Dafny.ISequence<char>>, Actions_Compile.Action<Materials.EncryptedDataKey, Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>> {
    public DecryptSingleEncryptedDataKey() {
      this._materials = default(Materials.DecryptionMaterials);
      this._client = default(Amazon.KeyManagementService.IAmazonKeyManagementService);
      this._awsKmsKey = default(Dafny.ISequence<char>);
      this._grantTokens = Dafny.Sequence<Dafny.ISequence<char>>.Empty;
    }
    public void __ctor(Materials.DecryptionMaterials materials, Amazon.KeyManagementService.IAmazonKeyManagementService client, Dafny.ISequence<char> awsKmsKey, Dafny.ISequence<Dafny.ISequence<char>> grantTokens)
    {
      (this)._materials = materials;
      (this)._client = client;
      (this)._awsKmsKey = awsKmsKey;
      (this)._grantTokens = grantTokens;
    }
    public Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>> Invoke(Materials.EncryptedDataKey edk)
    {
      Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>> res = default(Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>);
      KMSUtils.DecryptRequest _18455_decryptRequest;
      _18455_decryptRequest = @KMSUtils.DecryptRequest.create((this).awsKmsKey, (edk).dtor_ciphertext, ((this).materials).dtor_encryptionContext, (this).grantTokens);
      KMSUtils.DecryptResponse _18456_decryptResponse = KMSUtils.DecryptResponse.Default();
      Wrappers_Compile.Result<KMSUtils.DecryptResponse, Dafny.ISequence<char>> _18457_valueOrError0 = Wrappers_Compile.Result<KMSUtils.DecryptResponse, Dafny.ISequence<char>>.Default(KMSUtils.DecryptResponse.Default());
      Wrappers_Compile.Result<KMSUtils.DecryptResponse, Dafny.ISequence<char>> _out166;
      _out166 = KMSUtils.ClientHelper.Decrypt((this).client, _18455_decryptRequest);
      _18457_valueOrError0 = _out166;
      if ((_18457_valueOrError0).IsFailure()) {
        res = (_18457_valueOrError0).PropagateFailure<Materials.DecryptionMaterials>();
        return res;
      }
      _18456_decryptResponse = (_18457_valueOrError0).Extract();
      Wrappers_Compile.Outcome<Dafny.ISequence<char>> _18458_valueOrError1 = Wrappers_Compile.Outcome<Dafny.ISequence<char>>.Default();
      _18458_valueOrError1 = Wrappers_Compile.__default.Need<Dafny.ISequence<char>>((((_18456_decryptResponse).dtor_keyID).Equals(((this).awsKmsKey))) && (AlgorithmSuite.ID.ValidPlaintextDataKey(((this).materials).dtor_algorithmSuiteID, (_18456_decryptResponse).dtor_plaintext)), Dafny.Sequence<char>.FromString("Invalid response from KMS Decrypt"));
      if ((_18458_valueOrError1).IsFailure()) {
        res = (_18458_valueOrError1).PropagateFailure<Materials.DecryptionMaterials>();
        return res;
      }
      Materials.DecryptionMaterials _18459_result;
      _18459_result = ((this).materials).WithPlaintextDataKey((_18456_decryptResponse).dtor_plaintext);
      res = @Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>.create_Success(_18459_result);
      return res;
      return res;
    }
    public Materials.DecryptionMaterials _materials;public Materials.DecryptionMaterials materials { get {
      return this._materials;
    } }
    public Amazon.KeyManagementService.IAmazonKeyManagementService _client;public Amazon.KeyManagementService.IAmazonKeyManagementService client { get {
      return this._client;
    } }
    public Dafny.ISequence<char> _awsKmsKey;public Dafny.ISequence<char> awsKmsKey { get {
      return this._awsKmsKey;
    } }
    public Dafny.ISequence<Dafny.ISequence<char>> _grantTokens;public Dafny.ISequence<Dafny.ISequence<char>> grantTokens { get {
      return this._grantTokens;
    } }
  }

} // end of namespace AwsKmsMrkAwareSymmetricKeyringDef
namespace Base64Lemmas_Compile {





} // end of namespace Base64Lemmas_Compile
namespace Sorting_Compile {




  public partial class __default {
    public static bool LexicographicByteSeqBelow(Dafny.ISequence<byte> x, Dafny.ISequence<byte> y)
    {
      return Sorting_Compile.__default.LexicographicByteSeqBelowAux(x, y, BigInteger.Zero);
    }
    public static bool LexicographicByteSeqBelowAux(Dafny.ISequence<byte> x, Dafny.ISequence<byte> y, BigInteger n)
    {
      return (((n) == (new BigInteger((x).Count))) || (((n) != (new BigInteger((y).Count))) && (((x).Select(n)) < ((y).Select(n))))) || ((((n) != (new BigInteger((y).Count))) && (((x).Select(n)) == ((y).Select(n)))) && (Sorting_Compile.__default.LexicographicByteSeqBelowAux(x, y, (n) + (BigInteger.One))));
    }
    public static void SelectionSort<__Data>(__Data[] a, Func<__Data, __Data, bool> below)
    {
      BigInteger _18460_m;
      _18460_m = BigInteger.Zero;
      while ((_18460_m) < (new BigInteger((a).Length))) {
        BigInteger _18461_mindex;
        BigInteger _18462_n;
        BigInteger _rhs13 = _18460_m;
        BigInteger _rhs14 = (_18460_m) + (BigInteger.One);
        _18461_mindex = _rhs13;
        _18462_n = _rhs14;
        while ((_18462_n) < (new BigInteger((a).Length))) {
          if (!(Dafny.Helpers.Id<Func<__Data, __Data, bool>>(below)((a)[(int)(_18461_mindex)], (a)[(int)(_18462_n)]))) {
            _18461_mindex = _18462_n;
          }
          _18462_n = (_18462_n) + (BigInteger.One);
        }
        __Data _rhs15 = (a)[(int)(_18461_mindex)];
        __Data _rhs16 = (a)[(int)(_18460_m)];
        __Data[] _lhs0 = a;
        BigInteger _lhs1 = _18460_m;
        __Data[] _lhs2 = a;
        BigInteger _lhs3 = _18461_mindex;
        _lhs0[(int)(_lhs1)] = _rhs15;
        _lhs2[(int)(_lhs3)] = _rhs16;
        _18460_m = (_18460_m) + (BigInteger.One);
      }
    }
  }
} // end of namespace Sorting_Compile
namespace Time_Compile {



} // end of namespace Time_Compile
namespace TestDigest_mHelpers_Compile {





  public partial class __default {
    public static BigInteger ToInt(Dafny.ISequence<byte> bytes)
    {
      BigInteger n = BigInteger.Zero;
      n = BigInteger.Zero;
      BigInteger _18463_i;
      _18463_i = BigInteger.Zero;
      while ((_18463_i) < (new BigInteger((bytes).Count))) {
        n = ((new BigInteger(256)) * (n)) + (new BigInteger((bytes).Select(_18463_i)));
        _18463_i = (_18463_i) + (BigInteger.One);
      }
      return n;
    }
    public static void TestDigest(Dafny.ISequence<char> s, CryptoDatatypes_Compile.DigestAlgorithm alg, BigInteger expected)
    {
      if (!(Dafny.Helpers.Id<Func<Dafny.ISequence<char>, bool>>((_18464_s) => Dafny.Helpers.Quantifier<BigInteger>(Dafny.Helpers.IntegerRange(BigInteger.Zero, new BigInteger((_18464_s).Count)), true, (((_18465_i) => {
        return !(((_18465_i).Sign != -1) && ((_18465_i) < (new BigInteger((_18464_s).Count)))) || ((('a') <= ((_18464_s).Select(_18465_i))) && (((_18464_s).Select(_18465_i)) <= ('z')));
      }))))(s))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Crypto/Digest.dfy(30,6): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      Dafny.ISequence<byte> _18466_msg;
      _18466_msg = ((System.Func<Dafny.ISequence<byte>>) (() => {
        BigInteger dim11 = new BigInteger((s).Count);
        var arr11 = new byte[Dafny.Helpers.ToIntChecked(dim11,"C# array size must not be larger than max 32-bit int")];
        for (int i11 = 0; i11 < dim11; i11++) {
          var _18467_i = (BigInteger) i11;
          arr11[(int)(_18467_i)] = (byte)((s).Select(_18467_i));
        }
        return Dafny.Sequence<byte>.FromArray(arr11);
      }))();
      Dafny.ISequence<byte> _18468_digest = Dafny.Sequence<byte>.Empty;
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18469_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out167;
      _out167 = Digest_Compile.__default.Digest(alg, _18466_msg);
      _18469_valueOrError0 = _out167;
      if (!(!((_18469_valueOrError0).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Crypto/Digest.dfy(32,17): " + _18469_valueOrError0);
      }
      _18468_digest = (_18469_valueOrError0).Extract();
      if (!((new BigInteger((_18468_digest).Count)) == (Digest_Compile.__default.Length(alg)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Crypto/Digest.dfy(33,6): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      BigInteger _18470_actual;
      BigInteger _out168;
      _out168 = TestDigest_mHelpers_Compile.__default.ToInt(_18468_digest);
      _18470_actual = _out168;
      if (!((_18470_actual) == (expected))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Crypto/Digest.dfy(35,6): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
  }
} // end of namespace TestDigest_mHelpers_Compile
namespace TestDigest_Compile {




  public partial class __default {
    [Xunit.Fact]
    public static void DigestTestVectors()
    {
      Dafny.ISequence<char> _18471_s;
      _18471_s = Dafny.Sequence<char>.FromString("abc");
      TestDigest_mHelpers_Compile.__default.TestDigest(_18471_s, @CryptoDatatypes_Compile.DigestAlgorithm.create(), BigInteger.Parse("11610554759577678887058616627522426787358414133166247019097754655123425531747192578669846860198531688061507751898313498051436198428987376028989280584770719"));
      _18471_s = Dafny.Sequence<char>.FromString("");
      TestDigest_mHelpers_Compile.__default.TestDigest(_18471_s, @CryptoDatatypes_Compile.DigestAlgorithm.create(), BigInteger.Parse("10868450558671247443152026947160338505683745266658651051718065983487878962987857602829315249215796444208488632888003673539585986066311769564391053988452926"));
      _18471_s = Dafny.Sequence<char>.FromString("abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu");
      TestDigest_mHelpers_Compile.__default.TestDigest(_18471_s, @CryptoDatatypes_Compile.DigestAlgorithm.create(), BigInteger.Parse("7467751150072304710748607053756525574443640673541183129594735496433453152253989885323496399866777464427478124519714519652484878749913622135027995536779529"));
    }
  }
} // end of namespace TestDigest_Compile
namespace TestSignature_mHelpers_Compile {





  public partial class __default {
    public static void RequireGoodKeyLengths(Signature.ECDSAParams s, Signature.SignatureKeyPair sigKeyPair)
    {
      if (!((new BigInteger(((sigKeyPair).dtor_verificationKey).Count)) == ((s).FieldSize()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Crypto/Signature.dfy(20,6): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    public static void YCompression(Signature.ECDSAParams s, BigInteger fieldSize)
    {
      Signature.SignatureKeyPair _18472_res = Signature.SignatureKeyPair.Default();
      Wrappers_Compile.Result<Signature.SignatureKeyPair, Dafny.ISequence<char>> _18473_valueOrError0 = Wrappers_Compile.Result<Signature.SignatureKeyPair, Dafny.ISequence<char>>.Default(Signature.SignatureKeyPair.Default());
      Wrappers_Compile.Result<Signature.SignatureKeyPair, Dafny.ISequence<char>> _out169;
      _out169 = Signature.__default.KeyGen(s);
      _18473_valueOrError0 = _out169;
      if (!(!((_18473_valueOrError0).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Crypto/Signature.dfy(24,14): " + _18473_valueOrError0);
      }
      _18472_res = (_18473_valueOrError0).Extract();
      TestSignature_mHelpers_Compile.__default.RequireGoodKeyLengths(s, _18472_res);
      Dafny.ISequence<byte> _18474_public;
      Dafny.ISequence<byte> _18475_secret;
      Dafny.ISequence<byte> _rhs17 = (_18472_res).dtor_verificationKey;
      Dafny.ISequence<byte> _rhs18 = (_18472_res).dtor_signingKey;
      _18474_public = _rhs17;
      _18475_secret = _rhs18;
      if (!((new BigInteger((_18475_secret).Count)).Sign == 1)) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Crypto/Signature.dfy(29,6): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!((new BigInteger((_18474_public).Count)) == ((BigInteger.One) + (Dafny.Helpers.EuclideanDivision((fieldSize) + (new BigInteger(7)), new BigInteger(8)))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Crypto/Signature.dfy(30,6): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!((((_18474_public).Select(BigInteger.Zero)) == (2)) || (((_18474_public).Select(BigInteger.Zero)) == (3)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Crypto/Signature.dfy(31,6): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    public static void VerifyMessage(Signature.ECDSAParams @params)
    {
      Dafny.ISequence<byte> _18476_message = UTF8.ValidUTF8Bytes.Default();
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18477_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out170;
      _out170 = UTF8.__default.Encode(Dafny.Sequence<char>.FromString("Hello, World!"));
      _18477_valueOrError0 = _out170;
      if (!(!((_18477_valueOrError0).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Crypto/Signature.dfy(35,18): " + _18477_valueOrError0);
      }
      _18476_message = (_18477_valueOrError0).Extract();
      Signature.SignatureKeyPair _18478_keys = Signature.SignatureKeyPair.Default();
      Wrappers_Compile.Result<Signature.SignatureKeyPair, Dafny.ISequence<char>> _18479_valueOrError1 = Wrappers_Compile.Result<Signature.SignatureKeyPair, Dafny.ISequence<char>>.Default(Signature.SignatureKeyPair.Default());
      Wrappers_Compile.Result<Signature.SignatureKeyPair, Dafny.ISequence<char>> _out171;
      _out171 = Signature.__default.KeyGen(@params);
      _18479_valueOrError1 = _out171;
      if (!(!((_18479_valueOrError1).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Crypto/Signature.dfy(36,15): " + _18479_valueOrError1);
      }
      _18478_keys = (_18479_valueOrError1).Extract();
      TestSignature_mHelpers_Compile.__default.RequireGoodKeyLengths(@params, _18478_keys);
      Dafny.ISequence<byte> _18480_signature = Dafny.Sequence<byte>.Empty;
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18481_valueOrError2 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out172;
      _out172 = Signature.ECDSA.Sign(@params, (_18478_keys).dtor_signingKey, _18476_message);
      _18481_valueOrError2 = _out172;
      if (!(!((_18481_valueOrError2).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Crypto/Signature.dfy(39,20): " + _18481_valueOrError2);
      }
      _18480_signature = (_18481_valueOrError2).Extract();
      bool _18482_shouldBeTrue = false;
      Wrappers_Compile.Result<bool, Dafny.ISequence<char>> _18483_valueOrError3 = Wrappers_Compile.Result<bool, Dafny.ISequence<char>>.Default(false);
      Wrappers_Compile.Result<bool, Dafny.ISequence<char>> _out173;
      _out173 = Signature.ECDSA.Verify(@params, (_18478_keys).dtor_verificationKey, _18476_message, _18480_signature);
      _18483_valueOrError3 = _out173;
      if (!(!((_18483_valueOrError3).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Crypto/Signature.dfy(40,23): " + _18483_valueOrError3);
      }
      _18482_shouldBeTrue = (_18483_valueOrError3).Extract();
      if (!(_18482_shouldBeTrue)) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Crypto/Signature.dfy(41,6): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      bool _18484_shouldBeFalse = false;
      Wrappers_Compile.Result<bool, Dafny.ISequence<char>> _18485_valueOrError4 = Wrappers_Compile.Result<bool, Dafny.ISequence<char>>.Default(false);
      Wrappers_Compile.Result<bool, Dafny.ISequence<char>> _out174;
      _out174 = Signature.ECDSA.Verify(@params, (_18478_keys).dtor_verificationKey, Dafny.Sequence<byte>.Concat(_18476_message, Dafny.Sequence<byte>.FromElements(1)), _18480_signature);
      _18485_valueOrError4 = _out174;
      if (!(!((_18485_valueOrError4).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Crypto/Signature.dfy(43,24): " + _18485_valueOrError4);
      }
      _18484_shouldBeFalse = (_18485_valueOrError4).Extract();
      if (!(!(_18484_shouldBeFalse))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Crypto/Signature.dfy(44,6): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
  }
} // end of namespace TestSignature_mHelpers_Compile
namespace TestSignature_Compile {



  public partial class __default {
    [Xunit.Fact]
    public static void YCompression384()
    {
      TestSignature_mHelpers_Compile.__default.YCompression(@Signature.ECDSAParams.create_ECDSA__P384(), new BigInteger(384));
    }
    [Xunit.Fact]
    public static void YCompression256()
    {
      TestSignature_mHelpers_Compile.__default.YCompression(@Signature.ECDSAParams.create_ECDSA__P256(), new BigInteger(256));
    }
    [Xunit.Fact]
    public static void VerifyMessage384()
    {
      TestSignature_mHelpers_Compile.__default.VerifyMessage(@Signature.ECDSAParams.create_ECDSA__P384());
    }
    [Xunit.Fact]
    public static void VerifyMessage256()
    {
      TestSignature_mHelpers_Compile.__default.VerifyMessage(@Signature.ECDSAParams.create_ECDSA__P256());
    }
  }
} // end of namespace TestSignature_Compile
namespace TestHKDF {




  public partial class __default {
    [Xunit.Fact]
    public static void Test0()
    {
      byte[] _18486_tv__ikm;
      byte[] _nw17 = new byte[Dafny.Helpers.ToIntChecked(Dafny.Helpers.ToIntChecked(new BigInteger(22), "C# arrays may not be larger than the max 32-bit integer"),"C# array size must not be larger than max 32-bit int")];
      _nw17[(int)(0)] = 11;
      _nw17[(int)(1)] = 11;
      _nw17[(int)(2)] = 11;
      _nw17[(int)(3)] = 11;
      _nw17[(int)(4)] = 11;
      _nw17[(int)(5)] = 11;
      _nw17[(int)(6)] = 11;
      _nw17[(int)(7)] = 11;
      _nw17[(int)(8)] = 11;
      _nw17[(int)(9)] = 11;
      _nw17[(int)(10)] = 11;
      _nw17[(int)(11)] = 11;
      _nw17[(int)(12)] = 11;
      _nw17[(int)(13)] = 11;
      _nw17[(int)(14)] = 11;
      _nw17[(int)(15)] = 11;
      _nw17[(int)(16)] = 11;
      _nw17[(int)(17)] = 11;
      _nw17[(int)(18)] = 11;
      _nw17[(int)(19)] = 11;
      _nw17[(int)(20)] = 11;
      _nw17[(int)(21)] = 11;
      _18486_tv__ikm = _nw17;
      byte[] _18487_tv__salt;
      byte[] _nw18 = new byte[Dafny.Helpers.ToIntChecked(Dafny.Helpers.ToIntChecked(new BigInteger(13), "C# arrays may not be larger than the max 32-bit integer"),"C# array size must not be larger than max 32-bit int")];
      _nw18[(int)(0)] = 0;
      _nw18[(int)(1)] = 1;
      _nw18[(int)(2)] = 2;
      _nw18[(int)(3)] = 3;
      _nw18[(int)(4)] = 4;
      _nw18[(int)(5)] = 5;
      _nw18[(int)(6)] = 6;
      _nw18[(int)(7)] = 7;
      _nw18[(int)(8)] = 8;
      _nw18[(int)(9)] = 9;
      _nw18[(int)(10)] = 10;
      _nw18[(int)(11)] = 11;
      _nw18[(int)(12)] = 12;
      _18487_tv__salt = _nw18;
      byte[] _18488_tv__info;
      byte[] _nw19 = new byte[Dafny.Helpers.ToIntChecked(Dafny.Helpers.ToIntChecked(new BigInteger(10), "C# arrays may not be larger than the max 32-bit integer"),"C# array size must not be larger than max 32-bit int")];
      _nw19[(int)(0)] = 240;
      _nw19[(int)(1)] = 241;
      _nw19[(int)(2)] = 242;
      _nw19[(int)(3)] = 243;
      _nw19[(int)(4)] = 244;
      _nw19[(int)(5)] = 245;
      _nw19[(int)(6)] = 246;
      _nw19[(int)(7)] = 247;
      _nw19[(int)(8)] = 248;
      _nw19[(int)(9)] = 249;
      _18488_tv__info = _nw19;
      byte[] _18489_tv__okm__desired;
      byte[] _nw20 = new byte[Dafny.Helpers.ToIntChecked(Dafny.Helpers.ToIntChecked(new BigInteger(42), "C# arrays may not be larger than the max 32-bit integer"),"C# array size must not be larger than max 32-bit int")];
      _nw20[(int)(0)] = 60;
      _nw20[(int)(1)] = 178;
      _nw20[(int)(2)] = 95;
      _nw20[(int)(3)] = 37;
      _nw20[(int)(4)] = 250;
      _nw20[(int)(5)] = 172;
      _nw20[(int)(6)] = 213;
      _nw20[(int)(7)] = 122;
      _nw20[(int)(8)] = 144;
      _nw20[(int)(9)] = 67;
      _nw20[(int)(10)] = 79;
      _nw20[(int)(11)] = 100;
      _nw20[(int)(12)] = 208;
      _nw20[(int)(13)] = 54;
      _nw20[(int)(14)] = 47;
      _nw20[(int)(15)] = 42;
      _nw20[(int)(16)] = 45;
      _nw20[(int)(17)] = 45;
      _nw20[(int)(18)] = 10;
      _nw20[(int)(19)] = 144;
      _nw20[(int)(20)] = 207;
      _nw20[(int)(21)] = 26;
      _nw20[(int)(22)] = 90;
      _nw20[(int)(23)] = 76;
      _nw20[(int)(24)] = 93;
      _nw20[(int)(25)] = 176;
      _nw20[(int)(26)] = 45;
      _nw20[(int)(27)] = 86;
      _nw20[(int)(28)] = 236;
      _nw20[(int)(29)] = 196;
      _nw20[(int)(30)] = 197;
      _nw20[(int)(31)] = 191;
      _nw20[(int)(32)] = 52;
      _nw20[(int)(33)] = 0;
      _nw20[(int)(34)] = 114;
      _nw20[(int)(35)] = 8;
      _nw20[(int)(36)] = 213;
      _nw20[(int)(37)] = 184;
      _nw20[(int)(38)] = 135;
      _nw20[(int)(39)] = 24;
      _nw20[(int)(40)] = 88;
      _nw20[(int)(41)] = 101;
      _18489_tv__okm__desired = _nw20;
      Dafny.ISequence<byte> _18490_okm;
      Dafny.ISequence<byte> _out175;
      _out175 = HKDF_Compile.__default.Hkdf(@KeyDerivationAlgorithms.KeyDerivationAlgorithm.create_HKDF__WITH__SHA__256(), @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(Dafny.Helpers.SeqFromArray(_18487_tv__salt)), Dafny.Helpers.SeqFromArray(_18486_tv__ikm), Dafny.Helpers.SeqFromArray(_18488_tv__info), new BigInteger(42));
      _18490_okm = _out175;
      if (!((Dafny.Helpers.SeqFromArray(_18489_tv__okm__desired)).Equals((_18490_okm)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/hkdf/HKDF.dfy(31,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void Test1()
    {
      byte[] _18491_tv__ikm;
      byte[] _nw21 = new byte[Dafny.Helpers.ToIntChecked(Dafny.Helpers.ToIntChecked(new BigInteger(80), "C# arrays may not be larger than the max 32-bit integer"),"C# array size must not be larger than max 32-bit int")];
      _nw21[(int)(0)] = 0;
      _nw21[(int)(1)] = 1;
      _nw21[(int)(2)] = 2;
      _nw21[(int)(3)] = 3;
      _nw21[(int)(4)] = 4;
      _nw21[(int)(5)] = 5;
      _nw21[(int)(6)] = 6;
      _nw21[(int)(7)] = 7;
      _nw21[(int)(8)] = 8;
      _nw21[(int)(9)] = 9;
      _nw21[(int)(10)] = 10;
      _nw21[(int)(11)] = 11;
      _nw21[(int)(12)] = 12;
      _nw21[(int)(13)] = 13;
      _nw21[(int)(14)] = 14;
      _nw21[(int)(15)] = 15;
      _nw21[(int)(16)] = 16;
      _nw21[(int)(17)] = 17;
      _nw21[(int)(18)] = 18;
      _nw21[(int)(19)] = 19;
      _nw21[(int)(20)] = 20;
      _nw21[(int)(21)] = 21;
      _nw21[(int)(22)] = 22;
      _nw21[(int)(23)] = 23;
      _nw21[(int)(24)] = 24;
      _nw21[(int)(25)] = 25;
      _nw21[(int)(26)] = 26;
      _nw21[(int)(27)] = 27;
      _nw21[(int)(28)] = 28;
      _nw21[(int)(29)] = 29;
      _nw21[(int)(30)] = 30;
      _nw21[(int)(31)] = 31;
      _nw21[(int)(32)] = 32;
      _nw21[(int)(33)] = 33;
      _nw21[(int)(34)] = 34;
      _nw21[(int)(35)] = 35;
      _nw21[(int)(36)] = 36;
      _nw21[(int)(37)] = 37;
      _nw21[(int)(38)] = 38;
      _nw21[(int)(39)] = 39;
      _nw21[(int)(40)] = 40;
      _nw21[(int)(41)] = 41;
      _nw21[(int)(42)] = 42;
      _nw21[(int)(43)] = 43;
      _nw21[(int)(44)] = 44;
      _nw21[(int)(45)] = 45;
      _nw21[(int)(46)] = 46;
      _nw21[(int)(47)] = 47;
      _nw21[(int)(48)] = 48;
      _nw21[(int)(49)] = 49;
      _nw21[(int)(50)] = 50;
      _nw21[(int)(51)] = 51;
      _nw21[(int)(52)] = 52;
      _nw21[(int)(53)] = 53;
      _nw21[(int)(54)] = 54;
      _nw21[(int)(55)] = 55;
      _nw21[(int)(56)] = 56;
      _nw21[(int)(57)] = 57;
      _nw21[(int)(58)] = 58;
      _nw21[(int)(59)] = 59;
      _nw21[(int)(60)] = 60;
      _nw21[(int)(61)] = 61;
      _nw21[(int)(62)] = 62;
      _nw21[(int)(63)] = 63;
      _nw21[(int)(64)] = 64;
      _nw21[(int)(65)] = 65;
      _nw21[(int)(66)] = 66;
      _nw21[(int)(67)] = 67;
      _nw21[(int)(68)] = 68;
      _nw21[(int)(69)] = 69;
      _nw21[(int)(70)] = 70;
      _nw21[(int)(71)] = 71;
      _nw21[(int)(72)] = 72;
      _nw21[(int)(73)] = 73;
      _nw21[(int)(74)] = 74;
      _nw21[(int)(75)] = 75;
      _nw21[(int)(76)] = 76;
      _nw21[(int)(77)] = 77;
      _nw21[(int)(78)] = 78;
      _nw21[(int)(79)] = 79;
      _18491_tv__ikm = _nw21;
      byte[] _18492_tv__salt;
      byte[] _nw22 = new byte[Dafny.Helpers.ToIntChecked(Dafny.Helpers.ToIntChecked(new BigInteger(80), "C# arrays may not be larger than the max 32-bit integer"),"C# array size must not be larger than max 32-bit int")];
      _nw22[(int)(0)] = 96;
      _nw22[(int)(1)] = 97;
      _nw22[(int)(2)] = 98;
      _nw22[(int)(3)] = 99;
      _nw22[(int)(4)] = 100;
      _nw22[(int)(5)] = 101;
      _nw22[(int)(6)] = 102;
      _nw22[(int)(7)] = 103;
      _nw22[(int)(8)] = 104;
      _nw22[(int)(9)] = 105;
      _nw22[(int)(10)] = 106;
      _nw22[(int)(11)] = 107;
      _nw22[(int)(12)] = 108;
      _nw22[(int)(13)] = 109;
      _nw22[(int)(14)] = 110;
      _nw22[(int)(15)] = 111;
      _nw22[(int)(16)] = 112;
      _nw22[(int)(17)] = 113;
      _nw22[(int)(18)] = 114;
      _nw22[(int)(19)] = 115;
      _nw22[(int)(20)] = 116;
      _nw22[(int)(21)] = 117;
      _nw22[(int)(22)] = 118;
      _nw22[(int)(23)] = 119;
      _nw22[(int)(24)] = 120;
      _nw22[(int)(25)] = 121;
      _nw22[(int)(26)] = 122;
      _nw22[(int)(27)] = 123;
      _nw22[(int)(28)] = 124;
      _nw22[(int)(29)] = 125;
      _nw22[(int)(30)] = 126;
      _nw22[(int)(31)] = 127;
      _nw22[(int)(32)] = 128;
      _nw22[(int)(33)] = 129;
      _nw22[(int)(34)] = 130;
      _nw22[(int)(35)] = 130;
      _nw22[(int)(36)] = 86;
      _nw22[(int)(37)] = 133;
      _nw22[(int)(38)] = 134;
      _nw22[(int)(39)] = 135;
      _nw22[(int)(40)] = 136;
      _nw22[(int)(41)] = 137;
      _nw22[(int)(42)] = 138;
      _nw22[(int)(43)] = 139;
      _nw22[(int)(44)] = 140;
      _nw22[(int)(45)] = 141;
      _nw22[(int)(46)] = 142;
      _nw22[(int)(47)] = 143;
      _nw22[(int)(48)] = 144;
      _nw22[(int)(49)] = 145;
      _nw22[(int)(50)] = 146;
      _nw22[(int)(51)] = 147;
      _nw22[(int)(52)] = 148;
      _nw22[(int)(53)] = 149;
      _nw22[(int)(54)] = 150;
      _nw22[(int)(55)] = 151;
      _nw22[(int)(56)] = 152;
      _nw22[(int)(57)] = 153;
      _nw22[(int)(58)] = 154;
      _nw22[(int)(59)] = 155;
      _nw22[(int)(60)] = 156;
      _nw22[(int)(61)] = 157;
      _nw22[(int)(62)] = 158;
      _nw22[(int)(63)] = 159;
      _nw22[(int)(64)] = 160;
      _nw22[(int)(65)] = 161;
      _nw22[(int)(66)] = 162;
      _nw22[(int)(67)] = 163;
      _nw22[(int)(68)] = 164;
      _nw22[(int)(69)] = 165;
      _nw22[(int)(70)] = 166;
      _nw22[(int)(71)] = 167;
      _nw22[(int)(72)] = 168;
      _nw22[(int)(73)] = 169;
      _nw22[(int)(74)] = 170;
      _nw22[(int)(75)] = 171;
      _nw22[(int)(76)] = 172;
      _nw22[(int)(77)] = 173;
      _nw22[(int)(78)] = 174;
      _nw22[(int)(79)] = 175;
      _18492_tv__salt = _nw22;
      byte[] _18493_tv__info;
      byte[] _nw23 = new byte[Dafny.Helpers.ToIntChecked(Dafny.Helpers.ToIntChecked(new BigInteger(80), "C# arrays may not be larger than the max 32-bit integer"),"C# array size must not be larger than max 32-bit int")];
      _nw23[(int)(0)] = 176;
      _nw23[(int)(1)] = 177;
      _nw23[(int)(2)] = 178;
      _nw23[(int)(3)] = 179;
      _nw23[(int)(4)] = 180;
      _nw23[(int)(5)] = 181;
      _nw23[(int)(6)] = 182;
      _nw23[(int)(7)] = 183;
      _nw23[(int)(8)] = 184;
      _nw23[(int)(9)] = 185;
      _nw23[(int)(10)] = 186;
      _nw23[(int)(11)] = 187;
      _nw23[(int)(12)] = 188;
      _nw23[(int)(13)] = 189;
      _nw23[(int)(14)] = 190;
      _nw23[(int)(15)] = 191;
      _nw23[(int)(16)] = 192;
      _nw23[(int)(17)] = 193;
      _nw23[(int)(18)] = 194;
      _nw23[(int)(19)] = 195;
      _nw23[(int)(20)] = 196;
      _nw23[(int)(21)] = 197;
      _nw23[(int)(22)] = 198;
      _nw23[(int)(23)] = 199;
      _nw23[(int)(24)] = 200;
      _nw23[(int)(25)] = 201;
      _nw23[(int)(26)] = 202;
      _nw23[(int)(27)] = 203;
      _nw23[(int)(28)] = 204;
      _nw23[(int)(29)] = 205;
      _nw23[(int)(30)] = 206;
      _nw23[(int)(31)] = 207;
      _nw23[(int)(32)] = 208;
      _nw23[(int)(33)] = 209;
      _nw23[(int)(34)] = 210;
      _nw23[(int)(35)] = 211;
      _nw23[(int)(36)] = 212;
      _nw23[(int)(37)] = 213;
      _nw23[(int)(38)] = 214;
      _nw23[(int)(39)] = 215;
      _nw23[(int)(40)] = 216;
      _nw23[(int)(41)] = 217;
      _nw23[(int)(42)] = 218;
      _nw23[(int)(43)] = 219;
      _nw23[(int)(44)] = 220;
      _nw23[(int)(45)] = 221;
      _nw23[(int)(46)] = 222;
      _nw23[(int)(47)] = 223;
      _nw23[(int)(48)] = 224;
      _nw23[(int)(49)] = 225;
      _nw23[(int)(50)] = 226;
      _nw23[(int)(51)] = 227;
      _nw23[(int)(52)] = 228;
      _nw23[(int)(53)] = 229;
      _nw23[(int)(54)] = 230;
      _nw23[(int)(55)] = 231;
      _nw23[(int)(56)] = 232;
      _nw23[(int)(57)] = 233;
      _nw23[(int)(58)] = 234;
      _nw23[(int)(59)] = 235;
      _nw23[(int)(60)] = 236;
      _nw23[(int)(61)] = 237;
      _nw23[(int)(62)] = 238;
      _nw23[(int)(63)] = 239;
      _nw23[(int)(64)] = 240;
      _nw23[(int)(65)] = 241;
      _nw23[(int)(66)] = 242;
      _nw23[(int)(67)] = 243;
      _nw23[(int)(68)] = 244;
      _nw23[(int)(69)] = 245;
      _nw23[(int)(70)] = 246;
      _nw23[(int)(71)] = 247;
      _nw23[(int)(72)] = 248;
      _nw23[(int)(73)] = 249;
      _nw23[(int)(74)] = 250;
      _nw23[(int)(75)] = 251;
      _nw23[(int)(76)] = 252;
      _nw23[(int)(77)] = 253;
      _nw23[(int)(78)] = 254;
      _nw23[(int)(79)] = 255;
      _18493_tv__info = _nw23;
      byte[] _18494_tv__okm__desired;
      byte[] _nw24 = new byte[Dafny.Helpers.ToIntChecked(Dafny.Helpers.ToIntChecked(new BigInteger(82), "C# arrays may not be larger than the max 32-bit integer"),"C# array size must not be larger than max 32-bit int")];
      _nw24[(int)(0)] = 86;
      _nw24[(int)(1)] = 160;
      _nw24[(int)(2)] = 84;
      _nw24[(int)(3)] = 52;
      _nw24[(int)(4)] = 29;
      _nw24[(int)(5)] = 13;
      _nw24[(int)(6)] = 71;
      _nw24[(int)(7)] = 250;
      _nw24[(int)(8)] = 11;
      _nw24[(int)(9)] = 73;
      _nw24[(int)(10)] = 208;
      _nw24[(int)(11)] = 29;
      _nw24[(int)(12)] = 1;
      _nw24[(int)(13)] = 53;
      _nw24[(int)(14)] = 45;
      _nw24[(int)(15)] = 194;
      _nw24[(int)(16)] = 17;
      _nw24[(int)(17)] = 12;
      _nw24[(int)(18)] = 253;
      _nw24[(int)(19)] = 117;
      _nw24[(int)(20)] = 16;
      _nw24[(int)(21)] = 251;
      _nw24[(int)(22)] = 6;
      _nw24[(int)(23)] = 124;
      _nw24[(int)(24)] = 155;
      _nw24[(int)(25)] = 90;
      _nw24[(int)(26)] = 233;
      _nw24[(int)(27)] = 105;
      _nw24[(int)(28)] = 148;
      _nw24[(int)(29)] = 86;
      _nw24[(int)(30)] = 41;
      _nw24[(int)(31)] = 99;
      _nw24[(int)(32)] = 67;
      _nw24[(int)(33)] = 199;
      _nw24[(int)(34)] = 253;
      _nw24[(int)(35)] = 213;
      _nw24[(int)(36)] = 169;
      _nw24[(int)(37)] = 254;
      _nw24[(int)(38)] = 226;
      _nw24[(int)(39)] = 104;
      _nw24[(int)(40)] = 215;
      _nw24[(int)(41)] = 158;
      _nw24[(int)(42)] = 234;
      _nw24[(int)(43)] = 250;
      _nw24[(int)(44)] = 134;
      _nw24[(int)(45)] = 60;
      _nw24[(int)(46)] = 241;
      _nw24[(int)(47)] = 23;
      _nw24[(int)(48)] = 88;
      _nw24[(int)(49)] = 218;
      _nw24[(int)(50)] = 24;
      _nw24[(int)(51)] = 176;
      _nw24[(int)(52)] = 71;
      _nw24[(int)(53)] = 136;
      _nw24[(int)(54)] = 160;
      _nw24[(int)(55)] = 210;
      _nw24[(int)(56)] = 197;
      _nw24[(int)(57)] = 159;
      _nw24[(int)(58)] = 59;
      _nw24[(int)(59)] = 3;
      _nw24[(int)(60)] = 66;
      _nw24[(int)(61)] = 163;
      _nw24[(int)(62)] = 130;
      _nw24[(int)(63)] = 46;
      _nw24[(int)(64)] = 215;
      _nw24[(int)(65)] = 166;
      _nw24[(int)(66)] = 223;
      _nw24[(int)(67)] = 241;
      _nw24[(int)(68)] = 108;
      _nw24[(int)(69)] = 59;
      _nw24[(int)(70)] = 97;
      _nw24[(int)(71)] = 59;
      _nw24[(int)(72)] = 88;
      _nw24[(int)(73)] = 158;
      _nw24[(int)(74)] = 207;
      _nw24[(int)(75)] = 15;
      _nw24[(int)(76)] = 113;
      _nw24[(int)(77)] = 11;
      _nw24[(int)(78)] = 223;
      _nw24[(int)(79)] = 43;
      _nw24[(int)(80)] = 21;
      _nw24[(int)(81)] = 57;
      _18494_tv__okm__desired = _nw24;
      Dafny.ISequence<byte> _18495_okm;
      Dafny.ISequence<byte> _out176;
      _out176 = HKDF_Compile.__default.Hkdf(@KeyDerivationAlgorithms.KeyDerivationAlgorithm.create_HKDF__WITH__SHA__256(), @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(Dafny.Helpers.SeqFromArray(_18492_tv__salt)), Dafny.Helpers.SeqFromArray(_18491_tv__ikm), Dafny.Helpers.SeqFromArray(_18493_tv__info), new BigInteger(82));
      _18495_okm = _out176;
      if (!((Dafny.Helpers.SeqFromArray(_18494_tv__okm__desired)).Equals((_18495_okm)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/hkdf/HKDF.dfy(66,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void Test2()
    {
      Wrappers_Compile.Option<Dafny.ISequence<byte>> _18496_tv__salt;
      _18496_tv__salt = @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_None();
      byte[] _18497_tv__ikm;
      byte[] _nw25 = new byte[Dafny.Helpers.ToIntChecked(Dafny.Helpers.ToIntChecked(new BigInteger(22), "C# arrays may not be larger than the max 32-bit integer"),"C# array size must not be larger than max 32-bit int")];
      _nw25[(int)(0)] = 11;
      _nw25[(int)(1)] = 11;
      _nw25[(int)(2)] = 11;
      _nw25[(int)(3)] = 11;
      _nw25[(int)(4)] = 11;
      _nw25[(int)(5)] = 11;
      _nw25[(int)(6)] = 11;
      _nw25[(int)(7)] = 11;
      _nw25[(int)(8)] = 11;
      _nw25[(int)(9)] = 11;
      _nw25[(int)(10)] = 11;
      _nw25[(int)(11)] = 11;
      _nw25[(int)(12)] = 11;
      _nw25[(int)(13)] = 11;
      _nw25[(int)(14)] = 11;
      _nw25[(int)(15)] = 11;
      _nw25[(int)(16)] = 11;
      _nw25[(int)(17)] = 11;
      _nw25[(int)(18)] = 11;
      _nw25[(int)(19)] = 11;
      _nw25[(int)(20)] = 11;
      _nw25[(int)(21)] = 11;
      _18497_tv__ikm = _nw25;
      Dafny.ISequence<byte> _18498_tv__info;
      _18498_tv__info = Dafny.Sequence<byte>.FromElements();
      byte[] _18499_tv__okm__desired;
      byte[] _nw26 = new byte[Dafny.Helpers.ToIntChecked(Dafny.Helpers.ToIntChecked(new BigInteger(42), "C# arrays may not be larger than the max 32-bit integer"),"C# array size must not be larger than max 32-bit int")];
      _nw26[(int)(0)] = 141;
      _nw26[(int)(1)] = 164;
      _nw26[(int)(2)] = 231;
      _nw26[(int)(3)] = 117;
      _nw26[(int)(4)] = 165;
      _nw26[(int)(5)] = 99;
      _nw26[(int)(6)] = 193;
      _nw26[(int)(7)] = 143;
      _nw26[(int)(8)] = 113;
      _nw26[(int)(9)] = 95;
      _nw26[(int)(10)] = 128;
      _nw26[(int)(11)] = 42;
      _nw26[(int)(12)] = 6;
      _nw26[(int)(13)] = 60;
      _nw26[(int)(14)] = 90;
      _nw26[(int)(15)] = 49;
      _nw26[(int)(16)] = 184;
      _nw26[(int)(17)] = 161;
      _nw26[(int)(18)] = 31;
      _nw26[(int)(19)] = 92;
      _nw26[(int)(20)] = 94;
      _nw26[(int)(21)] = 225;
      _nw26[(int)(22)] = 135;
      _nw26[(int)(23)] = 158;
      _nw26[(int)(24)] = 195;
      _nw26[(int)(25)] = 69;
      _nw26[(int)(26)] = 78;
      _nw26[(int)(27)] = 95;
      _nw26[(int)(28)] = 60;
      _nw26[(int)(29)] = 115;
      _nw26[(int)(30)] = 141;
      _nw26[(int)(31)] = 45;
      _nw26[(int)(32)] = 157;
      _nw26[(int)(33)] = 32;
      _nw26[(int)(34)] = 19;
      _nw26[(int)(35)] = 149;
      _nw26[(int)(36)] = 250;
      _nw26[(int)(37)] = 164;
      _nw26[(int)(38)] = 182;
      _nw26[(int)(39)] = 26;
      _nw26[(int)(40)] = 150;
      _nw26[(int)(41)] = 200;
      _18499_tv__okm__desired = _nw26;
      Dafny.ISequence<byte> _18500_okm;
      Dafny.ISequence<byte> _out177;
      _out177 = HKDF_Compile.__default.Hkdf(@KeyDerivationAlgorithms.KeyDerivationAlgorithm.create_HKDF__WITH__SHA__256(), _18496_tv__salt, Dafny.Helpers.SeqFromArray(_18497_tv__ikm), (_18498_tv__info), new BigInteger(42));
      _18500_okm = _out177;
      if (!((Dafny.Helpers.SeqFromArray(_18499_tv__okm__desired)).Equals((_18500_okm)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/hkdf/HKDF.dfy(84,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void Test3()
    {
      byte[] _18501_tv__salt;
      byte[] _nw27 = new byte[Dafny.Helpers.ToIntChecked(Dafny.Helpers.ToIntChecked(new BigInteger(13), "C# arrays may not be larger than the max 32-bit integer"),"C# array size must not be larger than max 32-bit int")];
      _nw27[(int)(0)] = 0;
      _nw27[(int)(1)] = 1;
      _nw27[(int)(2)] = 2;
      _nw27[(int)(3)] = 3;
      _nw27[(int)(4)] = 4;
      _nw27[(int)(5)] = 5;
      _nw27[(int)(6)] = 6;
      _nw27[(int)(7)] = 7;
      _nw27[(int)(8)] = 8;
      _nw27[(int)(9)] = 9;
      _nw27[(int)(10)] = 10;
      _nw27[(int)(11)] = 11;
      _nw27[(int)(12)] = 12;
      _18501_tv__salt = _nw27;
      byte[] _18502_tv__ikm;
      byte[] _nw28 = new byte[Dafny.Helpers.ToIntChecked(Dafny.Helpers.ToIntChecked(new BigInteger(22), "C# arrays may not be larger than the max 32-bit integer"),"C# array size must not be larger than max 32-bit int")];
      _nw28[(int)(0)] = 11;
      _nw28[(int)(1)] = 11;
      _nw28[(int)(2)] = 11;
      _nw28[(int)(3)] = 11;
      _nw28[(int)(4)] = 11;
      _nw28[(int)(5)] = 11;
      _nw28[(int)(6)] = 11;
      _nw28[(int)(7)] = 11;
      _nw28[(int)(8)] = 11;
      _nw28[(int)(9)] = 11;
      _nw28[(int)(10)] = 11;
      _nw28[(int)(11)] = 11;
      _nw28[(int)(12)] = 11;
      _nw28[(int)(13)] = 11;
      _nw28[(int)(14)] = 11;
      _nw28[(int)(15)] = 11;
      _nw28[(int)(16)] = 11;
      _nw28[(int)(17)] = 11;
      _nw28[(int)(18)] = 11;
      _nw28[(int)(19)] = 11;
      _nw28[(int)(20)] = 11;
      _nw28[(int)(21)] = 11;
      _18502_tv__ikm = _nw28;
      byte[] _18503_tv__info;
      byte[] _nw29 = new byte[Dafny.Helpers.ToIntChecked(Dafny.Helpers.ToIntChecked(new BigInteger(10), "C# arrays may not be larger than the max 32-bit integer"),"C# array size must not be larger than max 32-bit int")];
      _nw29[(int)(0)] = 240;
      _nw29[(int)(1)] = 241;
      _nw29[(int)(2)] = 242;
      _nw29[(int)(3)] = 243;
      _nw29[(int)(4)] = 244;
      _nw29[(int)(5)] = 245;
      _nw29[(int)(6)] = 246;
      _nw29[(int)(7)] = 247;
      _nw29[(int)(8)] = 248;
      _nw29[(int)(9)] = 249;
      _18503_tv__info = _nw29;
      byte[] _18504_tv__okm__desired;
      byte[] _nw30 = new byte[Dafny.Helpers.ToIntChecked(Dafny.Helpers.ToIntChecked(new BigInteger(42), "C# arrays may not be larger than the max 32-bit integer"),"C# array size must not be larger than max 32-bit int")];
      _nw30[(int)(0)] = 155;
      _nw30[(int)(1)] = 80;
      _nw30[(int)(2)] = 151;
      _nw30[(int)(3)] = 168;
      _nw30[(int)(4)] = 96;
      _nw30[(int)(5)] = 56;
      _nw30[(int)(6)] = 184;
      _nw30[(int)(7)] = 5;
      _nw30[(int)(8)] = 48;
      _nw30[(int)(9)] = 144;
      _nw30[(int)(10)] = 118;
      _nw30[(int)(11)] = 164;
      _nw30[(int)(12)] = 75;
      _nw30[(int)(13)] = 58;
      _nw30[(int)(14)] = 159;
      _nw30[(int)(15)] = 56;
      _nw30[(int)(16)] = 6;
      _nw30[(int)(17)] = 62;
      _nw30[(int)(18)] = 37;
      _nw30[(int)(19)] = 181;
      _nw30[(int)(20)] = 22;
      _nw30[(int)(21)] = 220;
      _nw30[(int)(22)] = 191;
      _nw30[(int)(23)] = 54;
      _nw30[(int)(24)] = 159;
      _nw30[(int)(25)] = 57;
      _nw30[(int)(26)] = 76;
      _nw30[(int)(27)] = 250;
      _nw30[(int)(28)] = 180;
      _nw30[(int)(29)] = 54;
      _nw30[(int)(30)] = 133;
      _nw30[(int)(31)] = 247;
      _nw30[(int)(32)] = 72;
      _nw30[(int)(33)] = 182;
      _nw30[(int)(34)] = 69;
      _nw30[(int)(35)] = 119;
      _nw30[(int)(36)] = 99;
      _nw30[(int)(37)] = 228;
      _nw30[(int)(38)] = 240;
      _nw30[(int)(39)] = 32;
      _nw30[(int)(40)] = 79;
      _nw30[(int)(41)] = 197;
      _18504_tv__okm__desired = _nw30;
      Dafny.ISequence<byte> _18505_okm;
      Dafny.ISequence<byte> _out178;
      _out178 = HKDF_Compile.__default.Hkdf(@KeyDerivationAlgorithms.KeyDerivationAlgorithm.create_HKDF__WITH__SHA__384(), @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(Dafny.Helpers.SeqFromArray(_18501_tv__salt)), Dafny.Helpers.SeqFromArray(_18502_tv__ikm), Dafny.Helpers.SeqFromArray(_18503_tv__info), new BigInteger(42));
      _18505_okm = _out178;
      if (!((Dafny.Helpers.SeqFromArray(_18504_tv__okm__desired)).Equals((_18505_okm)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/hkdf/HKDF.dfy(102,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void Test4()
    {
      byte[] _18506_tv__salt;
      byte[] _nw31 = new byte[Dafny.Helpers.ToIntChecked(Dafny.Helpers.ToIntChecked(new BigInteger(80), "C# arrays may not be larger than the max 32-bit integer"),"C# array size must not be larger than max 32-bit int")];
      _nw31[(int)(0)] = 96;
      _nw31[(int)(1)] = 97;
      _nw31[(int)(2)] = 98;
      _nw31[(int)(3)] = 99;
      _nw31[(int)(4)] = 100;
      _nw31[(int)(5)] = 101;
      _nw31[(int)(6)] = 102;
      _nw31[(int)(7)] = 103;
      _nw31[(int)(8)] = 104;
      _nw31[(int)(9)] = 105;
      _nw31[(int)(10)] = 106;
      _nw31[(int)(11)] = 107;
      _nw31[(int)(12)] = 108;
      _nw31[(int)(13)] = 109;
      _nw31[(int)(14)] = 110;
      _nw31[(int)(15)] = 111;
      _nw31[(int)(16)] = 112;
      _nw31[(int)(17)] = 113;
      _nw31[(int)(18)] = 114;
      _nw31[(int)(19)] = 115;
      _nw31[(int)(20)] = 116;
      _nw31[(int)(21)] = 117;
      _nw31[(int)(22)] = 118;
      _nw31[(int)(23)] = 119;
      _nw31[(int)(24)] = 120;
      _nw31[(int)(25)] = 121;
      _nw31[(int)(26)] = 122;
      _nw31[(int)(27)] = 123;
      _nw31[(int)(28)] = 124;
      _nw31[(int)(29)] = 125;
      _nw31[(int)(30)] = 126;
      _nw31[(int)(31)] = 127;
      _nw31[(int)(32)] = 128;
      _nw31[(int)(33)] = 129;
      _nw31[(int)(34)] = 130;
      _nw31[(int)(35)] = 131;
      _nw31[(int)(36)] = 132;
      _nw31[(int)(37)] = 133;
      _nw31[(int)(38)] = 134;
      _nw31[(int)(39)] = 135;
      _nw31[(int)(40)] = 136;
      _nw31[(int)(41)] = 137;
      _nw31[(int)(42)] = 138;
      _nw31[(int)(43)] = 139;
      _nw31[(int)(44)] = 140;
      _nw31[(int)(45)] = 141;
      _nw31[(int)(46)] = 142;
      _nw31[(int)(47)] = 143;
      _nw31[(int)(48)] = 144;
      _nw31[(int)(49)] = 145;
      _nw31[(int)(50)] = 146;
      _nw31[(int)(51)] = 147;
      _nw31[(int)(52)] = 148;
      _nw31[(int)(53)] = 149;
      _nw31[(int)(54)] = 150;
      _nw31[(int)(55)] = 151;
      _nw31[(int)(56)] = 152;
      _nw31[(int)(57)] = 153;
      _nw31[(int)(58)] = 154;
      _nw31[(int)(59)] = 155;
      _nw31[(int)(60)] = 156;
      _nw31[(int)(61)] = 157;
      _nw31[(int)(62)] = 158;
      _nw31[(int)(63)] = 159;
      _nw31[(int)(64)] = 160;
      _nw31[(int)(65)] = 161;
      _nw31[(int)(66)] = 162;
      _nw31[(int)(67)] = 163;
      _nw31[(int)(68)] = 164;
      _nw31[(int)(69)] = 165;
      _nw31[(int)(70)] = 166;
      _nw31[(int)(71)] = 167;
      _nw31[(int)(72)] = 168;
      _nw31[(int)(73)] = 169;
      _nw31[(int)(74)] = 170;
      _nw31[(int)(75)] = 171;
      _nw31[(int)(76)] = 172;
      _nw31[(int)(77)] = 173;
      _nw31[(int)(78)] = 174;
      _nw31[(int)(79)] = 175;
      _18506_tv__salt = _nw31;
      byte[] _18507_tv__ikm;
      byte[] _nw32 = new byte[Dafny.Helpers.ToIntChecked(Dafny.Helpers.ToIntChecked(new BigInteger(80), "C# arrays may not be larger than the max 32-bit integer"),"C# array size must not be larger than max 32-bit int")];
      _nw32[(int)(0)] = 0;
      _nw32[(int)(1)] = 1;
      _nw32[(int)(2)] = 2;
      _nw32[(int)(3)] = 3;
      _nw32[(int)(4)] = 4;
      _nw32[(int)(5)] = 5;
      _nw32[(int)(6)] = 6;
      _nw32[(int)(7)] = 7;
      _nw32[(int)(8)] = 8;
      _nw32[(int)(9)] = 9;
      _nw32[(int)(10)] = 10;
      _nw32[(int)(11)] = 11;
      _nw32[(int)(12)] = 12;
      _nw32[(int)(13)] = 13;
      _nw32[(int)(14)] = 14;
      _nw32[(int)(15)] = 15;
      _nw32[(int)(16)] = 16;
      _nw32[(int)(17)] = 17;
      _nw32[(int)(18)] = 18;
      _nw32[(int)(19)] = 19;
      _nw32[(int)(20)] = 20;
      _nw32[(int)(21)] = 21;
      _nw32[(int)(22)] = 22;
      _nw32[(int)(23)] = 23;
      _nw32[(int)(24)] = 24;
      _nw32[(int)(25)] = 25;
      _nw32[(int)(26)] = 26;
      _nw32[(int)(27)] = 27;
      _nw32[(int)(28)] = 28;
      _nw32[(int)(29)] = 29;
      _nw32[(int)(30)] = 30;
      _nw32[(int)(31)] = 31;
      _nw32[(int)(32)] = 32;
      _nw32[(int)(33)] = 33;
      _nw32[(int)(34)] = 34;
      _nw32[(int)(35)] = 35;
      _nw32[(int)(36)] = 36;
      _nw32[(int)(37)] = 37;
      _nw32[(int)(38)] = 38;
      _nw32[(int)(39)] = 39;
      _nw32[(int)(40)] = 40;
      _nw32[(int)(41)] = 41;
      _nw32[(int)(42)] = 42;
      _nw32[(int)(43)] = 43;
      _nw32[(int)(44)] = 44;
      _nw32[(int)(45)] = 45;
      _nw32[(int)(46)] = 46;
      _nw32[(int)(47)] = 47;
      _nw32[(int)(48)] = 48;
      _nw32[(int)(49)] = 49;
      _nw32[(int)(50)] = 50;
      _nw32[(int)(51)] = 51;
      _nw32[(int)(52)] = 52;
      _nw32[(int)(53)] = 53;
      _nw32[(int)(54)] = 54;
      _nw32[(int)(55)] = 55;
      _nw32[(int)(56)] = 56;
      _nw32[(int)(57)] = 57;
      _nw32[(int)(58)] = 58;
      _nw32[(int)(59)] = 59;
      _nw32[(int)(60)] = 60;
      _nw32[(int)(61)] = 61;
      _nw32[(int)(62)] = 62;
      _nw32[(int)(63)] = 63;
      _nw32[(int)(64)] = 64;
      _nw32[(int)(65)] = 65;
      _nw32[(int)(66)] = 66;
      _nw32[(int)(67)] = 67;
      _nw32[(int)(68)] = 68;
      _nw32[(int)(69)] = 69;
      _nw32[(int)(70)] = 70;
      _nw32[(int)(71)] = 71;
      _nw32[(int)(72)] = 72;
      _nw32[(int)(73)] = 73;
      _nw32[(int)(74)] = 74;
      _nw32[(int)(75)] = 75;
      _nw32[(int)(76)] = 76;
      _nw32[(int)(77)] = 77;
      _nw32[(int)(78)] = 78;
      _nw32[(int)(79)] = 79;
      _18507_tv__ikm = _nw32;
      byte[] _18508_tv__info;
      byte[] _nw33 = new byte[Dafny.Helpers.ToIntChecked(Dafny.Helpers.ToIntChecked(new BigInteger(80), "C# arrays may not be larger than the max 32-bit integer"),"C# array size must not be larger than max 32-bit int")];
      _nw33[(int)(0)] = 176;
      _nw33[(int)(1)] = 177;
      _nw33[(int)(2)] = 178;
      _nw33[(int)(3)] = 179;
      _nw33[(int)(4)] = 180;
      _nw33[(int)(5)] = 181;
      _nw33[(int)(6)] = 182;
      _nw33[(int)(7)] = 183;
      _nw33[(int)(8)] = 184;
      _nw33[(int)(9)] = 185;
      _nw33[(int)(10)] = 186;
      _nw33[(int)(11)] = 187;
      _nw33[(int)(12)] = 188;
      _nw33[(int)(13)] = 189;
      _nw33[(int)(14)] = 190;
      _nw33[(int)(15)] = 191;
      _nw33[(int)(16)] = 192;
      _nw33[(int)(17)] = 193;
      _nw33[(int)(18)] = 194;
      _nw33[(int)(19)] = 195;
      _nw33[(int)(20)] = 196;
      _nw33[(int)(21)] = 197;
      _nw33[(int)(22)] = 198;
      _nw33[(int)(23)] = 199;
      _nw33[(int)(24)] = 200;
      _nw33[(int)(25)] = 201;
      _nw33[(int)(26)] = 202;
      _nw33[(int)(27)] = 203;
      _nw33[(int)(28)] = 204;
      _nw33[(int)(29)] = 205;
      _nw33[(int)(30)] = 206;
      _nw33[(int)(31)] = 207;
      _nw33[(int)(32)] = 208;
      _nw33[(int)(33)] = 209;
      _nw33[(int)(34)] = 210;
      _nw33[(int)(35)] = 211;
      _nw33[(int)(36)] = 212;
      _nw33[(int)(37)] = 213;
      _nw33[(int)(38)] = 214;
      _nw33[(int)(39)] = 215;
      _nw33[(int)(40)] = 216;
      _nw33[(int)(41)] = 217;
      _nw33[(int)(42)] = 218;
      _nw33[(int)(43)] = 219;
      _nw33[(int)(44)] = 220;
      _nw33[(int)(45)] = 221;
      _nw33[(int)(46)] = 222;
      _nw33[(int)(47)] = 223;
      _nw33[(int)(48)] = 224;
      _nw33[(int)(49)] = 225;
      _nw33[(int)(50)] = 226;
      _nw33[(int)(51)] = 227;
      _nw33[(int)(52)] = 228;
      _nw33[(int)(53)] = 229;
      _nw33[(int)(54)] = 230;
      _nw33[(int)(55)] = 231;
      _nw33[(int)(56)] = 232;
      _nw33[(int)(57)] = 233;
      _nw33[(int)(58)] = 234;
      _nw33[(int)(59)] = 235;
      _nw33[(int)(60)] = 236;
      _nw33[(int)(61)] = 237;
      _nw33[(int)(62)] = 238;
      _nw33[(int)(63)] = 239;
      _nw33[(int)(64)] = 240;
      _nw33[(int)(65)] = 241;
      _nw33[(int)(66)] = 242;
      _nw33[(int)(67)] = 243;
      _nw33[(int)(68)] = 244;
      _nw33[(int)(69)] = 245;
      _nw33[(int)(70)] = 246;
      _nw33[(int)(71)] = 247;
      _nw33[(int)(72)] = 248;
      _nw33[(int)(73)] = 249;
      _nw33[(int)(74)] = 250;
      _nw33[(int)(75)] = 251;
      _nw33[(int)(76)] = 252;
      _nw33[(int)(77)] = 253;
      _nw33[(int)(78)] = 254;
      _nw33[(int)(79)] = 255;
      _18508_tv__info = _nw33;
      byte[] _18509_tv__okm__desired;
      byte[] _nw34 = new byte[Dafny.Helpers.ToIntChecked(Dafny.Helpers.ToIntChecked(new BigInteger(82), "C# arrays may not be larger than the max 32-bit integer"),"C# array size must not be larger than max 32-bit int")];
      _nw34[(int)(0)] = 72;
      _nw34[(int)(1)] = 76;
      _nw34[(int)(2)] = 160;
      _nw34[(int)(3)] = 82;
      _nw34[(int)(4)] = 184;
      _nw34[(int)(5)] = 204;
      _nw34[(int)(6)] = 114;
      _nw34[(int)(7)] = 79;
      _nw34[(int)(8)] = 209;
      _nw34[(int)(9)] = 196;
      _nw34[(int)(10)] = 236;
      _nw34[(int)(11)] = 100;
      _nw34[(int)(12)] = 213;
      _nw34[(int)(13)] = 123;
      _nw34[(int)(14)] = 78;
      _nw34[(int)(15)] = 129;
      _nw34[(int)(16)] = 140;
      _nw34[(int)(17)] = 126;
      _nw34[(int)(18)] = 37;
      _nw34[(int)(19)] = 168;
      _nw34[(int)(20)] = 224;
      _nw34[(int)(21)] = 244;
      _nw34[(int)(22)] = 86;
      _nw34[(int)(23)] = 158;
      _nw34[(int)(24)] = 215;
      _nw34[(int)(25)] = 42;
      _nw34[(int)(26)] = 106;
      _nw34[(int)(27)] = 5;
      _nw34[(int)(28)] = 254;
      _nw34[(int)(29)] = 6;
      _nw34[(int)(30)] = 73;
      _nw34[(int)(31)] = 238;
      _nw34[(int)(32)] = 191;
      _nw34[(int)(33)] = 105;
      _nw34[(int)(34)] = 248;
      _nw34[(int)(35)] = 213;
      _nw34[(int)(36)] = 200;
      _nw34[(int)(37)] = 50;
      _nw34[(int)(38)] = 133;
      _nw34[(int)(39)] = 107;
      _nw34[(int)(40)] = 244;
      _nw34[(int)(41)] = 228;
      _nw34[(int)(42)] = 251;
      _nw34[(int)(43)] = 193;
      _nw34[(int)(44)] = 121;
      _nw34[(int)(45)] = 103;
      _nw34[(int)(46)] = 213;
      _nw34[(int)(47)] = 73;
      _nw34[(int)(48)] = 117;
      _nw34[(int)(49)] = 50;
      _nw34[(int)(50)] = 74;
      _nw34[(int)(51)] = 148;
      _nw34[(int)(52)] = 152;
      _nw34[(int)(53)] = 127;
      _nw34[(int)(54)] = 127;
      _nw34[(int)(55)] = 65;
      _nw34[(int)(56)] = 131;
      _nw34[(int)(57)] = 88;
      _nw34[(int)(58)] = 23;
      _nw34[(int)(59)] = 216;
      _nw34[(int)(60)] = 153;
      _nw34[(int)(61)] = 79;
      _nw34[(int)(62)] = 219;
      _nw34[(int)(63)] = 214;
      _nw34[(int)(64)] = 244;
      _nw34[(int)(65)] = 192;
      _nw34[(int)(66)] = 156;
      _nw34[(int)(67)] = 85;
      _nw34[(int)(68)] = 0;
      _nw34[(int)(69)] = 220;
      _nw34[(int)(70)] = 162;
      _nw34[(int)(71)] = 74;
      _nw34[(int)(72)] = 86;
      _nw34[(int)(73)] = 34;
      _nw34[(int)(74)] = 47;
      _nw34[(int)(75)] = 234;
      _nw34[(int)(76)] = 83;
      _nw34[(int)(77)] = 216;
      _nw34[(int)(78)] = 150;
      _nw34[(int)(79)] = 122;
      _nw34[(int)(80)] = 139;
      _nw34[(int)(81)] = 46;
      _18509_tv__okm__desired = _nw34;
      Dafny.ISequence<byte> _18510_okm;
      Dafny.ISequence<byte> _out179;
      _out179 = HKDF_Compile.__default.Hkdf(@KeyDerivationAlgorithms.KeyDerivationAlgorithm.create_HKDF__WITH__SHA__384(), @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(Dafny.Helpers.SeqFromArray(_18506_tv__salt)), Dafny.Helpers.SeqFromArray(_18507_tv__ikm), Dafny.Helpers.SeqFromArray(_18508_tv__info), new BigInteger(82));
      _18510_okm = _out179;
      if (!((Dafny.Helpers.SeqFromArray(_18509_tv__okm__desired)).Equals((_18510_okm)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/hkdf/HKDF.dfy(137,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void Test5()
    {
      Wrappers_Compile.Option<Dafny.ISequence<byte>> _18511_tv__salt;
      _18511_tv__salt = @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_None();
      byte[] _18512_tv__ikm;
      byte[] _nw35 = new byte[Dafny.Helpers.ToIntChecked(Dafny.Helpers.ToIntChecked(new BigInteger(22), "C# arrays may not be larger than the max 32-bit integer"),"C# array size must not be larger than max 32-bit int")];
      _nw35[(int)(0)] = 11;
      _nw35[(int)(1)] = 11;
      _nw35[(int)(2)] = 11;
      _nw35[(int)(3)] = 11;
      _nw35[(int)(4)] = 11;
      _nw35[(int)(5)] = 11;
      _nw35[(int)(6)] = 11;
      _nw35[(int)(7)] = 11;
      _nw35[(int)(8)] = 11;
      _nw35[(int)(9)] = 11;
      _nw35[(int)(10)] = 11;
      _nw35[(int)(11)] = 11;
      _nw35[(int)(12)] = 11;
      _nw35[(int)(13)] = 11;
      _nw35[(int)(14)] = 11;
      _nw35[(int)(15)] = 11;
      _nw35[(int)(16)] = 11;
      _nw35[(int)(17)] = 11;
      _nw35[(int)(18)] = 11;
      _nw35[(int)(19)] = 11;
      _nw35[(int)(20)] = 11;
      _nw35[(int)(21)] = 11;
      _18512_tv__ikm = _nw35;
      Dafny.ISequence<byte> _18513_tv__info;
      _18513_tv__info = Dafny.Sequence<byte>.FromElements();
      byte[] _18514_tv__okm__desired;
      byte[] _nw36 = new byte[Dafny.Helpers.ToIntChecked(Dafny.Helpers.ToIntChecked(new BigInteger(42), "C# arrays may not be larger than the max 32-bit integer"),"C# array size must not be larger than max 32-bit int")];
      _nw36[(int)(0)] = 200;
      _nw36[(int)(1)] = 201;
      _nw36[(int)(2)] = 110;
      _nw36[(int)(3)] = 113;
      _nw36[(int)(4)] = 15;
      _nw36[(int)(5)] = 137;
      _nw36[(int)(6)] = 176;
      _nw36[(int)(7)] = 215;
      _nw36[(int)(8)] = 153;
      _nw36[(int)(9)] = 11;
      _nw36[(int)(10)] = 202;
      _nw36[(int)(11)] = 104;
      _nw36[(int)(12)] = 188;
      _nw36[(int)(13)] = 222;
      _nw36[(int)(14)] = 200;
      _nw36[(int)(15)] = 207;
      _nw36[(int)(16)] = 133;
      _nw36[(int)(17)] = 64;
      _nw36[(int)(18)] = 98;
      _nw36[(int)(19)] = 229;
      _nw36[(int)(20)] = 76;
      _nw36[(int)(21)] = 115;
      _nw36[(int)(22)] = 167;
      _nw36[(int)(23)] = 171;
      _nw36[(int)(24)] = 199;
      _nw36[(int)(25)] = 67;
      _nw36[(int)(26)] = 250;
      _nw36[(int)(27)] = 222;
      _nw36[(int)(28)] = 155;
      _nw36[(int)(29)] = 36;
      _nw36[(int)(30)] = 45;
      _nw36[(int)(31)] = 170;
      _nw36[(int)(32)] = 204;
      _nw36[(int)(33)] = 28;
      _nw36[(int)(34)] = 234;
      _nw36[(int)(35)] = 86;
      _nw36[(int)(36)] = 112;
      _nw36[(int)(37)] = 65;
      _nw36[(int)(38)] = 91;
      _nw36[(int)(39)] = 82;
      _nw36[(int)(40)] = 132;
      _nw36[(int)(41)] = 156;
      _18514_tv__okm__desired = _nw36;
      Dafny.ISequence<byte> _18515_okm;
      Dafny.ISequence<byte> _out180;
      _out180 = HKDF_Compile.__default.Hkdf(@KeyDerivationAlgorithms.KeyDerivationAlgorithm.create_HKDF__WITH__SHA__384(), _18511_tv__salt, Dafny.Helpers.SeqFromArray(_18512_tv__ikm), (_18513_tv__info), new BigInteger(42));
      _18515_okm = _out180;
      if (!((Dafny.Helpers.SeqFromArray(_18514_tv__okm__desired)).Equals((_18515_okm)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/hkdf/HKDF.dfy(155,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void Test7()
    {
      byte[] _18516_tv__ikm;
      byte[] _nw37 = new byte[Dafny.Helpers.ToIntChecked(Dafny.Helpers.ToIntChecked(new BigInteger(22), "C# arrays may not be larger than the max 32-bit integer"),"C# array size must not be larger than max 32-bit int")];
      _nw37[(int)(0)] = 11;
      _nw37[(int)(1)] = 11;
      _nw37[(int)(2)] = 11;
      _nw37[(int)(3)] = 11;
      _nw37[(int)(4)] = 11;
      _nw37[(int)(5)] = 11;
      _nw37[(int)(6)] = 11;
      _nw37[(int)(7)] = 11;
      _nw37[(int)(8)] = 11;
      _nw37[(int)(9)] = 11;
      _nw37[(int)(10)] = 11;
      _nw37[(int)(11)] = 11;
      _nw37[(int)(12)] = 11;
      _nw37[(int)(13)] = 11;
      _nw37[(int)(14)] = 11;
      _nw37[(int)(15)] = 11;
      _nw37[(int)(16)] = 11;
      _nw37[(int)(17)] = 11;
      _nw37[(int)(18)] = 11;
      _nw37[(int)(19)] = 11;
      _nw37[(int)(20)] = 11;
      _nw37[(int)(21)] = 11;
      _18516_tv__ikm = _nw37;
      byte[] _18517_tv__salt;
      byte[] _nw38 = new byte[Dafny.Helpers.ToIntChecked(Dafny.Helpers.ToIntChecked(new BigInteger(13), "C# arrays may not be larger than the max 32-bit integer"),"C# array size must not be larger than max 32-bit int")];
      _nw38[(int)(0)] = 0;
      _nw38[(int)(1)] = 1;
      _nw38[(int)(2)] = 2;
      _nw38[(int)(3)] = 3;
      _nw38[(int)(4)] = 4;
      _nw38[(int)(5)] = 5;
      _nw38[(int)(6)] = 6;
      _nw38[(int)(7)] = 7;
      _nw38[(int)(8)] = 8;
      _nw38[(int)(9)] = 9;
      _nw38[(int)(10)] = 10;
      _nw38[(int)(11)] = 11;
      _nw38[(int)(12)] = 12;
      _18517_tv__salt = _nw38;
      byte[] _18518_tv__info;
      byte[] _nw39 = new byte[Dafny.Helpers.ToIntChecked(Dafny.Helpers.ToIntChecked(new BigInteger(10), "C# arrays may not be larger than the max 32-bit integer"),"C# array size must not be larger than max 32-bit int")];
      _nw39[(int)(0)] = 240;
      _nw39[(int)(1)] = 241;
      _nw39[(int)(2)] = 242;
      _nw39[(int)(3)] = 243;
      _nw39[(int)(4)] = 244;
      _nw39[(int)(5)] = 245;
      _nw39[(int)(6)] = 246;
      _nw39[(int)(7)] = 247;
      _nw39[(int)(8)] = 248;
      _nw39[(int)(9)] = 249;
      _18518_tv__info = _nw39;
      byte[] _18519_tv__okm__desired;
      byte[] _nw40 = new byte[Dafny.Helpers.ToIntChecked(Dafny.Helpers.ToIntChecked(new BigInteger(8129), "C# arrays may not be larger than the max 32-bit integer"),"C# array size must not be larger than max 32-bit int")];
      _nw40[(int)(0)] = 60;
      _nw40[(int)(1)] = 178;
      _nw40[(int)(2)] = 95;
      _nw40[(int)(3)] = 37;
      _nw40[(int)(4)] = 250;
      _nw40[(int)(5)] = 172;
      _nw40[(int)(6)] = 213;
      _nw40[(int)(7)] = 122;
      _nw40[(int)(8)] = 144;
      _nw40[(int)(9)] = 67;
      _nw40[(int)(10)] = 79;
      _nw40[(int)(11)] = 100;
      _nw40[(int)(12)] = 208;
      _nw40[(int)(13)] = 54;
      _nw40[(int)(14)] = 47;
      _nw40[(int)(15)] = 42;
      _nw40[(int)(16)] = 45;
      _nw40[(int)(17)] = 45;
      _nw40[(int)(18)] = 10;
      _nw40[(int)(19)] = 144;
      _nw40[(int)(20)] = 207;
      _nw40[(int)(21)] = 26;
      _nw40[(int)(22)] = 90;
      _nw40[(int)(23)] = 76;
      _nw40[(int)(24)] = 93;
      _nw40[(int)(25)] = 176;
      _nw40[(int)(26)] = 45;
      _nw40[(int)(27)] = 86;
      _nw40[(int)(28)] = 236;
      _nw40[(int)(29)] = 196;
      _nw40[(int)(30)] = 197;
      _nw40[(int)(31)] = 191;
      _nw40[(int)(32)] = 52;
      _nw40[(int)(33)] = 0;
      _nw40[(int)(34)] = 114;
      _nw40[(int)(35)] = 8;
      _nw40[(int)(36)] = 213;
      _nw40[(int)(37)] = 184;
      _nw40[(int)(38)] = 135;
      _nw40[(int)(39)] = 24;
      _nw40[(int)(40)] = 88;
      _nw40[(int)(41)] = 101;
      _nw40[(int)(42)] = 180;
      _nw40[(int)(43)] = 176;
      _nw40[(int)(44)] = 168;
      _nw40[(int)(45)] = 90;
      _nw40[(int)(46)] = 153;
      _nw40[(int)(47)] = 59;
      _nw40[(int)(48)] = 137;
      _nw40[(int)(49)] = 185;
      _nw40[(int)(50)] = 182;
      _nw40[(int)(51)] = 86;
      _nw40[(int)(52)] = 131;
      _nw40[(int)(53)] = 214;
      _nw40[(int)(54)] = 15;
      _nw40[(int)(55)] = 1;
      _nw40[(int)(56)] = 6;
      _nw40[(int)(57)] = 210;
      _nw40[(int)(58)] = 143;
      _nw40[(int)(59)] = 255;
      _nw40[(int)(60)] = 3;
      _nw40[(int)(61)] = 157;
      _nw40[(int)(62)] = 11;
      _nw40[(int)(63)] = 111;
      _nw40[(int)(64)] = 52;
      _nw40[(int)(65)] = 8;
      _nw40[(int)(66)] = 144;
      _nw40[(int)(67)] = 12;
      _nw40[(int)(68)] = 15;
      _nw40[(int)(69)] = 42;
      _nw40[(int)(70)] = 157;
      _nw40[(int)(71)] = 68;
      _nw40[(int)(72)] = 99;
      _nw40[(int)(73)] = 222;
      _nw40[(int)(74)] = 131;
      _nw40[(int)(75)] = 98;
      _nw40[(int)(76)] = 32;
      _nw40[(int)(77)] = 86;
      _nw40[(int)(78)] = 190;
      _nw40[(int)(79)] = 80;
      _nw40[(int)(80)] = 168;
      _nw40[(int)(81)] = 129;
      _nw40[(int)(82)] = 190;
      _nw40[(int)(83)] = 191;
      _nw40[(int)(84)] = 43;
      _nw40[(int)(85)] = 152;
      _nw40[(int)(86)] = 58;
      _nw40[(int)(87)] = 180;
      _nw40[(int)(88)] = 62;
      _nw40[(int)(89)] = 6;
      _nw40[(int)(90)] = 153;
      _nw40[(int)(91)] = 18;
      _nw40[(int)(92)] = 240;
      _nw40[(int)(93)] = 165;
      _nw40[(int)(94)] = 117;
      _nw40[(int)(95)] = 130;
      _nw40[(int)(96)] = 252;
      _nw40[(int)(97)] = 177;
      _nw40[(int)(98)] = 140;
      _nw40[(int)(99)] = 167;
      _nw40[(int)(100)] = 167;
      _nw40[(int)(101)] = 254;
      _nw40[(int)(102)] = 64;
      _nw40[(int)(103)] = 163;
      _nw40[(int)(104)] = 60;
      _nw40[(int)(105)] = 118;
      _nw40[(int)(106)] = 108;
      _nw40[(int)(107)] = 130;
      _nw40[(int)(108)] = 152;
      _nw40[(int)(109)] = 18;
      _nw40[(int)(110)] = 175;
      _nw40[(int)(111)] = 50;
      _nw40[(int)(112)] = 124;
      _nw40[(int)(113)] = 50;
      _nw40[(int)(114)] = 225;
      _nw40[(int)(115)] = 38;
      _nw40[(int)(116)] = 88;
      _nw40[(int)(117)] = 157;
      _nw40[(int)(118)] = 60;
      _nw40[(int)(119)] = 100;
      _nw40[(int)(120)] = 244;
      _nw40[(int)(121)] = 25;
      _nw40[(int)(122)] = 221;
      _nw40[(int)(123)] = 255;
      _nw40[(int)(124)] = 249;
      _nw40[(int)(125)] = 216;
      _nw40[(int)(126)] = 199;
      _nw40[(int)(127)] = 135;
      _nw40[(int)(128)] = 246;
      _nw40[(int)(129)] = 149;
      _nw40[(int)(130)] = 207;
      _nw40[(int)(131)] = 234;
      _nw40[(int)(132)] = 118;
      _nw40[(int)(133)] = 150;
      _nw40[(int)(134)] = 129;
      _nw40[(int)(135)] = 103;
      _nw40[(int)(136)] = 37;
      _nw40[(int)(137)] = 227;
      _nw40[(int)(138)] = 146;
      _nw40[(int)(139)] = 198;
      _nw40[(int)(140)] = 59;
      _nw40[(int)(141)] = 83;
      _nw40[(int)(142)] = 126;
      _nw40[(int)(143)] = 102;
      _nw40[(int)(144)] = 90;
      _nw40[(int)(145)] = 107;
      _nw40[(int)(146)] = 21;
      _nw40[(int)(147)] = 225;
      _nw40[(int)(148)] = 228;
      _nw40[(int)(149)] = 90;
      _nw40[(int)(150)] = 45;
      _nw40[(int)(151)] = 248;
      _nw40[(int)(152)] = 14;
      _nw40[(int)(153)] = 98;
      _nw40[(int)(154)] = 84;
      _nw40[(int)(155)] = 167;
      _nw40[(int)(156)] = 163;
      _nw40[(int)(157)] = 237;
      _nw40[(int)(158)] = 200;
      _nw40[(int)(159)] = 67;
      _nw40[(int)(160)] = 222;
      _nw40[(int)(161)] = 25;
      _nw40[(int)(162)] = 229;
      _nw40[(int)(163)] = 176;
      _nw40[(int)(164)] = 216;
      _nw40[(int)(165)] = 151;
      _nw40[(int)(166)] = 232;
      _nw40[(int)(167)] = 4;
      _nw40[(int)(168)] = 130;
      _nw40[(int)(169)] = 158;
      _nw40[(int)(170)] = 243;
      _nw40[(int)(171)] = 237;
      _nw40[(int)(172)] = 237;
      _nw40[(int)(173)] = 162;
      _nw40[(int)(174)] = 11;
      _nw40[(int)(175)] = 188;
      _nw40[(int)(176)] = 218;
      _nw40[(int)(177)] = 124;
      _nw40[(int)(178)] = 241;
      _nw40[(int)(179)] = 49;
      _nw40[(int)(180)] = 98;
      _nw40[(int)(181)] = 22;
      _nw40[(int)(182)] = 42;
      _nw40[(int)(183)] = 29;
      _nw40[(int)(184)] = 168;
      _nw40[(int)(185)] = 134;
      _nw40[(int)(186)] = 149;
      _nw40[(int)(187)] = 243;
      _nw40[(int)(188)] = 227;
      _nw40[(int)(189)] = 161;
      _nw40[(int)(190)] = 181;
      _nw40[(int)(191)] = 245;
      _nw40[(int)(192)] = 36;
      _nw40[(int)(193)] = 229;
      _nw40[(int)(194)] = 187;
      _nw40[(int)(195)] = 152;
      _nw40[(int)(196)] = 95;
      _nw40[(int)(197)] = 115;
      _nw40[(int)(198)] = 198;
      _nw40[(int)(199)] = 109;
      _nw40[(int)(200)] = 102;
      _nw40[(int)(201)] = 223;
      _nw40[(int)(202)] = 146;
      _nw40[(int)(203)] = 112;
      _nw40[(int)(204)] = 87;
      _nw40[(int)(205)] = 79;
      _nw40[(int)(206)] = 144;
      _nw40[(int)(207)] = 183;
      _nw40[(int)(208)] = 52;
      _nw40[(int)(209)] = 142;
      _nw40[(int)(210)] = 201;
      _nw40[(int)(211)] = 101;
      _nw40[(int)(212)] = 253;
      _nw40[(int)(213)] = 81;
      _nw40[(int)(214)] = 69;
      _nw40[(int)(215)] = 117;
      _nw40[(int)(216)] = 40;
      _nw40[(int)(217)] = 253;
      _nw40[(int)(218)] = 114;
      _nw40[(int)(219)] = 172;
      _nw40[(int)(220)] = 71;
      _nw40[(int)(221)] = 88;
      _nw40[(int)(222)] = 190;
      _nw40[(int)(223)] = 87;
      _nw40[(int)(224)] = 60;
      _nw40[(int)(225)] = 109;
      _nw40[(int)(226)] = 141;
      _nw40[(int)(227)] = 2;
      _nw40[(int)(228)] = 148;
      _nw40[(int)(229)] = 225;
      _nw40[(int)(230)] = 123;
      _nw40[(int)(231)] = 201;
      _nw40[(int)(232)] = 242;
      _nw40[(int)(233)] = 103;
      _nw40[(int)(234)] = 191;
      _nw40[(int)(235)] = 159;
      _nw40[(int)(236)] = 28;
      _nw40[(int)(237)] = 170;
      _nw40[(int)(238)] = 141;
      _nw40[(int)(239)] = 56;
      _nw40[(int)(240)] = 72;
      _nw40[(int)(241)] = 103;
      _nw40[(int)(242)] = 124;
      _nw40[(int)(243)] = 185;
      _nw40[(int)(244)] = 176;
      _nw40[(int)(245)] = 250;
      _nw40[(int)(246)] = 237;
      _nw40[(int)(247)] = 138;
      _nw40[(int)(248)] = 81;
      _nw40[(int)(249)] = 242;
      _nw40[(int)(250)] = 65;
      _nw40[(int)(251)] = 80;
      _nw40[(int)(252)] = 253;
      _nw40[(int)(253)] = 200;
      _nw40[(int)(254)] = 96;
      _nw40[(int)(255)] = 58;
      _nw40[(int)(256)] = 250;
      _nw40[(int)(257)] = 130;
      _nw40[(int)(258)] = 232;
      _nw40[(int)(259)] = 213;
      _nw40[(int)(260)] = 213;
      _nw40[(int)(261)] = 130;
      _nw40[(int)(262)] = 74;
      _nw40[(int)(263)] = 113;
      _nw40[(int)(264)] = 110;
      _nw40[(int)(265)] = 63;
      _nw40[(int)(266)] = 185;
      _nw40[(int)(267)] = 91;
      _nw40[(int)(268)] = 10;
      _nw40[(int)(269)] = 204;
      _nw40[(int)(270)] = 233;
      _nw40[(int)(271)] = 167;
      _nw40[(int)(272)] = 86;
      _nw40[(int)(273)] = 6;
      _nw40[(int)(274)] = 208;
      _nw40[(int)(275)] = 111;
      _nw40[(int)(276)] = 227;
      _nw40[(int)(277)] = 88;
      _nw40[(int)(278)] = 137;
      _nw40[(int)(279)] = 239;
      _nw40[(int)(280)] = 170;
      _nw40[(int)(281)] = 109;
      _nw40[(int)(282)] = 78;
      _nw40[(int)(283)] = 12;
      _nw40[(int)(284)] = 75;
      _nw40[(int)(285)] = 61;
      _nw40[(int)(286)] = 210;
      _nw40[(int)(287)] = 223;
      _nw40[(int)(288)] = 222;
      _nw40[(int)(289)] = 0;
      _nw40[(int)(290)] = 237;
      _nw40[(int)(291)] = 155;
      _nw40[(int)(292)] = 18;
      _nw40[(int)(293)] = 211;
      _nw40[(int)(294)] = 225;
      _nw40[(int)(295)] = 243;
      _nw40[(int)(296)] = 64;
      _nw40[(int)(297)] = 167;
      _nw40[(int)(298)] = 174;
      _nw40[(int)(299)] = 78;
      _nw40[(int)(300)] = 73;
      _nw40[(int)(301)] = 81;
      _nw40[(int)(302)] = 189;
      _nw40[(int)(303)] = 103;
      _nw40[(int)(304)] = 255;
      _nw40[(int)(305)] = 251;
      _nw40[(int)(306)] = 45;
      _nw40[(int)(307)] = 179;
      _nw40[(int)(308)] = 147;
      _nw40[(int)(309)] = 160;
      _nw40[(int)(310)] = 62;
      _nw40[(int)(311)] = 62;
      _nw40[(int)(312)] = 249;
      _nw40[(int)(313)] = 44;
      _nw40[(int)(314)] = 144;
      _nw40[(int)(315)] = 191;
      _nw40[(int)(316)] = 223;
      _nw40[(int)(317)] = 222;
      _nw40[(int)(318)] = 179;
      _nw40[(int)(319)] = 16;
      _nw40[(int)(320)] = 183;
      _nw40[(int)(321)] = 82;
      _nw40[(int)(322)] = 187;
      _nw40[(int)(323)] = 134;
      _nw40[(int)(324)] = 56;
      _nw40[(int)(325)] = 26;
      _nw40[(int)(326)] = 217;
      _nw40[(int)(327)] = 2;
      _nw40[(int)(328)] = 30;
      _nw40[(int)(329)] = 238;
      _nw40[(int)(330)] = 21;
      _nw40[(int)(331)] = 21;
      _nw40[(int)(332)] = 94;
      _nw40[(int)(333)] = 187;
      _nw40[(int)(334)] = 62;
      _nw40[(int)(335)] = 191;
      _nw40[(int)(336)] = 84;
      _nw40[(int)(337)] = 102;
      _nw40[(int)(338)] = 68;
      _nw40[(int)(339)] = 46;
      _nw40[(int)(340)] = 103;
      _nw40[(int)(341)] = 223;
      _nw40[(int)(342)] = 180;
      _nw40[(int)(343)] = 126;
      _nw40[(int)(344)] = 241;
      _nw40[(int)(345)] = 243;
      _nw40[(int)(346)] = 184;
      _nw40[(int)(347)] = 47;
      _nw40[(int)(348)] = 89;
      _nw40[(int)(349)] = 14;
      _nw40[(int)(350)] = 194;
      _nw40[(int)(351)] = 202;
      _nw40[(int)(352)] = 153;
      _nw40[(int)(353)] = 104;
      _nw40[(int)(354)] = 194;
      _nw40[(int)(355)] = 211;
      _nw40[(int)(356)] = 90;
      _nw40[(int)(357)] = 50;
      _nw40[(int)(358)] = 95;
      _nw40[(int)(359)] = 39;
      _nw40[(int)(360)] = 183;
      _nw40[(int)(361)] = 97;
      _nw40[(int)(362)] = 114;
      _nw40[(int)(363)] = 86;
      _nw40[(int)(364)] = 3;
      _nw40[(int)(365)] = 247;
      _nw40[(int)(366)] = 64;
      _nw40[(int)(367)] = 201;
      _nw40[(int)(368)] = 205;
      _nw40[(int)(369)] = 16;
      _nw40[(int)(370)] = 150;
      _nw40[(int)(371)] = 21;
      _nw40[(int)(372)] = 136;
      _nw40[(int)(373)] = 241;
      _nw40[(int)(374)] = 136;
      _nw40[(int)(375)] = 156;
      _nw40[(int)(376)] = 210;
      _nw40[(int)(377)] = 108;
      _nw40[(int)(378)] = 166;
      _nw40[(int)(379)] = 202;
      _nw40[(int)(380)] = 172;
      _nw40[(int)(381)] = 112;
      _nw40[(int)(382)] = 51;
      _nw40[(int)(383)] = 87;
      _nw40[(int)(384)] = 249;
      _nw40[(int)(385)] = 137;
      _nw40[(int)(386)] = 188;
      _nw40[(int)(387)] = 79;
      _nw40[(int)(388)] = 91;
      _nw40[(int)(389)] = 72;
      _nw40[(int)(390)] = 59;
      _nw40[(int)(391)] = 83;
      _nw40[(int)(392)] = 142;
      _nw40[(int)(393)] = 174;
      _nw40[(int)(394)] = 82;
      _nw40[(int)(395)] = 191;
      _nw40[(int)(396)] = 136;
      _nw40[(int)(397)] = 136;
      _nw40[(int)(398)] = 220;
      _nw40[(int)(399)] = 225;
      _nw40[(int)(400)] = 196;
      _nw40[(int)(401)] = 19;
      _nw40[(int)(402)] = 181;
      _nw40[(int)(403)] = 156;
      _nw40[(int)(404)] = 36;
      _nw40[(int)(405)] = 162;
      _nw40[(int)(406)] = 139;
      _nw40[(int)(407)] = 193;
      _nw40[(int)(408)] = 252;
      _nw40[(int)(409)] = 133;
      _nw40[(int)(410)] = 57;
      _nw40[(int)(411)] = 121;
      _nw40[(int)(412)] = 219;
      _nw40[(int)(413)] = 84;
      _nw40[(int)(414)] = 221;
      _nw40[(int)(415)] = 138;
      _nw40[(int)(416)] = 192;
      _nw40[(int)(417)] = 207;
      _nw40[(int)(418)] = 174;
      _nw40[(int)(419)] = 114;
      _nw40[(int)(420)] = 157;
      _nw40[(int)(421)] = 155;
      _nw40[(int)(422)] = 211;
      _nw40[(int)(423)] = 168;
      _nw40[(int)(424)] = 233;
      _nw40[(int)(425)] = 161;
      _nw40[(int)(426)] = 192;
      _nw40[(int)(427)] = 111;
      _nw40[(int)(428)] = 7;
      _nw40[(int)(429)] = 246;
      _nw40[(int)(430)] = 241;
      _nw40[(int)(431)] = 194;
      _nw40[(int)(432)] = 185;
      _nw40[(int)(433)] = 215;
      _nw40[(int)(434)] = 122;
      _nw40[(int)(435)] = 109;
      _nw40[(int)(436)] = 15;
      _nw40[(int)(437)] = 33;
      _nw40[(int)(438)] = 43;
      _nw40[(int)(439)] = 36;
      _nw40[(int)(440)] = 164;
      _nw40[(int)(441)] = 60;
      _nw40[(int)(442)] = 200;
      _nw40[(int)(443)] = 16;
      _nw40[(int)(444)] = 153;
      _nw40[(int)(445)] = 192;
      _nw40[(int)(446)] = 192;
      _nw40[(int)(447)] = 101;
      _nw40[(int)(448)] = 143;
      _nw40[(int)(449)] = 158;
      _nw40[(int)(450)] = 36;
      _nw40[(int)(451)] = 103;
      _nw40[(int)(452)] = 167;
      _nw40[(int)(453)] = 14;
      _nw40[(int)(454)] = 70;
      _nw40[(int)(455)] = 61;
      _nw40[(int)(456)] = 158;
      _nw40[(int)(457)] = 247;
      _nw40[(int)(458)] = 108;
      _nw40[(int)(459)] = 239;
      _nw40[(int)(460)] = 14;
      _nw40[(int)(461)] = 107;
      _nw40[(int)(462)] = 242;
      _nw40[(int)(463)] = 202;
      _nw40[(int)(464)] = 227;
      _nw40[(int)(465)] = 215;
      _nw40[(int)(466)] = 132;
      _nw40[(int)(467)] = 113;
      _nw40[(int)(468)] = 84;
      _nw40[(int)(469)] = 115;
      _nw40[(int)(470)] = 219;
      _nw40[(int)(471)] = 65;
      _nw40[(int)(472)] = 39;
      _nw40[(int)(473)] = 98;
      _nw40[(int)(474)] = 209;
      _nw40[(int)(475)] = 9;
      _nw40[(int)(476)] = 135;
      _nw40[(int)(477)] = 36;
      _nw40[(int)(478)] = 133;
      _nw40[(int)(479)] = 249;
      _nw40[(int)(480)] = 155;
      _nw40[(int)(481)] = 44;
      _nw40[(int)(482)] = 144;
      _nw40[(int)(483)] = 20;
      _nw40[(int)(484)] = 97;
      _nw40[(int)(485)] = 14;
      _nw40[(int)(486)] = 214;
      _nw40[(int)(487)] = 18;
      _nw40[(int)(488)] = 230;
      _nw40[(int)(489)] = 95;
      _nw40[(int)(490)] = 15;
      _nw40[(int)(491)] = 21;
      _nw40[(int)(492)] = 99;
      _nw40[(int)(493)] = 94;
      _nw40[(int)(494)] = 0;
      _nw40[(int)(495)] = 11;
      _nw40[(int)(496)] = 62;
      _nw40[(int)(497)] = 21;
      _nw40[(int)(498)] = 61;
      _nw40[(int)(499)] = 136;
      _nw40[(int)(500)] = 0;
      _nw40[(int)(501)] = 186;
      _nw40[(int)(502)] = 9;
      _nw40[(int)(503)] = 39;
      _nw40[(int)(504)] = 49;
      _nw40[(int)(505)] = 155;
      _nw40[(int)(506)] = 149;
      _nw40[(int)(507)] = 71;
      _nw40[(int)(508)] = 61;
      _nw40[(int)(509)] = 46;
      _nw40[(int)(510)] = 223;
      _nw40[(int)(511)] = 150;
      _nw40[(int)(512)] = 199;
      _nw40[(int)(513)] = 57;
      _nw40[(int)(514)] = 58;
      _nw40[(int)(515)] = 97;
      _nw40[(int)(516)] = 162;
      _nw40[(int)(517)] = 166;
      _nw40[(int)(518)] = 183;
      _nw40[(int)(519)] = 124;
      _nw40[(int)(520)] = 217;
      _nw40[(int)(521)] = 53;
      _nw40[(int)(522)] = 28;
      _nw40[(int)(523)] = 111;
      _nw40[(int)(524)] = 128;
      _nw40[(int)(525)] = 77;
      _nw40[(int)(526)] = 137;
      _nw40[(int)(527)] = 141;
      _nw40[(int)(528)] = 232;
      _nw40[(int)(529)] = 98;
      _nw40[(int)(530)] = 251;
      _nw40[(int)(531)] = 94;
      _nw40[(int)(532)] = 155;
      _nw40[(int)(533)] = 48;
      _nw40[(int)(534)] = 31;
      _nw40[(int)(535)] = 243;
      _nw40[(int)(536)] = 99;
      _nw40[(int)(537)] = 245;
      _nw40[(int)(538)] = 161;
      _nw40[(int)(539)] = 143;
      _nw40[(int)(540)] = 142;
      _nw40[(int)(541)] = 162;
      _nw40[(int)(542)] = 234;
      _nw40[(int)(543)] = 35;
      _nw40[(int)(544)] = 31;
      _nw40[(int)(545)] = 244;
      _nw40[(int)(546)] = 132;
      _nw40[(int)(547)] = 119;
      _nw40[(int)(548)] = 49;
      _nw40[(int)(549)] = 20;
      _nw40[(int)(550)] = 215;
      _nw40[(int)(551)] = 56;
      _nw40[(int)(552)] = 202;
      _nw40[(int)(553)] = 171;
      _nw40[(int)(554)] = 183;
      _nw40[(int)(555)] = 125;
      _nw40[(int)(556)] = 230;
      _nw40[(int)(557)] = 11;
      _nw40[(int)(558)] = 56;
      _nw40[(int)(559)] = 34;
      _nw40[(int)(560)] = 188;
      _nw40[(int)(561)] = 136;
      _nw40[(int)(562)] = 185;
      _nw40[(int)(563)] = 143;
      _nw40[(int)(564)] = 49;
      _nw40[(int)(565)] = 223;
      _nw40[(int)(566)] = 164;
      _nw40[(int)(567)] = 229;
      _nw40[(int)(568)] = 203;
      _nw40[(int)(569)] = 154;
      _nw40[(int)(570)] = 177;
      _nw40[(int)(571)] = 235;
      _nw40[(int)(572)] = 9;
      _nw40[(int)(573)] = 180;
      _nw40[(int)(574)] = 209;
      _nw40[(int)(575)] = 212;
      _nw40[(int)(576)] = 250;
      _nw40[(int)(577)] = 238;
      _nw40[(int)(578)] = 99;
      _nw40[(int)(579)] = 63;
      _nw40[(int)(580)] = 187;
      _nw40[(int)(581)] = 87;
      _nw40[(int)(582)] = 77;
      _nw40[(int)(583)] = 58;
      _nw40[(int)(584)] = 178;
      _nw40[(int)(585)] = 253;
      _nw40[(int)(586)] = 184;
      _nw40[(int)(587)] = 161;
      _nw40[(int)(588)] = 161;
      _nw40[(int)(589)] = 91;
      _nw40[(int)(590)] = 1;
      _nw40[(int)(591)] = 55;
      _nw40[(int)(592)] = 115;
      _nw40[(int)(593)] = 181;
      _nw40[(int)(594)] = 3;
      _nw40[(int)(595)] = 199;
      _nw40[(int)(596)] = 250;
      _nw40[(int)(597)] = 153;
      _nw40[(int)(598)] = 157;
      _nw40[(int)(599)] = 237;
      _nw40[(int)(600)] = 115;
      _nw40[(int)(601)] = 129;
      _nw40[(int)(602)] = 140;
      _nw40[(int)(603)] = 114;
      _nw40[(int)(604)] = 180;
      _nw40[(int)(605)] = 103;
      _nw40[(int)(606)] = 51;
      _nw40[(int)(607)] = 189;
      _nw40[(int)(608)] = 163;
      _nw40[(int)(609)] = 117;
      _nw40[(int)(610)] = 157;
      _nw40[(int)(611)] = 213;
      _nw40[(int)(612)] = 184;
      _nw40[(int)(613)] = 112;
      _nw40[(int)(614)] = 209;
      _nw40[(int)(615)] = 197;
      _nw40[(int)(616)] = 219;
      _nw40[(int)(617)] = 110;
      _nw40[(int)(618)] = 115;
      _nw40[(int)(619)] = 209;
      _nw40[(int)(620)] = 18;
      _nw40[(int)(621)] = 232;
      _nw40[(int)(622)] = 84;
      _nw40[(int)(623)] = 137;
      _nw40[(int)(624)] = 206;
      _nw40[(int)(625)] = 135;
      _nw40[(int)(626)] = 107;
      _nw40[(int)(627)] = 179;
      _nw40[(int)(628)] = 163;
      _nw40[(int)(629)] = 225;
      _nw40[(int)(630)] = 20;
      _nw40[(int)(631)] = 167;
      _nw40[(int)(632)] = 204;
      _nw40[(int)(633)] = 7;
      _nw40[(int)(634)] = 249;
      _nw40[(int)(635)] = 212;
      _nw40[(int)(636)] = 154;
      _nw40[(int)(637)] = 181;
      _nw40[(int)(638)] = 227;
      _nw40[(int)(639)] = 51;
      _nw40[(int)(640)] = 32;
      _nw40[(int)(641)] = 181;
      _nw40[(int)(642)] = 170;
      _nw40[(int)(643)] = 69;
      _nw40[(int)(644)] = 137;
      _nw40[(int)(645)] = 160;
      _nw40[(int)(646)] = 191;
      _nw40[(int)(647)] = 95;
      _nw40[(int)(648)] = 116;
      _nw40[(int)(649)] = 50;
      _nw40[(int)(650)] = 2;
      _nw40[(int)(651)] = 37;
      _nw40[(int)(652)] = 144;
      _nw40[(int)(653)] = 160;
      _nw40[(int)(654)] = 38;
      _nw40[(int)(655)] = 25;
      _nw40[(int)(656)] = 206;
      _nw40[(int)(657)] = 172;
      _nw40[(int)(658)] = 238;
      _nw40[(int)(659)] = 151;
      _nw40[(int)(660)] = 85;
      _nw40[(int)(661)] = 102;
      _nw40[(int)(662)] = 121;
      _nw40[(int)(663)] = 250;
      _nw40[(int)(664)] = 211;
      _nw40[(int)(665)] = 201;
      _nw40[(int)(666)] = 252;
      _nw40[(int)(667)] = 220;
      _nw40[(int)(668)] = 201;
      _nw40[(int)(669)] = 151;
      _nw40[(int)(670)] = 68;
      _nw40[(int)(671)] = 221;
      _nw40[(int)(672)] = 11;
      _nw40[(int)(673)] = 182;
      _nw40[(int)(674)] = 130;
      _nw40[(int)(675)] = 43;
      _nw40[(int)(676)] = 191;
      _nw40[(int)(677)] = 131;
      _nw40[(int)(678)] = 124;
      _nw40[(int)(679)] = 182;
      _nw40[(int)(680)] = 138;
      _nw40[(int)(681)] = 11;
      _nw40[(int)(682)] = 227;
      _nw40[(int)(683)] = 47;
      _nw40[(int)(684)] = 66;
      _nw40[(int)(685)] = 7;
      _nw40[(int)(686)] = 189;
      _nw40[(int)(687)] = 240;
      _nw40[(int)(688)] = 151;
      _nw40[(int)(689)] = 101;
      _nw40[(int)(690)] = 22;
      _nw40[(int)(691)] = 218;
      _nw40[(int)(692)] = 70;
      _nw40[(int)(693)] = 88;
      _nw40[(int)(694)] = 39;
      _nw40[(int)(695)] = 63;
      _nw40[(int)(696)] = 115;
      _nw40[(int)(697)] = 194;
      _nw40[(int)(698)] = 93;
      _nw40[(int)(699)] = 61;
      _nw40[(int)(700)] = 66;
      _nw40[(int)(701)] = 14;
      _nw40[(int)(702)] = 126;
      _nw40[(int)(703)] = 114;
      _nw40[(int)(704)] = 142;
      _nw40[(int)(705)] = 142;
      _nw40[(int)(706)] = 164;
      _nw40[(int)(707)] = 133;
      _nw40[(int)(708)] = 22;
      _nw40[(int)(709)] = 2;
      _nw40[(int)(710)] = 128;
      _nw40[(int)(711)] = 230;
      _nw40[(int)(712)] = 81;
      _nw40[(int)(713)] = 1;
      _nw40[(int)(714)] = 228;
      _nw40[(int)(715)] = 21;
      _nw40[(int)(716)] = 18;
      _nw40[(int)(717)] = 76;
      _nw40[(int)(718)] = 249;
      _nw40[(int)(719)] = 211;
      _nw40[(int)(720)] = 133;
      _nw40[(int)(721)] = 47;
      _nw40[(int)(722)] = 158;
      _nw40[(int)(723)] = 108;
      _nw40[(int)(724)] = 34;
      _nw40[(int)(725)] = 166;
      _nw40[(int)(726)] = 218;
      _nw40[(int)(727)] = 138;
      _nw40[(int)(728)] = 91;
      _nw40[(int)(729)] = 48;
      _nw40[(int)(730)] = 251;
      _nw40[(int)(731)] = 193;
      _nw40[(int)(732)] = 222;
      _nw40[(int)(733)] = 98;
      _nw40[(int)(734)] = 90;
      _nw40[(int)(735)] = 162;
      _nw40[(int)(736)] = 82;
      _nw40[(int)(737)] = 198;
      _nw40[(int)(738)] = 180;
      _nw40[(int)(739)] = 7;
      _nw40[(int)(740)] = 135;
      _nw40[(int)(741)] = 9;
      _nw40[(int)(742)] = 102;
      _nw40[(int)(743)] = 154;
      _nw40[(int)(744)] = 20;
      _nw40[(int)(745)] = 118;
      _nw40[(int)(746)] = 246;
      _nw40[(int)(747)] = 85;
      _nw40[(int)(748)] = 1;
      _nw40[(int)(749)] = 172;
      _nw40[(int)(750)] = 216;
      _nw40[(int)(751)] = 97;
      _nw40[(int)(752)] = 255;
      _nw40[(int)(753)] = 186;
      _nw40[(int)(754)] = 108;
      _nw40[(int)(755)] = 208;
      _nw40[(int)(756)] = 195;
      _nw40[(int)(757)] = 158;
      _nw40[(int)(758)] = 6;
      _nw40[(int)(759)] = 77;
      _nw40[(int)(760)] = 233;
      _nw40[(int)(761)] = 221;
      _nw40[(int)(762)] = 203;
      _nw40[(int)(763)] = 242;
      _nw40[(int)(764)] = 82;
      _nw40[(int)(765)] = 156;
      _nw40[(int)(766)] = 176;
      _nw40[(int)(767)] = 66;
      _nw40[(int)(768)] = 129;
      _nw40[(int)(769)] = 211;
      _nw40[(int)(770)] = 34;
      _nw40[(int)(771)] = 218;
      _nw40[(int)(772)] = 220;
      _nw40[(int)(773)] = 166;
      _nw40[(int)(774)] = 181;
      _nw40[(int)(775)] = 122;
      _nw40[(int)(776)] = 101;
      _nw40[(int)(777)] = 191;
      _nw40[(int)(778)] = 169;
      _nw40[(int)(779)] = 212;
      _nw40[(int)(780)] = 62;
      _nw40[(int)(781)] = 127;
      _nw40[(int)(782)] = 126;
      _nw40[(int)(783)] = 132;
      _nw40[(int)(784)] = 111;
      _nw40[(int)(785)] = 111;
      _nw40[(int)(786)] = 226;
      _nw40[(int)(787)] = 3;
      _nw40[(int)(788)] = 147;
      _nw40[(int)(789)] = 235;
      _nw40[(int)(790)] = 216;
      _nw40[(int)(791)] = 61;
      _nw40[(int)(792)] = 152;
      _nw40[(int)(793)] = 119;
      _nw40[(int)(794)] = 255;
      _nw40[(int)(795)] = 34;
      _nw40[(int)(796)] = 116;
      _nw40[(int)(797)] = 176;
      _nw40[(int)(798)] = 247;
      _nw40[(int)(799)] = 117;
      _nw40[(int)(800)] = 49;
      _nw40[(int)(801)] = 19;
      _nw40[(int)(802)] = 33;
      _nw40[(int)(803)] = 92;
      _nw40[(int)(804)] = 245;
      _nw40[(int)(805)] = 180;
      _nw40[(int)(806)] = 74;
      _nw40[(int)(807)] = 230;
      _nw40[(int)(808)] = 170;
      _nw40[(int)(809)] = 150;
      _nw40[(int)(810)] = 31;
      _nw40[(int)(811)] = 148;
      _nw40[(int)(812)] = 25;
      _nw40[(int)(813)] = 108;
      _nw40[(int)(814)] = 77;
      _nw40[(int)(815)] = 125;
      _nw40[(int)(816)] = 68;
      _nw40[(int)(817)] = 107;
      _nw40[(int)(818)] = 25;
      _nw40[(int)(819)] = 146;
      _nw40[(int)(820)] = 49;
      _nw40[(int)(821)] = 207;
      _nw40[(int)(822)] = 109;
      _nw40[(int)(823)] = 159;
      _nw40[(int)(824)] = 163;
      _nw40[(int)(825)] = 168;
      _nw40[(int)(826)] = 29;
      _nw40[(int)(827)] = 39;
      _nw40[(int)(828)] = 220;
      _nw40[(int)(829)] = 213;
      _nw40[(int)(830)] = 59;
      _nw40[(int)(831)] = 23;
      _nw40[(int)(832)] = 1;
      _nw40[(int)(833)] = 123;
      _nw40[(int)(834)] = 249;
      _nw40[(int)(835)] = 79;
      _nw40[(int)(836)] = 187;
      _nw40[(int)(837)] = 190;
      _nw40[(int)(838)] = 180;
      _nw40[(int)(839)] = 179;
      _nw40[(int)(840)] = 53;
      _nw40[(int)(841)] = 60;
      _nw40[(int)(842)] = 142;
      _nw40[(int)(843)] = 251;
      _nw40[(int)(844)] = 103;
      _nw40[(int)(845)] = 92;
      _nw40[(int)(846)] = 57;
      _nw40[(int)(847)] = 48;
      _nw40[(int)(848)] = 110;
      _nw40[(int)(849)] = 221;
      _nw40[(int)(850)] = 143;
      _nw40[(int)(851)] = 205;
      _nw40[(int)(852)] = 126;
      _nw40[(int)(853)] = 2;
      _nw40[(int)(854)] = 192;
      _nw40[(int)(855)] = 163;
      _nw40[(int)(856)] = 210;
      _nw40[(int)(857)] = 79;
      _nw40[(int)(858)] = 121;
      _nw40[(int)(859)] = 82;
      _nw40[(int)(860)] = 175;
      _nw40[(int)(861)] = 187;
      _nw40[(int)(862)] = 63;
      _nw40[(int)(863)] = 56;
      _nw40[(int)(864)] = 6;
      _nw40[(int)(865)] = 201;
      _nw40[(int)(866)] = 42;
      _nw40[(int)(867)] = 240;
      _nw40[(int)(868)] = 26;
      _nw40[(int)(869)] = 194;
      _nw40[(int)(870)] = 163;
      _nw40[(int)(871)] = 183;
      _nw40[(int)(872)] = 133;
      _nw40[(int)(873)] = 88;
      _nw40[(int)(874)] = 38;
      _nw40[(int)(875)] = 151;
      _nw40[(int)(876)] = 246;
      _nw40[(int)(877)] = 100;
      _nw40[(int)(878)] = 194;
      _nw40[(int)(879)] = 212;
      _nw40[(int)(880)] = 222;
      _nw40[(int)(881)] = 18;
      _nw40[(int)(882)] = 7;
      _nw40[(int)(883)] = 168;
      _nw40[(int)(884)] = 1;
      _nw40[(int)(885)] = 155;
      _nw40[(int)(886)] = 73;
      _nw40[(int)(887)] = 59;
      _nw40[(int)(888)] = 155;
      _nw40[(int)(889)] = 255;
      _nw40[(int)(890)] = 10;
      _nw40[(int)(891)] = 211;
      _nw40[(int)(892)] = 102;
      _nw40[(int)(893)] = 116;
      _nw40[(int)(894)] = 200;
      _nw40[(int)(895)] = 89;
      _nw40[(int)(896)] = 247;
      _nw40[(int)(897)] = 127;
      _nw40[(int)(898)] = 230;
      _nw40[(int)(899)] = 59;
      _nw40[(int)(900)] = 202;
      _nw40[(int)(901)] = 238;
      _nw40[(int)(902)] = 243;
      _nw40[(int)(903)] = 179;
      _nw40[(int)(904)] = 135;
      _nw40[(int)(905)] = 230;
      _nw40[(int)(906)] = 245;
      _nw40[(int)(907)] = 66;
      _nw40[(int)(908)] = 8;
      _nw40[(int)(909)] = 136;
      _nw40[(int)(910)] = 200;
      _nw40[(int)(911)] = 53;
      _nw40[(int)(912)] = 3;
      _nw40[(int)(913)] = 249;
      _nw40[(int)(914)] = 103;
      _nw40[(int)(915)] = 7;
      _nw40[(int)(916)] = 212;
      _nw40[(int)(917)] = 65;
      _nw40[(int)(918)] = 95;
      _nw40[(int)(919)] = 171;
      _nw40[(int)(920)] = 118;
      _nw40[(int)(921)] = 51;
      _nw40[(int)(922)] = 81;
      _nw40[(int)(923)] = 90;
      _nw40[(int)(924)] = 231;
      _nw40[(int)(925)] = 91;
      _nw40[(int)(926)] = 189;
      _nw40[(int)(927)] = 60;
      _nw40[(int)(928)] = 55;
      _nw40[(int)(929)] = 113;
      _nw40[(int)(930)] = 119;
      _nw40[(int)(931)] = 6;
      _nw40[(int)(932)] = 159;
      _nw40[(int)(933)] = 59;
      _nw40[(int)(934)] = 142;
      _nw40[(int)(935)] = 108;
      _nw40[(int)(936)] = 227;
      _nw40[(int)(937)] = 192;
      _nw40[(int)(938)] = 208;
      _nw40[(int)(939)] = 122;
      _nw40[(int)(940)] = 251;
      _nw40[(int)(941)] = 73;
      _nw40[(int)(942)] = 199;
      _nw40[(int)(943)] = 107;
      _nw40[(int)(944)] = 194;
      _nw40[(int)(945)] = 202;
      _nw40[(int)(946)] = 17;
      _nw40[(int)(947)] = 94;
      _nw40[(int)(948)] = 84;
      _nw40[(int)(949)] = 155;
      _nw40[(int)(950)] = 20;
      _nw40[(int)(951)] = 13;
      _nw40[(int)(952)] = 223;
      _nw40[(int)(953)] = 43;
      _nw40[(int)(954)] = 163;
      _nw40[(int)(955)] = 75;
      _nw40[(int)(956)] = 193;
      _nw40[(int)(957)] = 247;
      _nw40[(int)(958)] = 4;
      _nw40[(int)(959)] = 109;
      _nw40[(int)(960)] = 171;
      _nw40[(int)(961)] = 46;
      _nw40[(int)(962)] = 170;
      _nw40[(int)(963)] = 86;
      _nw40[(int)(964)] = 1;
      _nw40[(int)(965)] = 166;
      _nw40[(int)(966)] = 211;
      _nw40[(int)(967)] = 203;
      _nw40[(int)(968)] = 22;
      _nw40[(int)(969)] = 158;
      _nw40[(int)(970)] = 33;
      _nw40[(int)(971)] = 170;
      _nw40[(int)(972)] = 161;
      _nw40[(int)(973)] = 171;
      _nw40[(int)(974)] = 69;
      _nw40[(int)(975)] = 149;
      _nw40[(int)(976)] = 149;
      _nw40[(int)(977)] = 145;
      _nw40[(int)(978)] = 154;
      _nw40[(int)(979)] = 9;
      _nw40[(int)(980)] = 38;
      _nw40[(int)(981)] = 31;
      _nw40[(int)(982)] = 132;
      _nw40[(int)(983)] = 171;
      _nw40[(int)(984)] = 211;
      _nw40[(int)(985)] = 170;
      _nw40[(int)(986)] = 105;
      _nw40[(int)(987)] = 153;
      _nw40[(int)(988)] = 209;
      _nw40[(int)(989)] = 96;
      _nw40[(int)(990)] = 135;
      _nw40[(int)(991)] = 243;
      _nw40[(int)(992)] = 54;
      _nw40[(int)(993)] = 18;
      _nw40[(int)(994)] = 145;
      _nw40[(int)(995)] = 127;
      _nw40[(int)(996)] = 73;
      _nw40[(int)(997)] = 102;
      _nw40[(int)(998)] = 230;
      _nw40[(int)(999)] = 74;
      _nw40[(int)(1000)] = 53;
      _nw40[(int)(1001)] = 187;
      _nw40[(int)(1002)] = 227;
      _nw40[(int)(1003)] = 65;
      _nw40[(int)(1004)] = 149;
      _nw40[(int)(1005)] = 81;
      _nw40[(int)(1006)] = 31;
      _nw40[(int)(1007)] = 110;
      _nw40[(int)(1008)] = 43;
      _nw40[(int)(1009)] = 74;
      _nw40[(int)(1010)] = 73;
      _nw40[(int)(1011)] = 97;
      _nw40[(int)(1012)] = 22;
      _nw40[(int)(1013)] = 231;
      _nw40[(int)(1014)] = 119;
      _nw40[(int)(1015)] = 212;
      _nw40[(int)(1016)] = 154;
      _nw40[(int)(1017)] = 64;
      _nw40[(int)(1018)] = 247;
      _nw40[(int)(1019)] = 221;
      _nw40[(int)(1020)] = 255;
      _nw40[(int)(1021)] = 219;
      _nw40[(int)(1022)] = 208;
      _nw40[(int)(1023)] = 65;
      _nw40[(int)(1024)] = 79;
      _nw40[(int)(1025)] = 188;
      _nw40[(int)(1026)] = 120;
      _nw40[(int)(1027)] = 186;
      _nw40[(int)(1028)] = 8;
      _nw40[(int)(1029)] = 43;
      _nw40[(int)(1030)] = 82;
      _nw40[(int)(1031)] = 232;
      _nw40[(int)(1032)] = 103;
      _nw40[(int)(1033)] = 117;
      _nw40[(int)(1034)] = 11;
      _nw40[(int)(1035)] = 163;
      _nw40[(int)(1036)] = 137;
      _nw40[(int)(1037)] = 174;
      _nw40[(int)(1038)] = 172;
      _nw40[(int)(1039)] = 124;
      _nw40[(int)(1040)] = 188;
      _nw40[(int)(1041)] = 38;
      _nw40[(int)(1042)] = 104;
      _nw40[(int)(1043)] = 166;
      _nw40[(int)(1044)] = 171;
      _nw40[(int)(1045)] = 146;
      _nw40[(int)(1046)] = 129;
      _nw40[(int)(1047)] = 107;
      _nw40[(int)(1048)] = 212;
      _nw40[(int)(1049)] = 237;
      _nw40[(int)(1050)] = 11;
      _nw40[(int)(1051)] = 113;
      _nw40[(int)(1052)] = 190;
      _nw40[(int)(1053)] = 12;
      _nw40[(int)(1054)] = 66;
      _nw40[(int)(1055)] = 223;
      _nw40[(int)(1056)] = 234;
      _nw40[(int)(1057)] = 97;
      _nw40[(int)(1058)] = 98;
      _nw40[(int)(1059)] = 17;
      _nw40[(int)(1060)] = 32;
      _nw40[(int)(1061)] = 106;
      _nw40[(int)(1062)] = 6;
      _nw40[(int)(1063)] = 228;
      _nw40[(int)(1064)] = 86;
      _nw40[(int)(1065)] = 25;
      _nw40[(int)(1066)] = 164;
      _nw40[(int)(1067)] = 82;
      _nw40[(int)(1068)] = 82;
      _nw40[(int)(1069)] = 67;
      _nw40[(int)(1070)] = 151;
      _nw40[(int)(1071)] = 149;
      _nw40[(int)(1072)] = 65;
      _nw40[(int)(1073)] = 172;
      _nw40[(int)(1074)] = 26;
      _nw40[(int)(1075)] = 144;
      _nw40[(int)(1076)] = 69;
      _nw40[(int)(1077)] = 142;
      _nw40[(int)(1078)] = 214;
      _nw40[(int)(1079)] = 240;
      _nw40[(int)(1080)] = 84;
      _nw40[(int)(1081)] = 144;
      _nw40[(int)(1082)] = 163;
      _nw40[(int)(1083)] = 171;
      _nw40[(int)(1084)] = 234;
      _nw40[(int)(1085)] = 192;
      _nw40[(int)(1086)] = 90;
      _nw40[(int)(1087)] = 248;
      _nw40[(int)(1088)] = 20;
      _nw40[(int)(1089)] = 196;
      _nw40[(int)(1090)] = 139;
      _nw40[(int)(1091)] = 108;
      _nw40[(int)(1092)] = 68;
      _nw40[(int)(1093)] = 246;
      _nw40[(int)(1094)] = 126;
      _nw40[(int)(1095)] = 186;
      _nw40[(int)(1096)] = 88;
      _nw40[(int)(1097)] = 55;
      _nw40[(int)(1098)] = 138;
      _nw40[(int)(1099)] = 248;
      _nw40[(int)(1100)] = 10;
      _nw40[(int)(1101)] = 38;
      _nw40[(int)(1102)] = 73;
      _nw40[(int)(1103)] = 84;
      _nw40[(int)(1104)] = 230;
      _nw40[(int)(1105)] = 144;
      _nw40[(int)(1106)] = 169;
      _nw40[(int)(1107)] = 243;
      _nw40[(int)(1108)] = 106;
      _nw40[(int)(1109)] = 220;
      _nw40[(int)(1110)] = 201;
      _nw40[(int)(1111)] = 67;
      _nw40[(int)(1112)] = 147;
      _nw40[(int)(1113)] = 156;
      _nw40[(int)(1114)] = 252;
      _nw40[(int)(1115)] = 140;
      _nw40[(int)(1116)] = 111;
      _nw40[(int)(1117)] = 127;
      _nw40[(int)(1118)] = 185;
      _nw40[(int)(1119)] = 107;
      _nw40[(int)(1120)] = 9;
      _nw40[(int)(1121)] = 30;
      _nw40[(int)(1122)] = 254;
      _nw40[(int)(1123)] = 186;
      _nw40[(int)(1124)] = 199;
      _nw40[(int)(1125)] = 233;
      _nw40[(int)(1126)] = 202;
      _nw40[(int)(1127)] = 65;
      _nw40[(int)(1128)] = 19;
      _nw40[(int)(1129)] = 187;
      _nw40[(int)(1130)] = 103;
      _nw40[(int)(1131)] = 157;
      _nw40[(int)(1132)] = 118;
      _nw40[(int)(1133)] = 224;
      _nw40[(int)(1134)] = 147;
      _nw40[(int)(1135)] = 206;
      _nw40[(int)(1136)] = 221;
      _nw40[(int)(1137)] = 216;
      _nw40[(int)(1138)] = 129;
      _nw40[(int)(1139)] = 102;
      _nw40[(int)(1140)] = 199;
      _nw40[(int)(1141)] = 50;
      _nw40[(int)(1142)] = 156;
      _nw40[(int)(1143)] = 28;
      _nw40[(int)(1144)] = 196;
      _nw40[(int)(1145)] = 49;
      _nw40[(int)(1146)] = 89;
      _nw40[(int)(1147)] = 129;
      _nw40[(int)(1148)] = 160;
      _nw40[(int)(1149)] = 199;
      _nw40[(int)(1150)] = 97;
      _nw40[(int)(1151)] = 30;
      _nw40[(int)(1152)] = 93;
      _nw40[(int)(1153)] = 100;
      _nw40[(int)(1154)] = 230;
      _nw40[(int)(1155)] = 20;
      _nw40[(int)(1156)] = 129;
      _nw40[(int)(1157)] = 215;
      _nw40[(int)(1158)] = 66;
      _nw40[(int)(1159)] = 136;
      _nw40[(int)(1160)] = 58;
      _nw40[(int)(1161)] = 192;
      _nw40[(int)(1162)] = 17;
      _nw40[(int)(1163)] = 199;
      _nw40[(int)(1164)] = 168;
      _nw40[(int)(1165)] = 169;
      _nw40[(int)(1166)] = 154;
      _nw40[(int)(1167)] = 217;
      _nw40[(int)(1168)] = 63;
      _nw40[(int)(1169)] = 33;
      _nw40[(int)(1170)] = 65;
      _nw40[(int)(1171)] = 220;
      _nw40[(int)(1172)] = 43;
      _nw40[(int)(1173)] = 69;
      _nw40[(int)(1174)] = 10;
      _nw40[(int)(1175)] = 246;
      _nw40[(int)(1176)] = 162;
      _nw40[(int)(1177)] = 183;
      _nw40[(int)(1178)] = 182;
      _nw40[(int)(1179)] = 5;
      _nw40[(int)(1180)] = 82;
      _nw40[(int)(1181)] = 97;
      _nw40[(int)(1182)] = 123;
      _nw40[(int)(1183)] = 134;
      _nw40[(int)(1184)] = 208;
      _nw40[(int)(1185)] = 8;
      _nw40[(int)(1186)] = 115;
      _nw40[(int)(1187)] = 104;
      _nw40[(int)(1188)] = 109;
      _nw40[(int)(1189)] = 24;
      _nw40[(int)(1190)] = 217;
      _nw40[(int)(1191)] = 242;
      _nw40[(int)(1192)] = 129;
      _nw40[(int)(1193)] = 125;
      _nw40[(int)(1194)] = 18;
      _nw40[(int)(1195)] = 8;
      _nw40[(int)(1196)] = 116;
      _nw40[(int)(1197)] = 77;
      _nw40[(int)(1198)] = 45;
      _nw40[(int)(1199)] = 154;
      _nw40[(int)(1200)] = 245;
      _nw40[(int)(1201)] = 201;
      _nw40[(int)(1202)] = 77;
      _nw40[(int)(1203)] = 71;
      _nw40[(int)(1204)] = 181;
      _nw40[(int)(1205)] = 72;
      _nw40[(int)(1206)] = 79;
      _nw40[(int)(1207)] = 20;
      _nw40[(int)(1208)] = 77;
      _nw40[(int)(1209)] = 178;
      _nw40[(int)(1210)] = 134;
      _nw40[(int)(1211)] = 186;
      _nw40[(int)(1212)] = 159;
      _nw40[(int)(1213)] = 167;
      _nw40[(int)(1214)] = 237;
      _nw40[(int)(1215)] = 32;
      _nw40[(int)(1216)] = 50;
      _nw40[(int)(1217)] = 124;
      _nw40[(int)(1218)] = 205;
      _nw40[(int)(1219)] = 236;
      _nw40[(int)(1220)] = 112;
      _nw40[(int)(1221)] = 92;
      _nw40[(int)(1222)] = 244;
      _nw40[(int)(1223)] = 164;
      _nw40[(int)(1224)] = 239;
      _nw40[(int)(1225)] = 31;
      _nw40[(int)(1226)] = 109;
      _nw40[(int)(1227)] = 33;
      _nw40[(int)(1228)] = 223;
      _nw40[(int)(1229)] = 93;
      _nw40[(int)(1230)] = 22;
      _nw40[(int)(1231)] = 222;
      _nw40[(int)(1232)] = 166;
      _nw40[(int)(1233)] = 62;
      _nw40[(int)(1234)] = 30;
      _nw40[(int)(1235)] = 214;
      _nw40[(int)(1236)] = 132;
      _nw40[(int)(1237)] = 206;
      _nw40[(int)(1238)] = 151;
      _nw40[(int)(1239)] = 53;
      _nw40[(int)(1240)] = 178;
      _nw40[(int)(1241)] = 250;
      _nw40[(int)(1242)] = 208;
      _nw40[(int)(1243)] = 52;
      _nw40[(int)(1244)] = 66;
      _nw40[(int)(1245)] = 153;
      _nw40[(int)(1246)] = 248;
      _nw40[(int)(1247)] = 63;
      _nw40[(int)(1248)] = 2;
      _nw40[(int)(1249)] = 12;
      _nw40[(int)(1250)] = 178;
      _nw40[(int)(1251)] = 117;
      _nw40[(int)(1252)] = 241;
      _nw40[(int)(1253)] = 24;
      _nw40[(int)(1254)] = 113;
      _nw40[(int)(1255)] = 47;
      _nw40[(int)(1256)] = 34;
      _nw40[(int)(1257)] = 235;
      _nw40[(int)(1258)] = 149;
      _nw40[(int)(1259)] = 40;
      _nw40[(int)(1260)] = 66;
      _nw40[(int)(1261)] = 229;
      _nw40[(int)(1262)] = 127;
      _nw40[(int)(1263)] = 204;
      _nw40[(int)(1264)] = 29;
      _nw40[(int)(1265)] = 163;
      _nw40[(int)(1266)] = 90;
      _nw40[(int)(1267)] = 35;
      _nw40[(int)(1268)] = 151;
      _nw40[(int)(1269)] = 244;
      _nw40[(int)(1270)] = 28;
      _nw40[(int)(1271)] = 249;
      _nw40[(int)(1272)] = 70;
      _nw40[(int)(1273)] = 91;
      _nw40[(int)(1274)] = 74;
      _nw40[(int)(1275)] = 205;
      _nw40[(int)(1276)] = 46;
      _nw40[(int)(1277)] = 235;
      _nw40[(int)(1278)] = 100;
      _nw40[(int)(1279)] = 194;
      _nw40[(int)(1280)] = 188;
      _nw40[(int)(1281)] = 97;
      _nw40[(int)(1282)] = 51;
      _nw40[(int)(1283)] = 164;
      _nw40[(int)(1284)] = 241;
      _nw40[(int)(1285)] = 35;
      _nw40[(int)(1286)] = 176;
      _nw40[(int)(1287)] = 8;
      _nw40[(int)(1288)] = 91;
      _nw40[(int)(1289)] = 67;
      _nw40[(int)(1290)] = 204;
      _nw40[(int)(1291)] = 51;
      _nw40[(int)(1292)] = 133;
      _nw40[(int)(1293)] = 157;
      _nw40[(int)(1294)] = 28;
      _nw40[(int)(1295)] = 237;
      _nw40[(int)(1296)] = 234;
      _nw40[(int)(1297)] = 135;
      _nw40[(int)(1298)] = 140;
      _nw40[(int)(1299)] = 68;
      _nw40[(int)(1300)] = 248;
      _nw40[(int)(1301)] = 195;
      _nw40[(int)(1302)] = 168;
      _nw40[(int)(1303)] = 48;
      _nw40[(int)(1304)] = 152;
      _nw40[(int)(1305)] = 86;
      _nw40[(int)(1306)] = 41;
      _nw40[(int)(1307)] = 176;
      _nw40[(int)(1308)] = 53;
      _nw40[(int)(1309)] = 39;
      _nw40[(int)(1310)] = 199;
      _nw40[(int)(1311)] = 99;
      _nw40[(int)(1312)] = 122;
      _nw40[(int)(1313)] = 86;
      _nw40[(int)(1314)] = 70;
      _nw40[(int)(1315)] = 225;
      _nw40[(int)(1316)] = 87;
      _nw40[(int)(1317)] = 225;
      _nw40[(int)(1318)] = 139;
      _nw40[(int)(1319)] = 57;
      _nw40[(int)(1320)] = 93;
      _nw40[(int)(1321)] = 93;
      _nw40[(int)(1322)] = 161;
      _nw40[(int)(1323)] = 228;
      _nw40[(int)(1324)] = 186;
      _nw40[(int)(1325)] = 192;
      _nw40[(int)(1326)] = 84;
      _nw40[(int)(1327)] = 229;
      _nw40[(int)(1328)] = 185;
      _nw40[(int)(1329)] = 3;
      _nw40[(int)(1330)] = 73;
      _nw40[(int)(1331)] = 196;
      _nw40[(int)(1332)] = 133;
      _nw40[(int)(1333)] = 137;
      _nw40[(int)(1334)] = 215;
      _nw40[(int)(1335)] = 192;
      _nw40[(int)(1336)] = 41;
      _nw40[(int)(1337)] = 30;
      _nw40[(int)(1338)] = 84;
      _nw40[(int)(1339)] = 160;
      _nw40[(int)(1340)] = 75;
      _nw40[(int)(1341)] = 206;
      _nw40[(int)(1342)] = 4;
      _nw40[(int)(1343)] = 245;
      _nw40[(int)(1344)] = 53;
      _nw40[(int)(1345)] = 52;
      _nw40[(int)(1346)] = 32;
      _nw40[(int)(1347)] = 182;
      _nw40[(int)(1348)] = 141;
      _nw40[(int)(1349)] = 66;
      _nw40[(int)(1350)] = 50;
      _nw40[(int)(1351)] = 238;
      _nw40[(int)(1352)] = 90;
      _nw40[(int)(1353)] = 81;
      _nw40[(int)(1354)] = 50;
      _nw40[(int)(1355)] = 55;
      _nw40[(int)(1356)] = 132;
      _nw40[(int)(1357)] = 3;
      _nw40[(int)(1358)] = 238;
      _nw40[(int)(1359)] = 68;
      _nw40[(int)(1360)] = 207;
      _nw40[(int)(1361)] = 144;
      _nw40[(int)(1362)] = 15;
      _nw40[(int)(1363)] = 12;
      _nw40[(int)(1364)] = 127;
      _nw40[(int)(1365)] = 195;
      _nw40[(int)(1366)] = 85;
      _nw40[(int)(1367)] = 18;
      _nw40[(int)(1368)] = 67;
      _nw40[(int)(1369)] = 55;
      _nw40[(int)(1370)] = 4;
      _nw40[(int)(1371)] = 249;
      _nw40[(int)(1372)] = 232;
      _nw40[(int)(1373)] = 170;
      _nw40[(int)(1374)] = 189;
      _nw40[(int)(1375)] = 205;
      _nw40[(int)(1376)] = 197;
      _nw40[(int)(1377)] = 169;
      _nw40[(int)(1378)] = 128;
      _nw40[(int)(1379)] = 156;
      _nw40[(int)(1380)] = 103;
      _nw40[(int)(1381)] = 221;
      _nw40[(int)(1382)] = 172;
      _nw40[(int)(1383)] = 213;
      _nw40[(int)(1384)] = 46;
      _nw40[(int)(1385)] = 143;
      _nw40[(int)(1386)] = 218;
      _nw40[(int)(1387)] = 107;
      _nw40[(int)(1388)] = 253;
      _nw40[(int)(1389)] = 77;
      _nw40[(int)(1390)] = 76;
      _nw40[(int)(1391)] = 190;
      _nw40[(int)(1392)] = 63;
      _nw40[(int)(1393)] = 151;
      _nw40[(int)(1394)] = 44;
      _nw40[(int)(1395)] = 57;
      _nw40[(int)(1396)] = 37;
      _nw40[(int)(1397)] = 225;
      _nw40[(int)(1398)] = 135;
      _nw40[(int)(1399)] = 125;
      _nw40[(int)(1400)] = 21;
      _nw40[(int)(1401)] = 217;
      _nw40[(int)(1402)] = 0;
      _nw40[(int)(1403)] = 62;
      _nw40[(int)(1404)] = 83;
      _nw40[(int)(1405)] = 50;
      _nw40[(int)(1406)] = 51;
      _nw40[(int)(1407)] = 2;
      _nw40[(int)(1408)] = 176;
      _nw40[(int)(1409)] = 160;
      _nw40[(int)(1410)] = 161;
      _nw40[(int)(1411)] = 82;
      _nw40[(int)(1412)] = 112;
      _nw40[(int)(1413)] = 198;
      _nw40[(int)(1414)] = 128;
      _nw40[(int)(1415)] = 235;
      _nw40[(int)(1416)] = 40;
      _nw40[(int)(1417)] = 101;
      _nw40[(int)(1418)] = 151;
      _nw40[(int)(1419)] = 189;
      _nw40[(int)(1420)] = 86;
      _nw40[(int)(1421)] = 46;
      _nw40[(int)(1422)] = 206;
      _nw40[(int)(1423)] = 202;
      _nw40[(int)(1424)] = 90;
      _nw40[(int)(1425)] = 229;
      _nw40[(int)(1426)] = 188;
      _nw40[(int)(1427)] = 108;
      _nw40[(int)(1428)] = 235;
      _nw40[(int)(1429)] = 245;
      _nw40[(int)(1430)] = 52;
      _nw40[(int)(1431)] = 22;
      _nw40[(int)(1432)] = 48;
      _nw40[(int)(1433)] = 189;
      _nw40[(int)(1434)] = 88;
      _nw40[(int)(1435)] = 192;
      _nw40[(int)(1436)] = 95;
      _nw40[(int)(1437)] = 153;
      _nw40[(int)(1438)] = 109;
      _nw40[(int)(1439)] = 92;
      _nw40[(int)(1440)] = 74;
      _nw40[(int)(1441)] = 146;
      _nw40[(int)(1442)] = 135;
      _nw40[(int)(1443)] = 44;
      _nw40[(int)(1444)] = 130;
      _nw40[(int)(1445)] = 221;
      _nw40[(int)(1446)] = 91;
      _nw40[(int)(1447)] = 17;
      _nw40[(int)(1448)] = 46;
      _nw40[(int)(1449)] = 49;
      _nw40[(int)(1450)] = 24;
      _nw40[(int)(1451)] = 97;
      _nw40[(int)(1452)] = 221;
      _nw40[(int)(1453)] = 22;
      _nw40[(int)(1454)] = 174;
      _nw40[(int)(1455)] = 32;
      _nw40[(int)(1456)] = 12;
      _nw40[(int)(1457)] = 189;
      _nw40[(int)(1458)] = 52;
      _nw40[(int)(1459)] = 252;
      _nw40[(int)(1460)] = 204;
      _nw40[(int)(1461)] = 133;
      _nw40[(int)(1462)] = 19;
      _nw40[(int)(1463)] = 122;
      _nw40[(int)(1464)] = 242;
      _nw40[(int)(1465)] = 26;
      _nw40[(int)(1466)] = 106;
      _nw40[(int)(1467)] = 233;
      _nw40[(int)(1468)] = 218;
      _nw40[(int)(1469)] = 176;
      _nw40[(int)(1470)] = 88;
      _nw40[(int)(1471)] = 71;
      _nw40[(int)(1472)] = 169;
      _nw40[(int)(1473)] = 76;
      _nw40[(int)(1474)] = 77;
      _nw40[(int)(1475)] = 71;
      _nw40[(int)(1476)] = 32;
      _nw40[(int)(1477)] = 235;
      _nw40[(int)(1478)] = 0;
      _nw40[(int)(1479)] = 204;
      _nw40[(int)(1480)] = 37;
      _nw40[(int)(1481)] = 71;
      _nw40[(int)(1482)] = 18;
      _nw40[(int)(1483)] = 175;
      _nw40[(int)(1484)] = 99;
      _nw40[(int)(1485)] = 202;
      _nw40[(int)(1486)] = 141;
      _nw40[(int)(1487)] = 95;
      _nw40[(int)(1488)] = 73;
      _nw40[(int)(1489)] = 81;
      _nw40[(int)(1490)] = 102;
      _nw40[(int)(1491)] = 224;
      _nw40[(int)(1492)] = 83;
      _nw40[(int)(1493)] = 97;
      _nw40[(int)(1494)] = 121;
      _nw40[(int)(1495)] = 41;
      _nw40[(int)(1496)] = 56;
      _nw40[(int)(1497)] = 4;
      _nw40[(int)(1498)] = 168;
      _nw40[(int)(1499)] = 25;
      _nw40[(int)(1500)] = 161;
      _nw40[(int)(1501)] = 181;
      _nw40[(int)(1502)] = 109;
      _nw40[(int)(1503)] = 109;
      _nw40[(int)(1504)] = 32;
      _nw40[(int)(1505)] = 119;
      _nw40[(int)(1506)] = 50;
      _nw40[(int)(1507)] = 239;
      _nw40[(int)(1508)] = 157;
      _nw40[(int)(1509)] = 76;
      _nw40[(int)(1510)] = 87;
      _nw40[(int)(1511)] = 131;
      _nw40[(int)(1512)] = 49;
      _nw40[(int)(1513)] = 194;
      _nw40[(int)(1514)] = 143;
      _nw40[(int)(1515)] = 60;
      _nw40[(int)(1516)] = 252;
      _nw40[(int)(1517)] = 204;
      _nw40[(int)(1518)] = 151;
      _nw40[(int)(1519)] = 84;
      _nw40[(int)(1520)] = 138;
      _nw40[(int)(1521)] = 227;
      _nw40[(int)(1522)] = 161;
      _nw40[(int)(1523)] = 25;
      _nw40[(int)(1524)] = 224;
      _nw40[(int)(1525)] = 185;
      _nw40[(int)(1526)] = 11;
      _nw40[(int)(1527)] = 244;
      _nw40[(int)(1528)] = 243;
      _nw40[(int)(1529)] = 71;
      _nw40[(int)(1530)] = 100;
      _nw40[(int)(1531)] = 58;
      _nw40[(int)(1532)] = 187;
      _nw40[(int)(1533)] = 100;
      _nw40[(int)(1534)] = 10;
      _nw40[(int)(1535)] = 114;
      _nw40[(int)(1536)] = 9;
      _nw40[(int)(1537)] = 150;
      _nw40[(int)(1538)] = 49;
      _nw40[(int)(1539)] = 55;
      _nw40[(int)(1540)] = 88;
      _nw40[(int)(1541)] = 50;
      _nw40[(int)(1542)] = 236;
      _nw40[(int)(1543)] = 54;
      _nw40[(int)(1544)] = 134;
      _nw40[(int)(1545)] = 117;
      _nw40[(int)(1546)] = 225;
      _nw40[(int)(1547)] = 138;
      _nw40[(int)(1548)] = 112;
      _nw40[(int)(1549)] = 54;
      _nw40[(int)(1550)] = 231;
      _nw40[(int)(1551)] = 10;
      _nw40[(int)(1552)] = 172;
      _nw40[(int)(1553)] = 222;
      _nw40[(int)(1554)] = 40;
      _nw40[(int)(1555)] = 134;
      _nw40[(int)(1556)] = 247;
      _nw40[(int)(1557)] = 223;
      _nw40[(int)(1558)] = 22;
      _nw40[(int)(1559)] = 127;
      _nw40[(int)(1560)] = 174;
      _nw40[(int)(1561)] = 217;
      _nw40[(int)(1562)] = 89;
      _nw40[(int)(1563)] = 228;
      _nw40[(int)(1564)] = 121;
      _nw40[(int)(1565)] = 213;
      _nw40[(int)(1566)] = 171;
      _nw40[(int)(1567)] = 117;
      _nw40[(int)(1568)] = 38;
      _nw40[(int)(1569)] = 115;
      _nw40[(int)(1570)] = 184;
      _nw40[(int)(1571)] = 151;
      _nw40[(int)(1572)] = 65;
      _nw40[(int)(1573)] = 116;
      _nw40[(int)(1574)] = 80;
      _nw40[(int)(1575)] = 180;
      _nw40[(int)(1576)] = 6;
      _nw40[(int)(1577)] = 44;
      _nw40[(int)(1578)] = 68;
      _nw40[(int)(1579)] = 100;
      _nw40[(int)(1580)] = 103;
      _nw40[(int)(1581)] = 62;
      _nw40[(int)(1582)] = 45;
      _nw40[(int)(1583)] = 161;
      _nw40[(int)(1584)] = 105;
      _nw40[(int)(1585)] = 91;
      _nw40[(int)(1586)] = 205;
      _nw40[(int)(1587)] = 163;
      _nw40[(int)(1588)] = 170;
      _nw40[(int)(1589)] = 194;
      _nw40[(int)(1590)] = 69;
      _nw40[(int)(1591)] = 7;
      _nw40[(int)(1592)] = 110;
      _nw40[(int)(1593)] = 85;
      _nw40[(int)(1594)] = 9;
      _nw40[(int)(1595)] = 1;
      _nw40[(int)(1596)] = 75;
      _nw40[(int)(1597)] = 138;
      _nw40[(int)(1598)] = 93;
      _nw40[(int)(1599)] = 63;
      _nw40[(int)(1600)] = 223;
      _nw40[(int)(1601)] = 224;
      _nw40[(int)(1602)] = 35;
      _nw40[(int)(1603)] = 41;
      _nw40[(int)(1604)] = 87;
      _nw40[(int)(1605)] = 86;
      _nw40[(int)(1606)] = 162;
      _nw40[(int)(1607)] = 251;
      _nw40[(int)(1608)] = 222;
      _nw40[(int)(1609)] = 96;
      _nw40[(int)(1610)] = 116;
      _nw40[(int)(1611)] = 144;
      _nw40[(int)(1612)] = 226;
      _nw40[(int)(1613)] = 203;
      _nw40[(int)(1614)] = 220;
      _nw40[(int)(1615)] = 53;
      _nw40[(int)(1616)] = 58;
      _nw40[(int)(1617)] = 173;
      _nw40[(int)(1618)] = 189;
      _nw40[(int)(1619)] = 251;
      _nw40[(int)(1620)] = 66;
      _nw40[(int)(1621)] = 48;
      _nw40[(int)(1622)] = 70;
      _nw40[(int)(1623)] = 179;
      _nw40[(int)(1624)] = 124;
      _nw40[(int)(1625)] = 43;
      _nw40[(int)(1626)] = 199;
      _nw40[(int)(1627)] = 97;
      _nw40[(int)(1628)] = 140;
      _nw40[(int)(1629)] = 17;
      _nw40[(int)(1630)] = 72;
      _nw40[(int)(1631)] = 95;
      _nw40[(int)(1632)] = 156;
      _nw40[(int)(1633)] = 86;
      _nw40[(int)(1634)] = 49;
      _nw40[(int)(1635)] = 121;
      _nw40[(int)(1636)] = 101;
      _nw40[(int)(1637)] = 171;
      _nw40[(int)(1638)] = 191;
      _nw40[(int)(1639)] = 239;
      _nw40[(int)(1640)] = 131;
      _nw40[(int)(1641)] = 88;
      _nw40[(int)(1642)] = 82;
      _nw40[(int)(1643)] = 87;
      _nw40[(int)(1644)] = 5;
      _nw40[(int)(1645)] = 137;
      _nw40[(int)(1646)] = 132;
      _nw40[(int)(1647)] = 94;
      _nw40[(int)(1648)] = 50;
      _nw40[(int)(1649)] = 170;
      _nw40[(int)(1650)] = 154;
      _nw40[(int)(1651)] = 151;
      _nw40[(int)(1652)] = 92;
      _nw40[(int)(1653)] = 140;
      _nw40[(int)(1654)] = 85;
      _nw40[(int)(1655)] = 46;
      _nw40[(int)(1656)] = 61;
      _nw40[(int)(1657)] = 153;
      _nw40[(int)(1658)] = 222;
      _nw40[(int)(1659)] = 231;
      _nw40[(int)(1660)] = 189;
      _nw40[(int)(1661)] = 141;
      _nw40[(int)(1662)] = 109;
      _nw40[(int)(1663)] = 1;
      _nw40[(int)(1664)] = 214;
      _nw40[(int)(1665)] = 204;
      _nw40[(int)(1666)] = 195;
      _nw40[(int)(1667)] = 222;
      _nw40[(int)(1668)] = 189;
      _nw40[(int)(1669)] = 125;
      _nw40[(int)(1670)] = 161;
      _nw40[(int)(1671)] = 123;
      _nw40[(int)(1672)] = 134;
      _nw40[(int)(1673)] = 161;
      _nw40[(int)(1674)] = 81;
      _nw40[(int)(1675)] = 225;
      _nw40[(int)(1676)] = 165;
      _nw40[(int)(1677)] = 244;
      _nw40[(int)(1678)] = 58;
      _nw40[(int)(1679)] = 102;
      _nw40[(int)(1680)] = 39;
      _nw40[(int)(1681)] = 171;
      _nw40[(int)(1682)] = 183;
      _nw40[(int)(1683)] = 233;
      _nw40[(int)(1684)] = 66;
      _nw40[(int)(1685)] = 194;
      _nw40[(int)(1686)] = 210;
      _nw40[(int)(1687)] = 8;
      _nw40[(int)(1688)] = 90;
      _nw40[(int)(1689)] = 115;
      _nw40[(int)(1690)] = 202;
      _nw40[(int)(1691)] = 198;
      _nw40[(int)(1692)] = 68;
      _nw40[(int)(1693)] = 59;
      _nw40[(int)(1694)] = 247;
      _nw40[(int)(1695)] = 136;
      _nw40[(int)(1696)] = 21;
      _nw40[(int)(1697)] = 62;
      _nw40[(int)(1698)] = 34;
      _nw40[(int)(1699)] = 166;
      _nw40[(int)(1700)] = 149;
      _nw40[(int)(1701)] = 125;
      _nw40[(int)(1702)] = 2;
      _nw40[(int)(1703)] = 212;
      _nw40[(int)(1704)] = 34;
      _nw40[(int)(1705)] = 115;
      _nw40[(int)(1706)] = 239;
      _nw40[(int)(1707)] = 145;
      _nw40[(int)(1708)] = 25;
      _nw40[(int)(1709)] = 222;
      _nw40[(int)(1710)] = 220;
      _nw40[(int)(1711)] = 251;
      _nw40[(int)(1712)] = 117;
      _nw40[(int)(1713)] = 200;
      _nw40[(int)(1714)] = 88;
      _nw40[(int)(1715)] = 153;
      _nw40[(int)(1716)] = 4;
      _nw40[(int)(1717)] = 20;
      _nw40[(int)(1718)] = 110;
      _nw40[(int)(1719)] = 231;
      _nw40[(int)(1720)] = 168;
      _nw40[(int)(1721)] = 237;
      _nw40[(int)(1722)] = 102;
      _nw40[(int)(1723)] = 7;
      _nw40[(int)(1724)] = 133;
      _nw40[(int)(1725)] = 51;
      _nw40[(int)(1726)] = 6;
      _nw40[(int)(1727)] = 252;
      _nw40[(int)(1728)] = 181;
      _nw40[(int)(1729)] = 67;
      _nw40[(int)(1730)] = 83;
      _nw40[(int)(1731)] = 9;
      _nw40[(int)(1732)] = 243;
      _nw40[(int)(1733)] = 79;
      _nw40[(int)(1734)] = 230;
      _nw40[(int)(1735)] = 204;
      _nw40[(int)(1736)] = 58;
      _nw40[(int)(1737)] = 25;
      _nw40[(int)(1738)] = 37;
      _nw40[(int)(1739)] = 34;
      _nw40[(int)(1740)] = 165;
      _nw40[(int)(1741)] = 145;
      _nw40[(int)(1742)] = 76;
      _nw40[(int)(1743)] = 56;
      _nw40[(int)(1744)] = 220;
      _nw40[(int)(1745)] = 68;
      _nw40[(int)(1746)] = 180;
      _nw40[(int)(1747)] = 28;
      _nw40[(int)(1748)] = 60;
      _nw40[(int)(1749)] = 57;
      _nw40[(int)(1750)] = 110;
      _nw40[(int)(1751)] = 148;
      _nw40[(int)(1752)] = 225;
      _nw40[(int)(1753)] = 37;
      _nw40[(int)(1754)] = 201;
      _nw40[(int)(1755)] = 201;
      _nw40[(int)(1756)] = 186;
      _nw40[(int)(1757)] = 93;
      _nw40[(int)(1758)] = 224;
      _nw40[(int)(1759)] = 191;
      _nw40[(int)(1760)] = 197;
      _nw40[(int)(1761)] = 48;
      _nw40[(int)(1762)] = 172;
      _nw40[(int)(1763)] = 144;
      _nw40[(int)(1764)] = 118;
      _nw40[(int)(1765)] = 103;
      _nw40[(int)(1766)] = 206;
      _nw40[(int)(1767)] = 71;
      _nw40[(int)(1768)] = 103;
      _nw40[(int)(1769)] = 245;
      _nw40[(int)(1770)] = 203;
      _nw40[(int)(1771)] = 38;
      _nw40[(int)(1772)] = 98;
      _nw40[(int)(1773)] = 67;
      _nw40[(int)(1774)] = 253;
      _nw40[(int)(1775)] = 80;
      _nw40[(int)(1776)] = 48;
      _nw40[(int)(1777)] = 241;
      _nw40[(int)(1778)] = 24;
      _nw40[(int)(1779)] = 231;
      _nw40[(int)(1780)] = 26;
      _nw40[(int)(1781)] = 198;
      _nw40[(int)(1782)] = 150;
      _nw40[(int)(1783)] = 104;
      _nw40[(int)(1784)] = 188;
      _nw40[(int)(1785)] = 33;
      _nw40[(int)(1786)] = 85;
      _nw40[(int)(1787)] = 73;
      _nw40[(int)(1788)] = 225;
      _nw40[(int)(1789)] = 23;
      _nw40[(int)(1790)] = 44;
      _nw40[(int)(1791)] = 218;
      _nw40[(int)(1792)] = 131;
      _nw40[(int)(1793)] = 130;
      _nw40[(int)(1794)] = 222;
      _nw40[(int)(1795)] = 148;
      _nw40[(int)(1796)] = 35;
      _nw40[(int)(1797)] = 181;
      _nw40[(int)(1798)] = 67;
      _nw40[(int)(1799)] = 134;
      _nw40[(int)(1800)] = 111;
      _nw40[(int)(1801)] = 17;
      _nw40[(int)(1802)] = 108;
      _nw40[(int)(1803)] = 57;
      _nw40[(int)(1804)] = 109;
      _nw40[(int)(1805)] = 17;
      _nw40[(int)(1806)] = 44;
      _nw40[(int)(1807)] = 54;
      _nw40[(int)(1808)] = 234;
      _nw40[(int)(1809)] = 175;
      _nw40[(int)(1810)] = 230;
      _nw40[(int)(1811)] = 8;
      _nw40[(int)(1812)] = 84;
      _nw40[(int)(1813)] = 2;
      _nw40[(int)(1814)] = 106;
      _nw40[(int)(1815)] = 19;
      _nw40[(int)(1816)] = 71;
      _nw40[(int)(1817)] = 72;
      _nw40[(int)(1818)] = 22;
      _nw40[(int)(1819)] = 234;
      _nw40[(int)(1820)] = 118;
      _nw40[(int)(1821)] = 91;
      _nw40[(int)(1822)] = 128;
      _nw40[(int)(1823)] = 235;
      _nw40[(int)(1824)] = 146;
      _nw40[(int)(1825)] = 29;
      _nw40[(int)(1826)] = 244;
      _nw40[(int)(1827)] = 202;
      _nw40[(int)(1828)] = 237;
      _nw40[(int)(1829)] = 109;
      _nw40[(int)(1830)] = 230;
      _nw40[(int)(1831)] = 223;
      _nw40[(int)(1832)] = 43;
      _nw40[(int)(1833)] = 43;
      _nw40[(int)(1834)] = 187;
      _nw40[(int)(1835)] = 38;
      _nw40[(int)(1836)] = 137;
      _nw40[(int)(1837)] = 179;
      _nw40[(int)(1838)] = 227;
      _nw40[(int)(1839)] = 187;
      _nw40[(int)(1840)] = 104;
      _nw40[(int)(1841)] = 153;
      _nw40[(int)(1842)] = 77;
      _nw40[(int)(1843)] = 132;
      _nw40[(int)(1844)] = 126;
      _nw40[(int)(1845)] = 162;
      _nw40[(int)(1846)] = 151;
      _nw40[(int)(1847)] = 245;
      _nw40[(int)(1848)] = 248;
      _nw40[(int)(1849)] = 148;
      _nw40[(int)(1850)] = 8;
      _nw40[(int)(1851)] = 231;
      _nw40[(int)(1852)] = 198;
      _nw40[(int)(1853)] = 191;
      _nw40[(int)(1854)] = 131;
      _nw40[(int)(1855)] = 96;
      _nw40[(int)(1856)] = 157;
      _nw40[(int)(1857)] = 29;
      _nw40[(int)(1858)] = 218;
      _nw40[(int)(1859)] = 183;
      _nw40[(int)(1860)] = 37;
      _nw40[(int)(1861)] = 69;
      _nw40[(int)(1862)] = 61;
      _nw40[(int)(1863)] = 57;
      _nw40[(int)(1864)] = 227;
      _nw40[(int)(1865)] = 83;
      _nw40[(int)(1866)] = 237;
      _nw40[(int)(1867)] = 142;
      _nw40[(int)(1868)] = 46;
      _nw40[(int)(1869)] = 42;
      _nw40[(int)(1870)] = 198;
      _nw40[(int)(1871)] = 142;
      _nw40[(int)(1872)] = 158;
      _nw40[(int)(1873)] = 216;
      _nw40[(int)(1874)] = 217;
      _nw40[(int)(1875)] = 53;
      _nw40[(int)(1876)] = 186;
      _nw40[(int)(1877)] = 250;
      _nw40[(int)(1878)] = 53;
      _nw40[(int)(1879)] = 123;
      _nw40[(int)(1880)] = 64;
      _nw40[(int)(1881)] = 11;
      _nw40[(int)(1882)] = 106;
      _nw40[(int)(1883)] = 130;
      _nw40[(int)(1884)] = 156;
      _nw40[(int)(1885)] = 194;
      _nw40[(int)(1886)] = 217;
      _nw40[(int)(1887)] = 209;
      _nw40[(int)(1888)] = 56;
      _nw40[(int)(1889)] = 208;
      _nw40[(int)(1890)] = 80;
      _nw40[(int)(1891)] = 182;
      _nw40[(int)(1892)] = 162;
      _nw40[(int)(1893)] = 138;
      _nw40[(int)(1894)] = 236;
      _nw40[(int)(1895)] = 151;
      _nw40[(int)(1896)] = 145;
      _nw40[(int)(1897)] = 17;
      _nw40[(int)(1898)] = 125;
      _nw40[(int)(1899)] = 140;
      _nw40[(int)(1900)] = 251;
      _nw40[(int)(1901)] = 244;
      _nw40[(int)(1902)] = 172;
      _nw40[(int)(1903)] = 223;
      _nw40[(int)(1904)] = 226;
      _nw40[(int)(1905)] = 175;
      _nw40[(int)(1906)] = 26;
      _nw40[(int)(1907)] = 116;
      _nw40[(int)(1908)] = 251;
      _nw40[(int)(1909)] = 58;
      _nw40[(int)(1910)] = 194;
      _nw40[(int)(1911)] = 248;
      _nw40[(int)(1912)] = 228;
      _nw40[(int)(1913)] = 122;
      _nw40[(int)(1914)] = 80;
      _nw40[(int)(1915)] = 247;
      _nw40[(int)(1916)] = 17;
      _nw40[(int)(1917)] = 37;
      _nw40[(int)(1918)] = 168;
      _nw40[(int)(1919)] = 248;
      _nw40[(int)(1920)] = 153;
      _nw40[(int)(1921)] = 56;
      _nw40[(int)(1922)] = 148;
      _nw40[(int)(1923)] = 12;
      _nw40[(int)(1924)] = 114;
      _nw40[(int)(1925)] = 220;
      _nw40[(int)(1926)] = 234;
      _nw40[(int)(1927)] = 74;
      _nw40[(int)(1928)] = 80;
      _nw40[(int)(1929)] = 5;
      _nw40[(int)(1930)] = 208;
      _nw40[(int)(1931)] = 238;
      _nw40[(int)(1932)] = 164;
      _nw40[(int)(1933)] = 208;
      _nw40[(int)(1934)] = 108;
      _nw40[(int)(1935)] = 198;
      _nw40[(int)(1936)] = 92;
      _nw40[(int)(1937)] = 55;
      _nw40[(int)(1938)] = 46;
      _nw40[(int)(1939)] = 20;
      _nw40[(int)(1940)] = 111;
      _nw40[(int)(1941)] = 58;
      _nw40[(int)(1942)] = 32;
      _nw40[(int)(1943)] = 17;
      _nw40[(int)(1944)] = 11;
      _nw40[(int)(1945)] = 43;
      _nw40[(int)(1946)] = 217;
      _nw40[(int)(1947)] = 241;
      _nw40[(int)(1948)] = 119;
      _nw40[(int)(1949)] = 90;
      _nw40[(int)(1950)] = 87;
      _nw40[(int)(1951)] = 225;
      _nw40[(int)(1952)] = 136;
      _nw40[(int)(1953)] = 59;
      _nw40[(int)(1954)] = 127;
      _nw40[(int)(1955)] = 102;
      _nw40[(int)(1956)] = 158;
      _nw40[(int)(1957)] = 69;
      _nw40[(int)(1958)] = 0;
      _nw40[(int)(1959)] = 149;
      _nw40[(int)(1960)] = 226;
      _nw40[(int)(1961)] = 106;
      _nw40[(int)(1962)] = 89;
      _nw40[(int)(1963)] = 223;
      _nw40[(int)(1964)] = 134;
      _nw40[(int)(1965)] = 165;
      _nw40[(int)(1966)] = 34;
      _nw40[(int)(1967)] = 41;
      _nw40[(int)(1968)] = 16;
      _nw40[(int)(1969)] = 59;
      _nw40[(int)(1970)] = 218;
      _nw40[(int)(1971)] = 188;
      _nw40[(int)(1972)] = 24;
      _nw40[(int)(1973)] = 149;
      _nw40[(int)(1974)] = 145;
      _nw40[(int)(1975)] = 2;
      _nw40[(int)(1976)] = 121;
      _nw40[(int)(1977)] = 66;
      _nw40[(int)(1978)] = 128;
      _nw40[(int)(1979)] = 186;
      _nw40[(int)(1980)] = 252;
      _nw40[(int)(1981)] = 168;
      _nw40[(int)(1982)] = 233;
      _nw40[(int)(1983)] = 102;
      _nw40[(int)(1984)] = 248;
      _nw40[(int)(1985)] = 102;
      _nw40[(int)(1986)] = 126;
      _nw40[(int)(1987)] = 49;
      _nw40[(int)(1988)] = 90;
      _nw40[(int)(1989)] = 212;
      _nw40[(int)(1990)] = 102;
      _nw40[(int)(1991)] = 202;
      _nw40[(int)(1992)] = 116;
      _nw40[(int)(1993)] = 97;
      _nw40[(int)(1994)] = 147;
      _nw40[(int)(1995)] = 94;
      _nw40[(int)(1996)] = 39;
      _nw40[(int)(1997)] = 245;
      _nw40[(int)(1998)] = 233;
      _nw40[(int)(1999)] = 34;
      _nw40[(int)(2000)] = 77;
      _nw40[(int)(2001)] = 7;
      _nw40[(int)(2002)] = 113;
      _nw40[(int)(2003)] = 237;
      _nw40[(int)(2004)] = 89;
      _nw40[(int)(2005)] = 14;
      _nw40[(int)(2006)] = 246;
      _nw40[(int)(2007)] = 156;
      _nw40[(int)(2008)] = 61;
      _nw40[(int)(2009)] = 30;
      _nw40[(int)(2010)] = 173;
      _nw40[(int)(2011)] = 163;
      _nw40[(int)(2012)] = 83;
      _nw40[(int)(2013)] = 164;
      _nw40[(int)(2014)] = 13;
      _nw40[(int)(2015)] = 11;
      _nw40[(int)(2016)] = 190;
      _nw40[(int)(2017)] = 52;
      _nw40[(int)(2018)] = 11;
      _nw40[(int)(2019)] = 165;
      _nw40[(int)(2020)] = 35;
      _nw40[(int)(2021)] = 70;
      _nw40[(int)(2022)] = 217;
      _nw40[(int)(2023)] = 19;
      _nw40[(int)(2024)] = 151;
      _nw40[(int)(2025)] = 112;
      _nw40[(int)(2026)] = 64;
      _nw40[(int)(2027)] = 190;
      _nw40[(int)(2028)] = 214;
      _nw40[(int)(2029)] = 142;
      _nw40[(int)(2030)] = 132;
      _nw40[(int)(2031)] = 48;
      _nw40[(int)(2032)] = 20;
      _nw40[(int)(2033)] = 51;
      _nw40[(int)(2034)] = 15;
      _nw40[(int)(2035)] = 242;
      _nw40[(int)(2036)] = 35;
      _nw40[(int)(2037)] = 27;
      _nw40[(int)(2038)] = 175;
      _nw40[(int)(2039)] = 106;
      _nw40[(int)(2040)] = 222;
      _nw40[(int)(2041)] = 165;
      _nw40[(int)(2042)] = 153;
      _nw40[(int)(2043)] = 231;
      _nw40[(int)(2044)] = 119;
      _nw40[(int)(2045)] = 71;
      _nw40[(int)(2046)] = 155;
      _nw40[(int)(2047)] = 75;
      _nw40[(int)(2048)] = 75;
      _nw40[(int)(2049)] = 124;
      _nw40[(int)(2050)] = 106;
      _nw40[(int)(2051)] = 225;
      _nw40[(int)(2052)] = 142;
      _nw40[(int)(2053)] = 247;
      _nw40[(int)(2054)] = 7;
      _nw40[(int)(2055)] = 22;
      _nw40[(int)(2056)] = 245;
      _nw40[(int)(2057)] = 213;
      _nw40[(int)(2058)] = 102;
      _nw40[(int)(2059)] = 86;
      _nw40[(int)(2060)] = 62;
      _nw40[(int)(2061)] = 162;
      _nw40[(int)(2062)] = 223;
      _nw40[(int)(2063)] = 102;
      _nw40[(int)(2064)] = 172;
      _nw40[(int)(2065)] = 215;
      _nw40[(int)(2066)] = 22;
      _nw40[(int)(2067)] = 202;
      _nw40[(int)(2068)] = 185;
      _nw40[(int)(2069)] = 35;
      _nw40[(int)(2070)] = 163;
      _nw40[(int)(2071)] = 84;
      _nw40[(int)(2072)] = 154;
      _nw40[(int)(2073)] = 188;
      _nw40[(int)(2074)] = 46;
      _nw40[(int)(2075)] = 203;
      _nw40[(int)(2076)] = 230;
      _nw40[(int)(2077)] = 172;
      _nw40[(int)(2078)] = 136;
      _nw40[(int)(2079)] = 130;
      _nw40[(int)(2080)] = 95;
      _nw40[(int)(2081)] = 86;
      _nw40[(int)(2082)] = 70;
      _nw40[(int)(2083)] = 128;
      _nw40[(int)(2084)] = 232;
      _nw40[(int)(2085)] = 26;
      _nw40[(int)(2086)] = 105;
      _nw40[(int)(2087)] = 20;
      _nw40[(int)(2088)] = 108;
      _nw40[(int)(2089)] = 34;
      _nw40[(int)(2090)] = 129;
      _nw40[(int)(2091)] = 36;
      _nw40[(int)(2092)] = 74;
      _nw40[(int)(2093)] = 39;
      _nw40[(int)(2094)] = 184;
      _nw40[(int)(2095)] = 87;
      _nw40[(int)(2096)] = 110;
      _nw40[(int)(2097)] = 204;
      _nw40[(int)(2098)] = 209;
      _nw40[(int)(2099)] = 205;
      _nw40[(int)(2100)] = 193;
      _nw40[(int)(2101)] = 229;
      _nw40[(int)(2102)] = 25;
      _nw40[(int)(2103)] = 142;
      _nw40[(int)(2104)] = 160;
      _nw40[(int)(2105)] = 255;
      _nw40[(int)(2106)] = 34;
      _nw40[(int)(2107)] = 217;
      _nw40[(int)(2108)] = 95;
      _nw40[(int)(2109)] = 228;
      _nw40[(int)(2110)] = 140;
      _nw40[(int)(2111)] = 121;
      _nw40[(int)(2112)] = 126;
      _nw40[(int)(2113)] = 22;
      _nw40[(int)(2114)] = 121;
      _nw40[(int)(2115)] = 117;
      _nw40[(int)(2116)] = 115;
      _nw40[(int)(2117)] = 233;
      _nw40[(int)(2118)] = 35;
      _nw40[(int)(2119)] = 77;
      _nw40[(int)(2120)] = 206;
      _nw40[(int)(2121)] = 92;
      _nw40[(int)(2122)] = 119;
      _nw40[(int)(2123)] = 242;
      _nw40[(int)(2124)] = 229;
      _nw40[(int)(2125)] = 204;
      _nw40[(int)(2126)] = 34;
      _nw40[(int)(2127)] = 155;
      _nw40[(int)(2128)] = 38;
      _nw40[(int)(2129)] = 212;
      _nw40[(int)(2130)] = 50;
      _nw40[(int)(2131)] = 48;
      _nw40[(int)(2132)] = 249;
      _nw40[(int)(2133)] = 191;
      _nw40[(int)(2134)] = 145;
      _nw40[(int)(2135)] = 50;
      _nw40[(int)(2136)] = 191;
      _nw40[(int)(2137)] = 150;
      _nw40[(int)(2138)] = 190;
      _nw40[(int)(2139)] = 93;
      _nw40[(int)(2140)] = 91;
      _nw40[(int)(2141)] = 29;
      _nw40[(int)(2142)] = 163;
      _nw40[(int)(2143)] = 122;
      _nw40[(int)(2144)] = 85;
      _nw40[(int)(2145)] = 254;
      _nw40[(int)(2146)] = 93;
      _nw40[(int)(2147)] = 14;
      _nw40[(int)(2148)] = 213;
      _nw40[(int)(2149)] = 129;
      _nw40[(int)(2150)] = 24;
      _nw40[(int)(2151)] = 158;
      _nw40[(int)(2152)] = 133;
      _nw40[(int)(2153)] = 185;
      _nw40[(int)(2154)] = 177;
      _nw40[(int)(2155)] = 110;
      _nw40[(int)(2156)] = 220;
      _nw40[(int)(2157)] = 109;
      _nw40[(int)(2158)] = 33;
      _nw40[(int)(2159)] = 45;
      _nw40[(int)(2160)] = 243;
      _nw40[(int)(2161)] = 25;
      _nw40[(int)(2162)] = 224;
      _nw40[(int)(2163)] = 131;
      _nw40[(int)(2164)] = 27;
      _nw40[(int)(2165)] = 110;
      _nw40[(int)(2166)] = 64;
      _nw40[(int)(2167)] = 151;
      _nw40[(int)(2168)] = 128;
      _nw40[(int)(2169)] = 18;
      _nw40[(int)(2170)] = 7;
      _nw40[(int)(2171)] = 103;
      _nw40[(int)(2172)] = 45;
      _nw40[(int)(2173)] = 245;
      _nw40[(int)(2174)] = 182;
      _nw40[(int)(2175)] = 171;
      _nw40[(int)(2176)] = 225;
      _nw40[(int)(2177)] = 236;
      _nw40[(int)(2178)] = 21;
      _nw40[(int)(2179)] = 98;
      _nw40[(int)(2180)] = 255;
      _nw40[(int)(2181)] = 137;
      _nw40[(int)(2182)] = 44;
      _nw40[(int)(2183)] = 40;
      _nw40[(int)(2184)] = 68;
      _nw40[(int)(2185)] = 124;
      _nw40[(int)(2186)] = 12;
      _nw40[(int)(2187)] = 21;
      _nw40[(int)(2188)] = 160;
      _nw40[(int)(2189)] = 230;
      _nw40[(int)(2190)] = 85;
      _nw40[(int)(2191)] = 83;
      _nw40[(int)(2192)] = 20;
      _nw40[(int)(2193)] = 2;
      _nw40[(int)(2194)] = 161;
      _nw40[(int)(2195)] = 219;
      _nw40[(int)(2196)] = 132;
      _nw40[(int)(2197)] = 150;
      _nw40[(int)(2198)] = 31;
      _nw40[(int)(2199)] = 140;
      _nw40[(int)(2200)] = 244;
      _nw40[(int)(2201)] = 103;
      _nw40[(int)(2202)] = 76;
      _nw40[(int)(2203)] = 144;
      _nw40[(int)(2204)] = 182;
      _nw40[(int)(2205)] = 70;
      _nw40[(int)(2206)] = 76;
      _nw40[(int)(2207)] = 191;
      _nw40[(int)(2208)] = 16;
      _nw40[(int)(2209)] = 242;
      _nw40[(int)(2210)] = 254;
      _nw40[(int)(2211)] = 9;
      _nw40[(int)(2212)] = 39;
      _nw40[(int)(2213)] = 46;
      _nw40[(int)(2214)] = 4;
      _nw40[(int)(2215)] = 156;
      _nw40[(int)(2216)] = 243;
      _nw40[(int)(2217)] = 6;
      _nw40[(int)(2218)] = 40;
      _nw40[(int)(2219)] = 119;
      _nw40[(int)(2220)] = 9;
      _nw40[(int)(2221)] = 202;
      _nw40[(int)(2222)] = 174;
      _nw40[(int)(2223)] = 55;
      _nw40[(int)(2224)] = 159;
      _nw40[(int)(2225)] = 225;
      _nw40[(int)(2226)] = 132;
      _nw40[(int)(2227)] = 78;
      _nw40[(int)(2228)] = 160;
      _nw40[(int)(2229)] = 53;
      _nw40[(int)(2230)] = 189;
      _nw40[(int)(2231)] = 77;
      _nw40[(int)(2232)] = 170;
      _nw40[(int)(2233)] = 185;
      _nw40[(int)(2234)] = 96;
      _nw40[(int)(2235)] = 169;
      _nw40[(int)(2236)] = 247;
      _nw40[(int)(2237)] = 122;
      _nw40[(int)(2238)] = 159;
      _nw40[(int)(2239)] = 195;
      _nw40[(int)(2240)] = 226;
      _nw40[(int)(2241)] = 255;
      _nw40[(int)(2242)] = 191;
      _nw40[(int)(2243)] = 142;
      _nw40[(int)(2244)] = 25;
      _nw40[(int)(2245)] = 168;
      _nw40[(int)(2246)] = 162;
      _nw40[(int)(2247)] = 79;
      _nw40[(int)(2248)] = 139;
      _nw40[(int)(2249)] = 164;
      _nw40[(int)(2250)] = 167;
      _nw40[(int)(2251)] = 11;
      _nw40[(int)(2252)] = 64;
      _nw40[(int)(2253)] = 133;
      _nw40[(int)(2254)] = 55;
      _nw40[(int)(2255)] = 227;
      _nw40[(int)(2256)] = 180;
      _nw40[(int)(2257)] = 192;
      _nw40[(int)(2258)] = 11;
      _nw40[(int)(2259)] = 166;
      _nw40[(int)(2260)] = 255;
      _nw40[(int)(2261)] = 65;
      _nw40[(int)(2262)] = 141;
      _nw40[(int)(2263)] = 110;
      _nw40[(int)(2264)] = 38;
      _nw40[(int)(2265)] = 94;
      _nw40[(int)(2266)] = 1;
      _nw40[(int)(2267)] = 43;
      _nw40[(int)(2268)] = 177;
      _nw40[(int)(2269)] = 25;
      _nw40[(int)(2270)] = 253;
      _nw40[(int)(2271)] = 199;
      _nw40[(int)(2272)] = 175;
      _nw40[(int)(2273)] = 247;
      _nw40[(int)(2274)] = 5;
      _nw40[(int)(2275)] = 35;
      _nw40[(int)(2276)] = 109;
      _nw40[(int)(2277)] = 177;
      _nw40[(int)(2278)] = 137;
      _nw40[(int)(2279)] = 162;
      _nw40[(int)(2280)] = 10;
      _nw40[(int)(2281)] = 177;
      _nw40[(int)(2282)] = 199;
      _nw40[(int)(2283)] = 202;
      _nw40[(int)(2284)] = 112;
      _nw40[(int)(2285)] = 131;
      _nw40[(int)(2286)] = 103;
      _nw40[(int)(2287)] = 248;
      _nw40[(int)(2288)] = 221;
      _nw40[(int)(2289)] = 232;
      _nw40[(int)(2290)] = 14;
      _nw40[(int)(2291)] = 189;
      _nw40[(int)(2292)] = 148;
      _nw40[(int)(2293)] = 150;
      _nw40[(int)(2294)] = 61;
      _nw40[(int)(2295)] = 107;
      _nw40[(int)(2296)] = 133;
      _nw40[(int)(2297)] = 4;
      _nw40[(int)(2298)] = 151;
      _nw40[(int)(2299)] = 175;
      _nw40[(int)(2300)] = 120;
      _nw40[(int)(2301)] = 56;
      _nw40[(int)(2302)] = 136;
      _nw40[(int)(2303)] = 135;
      _nw40[(int)(2304)] = 201;
      _nw40[(int)(2305)] = 94;
      _nw40[(int)(2306)] = 141;
      _nw40[(int)(2307)] = 42;
      _nw40[(int)(2308)] = 103;
      _nw40[(int)(2309)] = 150;
      _nw40[(int)(2310)] = 67;
      _nw40[(int)(2311)] = 72;
      _nw40[(int)(2312)] = 200;
      _nw40[(int)(2313)] = 81;
      _nw40[(int)(2314)] = 61;
      _nw40[(int)(2315)] = 7;
      _nw40[(int)(2316)] = 104;
      _nw40[(int)(2317)] = 248;
      _nw40[(int)(2318)] = 65;
      _nw40[(int)(2319)] = 99;
      _nw40[(int)(2320)] = 179;
      _nw40[(int)(2321)] = 57;
      _nw40[(int)(2322)] = 176;
      _nw40[(int)(2323)] = 246;
      _nw40[(int)(2324)] = 171;
      _nw40[(int)(2325)] = 165;
      _nw40[(int)(2326)] = 199;
      _nw40[(int)(2327)] = 2;
      _nw40[(int)(2328)] = 255;
      _nw40[(int)(2329)] = 244;
      _nw40[(int)(2330)] = 156;
      _nw40[(int)(2331)] = 85;
      _nw40[(int)(2332)] = 80;
      _nw40[(int)(2333)] = 59;
      _nw40[(int)(2334)] = 74;
      _nw40[(int)(2335)] = 109;
      _nw40[(int)(2336)] = 136;
      _nw40[(int)(2337)] = 118;
      _nw40[(int)(2338)] = 172;
      _nw40[(int)(2339)] = 254;
      _nw40[(int)(2340)] = 165;
      _nw40[(int)(2341)] = 231;
      _nw40[(int)(2342)] = 115;
      _nw40[(int)(2343)] = 245;
      _nw40[(int)(2344)] = 57;
      _nw40[(int)(2345)] = 227;
      _nw40[(int)(2346)] = 144;
      _nw40[(int)(2347)] = 3;
      _nw40[(int)(2348)] = 181;
      _nw40[(int)(2349)] = 247;
      _nw40[(int)(2350)] = 89;
      _nw40[(int)(2351)] = 6;
      _nw40[(int)(2352)] = 190;
      _nw40[(int)(2353)] = 10;
      _nw40[(int)(2354)] = 244;
      _nw40[(int)(2355)] = 123;
      _nw40[(int)(2356)] = 116;
      _nw40[(int)(2357)] = 144;
      _nw40[(int)(2358)] = 6;
      _nw40[(int)(2359)] = 33;
      _nw40[(int)(2360)] = 254;
      _nw40[(int)(2361)] = 139;
      _nw40[(int)(2362)] = 30;
      _nw40[(int)(2363)] = 115;
      _nw40[(int)(2364)] = 118;
      _nw40[(int)(2365)] = 72;
      _nw40[(int)(2366)] = 225;
      _nw40[(int)(2367)] = 150;
      _nw40[(int)(2368)] = 36;
      _nw40[(int)(2369)] = 203;
      _nw40[(int)(2370)] = 49;
      _nw40[(int)(2371)] = 219;
      _nw40[(int)(2372)] = 25;
      _nw40[(int)(2373)] = 254;
      _nw40[(int)(2374)] = 246;
      _nw40[(int)(2375)] = 59;
      _nw40[(int)(2376)] = 78;
      _nw40[(int)(2377)] = 71;
      _nw40[(int)(2378)] = 222;
      _nw40[(int)(2379)] = 157;
      _nw40[(int)(2380)] = 170;
      _nw40[(int)(2381)] = 63;
      _nw40[(int)(2382)] = 175;
      _nw40[(int)(2383)] = 170;
      _nw40[(int)(2384)] = 129;
      _nw40[(int)(2385)] = 236;
      _nw40[(int)(2386)] = 70;
      _nw40[(int)(2387)] = 155;
      _nw40[(int)(2388)] = 242;
      _nw40[(int)(2389)] = 111;
      _nw40[(int)(2390)] = 40;
      _nw40[(int)(2391)] = 134;
      _nw40[(int)(2392)] = 139;
      _nw40[(int)(2393)] = 148;
      _nw40[(int)(2394)] = 198;
      _nw40[(int)(2395)] = 49;
      _nw40[(int)(2396)] = 132;
      _nw40[(int)(2397)] = 69;
      _nw40[(int)(2398)] = 132;
      _nw40[(int)(2399)] = 145;
      _nw40[(int)(2400)] = 135;
      _nw40[(int)(2401)] = 119;
      _nw40[(int)(2402)] = 77;
      _nw40[(int)(2403)] = 109;
      _nw40[(int)(2404)] = 198;
      _nw40[(int)(2405)] = 208;
      _nw40[(int)(2406)] = 36;
      _nw40[(int)(2407)] = 226;
      _nw40[(int)(2408)] = 180;
      _nw40[(int)(2409)] = 36;
      _nw40[(int)(2410)] = 232;
      _nw40[(int)(2411)] = 208;
      _nw40[(int)(2412)] = 8;
      _nw40[(int)(2413)] = 94;
      _nw40[(int)(2414)] = 21;
      _nw40[(int)(2415)] = 155;
      _nw40[(int)(2416)] = 179;
      _nw40[(int)(2417)] = 174;
      _nw40[(int)(2418)] = 42;
      _nw40[(int)(2419)] = 133;
      _nw40[(int)(2420)] = 208;
      _nw40[(int)(2421)] = 251;
      _nw40[(int)(2422)] = 147;
      _nw40[(int)(2423)] = 26;
      _nw40[(int)(2424)] = 7;
      _nw40[(int)(2425)] = 220;
      _nw40[(int)(2426)] = 148;
      _nw40[(int)(2427)] = 61;
      _nw40[(int)(2428)] = 141;
      _nw40[(int)(2429)] = 228;
      _nw40[(int)(2430)] = 180;
      _nw40[(int)(2431)] = 232;
      _nw40[(int)(2432)] = 56;
      _nw40[(int)(2433)] = 28;
      _nw40[(int)(2434)] = 169;
      _nw40[(int)(2435)] = 35;
      _nw40[(int)(2436)] = 158;
      _nw40[(int)(2437)] = 79;
      _nw40[(int)(2438)] = 192;
      _nw40[(int)(2439)] = 26;
      _nw40[(int)(2440)] = 17;
      _nw40[(int)(2441)] = 90;
      _nw40[(int)(2442)] = 146;
      _nw40[(int)(2443)] = 187;
      _nw40[(int)(2444)] = 253;
      _nw40[(int)(2445)] = 120;
      _nw40[(int)(2446)] = 134;
      _nw40[(int)(2447)] = 86;
      _nw40[(int)(2448)] = 67;
      _nw40[(int)(2449)] = 144;
      _nw40[(int)(2450)] = 108;
      _nw40[(int)(2451)] = 70;
      _nw40[(int)(2452)] = 54;
      _nw40[(int)(2453)] = 48;
      _nw40[(int)(2454)] = 138;
      _nw40[(int)(2455)] = 13;
      _nw40[(int)(2456)] = 50;
      _nw40[(int)(2457)] = 179;
      _nw40[(int)(2458)] = 1;
      _nw40[(int)(2459)] = 146;
      _nw40[(int)(2460)] = 123;
      _nw40[(int)(2461)] = 235;
      _nw40[(int)(2462)] = 240;
      _nw40[(int)(2463)] = 248;
      _nw40[(int)(2464)] = 109;
      _nw40[(int)(2465)] = 173;
      _nw40[(int)(2466)] = 143;
      _nw40[(int)(2467)] = 34;
      _nw40[(int)(2468)] = 182;
      _nw40[(int)(2469)] = 81;
      _nw40[(int)(2470)] = 46;
      _nw40[(int)(2471)] = 48;
      _nw40[(int)(2472)] = 242;
      _nw40[(int)(2473)] = 60;
      _nw40[(int)(2474)] = 182;
      _nw40[(int)(2475)] = 230;
      _nw40[(int)(2476)] = 78;
      _nw40[(int)(2477)] = 169;
      _nw40[(int)(2478)] = 98;
      _nw40[(int)(2479)] = 38;
      _nw40[(int)(2480)] = 11;
      _nw40[(int)(2481)] = 53;
      _nw40[(int)(2482)] = 26;
      _nw40[(int)(2483)] = 81;
      _nw40[(int)(2484)] = 168;
      _nw40[(int)(2485)] = 66;
      _nw40[(int)(2486)] = 233;
      _nw40[(int)(2487)] = 95;
      _nw40[(int)(2488)] = 90;
      _nw40[(int)(2489)] = 161;
      _nw40[(int)(2490)] = 127;
      _nw40[(int)(2491)] = 186;
      _nw40[(int)(2492)] = 104;
      _nw40[(int)(2493)] = 159;
      _nw40[(int)(2494)] = 161;
      _nw40[(int)(2495)] = 182;
      _nw40[(int)(2496)] = 178;
      _nw40[(int)(2497)] = 237;
      _nw40[(int)(2498)] = 12;
      _nw40[(int)(2499)] = 230;
      _nw40[(int)(2500)] = 169;
      _nw40[(int)(2501)] = 179;
      _nw40[(int)(2502)] = 46;
      _nw40[(int)(2503)] = 214;
      _nw40[(int)(2504)] = 91;
      _nw40[(int)(2505)] = 154;
      _nw40[(int)(2506)] = 96;
      _nw40[(int)(2507)] = 212;
      _nw40[(int)(2508)] = 20;
      _nw40[(int)(2509)] = 212;
      _nw40[(int)(2510)] = 227;
      _nw40[(int)(2511)] = 161;
      _nw40[(int)(2512)] = 187;
      _nw40[(int)(2513)] = 181;
      _nw40[(int)(2514)] = 41;
      _nw40[(int)(2515)] = 201;
      _nw40[(int)(2516)] = 18;
      _nw40[(int)(2517)] = 149;
      _nw40[(int)(2518)] = 212;
      _nw40[(int)(2519)] = 216;
      _nw40[(int)(2520)] = 11;
      _nw40[(int)(2521)] = 152;
      _nw40[(int)(2522)] = 9;
      _nw40[(int)(2523)] = 217;
      _nw40[(int)(2524)] = 134;
      _nw40[(int)(2525)] = 223;
      _nw40[(int)(2526)] = 229;
      _nw40[(int)(2527)] = 195;
      _nw40[(int)(2528)] = 83;
      _nw40[(int)(2529)] = 4;
      _nw40[(int)(2530)] = 141;
      _nw40[(int)(2531)] = 188;
      _nw40[(int)(2532)] = 220;
      _nw40[(int)(2533)] = 177;
      _nw40[(int)(2534)] = 112;
      _nw40[(int)(2535)] = 161;
      _nw40[(int)(2536)] = 64;
      _nw40[(int)(2537)] = 127;
      _nw40[(int)(2538)] = 223;
      _nw40[(int)(2539)] = 173;
      _nw40[(int)(2540)] = 204;
      _nw40[(int)(2541)] = 116;
      _nw40[(int)(2542)] = 96;
      _nw40[(int)(2543)] = 26;
      _nw40[(int)(2544)] = 182;
      _nw40[(int)(2545)] = 204;
      _nw40[(int)(2546)] = 128;
      _nw40[(int)(2547)] = 146;
      _nw40[(int)(2548)] = 241;
      _nw40[(int)(2549)] = 212;
      _nw40[(int)(2550)] = 9;
      _nw40[(int)(2551)] = 234;
      _nw40[(int)(2552)] = 101;
      _nw40[(int)(2553)] = 42;
      _nw40[(int)(2554)] = 233;
      _nw40[(int)(2555)] = 85;
      _nw40[(int)(2556)] = 220;
      _nw40[(int)(2557)] = 185;
      _nw40[(int)(2558)] = 126;
      _nw40[(int)(2559)] = 25;
      _nw40[(int)(2560)] = 175;
      _nw40[(int)(2561)] = 72;
      _nw40[(int)(2562)] = 165;
      _nw40[(int)(2563)] = 239;
      _nw40[(int)(2564)] = 241;
      _nw40[(int)(2565)] = 124;
      _nw40[(int)(2566)] = 74;
      _nw40[(int)(2567)] = 10;
      _nw40[(int)(2568)] = 152;
      _nw40[(int)(2569)] = 218;
      _nw40[(int)(2570)] = 1;
      _nw40[(int)(2571)] = 36;
      _nw40[(int)(2572)] = 161;
      _nw40[(int)(2573)] = 251;
      _nw40[(int)(2574)] = 98;
      _nw40[(int)(2575)] = 148;
      _nw40[(int)(2576)] = 42;
      _nw40[(int)(2577)] = 38;
      _nw40[(int)(2578)] = 77;
      _nw40[(int)(2579)] = 103;
      _nw40[(int)(2580)] = 235;
      _nw40[(int)(2581)] = 150;
      _nw40[(int)(2582)] = 200;
      _nw40[(int)(2583)] = 182;
      _nw40[(int)(2584)] = 207;
      _nw40[(int)(2585)] = 150;
      _nw40[(int)(2586)] = 18;
      _nw40[(int)(2587)] = 207;
      _nw40[(int)(2588)] = 208;
      _nw40[(int)(2589)] = 199;
      _nw40[(int)(2590)] = 177;
      _nw40[(int)(2591)] = 172;
      _nw40[(int)(2592)] = 204;
      _nw40[(int)(2593)] = 9;
      _nw40[(int)(2594)] = 93;
      _nw40[(int)(2595)] = 93;
      _nw40[(int)(2596)] = 102;
      _nw40[(int)(2597)] = 20;
      _nw40[(int)(2598)] = 193;
      _nw40[(int)(2599)] = 235;
      _nw40[(int)(2600)] = 247;
      _nw40[(int)(2601)] = 8;
      _nw40[(int)(2602)] = 76;
      _nw40[(int)(2603)] = 84;
      _nw40[(int)(2604)] = 177;
      _nw40[(int)(2605)] = 199;
      _nw40[(int)(2606)] = 146;
      _nw40[(int)(2607)] = 136;
      _nw40[(int)(2608)] = 109;
      _nw40[(int)(2609)] = 238;
      _nw40[(int)(2610)] = 140;
      _nw40[(int)(2611)] = 180;
      _nw40[(int)(2612)] = 216;
      _nw40[(int)(2613)] = 71;
      _nw40[(int)(2614)] = 65;
      _nw40[(int)(2615)] = 76;
      _nw40[(int)(2616)] = 63;
      _nw40[(int)(2617)] = 80;
      _nw40[(int)(2618)] = 193;
      _nw40[(int)(2619)] = 162;
      _nw40[(int)(2620)] = 187;
      _nw40[(int)(2621)] = 92;
      _nw40[(int)(2622)] = 36;
      _nw40[(int)(2623)] = 37;
      _nw40[(int)(2624)] = 210;
      _nw40[(int)(2625)] = 177;
      _nw40[(int)(2626)] = 212;
      _nw40[(int)(2627)] = 228;
      _nw40[(int)(2628)] = 21;
      _nw40[(int)(2629)] = 204;
      _nw40[(int)(2630)] = 204;
      _nw40[(int)(2631)] = 239;
      _nw40[(int)(2632)] = 225;
      _nw40[(int)(2633)] = 64;
      _nw40[(int)(2634)] = 200;
      _nw40[(int)(2635)] = 118;
      _nw40[(int)(2636)] = 175;
      _nw40[(int)(2637)] = 166;
      _nw40[(int)(2638)] = 184;
      _nw40[(int)(2639)] = 43;
      _nw40[(int)(2640)] = 247;
      _nw40[(int)(2641)] = 177;
      _nw40[(int)(2642)] = 219;
      _nw40[(int)(2643)] = 99;
      _nw40[(int)(2644)] = 88;
      _nw40[(int)(2645)] = 69;
      _nw40[(int)(2646)] = 220;
      _nw40[(int)(2647)] = 143;
      _nw40[(int)(2648)] = 126;
      _nw40[(int)(2649)] = 144;
      _nw40[(int)(2650)] = 34;
      _nw40[(int)(2651)] = 245;
      _nw40[(int)(2652)] = 237;
      _nw40[(int)(2653)] = 46;
      _nw40[(int)(2654)] = 202;
      _nw40[(int)(2655)] = 146;
      _nw40[(int)(2656)] = 211;
      _nw40[(int)(2657)] = 146;
      _nw40[(int)(2658)] = 160;
      _nw40[(int)(2659)] = 232;
      _nw40[(int)(2660)] = 171;
      _nw40[(int)(2661)] = 18;
      _nw40[(int)(2662)] = 175;
      _nw40[(int)(2663)] = 150;
      _nw40[(int)(2664)] = 236;
      _nw40[(int)(2665)] = 169;
      _nw40[(int)(2666)] = 42;
      _nw40[(int)(2667)] = 71;
      _nw40[(int)(2668)] = 154;
      _nw40[(int)(2669)] = 151;
      _nw40[(int)(2670)] = 101;
      _nw40[(int)(2671)] = 148;
      _nw40[(int)(2672)] = 101;
      _nw40[(int)(2673)] = 102;
      _nw40[(int)(2674)] = 224;
      _nw40[(int)(2675)] = 197;
      _nw40[(int)(2676)] = 45;
      _nw40[(int)(2677)] = 223;
      _nw40[(int)(2678)] = 243;
      _nw40[(int)(2679)] = 97;
      _nw40[(int)(2680)] = 205;
      _nw40[(int)(2681)] = 29;
      _nw40[(int)(2682)] = 107;
      _nw40[(int)(2683)] = 72;
      _nw40[(int)(2684)] = 0;
      _nw40[(int)(2685)] = 94;
      _nw40[(int)(2686)] = 141;
      _nw40[(int)(2687)] = 145;
      _nw40[(int)(2688)] = 241;
      _nw40[(int)(2689)] = 30;
      _nw40[(int)(2690)] = 166;
      _nw40[(int)(2691)] = 97;
      _nw40[(int)(2692)] = 61;
      _nw40[(int)(2693)] = 222;
      _nw40[(int)(2694)] = 49;
      _nw40[(int)(2695)] = 2;
      _nw40[(int)(2696)] = 105;
      _nw40[(int)(2697)] = 129;
      _nw40[(int)(2698)] = 43;
      _nw40[(int)(2699)] = 43;
      _nw40[(int)(2700)] = 48;
      _nw40[(int)(2701)] = 46;
      _nw40[(int)(2702)] = 158;
      _nw40[(int)(2703)] = 176;
      _nw40[(int)(2704)] = 208;
      _nw40[(int)(2705)] = 71;
      _nw40[(int)(2706)] = 14;
      _nw40[(int)(2707)] = 83;
      _nw40[(int)(2708)] = 234;
      _nw40[(int)(2709)] = 3;
      _nw40[(int)(2710)] = 87;
      _nw40[(int)(2711)] = 193;
      _nw40[(int)(2712)] = 148;
      _nw40[(int)(2713)] = 98;
      _nw40[(int)(2714)] = 61;
      _nw40[(int)(2715)] = 206;
      _nw40[(int)(2716)] = 100;
      _nw40[(int)(2717)] = 3;
      _nw40[(int)(2718)] = 32;
      _nw40[(int)(2719)] = 147;
      _nw40[(int)(2720)] = 85;
      _nw40[(int)(2721)] = 47;
      _nw40[(int)(2722)] = 209;
      _nw40[(int)(2723)] = 201;
      _nw40[(int)(2724)] = 251;
      _nw40[(int)(2725)] = 150;
      _nw40[(int)(2726)] = 199;
      _nw40[(int)(2727)] = 57;
      _nw40[(int)(2728)] = 97;
      _nw40[(int)(2729)] = 220;
      _nw40[(int)(2730)] = 18;
      _nw40[(int)(2731)] = 135;
      _nw40[(int)(2732)] = 190;
      _nw40[(int)(2733)] = 30;
      _nw40[(int)(2734)] = 203;
      _nw40[(int)(2735)] = 234;
      _nw40[(int)(2736)] = 187;
      _nw40[(int)(2737)] = 135;
      _nw40[(int)(2738)] = 48;
      _nw40[(int)(2739)] = 61;
      _nw40[(int)(2740)] = 53;
      _nw40[(int)(2741)] = 20;
      _nw40[(int)(2742)] = 172;
      _nw40[(int)(2743)] = 63;
      _nw40[(int)(2744)] = 100;
      _nw40[(int)(2745)] = 138;
      _nw40[(int)(2746)] = 207;
      _nw40[(int)(2747)] = 205;
      _nw40[(int)(2748)] = 141;
      _nw40[(int)(2749)] = 233;
      _nw40[(int)(2750)] = 185;
      _nw40[(int)(2751)] = 191;
      _nw40[(int)(2752)] = 191;
      _nw40[(int)(2753)] = 199;
      _nw40[(int)(2754)] = 112;
      _nw40[(int)(2755)] = 208;
      _nw40[(int)(2756)] = 224;
      _nw40[(int)(2757)] = 111;
      _nw40[(int)(2758)] = 138;
      _nw40[(int)(2759)] = 91;
      _nw40[(int)(2760)] = 201;
      _nw40[(int)(2761)] = 199;
      _nw40[(int)(2762)] = 90;
      _nw40[(int)(2763)] = 206;
      _nw40[(int)(2764)] = 139;
      _nw40[(int)(2765)] = 48;
      _nw40[(int)(2766)] = 161;
      _nw40[(int)(2767)] = 245;
      _nw40[(int)(2768)] = 160;
      _nw40[(int)(2769)] = 253;
      _nw40[(int)(2770)] = 75;
      _nw40[(int)(2771)] = 36;
      _nw40[(int)(2772)] = 12;
      _nw40[(int)(2773)] = 243;
      _nw40[(int)(2774)] = 182;
      _nw40[(int)(2775)] = 252;
      _nw40[(int)(2776)] = 254;
      _nw40[(int)(2777)] = 185;
      _nw40[(int)(2778)] = 223;
      _nw40[(int)(2779)] = 187;
      _nw40[(int)(2780)] = 254;
      _nw40[(int)(2781)] = 33;
      _nw40[(int)(2782)] = 99;
      _nw40[(int)(2783)] = 185;
      _nw40[(int)(2784)] = 111;
      _nw40[(int)(2785)] = 233;
      _nw40[(int)(2786)] = 101;
      _nw40[(int)(2787)] = 15;
      _nw40[(int)(2788)] = 140;
      _nw40[(int)(2789)] = 62;
      _nw40[(int)(2790)] = 172;
      _nw40[(int)(2791)] = 45;
      _nw40[(int)(2792)] = 38;
      _nw40[(int)(2793)] = 204;
      _nw40[(int)(2794)] = 200;
      _nw40[(int)(2795)] = 104;
      _nw40[(int)(2796)] = 111;
      _nw40[(int)(2797)] = 50;
      _nw40[(int)(2798)] = 64;
      _nw40[(int)(2799)] = 145;
      _nw40[(int)(2800)] = 51;
      _nw40[(int)(2801)] = 27;
      _nw40[(int)(2802)] = 203;
      _nw40[(int)(2803)] = 240;
      _nw40[(int)(2804)] = 122;
      _nw40[(int)(2805)] = 17;
      _nw40[(int)(2806)] = 70;
      _nw40[(int)(2807)] = 120;
      _nw40[(int)(2808)] = 1;
      _nw40[(int)(2809)] = 192;
      _nw40[(int)(2810)] = 161;
      _nw40[(int)(2811)] = 246;
      _nw40[(int)(2812)] = 120;
      _nw40[(int)(2813)] = 221;
      _nw40[(int)(2814)] = 56;
      _nw40[(int)(2815)] = 102;
      _nw40[(int)(2816)] = 226;
      _nw40[(int)(2817)] = 243;
      _nw40[(int)(2818)] = 151;
      _nw40[(int)(2819)] = 47;
      _nw40[(int)(2820)] = 252;
      _nw40[(int)(2821)] = 221;
      _nw40[(int)(2822)] = 122;
      _nw40[(int)(2823)] = 216;
      _nw40[(int)(2824)] = 38;
      _nw40[(int)(2825)] = 84;
      _nw40[(int)(2826)] = 189;
      _nw40[(int)(2827)] = 181;
      _nw40[(int)(2828)] = 163;
      _nw40[(int)(2829)] = 148;
      _nw40[(int)(2830)] = 228;
      _nw40[(int)(2831)] = 8;
      _nw40[(int)(2832)] = 94;
      _nw40[(int)(2833)] = 101;
      _nw40[(int)(2834)] = 198;
      _nw40[(int)(2835)] = 88;
      _nw40[(int)(2836)] = 98;
      _nw40[(int)(2837)] = 83;
      _nw40[(int)(2838)] = 203;
      _nw40[(int)(2839)] = 70;
      _nw40[(int)(2840)] = 154;
      _nw40[(int)(2841)] = 54;
      _nw40[(int)(2842)] = 209;
      _nw40[(int)(2843)] = 246;
      _nw40[(int)(2844)] = 67;
      _nw40[(int)(2845)] = 249;
      _nw40[(int)(2846)] = 57;
      _nw40[(int)(2847)] = 16;
      _nw40[(int)(2848)] = 201;
      _nw40[(int)(2849)] = 51;
      _nw40[(int)(2850)] = 124;
      _nw40[(int)(2851)] = 26;
      _nw40[(int)(2852)] = 49;
      _nw40[(int)(2853)] = 145;
      _nw40[(int)(2854)] = 66;
      _nw40[(int)(2855)] = 223;
      _nw40[(int)(2856)] = 248;
      _nw40[(int)(2857)] = 72;
      _nw40[(int)(2858)] = 175;
      _nw40[(int)(2859)] = 165;
      _nw40[(int)(2860)] = 134;
      _nw40[(int)(2861)] = 74;
      _nw40[(int)(2862)] = 92;
      _nw40[(int)(2863)] = 72;
      _nw40[(int)(2864)] = 48;
      _nw40[(int)(2865)] = 98;
      _nw40[(int)(2866)] = 114;
      _nw40[(int)(2867)] = 35;
      _nw40[(int)(2868)] = 85;
      _nw40[(int)(2869)] = 105;
      _nw40[(int)(2870)] = 148;
      _nw40[(int)(2871)] = 156;
      _nw40[(int)(2872)] = 103;
      _nw40[(int)(2873)] = 97;
      _nw40[(int)(2874)] = 169;
      _nw40[(int)(2875)] = 153;
      _nw40[(int)(2876)] = 235;
      _nw40[(int)(2877)] = 239;
      _nw40[(int)(2878)] = 191;
      _nw40[(int)(2879)] = 231;
      _nw40[(int)(2880)] = 225;
      _nw40[(int)(2881)] = 126;
      _nw40[(int)(2882)] = 36;
      _nw40[(int)(2883)] = 98;
      _nw40[(int)(2884)] = 56;
      _nw40[(int)(2885)] = 168;
      _nw40[(int)(2886)] = 134;
      _nw40[(int)(2887)] = 215;
      _nw40[(int)(2888)] = 58;
      _nw40[(int)(2889)] = 160;
      _nw40[(int)(2890)] = 149;
      _nw40[(int)(2891)] = 35;
      _nw40[(int)(2892)] = 130;
      _nw40[(int)(2893)] = 124;
      _nw40[(int)(2894)] = 240;
      _nw40[(int)(2895)] = 92;
      _nw40[(int)(2896)] = 107;
      _nw40[(int)(2897)] = 167;
      _nw40[(int)(2898)] = 144;
      _nw40[(int)(2899)] = 47;
      _nw40[(int)(2900)] = 129;
      _nw40[(int)(2901)] = 4;
      _nw40[(int)(2902)] = 82;
      _nw40[(int)(2903)] = 170;
      _nw40[(int)(2904)] = 34;
      _nw40[(int)(2905)] = 226;
      _nw40[(int)(2906)] = 171;
      _nw40[(int)(2907)] = 7;
      _nw40[(int)(2908)] = 123;
      _nw40[(int)(2909)] = 34;
      _nw40[(int)(2910)] = 128;
      _nw40[(int)(2911)] = 236;
      _nw40[(int)(2912)] = 162;
      _nw40[(int)(2913)] = 117;
      _nw40[(int)(2914)] = 108;
      _nw40[(int)(2915)] = 83;
      _nw40[(int)(2916)] = 100;
      _nw40[(int)(2917)] = 180;
      _nw40[(int)(2918)] = 226;
      _nw40[(int)(2919)] = 40;
      _nw40[(int)(2920)] = 251;
      _nw40[(int)(2921)] = 227;
      _nw40[(int)(2922)] = 173;
      _nw40[(int)(2923)] = 171;
      _nw40[(int)(2924)] = 196;
      _nw40[(int)(2925)] = 81;
      _nw40[(int)(2926)] = 82;
      _nw40[(int)(2927)] = 242;
      _nw40[(int)(2928)] = 148;
      _nw40[(int)(2929)] = 193;
      _nw40[(int)(2930)] = 10;
      _nw40[(int)(2931)] = 183;
      _nw40[(int)(2932)] = 51;
      _nw40[(int)(2933)] = 142;
      _nw40[(int)(2934)] = 82;
      _nw40[(int)(2935)] = 76;
      _nw40[(int)(2936)] = 112;
      _nw40[(int)(2937)] = 80;
      _nw40[(int)(2938)] = 206;
      _nw40[(int)(2939)] = 9;
      _nw40[(int)(2940)] = 237;
      _nw40[(int)(2941)] = 227;
      _nw40[(int)(2942)] = 10;
      _nw40[(int)(2943)] = 115;
      _nw40[(int)(2944)] = 182;
      _nw40[(int)(2945)] = 76;
      _nw40[(int)(2946)] = 89;
      _nw40[(int)(2947)] = 224;
      _nw40[(int)(2948)] = 184;
      _nw40[(int)(2949)] = 94;
      _nw40[(int)(2950)] = 13;
      _nw40[(int)(2951)] = 210;
      _nw40[(int)(2952)] = 219;
      _nw40[(int)(2953)] = 136;
      _nw40[(int)(2954)] = 116;
      _nw40[(int)(2955)] = 221;
      _nw40[(int)(2956)] = 59;
      _nw40[(int)(2957)] = 195;
      _nw40[(int)(2958)] = 76;
      _nw40[(int)(2959)] = 144;
      _nw40[(int)(2960)] = 46;
      _nw40[(int)(2961)] = 149;
      _nw40[(int)(2962)] = 59;
      _nw40[(int)(2963)] = 55;
      _nw40[(int)(2964)] = 243;
      _nw40[(int)(2965)] = 129;
      _nw40[(int)(2966)] = 199;
      _nw40[(int)(2967)] = 46;
      _nw40[(int)(2968)] = 180;
      _nw40[(int)(2969)] = 164;
      _nw40[(int)(2970)] = 21;
      _nw40[(int)(2971)] = 0;
      _nw40[(int)(2972)] = 48;
      _nw40[(int)(2973)] = 56;
      _nw40[(int)(2974)] = 201;
      _nw40[(int)(2975)] = 67;
      _nw40[(int)(2976)] = 30;
      _nw40[(int)(2977)] = 190;
      _nw40[(int)(2978)] = 145;
      _nw40[(int)(2979)] = 161;
      _nw40[(int)(2980)] = 130;
      _nw40[(int)(2981)] = 124;
      _nw40[(int)(2982)] = 248;
      _nw40[(int)(2983)] = 29;
      _nw40[(int)(2984)] = 103;
      _nw40[(int)(2985)] = 111;
      _nw40[(int)(2986)] = 14;
      _nw40[(int)(2987)] = 113;
      _nw40[(int)(2988)] = 16;
      _nw40[(int)(2989)] = 54;
      _nw40[(int)(2990)] = 246;
      _nw40[(int)(2991)] = 60;
      _nw40[(int)(2992)] = 1;
      _nw40[(int)(2993)] = 202;
      _nw40[(int)(2994)] = 143;
      _nw40[(int)(2995)] = 67;
      _nw40[(int)(2996)] = 253;
      _nw40[(int)(2997)] = 183;
      _nw40[(int)(2998)] = 141;
      _nw40[(int)(2999)] = 247;
      _nw40[(int)(3000)] = 82;
      _nw40[(int)(3001)] = 84;
      _nw40[(int)(3002)] = 33;
      _nw40[(int)(3003)] = 155;
      _nw40[(int)(3004)] = 177;
      _nw40[(int)(3005)] = 95;
      _nw40[(int)(3006)] = 64;
      _nw40[(int)(3007)] = 132;
      _nw40[(int)(3008)] = 187;
      _nw40[(int)(3009)] = 210;
      _nw40[(int)(3010)] = 167;
      _nw40[(int)(3011)] = 26;
      _nw40[(int)(3012)] = 211;
      _nw40[(int)(3013)] = 170;
      _nw40[(int)(3014)] = 238;
      _nw40[(int)(3015)] = 182;
      _nw40[(int)(3016)] = 239;
      _nw40[(int)(3017)] = 64;
      _nw40[(int)(3018)] = 191;
      _nw40[(int)(3019)] = 31;
      _nw40[(int)(3020)] = 71;
      _nw40[(int)(3021)] = 61;
      _nw40[(int)(3022)] = 186;
      _nw40[(int)(3023)] = 145;
      _nw40[(int)(3024)] = 168;
      _nw40[(int)(3025)] = 133;
      _nw40[(int)(3026)] = 42;
      _nw40[(int)(3027)] = 19;
      _nw40[(int)(3028)] = 20;
      _nw40[(int)(3029)] = 242;
      _nw40[(int)(3030)] = 220;
      _nw40[(int)(3031)] = 132;
      _nw40[(int)(3032)] = 159;
      _nw40[(int)(3033)] = 235;
      _nw40[(int)(3034)] = 202;
      _nw40[(int)(3035)] = 151;
      _nw40[(int)(3036)] = 230;
      _nw40[(int)(3037)] = 219;
      _nw40[(int)(3038)] = 62;
      _nw40[(int)(3039)] = 57;
      _nw40[(int)(3040)] = 20;
      _nw40[(int)(3041)] = 230;
      _nw40[(int)(3042)] = 153;
      _nw40[(int)(3043)] = 229;
      _nw40[(int)(3044)] = 128;
      _nw40[(int)(3045)] = 20;
      _nw40[(int)(3046)] = 32;
      _nw40[(int)(3047)] = 228;
      _nw40[(int)(3048)] = 11;
      _nw40[(int)(3049)] = 179;
      _nw40[(int)(3050)] = 50;
      _nw40[(int)(3051)] = 90;
      _nw40[(int)(3052)] = 158;
      _nw40[(int)(3053)] = 105;
      _nw40[(int)(3054)] = 167;
      _nw40[(int)(3055)] = 76;
      _nw40[(int)(3056)] = 140;
      _nw40[(int)(3057)] = 183;
      _nw40[(int)(3058)] = 31;
      _nw40[(int)(3059)] = 159;
      _nw40[(int)(3060)] = 183;
      _nw40[(int)(3061)] = 44;
      _nw40[(int)(3062)] = 130;
      _nw40[(int)(3063)] = 32;
      _nw40[(int)(3064)] = 146;
      _nw40[(int)(3065)] = 240;
      _nw40[(int)(3066)] = 13;
      _nw40[(int)(3067)] = 57;
      _nw40[(int)(3068)] = 151;
      _nw40[(int)(3069)] = 65;
      _nw40[(int)(3070)] = 60;
      _nw40[(int)(3071)] = 180;
      _nw40[(int)(3072)] = 161;
      _nw40[(int)(3073)] = 96;
      _nw40[(int)(3074)] = 103;
      _nw40[(int)(3075)] = 8;
      _nw40[(int)(3076)] = 68;
      _nw40[(int)(3077)] = 204;
      _nw40[(int)(3078)] = 156;
      _nw40[(int)(3079)] = 202;
      _nw40[(int)(3080)] = 11;
      _nw40[(int)(3081)] = 68;
      _nw40[(int)(3082)] = 182;
      _nw40[(int)(3083)] = 177;
      _nw40[(int)(3084)] = 53;
      _nw40[(int)(3085)] = 73;
      _nw40[(int)(3086)] = 204;
      _nw40[(int)(3087)] = 167;
      _nw40[(int)(3088)] = 175;
      _nw40[(int)(3089)] = 193;
      _nw40[(int)(3090)] = 20;
      _nw40[(int)(3091)] = 1;
      _nw40[(int)(3092)] = 170;
      _nw40[(int)(3093)] = 111;
      _nw40[(int)(3094)] = 249;
      _nw40[(int)(3095)] = 29;
      _nw40[(int)(3096)] = 142;
      _nw40[(int)(3097)] = 198;
      _nw40[(int)(3098)] = 30;
      _nw40[(int)(3099)] = 147;
      _nw40[(int)(3100)] = 25;
      _nw40[(int)(3101)] = 241;
      _nw40[(int)(3102)] = 3;
      _nw40[(int)(3103)] = 22;
      _nw40[(int)(3104)] = 147;
      _nw40[(int)(3105)] = 72;
      _nw40[(int)(3106)] = 123;
      _nw40[(int)(3107)] = 245;
      _nw40[(int)(3108)] = 109;
      _nw40[(int)(3109)] = 181;
      _nw40[(int)(3110)] = 67;
      _nw40[(int)(3111)] = 162;
      _nw40[(int)(3112)] = 164;
      _nw40[(int)(3113)] = 154;
      _nw40[(int)(3114)] = 71;
      _nw40[(int)(3115)] = 28;
      _nw40[(int)(3116)] = 48;
      _nw40[(int)(3117)] = 11;
      _nw40[(int)(3118)] = 204;
      _nw40[(int)(3119)] = 2;
      _nw40[(int)(3120)] = 143;
      _nw40[(int)(3121)] = 150;
      _nw40[(int)(3122)] = 6;
      _nw40[(int)(3123)] = 72;
      _nw40[(int)(3124)] = 9;
      _nw40[(int)(3125)] = 108;
      _nw40[(int)(3126)] = 187;
      _nw40[(int)(3127)] = 16;
      _nw40[(int)(3128)] = 209;
      _nw40[(int)(3129)] = 184;
      _nw40[(int)(3130)] = 1;
      _nw40[(int)(3131)] = 183;
      _nw40[(int)(3132)] = 131;
      _nw40[(int)(3133)] = 219;
      _nw40[(int)(3134)] = 118;
      _nw40[(int)(3135)] = 1;
      _nw40[(int)(3136)] = 61;
      _nw40[(int)(3137)] = 12;
      _nw40[(int)(3138)] = 60;
      _nw40[(int)(3139)] = 187;
      _nw40[(int)(3140)] = 47;
      _nw40[(int)(3141)] = 30;
      _nw40[(int)(3142)] = 1;
      _nw40[(int)(3143)] = 154;
      _nw40[(int)(3144)] = 234;
      _nw40[(int)(3145)] = 127;
      _nw40[(int)(3146)] = 23;
      _nw40[(int)(3147)] = 194;
      _nw40[(int)(3148)] = 199;
      _nw40[(int)(3149)] = 194;
      _nw40[(int)(3150)] = 204;
      _nw40[(int)(3151)] = 226;
      _nw40[(int)(3152)] = 124;
      _nw40[(int)(3153)] = 222;
      _nw40[(int)(3154)] = 166;
      _nw40[(int)(3155)] = 249;
      _nw40[(int)(3156)] = 88;
      _nw40[(int)(3157)] = 54;
      _nw40[(int)(3158)] = 191;
      _nw40[(int)(3159)] = 118;
      _nw40[(int)(3160)] = 221;
      _nw40[(int)(3161)] = 27;
      _nw40[(int)(3162)] = 238;
      _nw40[(int)(3163)] = 61;
      _nw40[(int)(3164)] = 134;
      _nw40[(int)(3165)] = 23;
      _nw40[(int)(3166)] = 175;
      _nw40[(int)(3167)] = 218;
      _nw40[(int)(3168)] = 197;
      _nw40[(int)(3169)] = 42;
      _nw40[(int)(3170)] = 210;
      _nw40[(int)(3171)] = 43;
      _nw40[(int)(3172)] = 179;
      _nw40[(int)(3173)] = 250;
      _nw40[(int)(3174)] = 0;
      _nw40[(int)(3175)] = 245;
      _nw40[(int)(3176)] = 102;
      _nw40[(int)(3177)] = 222;
      _nw40[(int)(3178)] = 196;
      _nw40[(int)(3179)] = 95;
      _nw40[(int)(3180)] = 250;
      _nw40[(int)(3181)] = 62;
      _nw40[(int)(3182)] = 152;
      _nw40[(int)(3183)] = 49;
      _nw40[(int)(3184)] = 131;
      _nw40[(int)(3185)] = 181;
      _nw40[(int)(3186)] = 121;
      _nw40[(int)(3187)] = 77;
      _nw40[(int)(3188)] = 23;
      _nw40[(int)(3189)] = 50;
      _nw40[(int)(3190)] = 244;
      _nw40[(int)(3191)] = 106;
      _nw40[(int)(3192)] = 205;
      _nw40[(int)(3193)] = 227;
      _nw40[(int)(3194)] = 163;
      _nw40[(int)(3195)] = 221;
      _nw40[(int)(3196)] = 250;
      _nw40[(int)(3197)] = 232;
      _nw40[(int)(3198)] = 106;
      _nw40[(int)(3199)] = 230;
      _nw40[(int)(3200)] = 62;
      _nw40[(int)(3201)] = 134;
      _nw40[(int)(3202)] = 235;
      _nw40[(int)(3203)] = 121;
      _nw40[(int)(3204)] = 225;
      _nw40[(int)(3205)] = 253;
      _nw40[(int)(3206)] = 210;
      _nw40[(int)(3207)] = 123;
      _nw40[(int)(3208)] = 204;
      _nw40[(int)(3209)] = 57;
      _nw40[(int)(3210)] = 218;
      _nw40[(int)(3211)] = 6;
      _nw40[(int)(3212)] = 228;
      _nw40[(int)(3213)] = 128;
      _nw40[(int)(3214)] = 9;
      _nw40[(int)(3215)] = 13;
      _nw40[(int)(3216)] = 245;
      _nw40[(int)(3217)] = 98;
      _nw40[(int)(3218)] = 218;
      _nw40[(int)(3219)] = 158;
      _nw40[(int)(3220)] = 229;
      _nw40[(int)(3221)] = 137;
      _nw40[(int)(3222)] = 238;
      _nw40[(int)(3223)] = 231;
      _nw40[(int)(3224)] = 13;
      _nw40[(int)(3225)] = 197;
      _nw40[(int)(3226)] = 185;
      _nw40[(int)(3227)] = 214;
      _nw40[(int)(3228)] = 136;
      _nw40[(int)(3229)] = 249;
      _nw40[(int)(3230)] = 173;
      _nw40[(int)(3231)] = 108;
      _nw40[(int)(3232)] = 236;
      _nw40[(int)(3233)] = 122;
      _nw40[(int)(3234)] = 0;
      _nw40[(int)(3235)] = 70;
      _nw40[(int)(3236)] = 154;
      _nw40[(int)(3237)] = 216;
      _nw40[(int)(3238)] = 73;
      _nw40[(int)(3239)] = 195;
      _nw40[(int)(3240)] = 64;
      _nw40[(int)(3241)] = 195;
      _nw40[(int)(3242)] = 75;
      _nw40[(int)(3243)] = 204;
      _nw40[(int)(3244)] = 33;
      _nw40[(int)(3245)] = 188;
      _nw40[(int)(3246)] = 49;
      _nw40[(int)(3247)] = 244;
      _nw40[(int)(3248)] = 238;
      _nw40[(int)(3249)] = 203;
      _nw40[(int)(3250)] = 100;
      _nw40[(int)(3251)] = 137;
      _nw40[(int)(3252)] = 9;
      _nw40[(int)(3253)] = 102;
      _nw40[(int)(3254)] = 65;
      _nw40[(int)(3255)] = 109;
      _nw40[(int)(3256)] = 56;
      _nw40[(int)(3257)] = 211;
      _nw40[(int)(3258)] = 159;
      _nw40[(int)(3259)] = 204;
      _nw40[(int)(3260)] = 80;
      _nw40[(int)(3261)] = 109;
      _nw40[(int)(3262)] = 237;
      _nw40[(int)(3263)] = 106;
      _nw40[(int)(3264)] = 203;
      _nw40[(int)(3265)] = 41;
      _nw40[(int)(3266)] = 114;
      _nw40[(int)(3267)] = 50;
      _nw40[(int)(3268)] = 80;
      _nw40[(int)(3269)] = 65;
      _nw40[(int)(3270)] = 189;
      _nw40[(int)(3271)] = 52;
      _nw40[(int)(3272)] = 143;
      _nw40[(int)(3273)] = 97;
      _nw40[(int)(3274)] = 126;
      _nw40[(int)(3275)] = 61;
      _nw40[(int)(3276)] = 211;
      _nw40[(int)(3277)] = 99;
      _nw40[(int)(3278)] = 207;
      _nw40[(int)(3279)] = 82;
      _nw40[(int)(3280)] = 150;
      _nw40[(int)(3281)] = 91;
      _nw40[(int)(3282)] = 10;
      _nw40[(int)(3283)] = 35;
      _nw40[(int)(3284)] = 248;
      _nw40[(int)(3285)] = 10;
      _nw40[(int)(3286)] = 26;
      _nw40[(int)(3287)] = 191;
      _nw40[(int)(3288)] = 154;
      _nw40[(int)(3289)] = 177;
      _nw40[(int)(3290)] = 166;
      _nw40[(int)(3291)] = 156;
      _nw40[(int)(3292)] = 25;
      _nw40[(int)(3293)] = 127;
      _nw40[(int)(3294)] = 135;
      _nw40[(int)(3295)] = 193;
      _nw40[(int)(3296)] = 233;
      _nw40[(int)(3297)] = 15;
      _nw40[(int)(3298)] = 173;
      _nw40[(int)(3299)] = 208;
      _nw40[(int)(3300)] = 73;
      _nw40[(int)(3301)] = 11;
      _nw40[(int)(3302)] = 150;
      _nw40[(int)(3303)] = 25;
      _nw40[(int)(3304)] = 26;
      _nw40[(int)(3305)] = 29;
      _nw40[(int)(3306)] = 73;
      _nw40[(int)(3307)] = 141;
      _nw40[(int)(3308)] = 142;
      _nw40[(int)(3309)] = 147;
      _nw40[(int)(3310)] = 165;
      _nw40[(int)(3311)] = 109;
      _nw40[(int)(3312)] = 30;
      _nw40[(int)(3313)] = 58;
      _nw40[(int)(3314)] = 226;
      _nw40[(int)(3315)] = 226;
      _nw40[(int)(3316)] = 114;
      _nw40[(int)(3317)] = 128;
      _nw40[(int)(3318)] = 146;
      _nw40[(int)(3319)] = 59;
      _nw40[(int)(3320)] = 168;
      _nw40[(int)(3321)] = 6;
      _nw40[(int)(3322)] = 166;
      _nw40[(int)(3323)] = 94;
      _nw40[(int)(3324)] = 173;
      _nw40[(int)(3325)] = 53;
      _nw40[(int)(3326)] = 182;
      _nw40[(int)(3327)] = 178;
      _nw40[(int)(3328)] = 217;
      _nw40[(int)(3329)] = 238;
      _nw40[(int)(3330)] = 237;
      _nw40[(int)(3331)] = 0;
      _nw40[(int)(3332)] = 181;
      _nw40[(int)(3333)] = 161;
      _nw40[(int)(3334)] = 226;
      _nw40[(int)(3335)] = 15;
      _nw40[(int)(3336)] = 6;
      _nw40[(int)(3337)] = 225;
      _nw40[(int)(3338)] = 231;
      _nw40[(int)(3339)] = 180;
      _nw40[(int)(3340)] = 45;
      _nw40[(int)(3341)] = 62;
      _nw40[(int)(3342)] = 41;
      _nw40[(int)(3343)] = 186;
      _nw40[(int)(3344)] = 174;
      _nw40[(int)(3345)] = 29;
      _nw40[(int)(3346)] = 58;
      _nw40[(int)(3347)] = 89;
      _nw40[(int)(3348)] = 93;
      _nw40[(int)(3349)] = 239;
      _nw40[(int)(3350)] = 235;
      _nw40[(int)(3351)] = 210;
      _nw40[(int)(3352)] = 184;
      _nw40[(int)(3353)] = 20;
      _nw40[(int)(3354)] = 172;
      _nw40[(int)(3355)] = 82;
      _nw40[(int)(3356)] = 28;
      _nw40[(int)(3357)] = 90;
      _nw40[(int)(3358)] = 189;
      _nw40[(int)(3359)] = 232;
      _nw40[(int)(3360)] = 136;
      _nw40[(int)(3361)] = 72;
      _nw40[(int)(3362)] = 199;
      _nw40[(int)(3363)] = 222;
      _nw40[(int)(3364)] = 73;
      _nw40[(int)(3365)] = 202;
      _nw40[(int)(3366)] = 226;
      _nw40[(int)(3367)] = 11;
      _nw40[(int)(3368)] = 54;
      _nw40[(int)(3369)] = 127;
      _nw40[(int)(3370)] = 180;
      _nw40[(int)(3371)] = 169;
      _nw40[(int)(3372)] = 171;
      _nw40[(int)(3373)] = 70;
      _nw40[(int)(3374)] = 241;
      _nw40[(int)(3375)] = 127;
      _nw40[(int)(3376)] = 54;
      _nw40[(int)(3377)] = 10;
      _nw40[(int)(3378)] = 188;
      _nw40[(int)(3379)] = 18;
      _nw40[(int)(3380)] = 52;
      _nw40[(int)(3381)] = 179;
      _nw40[(int)(3382)] = 174;
      _nw40[(int)(3383)] = 41;
      _nw40[(int)(3384)] = 240;
      _nw40[(int)(3385)] = 214;
      _nw40[(int)(3386)] = 15;
      _nw40[(int)(3387)] = 3;
      _nw40[(int)(3388)] = 202;
      _nw40[(int)(3389)] = 144;
      _nw40[(int)(3390)] = 47;
      _nw40[(int)(3391)] = 170;
      _nw40[(int)(3392)] = 8;
      _nw40[(int)(3393)] = 230;
      _nw40[(int)(3394)] = 76;
      _nw40[(int)(3395)] = 202;
      _nw40[(int)(3396)] = 220;
      _nw40[(int)(3397)] = 151;
      _nw40[(int)(3398)] = 200;
      _nw40[(int)(3399)] = 155;
      _nw40[(int)(3400)] = 194;
      _nw40[(int)(3401)] = 211;
      _nw40[(int)(3402)] = 78;
      _nw40[(int)(3403)] = 4;
      _nw40[(int)(3404)] = 79;
      _nw40[(int)(3405)] = 107;
      _nw40[(int)(3406)] = 135;
      _nw40[(int)(3407)] = 10;
      _nw40[(int)(3408)] = 114;
      _nw40[(int)(3409)] = 195;
      _nw40[(int)(3410)] = 97;
      _nw40[(int)(3411)] = 80;
      _nw40[(int)(3412)] = 158;
      _nw40[(int)(3413)] = 160;
      _nw40[(int)(3414)] = 39;
      _nw40[(int)(3415)] = 159;
      _nw40[(int)(3416)] = 191;
      _nw40[(int)(3417)] = 12;
      _nw40[(int)(3418)] = 203;
      _nw40[(int)(3419)] = 8;
      _nw40[(int)(3420)] = 144;
      _nw40[(int)(3421)] = 0;
      _nw40[(int)(3422)] = 65;
      _nw40[(int)(3423)] = 65;
      _nw40[(int)(3424)] = 199;
      _nw40[(int)(3425)] = 187;
      _nw40[(int)(3426)] = 239;
      _nw40[(int)(3427)] = 153;
      _nw40[(int)(3428)] = 142;
      _nw40[(int)(3429)] = 22;
      _nw40[(int)(3430)] = 189;
      _nw40[(int)(3431)] = 24;
      _nw40[(int)(3432)] = 29;
      _nw40[(int)(3433)] = 14;
      _nw40[(int)(3434)] = 64;
      _nw40[(int)(3435)] = 129;
      _nw40[(int)(3436)] = 12;
      _nw40[(int)(3437)] = 145;
      _nw40[(int)(3438)] = 145;
      _nw40[(int)(3439)] = 129;
      _nw40[(int)(3440)] = 49;
      _nw40[(int)(3441)] = 40;
      _nw40[(int)(3442)] = 240;
      _nw40[(int)(3443)] = 223;
      _nw40[(int)(3444)] = 128;
      _nw40[(int)(3445)] = 201;
      _nw40[(int)(3446)] = 26;
      _nw40[(int)(3447)] = 182;
      _nw40[(int)(3448)] = 61;
      _nw40[(int)(3449)] = 174;
      _nw40[(int)(3450)] = 225;
      _nw40[(int)(3451)] = 1;
      _nw40[(int)(3452)] = 223;
      _nw40[(int)(3453)] = 171;
      _nw40[(int)(3454)] = 59;
      _nw40[(int)(3455)] = 159;
      _nw40[(int)(3456)] = 201;
      _nw40[(int)(3457)] = 74;
      _nw40[(int)(3458)] = 11;
      _nw40[(int)(3459)] = 204;
      _nw40[(int)(3460)] = 192;
      _nw40[(int)(3461)] = 93;
      _nw40[(int)(3462)] = 175;
      _nw40[(int)(3463)] = 109;
      _nw40[(int)(3464)] = 89;
      _nw40[(int)(3465)] = 186;
      _nw40[(int)(3466)] = 74;
      _nw40[(int)(3467)] = 148;
      _nw40[(int)(3468)] = 19;
      _nw40[(int)(3469)] = 207;
      _nw40[(int)(3470)] = 215;
      _nw40[(int)(3471)] = 60;
      _nw40[(int)(3472)] = 94;
      _nw40[(int)(3473)] = 188;
      _nw40[(int)(3474)] = 184;
      _nw40[(int)(3475)] = 87;
      _nw40[(int)(3476)] = 31;
      _nw40[(int)(3477)] = 170;
      _nw40[(int)(3478)] = 170;
      _nw40[(int)(3479)] = 200;
      _nw40[(int)(3480)] = 43;
      _nw40[(int)(3481)] = 193;
      _nw40[(int)(3482)] = 231;
      _nw40[(int)(3483)] = 116;
      _nw40[(int)(3484)] = 166;
      _nw40[(int)(3485)] = 2;
      _nw40[(int)(3486)] = 84;
      _nw40[(int)(3487)] = 77;
      _nw40[(int)(3488)] = 136;
      _nw40[(int)(3489)] = 177;
      _nw40[(int)(3490)] = 196;
      _nw40[(int)(3491)] = 19;
      _nw40[(int)(3492)] = 231;
      _nw40[(int)(3493)] = 169;
      _nw40[(int)(3494)] = 37;
      _nw40[(int)(3495)] = 139;
      _nw40[(int)(3496)] = 234;
      _nw40[(int)(3497)] = 103;
      _nw40[(int)(3498)] = 196;
      _nw40[(int)(3499)] = 47;
      _nw40[(int)(3500)] = 201;
      _nw40[(int)(3501)] = 140;
      _nw40[(int)(3502)] = 19;
      _nw40[(int)(3503)] = 80;
      _nw40[(int)(3504)] = 217;
      _nw40[(int)(3505)] = 202;
      _nw40[(int)(3506)] = 212;
      _nw40[(int)(3507)] = 19;
      _nw40[(int)(3508)] = 113;
      _nw40[(int)(3509)] = 208;
      _nw40[(int)(3510)] = 250;
      _nw40[(int)(3511)] = 49;
      _nw40[(int)(3512)] = 155;
      _nw40[(int)(3513)] = 47;
      _nw40[(int)(3514)] = 62;
      _nw40[(int)(3515)] = 119;
      _nw40[(int)(3516)] = 86;
      _nw40[(int)(3517)] = 36;
      _nw40[(int)(3518)] = 206;
      _nw40[(int)(3519)] = 139;
      _nw40[(int)(3520)] = 99;
      _nw40[(int)(3521)] = 18;
      _nw40[(int)(3522)] = 225;
      _nw40[(int)(3523)] = 41;
      _nw40[(int)(3524)] = 11;
      _nw40[(int)(3525)] = 37;
      _nw40[(int)(3526)] = 231;
      _nw40[(int)(3527)] = 220;
      _nw40[(int)(3528)] = 3;
      _nw40[(int)(3529)] = 189;
      _nw40[(int)(3530)] = 248;
      _nw40[(int)(3531)] = 198;
      _nw40[(int)(3532)] = 187;
      _nw40[(int)(3533)] = 123;
      _nw40[(int)(3534)] = 46;
      _nw40[(int)(3535)] = 7;
      _nw40[(int)(3536)] = 26;
      _nw40[(int)(3537)] = 160;
      _nw40[(int)(3538)] = 122;
      _nw40[(int)(3539)] = 227;
      _nw40[(int)(3540)] = 11;
      _nw40[(int)(3541)] = 71;
      _nw40[(int)(3542)] = 169;
      _nw40[(int)(3543)] = 210;
      _nw40[(int)(3544)] = 82;
      _nw40[(int)(3545)] = 62;
      _nw40[(int)(3546)] = 40;
      _nw40[(int)(3547)] = 133;
      _nw40[(int)(3548)] = 2;
      _nw40[(int)(3549)] = 58;
      _nw40[(int)(3550)] = 88;
      _nw40[(int)(3551)] = 177;
      _nw40[(int)(3552)] = 245;
      _nw40[(int)(3553)] = 84;
      _nw40[(int)(3554)] = 74;
      _nw40[(int)(3555)] = 33;
      _nw40[(int)(3556)] = 70;
      _nw40[(int)(3557)] = 146;
      _nw40[(int)(3558)] = 209;
      _nw40[(int)(3559)] = 67;
      _nw40[(int)(3560)] = 170;
      _nw40[(int)(3561)] = 38;
      _nw40[(int)(3562)] = 248;
      _nw40[(int)(3563)] = 134;
      _nw40[(int)(3564)] = 133;
      _nw40[(int)(3565)] = 137;
      _nw40[(int)(3566)] = 111;
      _nw40[(int)(3567)] = 82;
      _nw40[(int)(3568)] = 189;
      _nw40[(int)(3569)] = 205;
      _nw40[(int)(3570)] = 119;
      _nw40[(int)(3571)] = 37;
      _nw40[(int)(3572)] = 138;
      _nw40[(int)(3573)] = 173;
      _nw40[(int)(3574)] = 97;
      _nw40[(int)(3575)] = 220;
      _nw40[(int)(3576)] = 110;
      _nw40[(int)(3577)] = 131;
      _nw40[(int)(3578)] = 39;
      _nw40[(int)(3579)] = 51;
      _nw40[(int)(3580)] = 179;
      _nw40[(int)(3581)] = 80;
      _nw40[(int)(3582)] = 238;
      _nw40[(int)(3583)] = 111;
      _nw40[(int)(3584)] = 41;
      _nw40[(int)(3585)] = 47;
      _nw40[(int)(3586)] = 100;
      _nw40[(int)(3587)] = 82;
      _nw40[(int)(3588)] = 102;
      _nw40[(int)(3589)] = 226;
      _nw40[(int)(3590)] = 191;
      _nw40[(int)(3591)] = 244;
      _nw40[(int)(3592)] = 106;
      _nw40[(int)(3593)] = 26;
      _nw40[(int)(3594)] = 21;
      _nw40[(int)(3595)] = 81;
      _nw40[(int)(3596)] = 203;
      _nw40[(int)(3597)] = 54;
      _nw40[(int)(3598)] = 182;
      _nw40[(int)(3599)] = 88;
      _nw40[(int)(3600)] = 112;
      _nw40[(int)(3601)] = 153;
      _nw40[(int)(3602)] = 195;
      _nw40[(int)(3603)] = 82;
      _nw40[(int)(3604)] = 29;
      _nw40[(int)(3605)] = 182;
      _nw40[(int)(3606)] = 181;
      _nw40[(int)(3607)] = 56;
      _nw40[(int)(3608)] = 102;
      _nw40[(int)(3609)] = 230;
      _nw40[(int)(3610)] = 255;
      _nw40[(int)(3611)] = 245;
      _nw40[(int)(3612)] = 37;
      _nw40[(int)(3613)] = 145;
      _nw40[(int)(3614)] = 199;
      _nw40[(int)(3615)] = 62;
      _nw40[(int)(3616)] = 84;
      _nw40[(int)(3617)] = 201;
      _nw40[(int)(3618)] = 155;
      _nw40[(int)(3619)] = 19;
      _nw40[(int)(3620)] = 186;
      _nw40[(int)(3621)] = 75;
      _nw40[(int)(3622)] = 218;
      _nw40[(int)(3623)] = 57;
      _nw40[(int)(3624)] = 210;
      _nw40[(int)(3625)] = 210;
      _nw40[(int)(3626)] = 91;
      _nw40[(int)(3627)] = 163;
      _nw40[(int)(3628)] = 20;
      _nw40[(int)(3629)] = 133;
      _nw40[(int)(3630)] = 8;
      _nw40[(int)(3631)] = 120;
      _nw40[(int)(3632)] = 150;
      _nw40[(int)(3633)] = 20;
      _nw40[(int)(3634)] = 142;
      _nw40[(int)(3635)] = 4;
      _nw40[(int)(3636)] = 125;
      _nw40[(int)(3637)] = 233;
      _nw40[(int)(3638)] = 42;
      _nw40[(int)(3639)] = 248;
      _nw40[(int)(3640)] = 116;
      _nw40[(int)(3641)] = 117;
      _nw40[(int)(3642)] = 94;
      _nw40[(int)(3643)] = 133;
      _nw40[(int)(3644)] = 70;
      _nw40[(int)(3645)] = 7;
      _nw40[(int)(3646)] = 63;
      _nw40[(int)(3647)] = 114;
      _nw40[(int)(3648)] = 197;
      _nw40[(int)(3649)] = 67;
      _nw40[(int)(3650)] = 39;
      _nw40[(int)(3651)] = 222;
      _nw40[(int)(3652)] = 122;
      _nw40[(int)(3653)] = 234;
      _nw40[(int)(3654)] = 104;
      _nw40[(int)(3655)] = 125;
      _nw40[(int)(3656)] = 232;
      _nw40[(int)(3657)] = 122;
      _nw40[(int)(3658)] = 143;
      _nw40[(int)(3659)] = 195;
      _nw40[(int)(3660)] = 45;
      _nw40[(int)(3661)] = 157;
      _nw40[(int)(3662)] = 114;
      _nw40[(int)(3663)] = 176;
      _nw40[(int)(3664)] = 82;
      _nw40[(int)(3665)] = 229;
      _nw40[(int)(3666)] = 54;
      _nw40[(int)(3667)] = 250;
      _nw40[(int)(3668)] = 135;
      _nw40[(int)(3669)] = 1;
      _nw40[(int)(3670)] = 52;
      _nw40[(int)(3671)] = 55;
      _nw40[(int)(3672)] = 18;
      _nw40[(int)(3673)] = 138;
      _nw40[(int)(3674)] = 116;
      _nw40[(int)(3675)] = 134;
      _nw40[(int)(3676)] = 31;
      _nw40[(int)(3677)] = 74;
      _nw40[(int)(3678)] = 64;
      _nw40[(int)(3679)] = 43;
      _nw40[(int)(3680)] = 209;
      _nw40[(int)(3681)] = 254;
      _nw40[(int)(3682)] = 34;
      _nw40[(int)(3683)] = 111;
      _nw40[(int)(3684)] = 92;
      _nw40[(int)(3685)] = 200;
      _nw40[(int)(3686)] = 10;
      _nw40[(int)(3687)] = 140;
      _nw40[(int)(3688)] = 49;
      _nw40[(int)(3689)] = 67;
      _nw40[(int)(3690)] = 18;
      _nw40[(int)(3691)] = 114;
      _nw40[(int)(3692)] = 100;
      _nw40[(int)(3693)] = 189;
      _nw40[(int)(3694)] = 107;
      _nw40[(int)(3695)] = 231;
      _nw40[(int)(3696)] = 23;
      _nw40[(int)(3697)] = 114;
      _nw40[(int)(3698)] = 227;
      _nw40[(int)(3699)] = 253;
      _nw40[(int)(3700)] = 127;
      _nw40[(int)(3701)] = 246;
      _nw40[(int)(3702)] = 129;
      _nw40[(int)(3703)] = 118;
      _nw40[(int)(3704)] = 169;
      _nw40[(int)(3705)] = 67;
      _nw40[(int)(3706)] = 221;
      _nw40[(int)(3707)] = 82;
      _nw40[(int)(3708)] = 93;
      _nw40[(int)(3709)] = 188;
      _nw40[(int)(3710)] = 59;
      _nw40[(int)(3711)] = 247;
      _nw40[(int)(3712)] = 160;
      _nw40[(int)(3713)] = 148;
      _nw40[(int)(3714)] = 206;
      _nw40[(int)(3715)] = 214;
      _nw40[(int)(3716)] = 192;
      _nw40[(int)(3717)] = 220;
      _nw40[(int)(3718)] = 177;
      _nw40[(int)(3719)] = 160;
      _nw40[(int)(3720)] = 222;
      _nw40[(int)(3721)] = 130;
      _nw40[(int)(3722)] = 229;
      _nw40[(int)(3723)] = 165;
      _nw40[(int)(3724)] = 39;
      _nw40[(int)(3725)] = 49;
      _nw40[(int)(3726)] = 3;
      _nw40[(int)(3727)] = 173;
      _nw40[(int)(3728)] = 100;
      _nw40[(int)(3729)] = 148;
      _nw40[(int)(3730)] = 119;
      _nw40[(int)(3731)] = 124;
      _nw40[(int)(3732)] = 211;
      _nw40[(int)(3733)] = 223;
      _nw40[(int)(3734)] = 138;
      _nw40[(int)(3735)] = 142;
      _nw40[(int)(3736)] = 149;
      _nw40[(int)(3737)] = 32;
      _nw40[(int)(3738)] = 217;
      _nw40[(int)(3739)] = 135;
      _nw40[(int)(3740)] = 173;
      _nw40[(int)(3741)] = 39;
      _nw40[(int)(3742)] = 68;
      _nw40[(int)(3743)] = 196;
      _nw40[(int)(3744)] = 97;
      _nw40[(int)(3745)] = 178;
      _nw40[(int)(3746)] = 50;
      _nw40[(int)(3747)] = 65;
      _nw40[(int)(3748)] = 11;
      _nw40[(int)(3749)] = 167;
      _nw40[(int)(3750)] = 48;
      _nw40[(int)(3751)] = 40;
      _nw40[(int)(3752)] = 212;
      _nw40[(int)(3753)] = 93;
      _nw40[(int)(3754)] = 228;
      _nw40[(int)(3755)] = 219;
      _nw40[(int)(3756)] = 210;
      _nw40[(int)(3757)] = 173;
      _nw40[(int)(3758)] = 188;
      _nw40[(int)(3759)] = 45;
      _nw40[(int)(3760)] = 108;
      _nw40[(int)(3761)] = 29;
      _nw40[(int)(3762)] = 214;
      _nw40[(int)(3763)] = 177;
      _nw40[(int)(3764)] = 249;
      _nw40[(int)(3765)] = 194;
      _nw40[(int)(3766)] = 57;
      _nw40[(int)(3767)] = 145;
      _nw40[(int)(3768)] = 85;
      _nw40[(int)(3769)] = 2;
      _nw40[(int)(3770)] = 236;
      _nw40[(int)(3771)] = 155;
      _nw40[(int)(3772)] = 96;
      _nw40[(int)(3773)] = 186;
      _nw40[(int)(3774)] = 7;
      _nw40[(int)(3775)] = 219;
      _nw40[(int)(3776)] = 63;
      _nw40[(int)(3777)] = 26;
      _nw40[(int)(3778)] = 70;
      _nw40[(int)(3779)] = 109;
      _nw40[(int)(3780)] = 2;
      _nw40[(int)(3781)] = 247;
      _nw40[(int)(3782)] = 216;
      _nw40[(int)(3783)] = 110;
      _nw40[(int)(3784)] = 31;
      _nw40[(int)(3785)] = 122;
      _nw40[(int)(3786)] = 88;
      _nw40[(int)(3787)] = 160;
      _nw40[(int)(3788)] = 38;
      _nw40[(int)(3789)] = 240;
      _nw40[(int)(3790)] = 95;
      _nw40[(int)(3791)] = 241;
      _nw40[(int)(3792)] = 76;
      _nw40[(int)(3793)] = 18;
      _nw40[(int)(3794)] = 197;
      _nw40[(int)(3795)] = 108;
      _nw40[(int)(3796)] = 241;
      _nw40[(int)(3797)] = 133;
      _nw40[(int)(3798)] = 56;
      _nw40[(int)(3799)] = 119;
      _nw40[(int)(3800)] = 156;
      _nw40[(int)(3801)] = 84;
      _nw40[(int)(3802)] = 109;
      _nw40[(int)(3803)] = 141;
      _nw40[(int)(3804)] = 45;
      _nw40[(int)(3805)] = 39;
      _nw40[(int)(3806)] = 98;
      _nw40[(int)(3807)] = 12;
      _nw40[(int)(3808)] = 117;
      _nw40[(int)(3809)] = 130;
      _nw40[(int)(3810)] = 239;
      _nw40[(int)(3811)] = 179;
      _nw40[(int)(3812)] = 253;
      _nw40[(int)(3813)] = 24;
      _nw40[(int)(3814)] = 145;
      _nw40[(int)(3815)] = 104;
      _nw40[(int)(3816)] = 239;
      _nw40[(int)(3817)] = 225;
      _nw40[(int)(3818)] = 168;
      _nw40[(int)(3819)] = 105;
      _nw40[(int)(3820)] = 146;
      _nw40[(int)(3821)] = 191;
      _nw40[(int)(3822)] = 20;
      _nw40[(int)(3823)] = 196;
      _nw40[(int)(3824)] = 9;
      _nw40[(int)(3825)] = 44;
      _nw40[(int)(3826)] = 136;
      _nw40[(int)(3827)] = 238;
      _nw40[(int)(3828)] = 81;
      _nw40[(int)(3829)] = 135;
      _nw40[(int)(3830)] = 251;
      _nw40[(int)(3831)] = 183;
      _nw40[(int)(3832)] = 129;
      _nw40[(int)(3833)] = 43;
      _nw40[(int)(3834)] = 76;
      _nw40[(int)(3835)] = 105;
      _nw40[(int)(3836)] = 222;
      _nw40[(int)(3837)] = 136;
      _nw40[(int)(3838)] = 12;
      _nw40[(int)(3839)] = 183;
      _nw40[(int)(3840)] = 190;
      _nw40[(int)(3841)] = 46;
      _nw40[(int)(3842)] = 194;
      _nw40[(int)(3843)] = 166;
      _nw40[(int)(3844)] = 177;
      _nw40[(int)(3845)] = 230;
      _nw40[(int)(3846)] = 218;
      _nw40[(int)(3847)] = 209;
      _nw40[(int)(3848)] = 62;
      _nw40[(int)(3849)] = 79;
      _nw40[(int)(3850)] = 179;
      _nw40[(int)(3851)] = 85;
      _nw40[(int)(3852)] = 208;
      _nw40[(int)(3853)] = 187;
      _nw40[(int)(3854)] = 169;
      _nw40[(int)(3855)] = 227;
      _nw40[(int)(3856)] = 98;
      _nw40[(int)(3857)] = 251;
      _nw40[(int)(3858)] = 72;
      _nw40[(int)(3859)] = 179;
      _nw40[(int)(3860)] = 94;
      _nw40[(int)(3861)] = 109;
      _nw40[(int)(3862)] = 10;
      _nw40[(int)(3863)] = 209;
      _nw40[(int)(3864)] = 215;
      _nw40[(int)(3865)] = 78;
      _nw40[(int)(3866)] = 137;
      _nw40[(int)(3867)] = 1;
      _nw40[(int)(3868)] = 223;
      _nw40[(int)(3869)] = 211;
      _nw40[(int)(3870)] = 125;
      _nw40[(int)(3871)] = 57;
      _nw40[(int)(3872)] = 59;
      _nw40[(int)(3873)] = 2;
      _nw40[(int)(3874)] = 255;
      _nw40[(int)(3875)] = 121;
      _nw40[(int)(3876)] = 5;
      _nw40[(int)(3877)] = 101;
      _nw40[(int)(3878)] = 138;
      _nw40[(int)(3879)] = 223;
      _nw40[(int)(3880)] = 200;
      _nw40[(int)(3881)] = 141;
      _nw40[(int)(3882)] = 75;
      _nw40[(int)(3883)] = 17;
      _nw40[(int)(3884)] = 105;
      _nw40[(int)(3885)] = 48;
      _nw40[(int)(3886)] = 168;
      _nw40[(int)(3887)] = 138;
      _nw40[(int)(3888)] = 118;
      _nw40[(int)(3889)] = 26;
      _nw40[(int)(3890)] = 202;
      _nw40[(int)(3891)] = 244;
      _nw40[(int)(3892)] = 164;
      _nw40[(int)(3893)] = 246;
      _nw40[(int)(3894)] = 191;
      _nw40[(int)(3895)] = 83;
      _nw40[(int)(3896)] = 26;
      _nw40[(int)(3897)] = 187;
      _nw40[(int)(3898)] = 5;
      _nw40[(int)(3899)] = 250;
      _nw40[(int)(3900)] = 160;
      _nw40[(int)(3901)] = 180;
      _nw40[(int)(3902)] = 26;
      _nw40[(int)(3903)] = 133;
      _nw40[(int)(3904)] = 62;
      _nw40[(int)(3905)] = 89;
      _nw40[(int)(3906)] = 253;
      _nw40[(int)(3907)] = 243;
      _nw40[(int)(3908)] = 175;
      _nw40[(int)(3909)] = 121;
      _nw40[(int)(3910)] = 219;
      _nw40[(int)(3911)] = 19;
      _nw40[(int)(3912)] = 203;
      _nw40[(int)(3913)] = 32;
      _nw40[(int)(3914)] = 149;
      _nw40[(int)(3915)] = 134;
      _nw40[(int)(3916)] = 7;
      _nw40[(int)(3917)] = 222;
      _nw40[(int)(3918)] = 183;
      _nw40[(int)(3919)] = 3;
      _nw40[(int)(3920)] = 111;
      _nw40[(int)(3921)] = 219;
      _nw40[(int)(3922)] = 197;
      _nw40[(int)(3923)] = 99;
      _nw40[(int)(3924)] = 154;
      _nw40[(int)(3925)] = 127;
      _nw40[(int)(3926)] = 227;
      _nw40[(int)(3927)] = 197;
      _nw40[(int)(3928)] = 13;
      _nw40[(int)(3929)] = 137;
      _nw40[(int)(3930)] = 9;
      _nw40[(int)(3931)] = 176;
      _nw40[(int)(3932)] = 58;
      _nw40[(int)(3933)] = 91;
      _nw40[(int)(3934)] = 131;
      _nw40[(int)(3935)] = 55;
      _nw40[(int)(3936)] = 16;
      _nw40[(int)(3937)] = 102;
      _nw40[(int)(3938)] = 241;
      _nw40[(int)(3939)] = 177;
      _nw40[(int)(3940)] = 17;
      _nw40[(int)(3941)] = 253;
      _nw40[(int)(3942)] = 213;
      _nw40[(int)(3943)] = 21;
      _nw40[(int)(3944)] = 18;
      _nw40[(int)(3945)] = 136;
      _nw40[(int)(3946)] = 131;
      _nw40[(int)(3947)] = 52;
      _nw40[(int)(3948)] = 241;
      _nw40[(int)(3949)] = 186;
      _nw40[(int)(3950)] = 219;
      _nw40[(int)(3951)] = 201;
      _nw40[(int)(3952)] = 215;
      _nw40[(int)(3953)] = 42;
      _nw40[(int)(3954)] = 218;
      _nw40[(int)(3955)] = 127;
      _nw40[(int)(3956)] = 110;
      _nw40[(int)(3957)] = 109;
      _nw40[(int)(3958)] = 197;
      _nw40[(int)(3959)] = 230;
      _nw40[(int)(3960)] = 4;
      _nw40[(int)(3961)] = 32;
      _nw40[(int)(3962)] = 35;
      _nw40[(int)(3963)] = 136;
      _nw40[(int)(3964)] = 65;
      _nw40[(int)(3965)] = 239;
      _nw40[(int)(3966)] = 13;
      _nw40[(int)(3967)] = 186;
      _nw40[(int)(3968)] = 11;
      _nw40[(int)(3969)] = 193;
      _nw40[(int)(3970)] = 127;
      _nw40[(int)(3971)] = 98;
      _nw40[(int)(3972)] = 211;
      _nw40[(int)(3973)] = 233;
      _nw40[(int)(3974)] = 145;
      _nw40[(int)(3975)] = 159;
      _nw40[(int)(3976)] = 194;
      _nw40[(int)(3977)] = 26;
      _nw40[(int)(3978)] = 188;
      _nw40[(int)(3979)] = 122;
      _nw40[(int)(3980)] = 211;
      _nw40[(int)(3981)] = 138;
      _nw40[(int)(3982)] = 234;
      _nw40[(int)(3983)] = 174;
      _nw40[(int)(3984)] = 253;
      _nw40[(int)(3985)] = 62;
      _nw40[(int)(3986)] = 113;
      _nw40[(int)(3987)] = 219;
      _nw40[(int)(3988)] = 160;
      _nw40[(int)(3989)] = 127;
      _nw40[(int)(3990)] = 45;
      _nw40[(int)(3991)] = 121;
      _nw40[(int)(3992)] = 238;
      _nw40[(int)(3993)] = 131;
      _nw40[(int)(3994)] = 105;
      _nw40[(int)(3995)] = 205;
      _nw40[(int)(3996)] = 180;
      _nw40[(int)(3997)] = 51;
      _nw40[(int)(3998)] = 15;
      _nw40[(int)(3999)] = 131;
      _nw40[(int)(4000)] = 208;
      _nw40[(int)(4001)] = 167;
      _nw40[(int)(4002)] = 135;
      _nw40[(int)(4003)] = 118;
      _nw40[(int)(4004)] = 90;
      _nw40[(int)(4005)] = 156;
      _nw40[(int)(4006)] = 228;
      _nw40[(int)(4007)] = 206;
      _nw40[(int)(4008)] = 230;
      _nw40[(int)(4009)] = 236;
      _nw40[(int)(4010)] = 251;
      _nw40[(int)(4011)] = 129;
      _nw40[(int)(4012)] = 58;
      _nw40[(int)(4013)] = 169;
      _nw40[(int)(4014)] = 49;
      _nw40[(int)(4015)] = 140;
      _nw40[(int)(4016)] = 64;
      _nw40[(int)(4017)] = 224;
      _nw40[(int)(4018)] = 32;
      _nw40[(int)(4019)] = 108;
      _nw40[(int)(4020)] = 1;
      _nw40[(int)(4021)] = 3;
      _nw40[(int)(4022)] = 41;
      _nw40[(int)(4023)] = 5;
      _nw40[(int)(4024)] = 225;
      _nw40[(int)(4025)] = 33;
      _nw40[(int)(4026)] = 103;
      _nw40[(int)(4027)] = 205;
      _nw40[(int)(4028)] = 63;
      _nw40[(int)(4029)] = 0;
      _nw40[(int)(4030)] = 165;
      _nw40[(int)(4031)] = 54;
      _nw40[(int)(4032)] = 34;
      _nw40[(int)(4033)] = 51;
      _nw40[(int)(4034)] = 116;
      _nw40[(int)(4035)] = 125;
      _nw40[(int)(4036)] = 237;
      _nw40[(int)(4037)] = 157;
      _nw40[(int)(4038)] = 201;
      _nw40[(int)(4039)] = 250;
      _nw40[(int)(4040)] = 226;
      _nw40[(int)(4041)] = 218;
      _nw40[(int)(4042)] = 22;
      _nw40[(int)(4043)] = 34;
      _nw40[(int)(4044)] = 92;
      _nw40[(int)(4045)] = 168;
      _nw40[(int)(4046)] = 68;
      _nw40[(int)(4047)] = 166;
      _nw40[(int)(4048)] = 106;
      _nw40[(int)(4049)] = 75;
      _nw40[(int)(4050)] = 121;
      _nw40[(int)(4051)] = 66;
      _nw40[(int)(4052)] = 183;
      _nw40[(int)(4053)] = 214;
      _nw40[(int)(4054)] = 29;
      _nw40[(int)(4055)] = 39;
      _nw40[(int)(4056)] = 19;
      _nw40[(int)(4057)] = 226;
      _nw40[(int)(4058)] = 125;
      _nw40[(int)(4059)] = 46;
      _nw40[(int)(4060)] = 91;
      _nw40[(int)(4061)] = 48;
      _nw40[(int)(4062)] = 157;
      _nw40[(int)(4063)] = 10;
      _nw40[(int)(4064)] = 26;
      _nw40[(int)(4065)] = 205;
      _nw40[(int)(4066)] = 55;
      _nw40[(int)(4067)] = 139;
      _nw40[(int)(4068)] = 76;
      _nw40[(int)(4069)] = 129;
      _nw40[(int)(4070)] = 196;
      _nw40[(int)(4071)] = 33;
      _nw40[(int)(4072)] = 49;
      _nw40[(int)(4073)] = 32;
      _nw40[(int)(4074)] = 201;
      _nw40[(int)(4075)] = 219;
      _nw40[(int)(4076)] = 177;
      _nw40[(int)(4077)] = 237;
      _nw40[(int)(4078)] = 144;
      _nw40[(int)(4079)] = 73;
      _nw40[(int)(4080)] = 125;
      _nw40[(int)(4081)] = 228;
      _nw40[(int)(4082)] = 101;
      _nw40[(int)(4083)] = 245;
      _nw40[(int)(4084)] = 103;
      _nw40[(int)(4085)] = 17;
      _nw40[(int)(4086)] = 125;
      _nw40[(int)(4087)] = 19;
      _nw40[(int)(4088)] = 93;
      _nw40[(int)(4089)] = 161;
      _nw40[(int)(4090)] = 178;
      _nw40[(int)(4091)] = 243;
      _nw40[(int)(4092)] = 110;
      _nw40[(int)(4093)] = 40;
      _nw40[(int)(4094)] = 136;
      _nw40[(int)(4095)] = 2;
      _nw40[(int)(4096)] = 94;
      _nw40[(int)(4097)] = 244;
      _nw40[(int)(4098)] = 220;
      _nw40[(int)(4099)] = 80;
      _nw40[(int)(4100)] = 8;
      _nw40[(int)(4101)] = 14;
      _nw40[(int)(4102)] = 217;
      _nw40[(int)(4103)] = 238;
      _nw40[(int)(4104)] = 20;
      _nw40[(int)(4105)] = 126;
      _nw40[(int)(4106)] = 147;
      _nw40[(int)(4107)] = 142;
      _nw40[(int)(4108)] = 106;
      _nw40[(int)(4109)] = 68;
      _nw40[(int)(4110)] = 92;
      _nw40[(int)(4111)] = 207;
      _nw40[(int)(4112)] = 77;
      _nw40[(int)(4113)] = 229;
      _nw40[(int)(4114)] = 198;
      _nw40[(int)(4115)] = 225;
      _nw40[(int)(4116)] = 241;
      _nw40[(int)(4117)] = 195;
      _nw40[(int)(4118)] = 152;
      _nw40[(int)(4119)] = 46;
      _nw40[(int)(4120)] = 50;
      _nw40[(int)(4121)] = 76;
      _nw40[(int)(4122)] = 24;
      _nw40[(int)(4123)] = 175;
      _nw40[(int)(4124)] = 74;
      _nw40[(int)(4125)] = 28;
      _nw40[(int)(4126)] = 55;
      _nw40[(int)(4127)] = 44;
      _nw40[(int)(4128)] = 110;
      _nw40[(int)(4129)] = 108;
      _nw40[(int)(4130)] = 142;
      _nw40[(int)(4131)] = 207;
      _nw40[(int)(4132)] = 159;
      _nw40[(int)(4133)] = 207;
      _nw40[(int)(4134)] = 229;
      _nw40[(int)(4135)] = 8;
      _nw40[(int)(4136)] = 245;
      _nw40[(int)(4137)] = 66;
      _nw40[(int)(4138)] = 165;
      _nw40[(int)(4139)] = 28;
      _nw40[(int)(4140)] = 144;
      _nw40[(int)(4141)] = 50;
      _nw40[(int)(4142)] = 32;
      _nw40[(int)(4143)] = 225;
      _nw40[(int)(4144)] = 177;
      _nw40[(int)(4145)] = 229;
      _nw40[(int)(4146)] = 96;
      _nw40[(int)(4147)] = 50;
      _nw40[(int)(4148)] = 217;
      _nw40[(int)(4149)] = 83;
      _nw40[(int)(4150)] = 215;
      _nw40[(int)(4151)] = 17;
      _nw40[(int)(4152)] = 190;
      _nw40[(int)(4153)] = 176;
      _nw40[(int)(4154)] = 51;
      _nw40[(int)(4155)] = 128;
      _nw40[(int)(4156)] = 39;
      _nw40[(int)(4157)] = 122;
      _nw40[(int)(4158)] = 135;
      _nw40[(int)(4159)] = 71;
      _nw40[(int)(4160)] = 89;
      _nw40[(int)(4161)] = 17;
      _nw40[(int)(4162)] = 85;
      _nw40[(int)(4163)] = 80;
      _nw40[(int)(4164)] = 240;
      _nw40[(int)(4165)] = 165;
      _nw40[(int)(4166)] = 6;
      _nw40[(int)(4167)] = 131;
      _nw40[(int)(4168)] = 250;
      _nw40[(int)(4169)] = 6;
      _nw40[(int)(4170)] = 133;
      _nw40[(int)(4171)] = 153;
      _nw40[(int)(4172)] = 0;
      _nw40[(int)(4173)] = 14;
      _nw40[(int)(4174)] = 114;
      _nw40[(int)(4175)] = 44;
      _nw40[(int)(4176)] = 43;
      _nw40[(int)(4177)] = 20;
      _nw40[(int)(4178)] = 170;
      _nw40[(int)(4179)] = 254;
      _nw40[(int)(4180)] = 77;
      _nw40[(int)(4181)] = 226;
      _nw40[(int)(4182)] = 90;
      _nw40[(int)(4183)] = 23;
      _nw40[(int)(4184)] = 34;
      _nw40[(int)(4185)] = 219;
      _nw40[(int)(4186)] = 244;
      _nw40[(int)(4187)] = 84;
      _nw40[(int)(4188)] = 10;
      _nw40[(int)(4189)] = 127;
      _nw40[(int)(4190)] = 174;
      _nw40[(int)(4191)] = 211;
      _nw40[(int)(4192)] = 58;
      _nw40[(int)(4193)] = 225;
      _nw40[(int)(4194)] = 185;
      _nw40[(int)(4195)] = 217;
      _nw40[(int)(4196)] = 113;
      _nw40[(int)(4197)] = 187;
      _nw40[(int)(4198)] = 28;
      _nw40[(int)(4199)] = 82;
      _nw40[(int)(4200)] = 137;
      _nw40[(int)(4201)] = 172;
      _nw40[(int)(4202)] = 54;
      _nw40[(int)(4203)] = 229;
      _nw40[(int)(4204)] = 205;
      _nw40[(int)(4205)] = 65;
      _nw40[(int)(4206)] = 54;
      _nw40[(int)(4207)] = 255;
      _nw40[(int)(4208)] = 107;
      _nw40[(int)(4209)] = 230;
      _nw40[(int)(4210)] = 210;
      _nw40[(int)(4211)] = 163;
      _nw40[(int)(4212)] = 132;
      _nw40[(int)(4213)] = 139;
      _nw40[(int)(4214)] = 188;
      _nw40[(int)(4215)] = 177;
      _nw40[(int)(4216)] = 139;
      _nw40[(int)(4217)] = 72;
      _nw40[(int)(4218)] = 163;
      _nw40[(int)(4219)] = 88;
      _nw40[(int)(4220)] = 169;
      _nw40[(int)(4221)] = 144;
      _nw40[(int)(4222)] = 95;
      _nw40[(int)(4223)] = 234;
      _nw40[(int)(4224)] = 211;
      _nw40[(int)(4225)] = 49;
      _nw40[(int)(4226)] = 45;
      _nw40[(int)(4227)] = 154;
      _nw40[(int)(4228)] = 67;
      _nw40[(int)(4229)] = 190;
      _nw40[(int)(4230)] = 161;
      _nw40[(int)(4231)] = 120;
      _nw40[(int)(4232)] = 63;
      _nw40[(int)(4233)] = 212;
      _nw40[(int)(4234)] = 81;
      _nw40[(int)(4235)] = 252;
      _nw40[(int)(4236)] = 59;
      _nw40[(int)(4237)] = 210;
      _nw40[(int)(4238)] = 166;
      _nw40[(int)(4239)] = 195;
      _nw40[(int)(4240)] = 139;
      _nw40[(int)(4241)] = 232;
      _nw40[(int)(4242)] = 58;
      _nw40[(int)(4243)] = 141;
      _nw40[(int)(4244)] = 36;
      _nw40[(int)(4245)] = 153;
      _nw40[(int)(4246)] = 132;
      _nw40[(int)(4247)] = 109;
      _nw40[(int)(4248)] = 51;
      _nw40[(int)(4249)] = 60;
      _nw40[(int)(4250)] = 195;
      _nw40[(int)(4251)] = 210;
      _nw40[(int)(4252)] = 175;
      _nw40[(int)(4253)] = 25;
      _nw40[(int)(4254)] = 183;
      _nw40[(int)(4255)] = 205;
      _nw40[(int)(4256)] = 35;
      _nw40[(int)(4257)] = 92;
      _nw40[(int)(4258)] = 85;
      _nw40[(int)(4259)] = 40;
      _nw40[(int)(4260)] = 47;
      _nw40[(int)(4261)] = 6;
      _nw40[(int)(4262)] = 9;
      _nw40[(int)(4263)] = 74;
      _nw40[(int)(4264)] = 242;
      _nw40[(int)(4265)] = 27;
      _nw40[(int)(4266)] = 192;
      _nw40[(int)(4267)] = 148;
      _nw40[(int)(4268)] = 129;
      _nw40[(int)(4269)] = 130;
      _nw40[(int)(4270)] = 238;
      _nw40[(int)(4271)] = 140;
      _nw40[(int)(4272)] = 48;
      _nw40[(int)(4273)] = 158;
      _nw40[(int)(4274)] = 138;
      _nw40[(int)(4275)] = 138;
      _nw40[(int)(4276)] = 99;
      _nw40[(int)(4277)] = 20;
      _nw40[(int)(4278)] = 228;
      _nw40[(int)(4279)] = 114;
      _nw40[(int)(4280)] = 119;
      _nw40[(int)(4281)] = 149;
      _nw40[(int)(4282)] = 129;
      _nw40[(int)(4283)] = 85;
      _nw40[(int)(4284)] = 157;
      _nw40[(int)(4285)] = 54;
      _nw40[(int)(4286)] = 103;
      _nw40[(int)(4287)] = 187;
      _nw40[(int)(4288)] = 238;
      _nw40[(int)(4289)] = 213;
      _nw40[(int)(4290)] = 119;
      _nw40[(int)(4291)] = 147;
      _nw40[(int)(4292)] = 46;
      _nw40[(int)(4293)] = 205;
      _nw40[(int)(4294)] = 101;
      _nw40[(int)(4295)] = 24;
      _nw40[(int)(4296)] = 154;
      _nw40[(int)(4297)] = 28;
      _nw40[(int)(4298)] = 11;
      _nw40[(int)(4299)] = 76;
      _nw40[(int)(4300)] = 237;
      _nw40[(int)(4301)] = 44;
      _nw40[(int)(4302)] = 87;
      _nw40[(int)(4303)] = 118;
      _nw40[(int)(4304)] = 8;
      _nw40[(int)(4305)] = 84;
      _nw40[(int)(4306)] = 57;
      _nw40[(int)(4307)] = 28;
      _nw40[(int)(4308)] = 213;
      _nw40[(int)(4309)] = 237;
      _nw40[(int)(4310)] = 95;
      _nw40[(int)(4311)] = 243;
      _nw40[(int)(4312)] = 150;
      _nw40[(int)(4313)] = 200;
      _nw40[(int)(4314)] = 68;
      _nw40[(int)(4315)] = 41;
      _nw40[(int)(4316)] = 168;
      _nw40[(int)(4317)] = 116;
      _nw40[(int)(4318)] = 38;
      _nw40[(int)(4319)] = 184;
      _nw40[(int)(4320)] = 152;
      _nw40[(int)(4321)] = 140;
      _nw40[(int)(4322)] = 83;
      _nw40[(int)(4323)] = 191;
      _nw40[(int)(4324)] = 155;
      _nw40[(int)(4325)] = 202;
      _nw40[(int)(4326)] = 39;
      _nw40[(int)(4327)] = 220;
      _nw40[(int)(4328)] = 183;
      _nw40[(int)(4329)] = 179;
      _nw40[(int)(4330)] = 229;
      _nw40[(int)(4331)] = 227;
      _nw40[(int)(4332)] = 111;
      _nw40[(int)(4333)] = 94;
      _nw40[(int)(4334)] = 22;
      _nw40[(int)(4335)] = 232;
      _nw40[(int)(4336)] = 113;
      _nw40[(int)(4337)] = 113;
      _nw40[(int)(4338)] = 21;
      _nw40[(int)(4339)] = 213;
      _nw40[(int)(4340)] = 109;
      _nw40[(int)(4341)] = 129;
      _nw40[(int)(4342)] = 20;
      _nw40[(int)(4343)] = 111;
      _nw40[(int)(4344)] = 83;
      _nw40[(int)(4345)] = 163;
      _nw40[(int)(4346)] = 210;
      _nw40[(int)(4347)] = 195;
      _nw40[(int)(4348)] = 15;
      _nw40[(int)(4349)] = 75;
      _nw40[(int)(4350)] = 170;
      _nw40[(int)(4351)] = 197;
      _nw40[(int)(4352)] = 28;
      _nw40[(int)(4353)] = 128;
      _nw40[(int)(4354)] = 201;
      _nw40[(int)(4355)] = 196;
      _nw40[(int)(4356)] = 84;
      _nw40[(int)(4357)] = 60;
      _nw40[(int)(4358)] = 128;
      _nw40[(int)(4359)] = 253;
      _nw40[(int)(4360)] = 132;
      _nw40[(int)(4361)] = 22;
      _nw40[(int)(4362)] = 211;
      _nw40[(int)(4363)] = 100;
      _nw40[(int)(4364)] = 190;
      _nw40[(int)(4365)] = 129;
      _nw40[(int)(4366)] = 137;
      _nw40[(int)(4367)] = 174;
      _nw40[(int)(4368)] = 176;
      _nw40[(int)(4369)] = 221;
      _nw40[(int)(4370)] = 28;
      _nw40[(int)(4371)] = 126;
      _nw40[(int)(4372)] = 166;
      _nw40[(int)(4373)] = 48;
      _nw40[(int)(4374)] = 152;
      _nw40[(int)(4375)] = 114;
      _nw40[(int)(4376)] = 233;
      _nw40[(int)(4377)] = 102;
      _nw40[(int)(4378)] = 110;
      _nw40[(int)(4379)] = 89;
      _nw40[(int)(4380)] = 118;
      _nw40[(int)(4381)] = 59;
      _nw40[(int)(4382)] = 43;
      _nw40[(int)(4383)] = 31;
      _nw40[(int)(4384)] = 195;
      _nw40[(int)(4385)] = 56;
      _nw40[(int)(4386)] = 131;
      _nw40[(int)(4387)] = 187;
      _nw40[(int)(4388)] = 86;
      _nw40[(int)(4389)] = 113;
      _nw40[(int)(4390)] = 127;
      _nw40[(int)(4391)] = 219;
      _nw40[(int)(4392)] = 125;
      _nw40[(int)(4393)] = 251;
      _nw40[(int)(4394)] = 25;
      _nw40[(int)(4395)] = 162;
      _nw40[(int)(4396)] = 108;
      _nw40[(int)(4397)] = 190;
      _nw40[(int)(4398)] = 254;
      _nw40[(int)(4399)] = 20;
      _nw40[(int)(4400)] = 160;
      _nw40[(int)(4401)] = 18;
      _nw40[(int)(4402)] = 52;
      _nw40[(int)(4403)] = 81;
      _nw40[(int)(4404)] = 84;
      _nw40[(int)(4405)] = 252;
      _nw40[(int)(4406)] = 43;
      _nw40[(int)(4407)] = 69;
      _nw40[(int)(4408)] = 101;
      _nw40[(int)(4409)] = 115;
      _nw40[(int)(4410)] = 255;
      _nw40[(int)(4411)] = 197;
      _nw40[(int)(4412)] = 81;
      _nw40[(int)(4413)] = 100;
      _nw40[(int)(4414)] = 42;
      _nw40[(int)(4415)] = 242;
      _nw40[(int)(4416)] = 158;
      _nw40[(int)(4417)] = 5;
      _nw40[(int)(4418)] = 48;
      _nw40[(int)(4419)] = 4;
      _nw40[(int)(4420)] = 19;
      _nw40[(int)(4421)] = 241;
      _nw40[(int)(4422)] = 1;
      _nw40[(int)(4423)] = 37;
      _nw40[(int)(4424)] = 4;
      _nw40[(int)(4425)] = 211;
      _nw40[(int)(4426)] = 28;
      _nw40[(int)(4427)] = 9;
      _nw40[(int)(4428)] = 232;
      _nw40[(int)(4429)] = 200;
      _nw40[(int)(4430)] = 149;
      _nw40[(int)(4431)] = 64;
      _nw40[(int)(4432)] = 28;
      _nw40[(int)(4433)] = 218;
      _nw40[(int)(4434)] = 77;
      _nw40[(int)(4435)] = 134;
      _nw40[(int)(4436)] = 111;
      _nw40[(int)(4437)] = 201;
      _nw40[(int)(4438)] = 139;
      _nw40[(int)(4439)] = 171;
      _nw40[(int)(4440)] = 54;
      _nw40[(int)(4441)] = 190;
      _nw40[(int)(4442)] = 64;
      _nw40[(int)(4443)] = 246;
      _nw40[(int)(4444)] = 89;
      _nw40[(int)(4445)] = 26;
      _nw40[(int)(4446)] = 246;
      _nw40[(int)(4447)] = 140;
      _nw40[(int)(4448)] = 193;
      _nw40[(int)(4449)] = 133;
      _nw40[(int)(4450)] = 177;
      _nw40[(int)(4451)] = 77;
      _nw40[(int)(4452)] = 85;
      _nw40[(int)(4453)] = 125;
      _nw40[(int)(4454)] = 200;
      _nw40[(int)(4455)] = 119;
      _nw40[(int)(4456)] = 47;
      _nw40[(int)(4457)] = 38;
      _nw40[(int)(4458)] = 144;
      _nw40[(int)(4459)] = 38;
      _nw40[(int)(4460)] = 214;
      _nw40[(int)(4461)] = 98;
      _nw40[(int)(4462)] = 150;
      _nw40[(int)(4463)] = 90;
      _nw40[(int)(4464)] = 204;
      _nw40[(int)(4465)] = 205;
      _nw40[(int)(4466)] = 103;
      _nw40[(int)(4467)] = 114;
      _nw40[(int)(4468)] = 6;
      _nw40[(int)(4469)] = 213;
      _nw40[(int)(4470)] = 118;
      _nw40[(int)(4471)] = 36;
      _nw40[(int)(4472)] = 145;
      _nw40[(int)(4473)] = 109;
      _nw40[(int)(4474)] = 191;
      _nw40[(int)(4475)] = 139;
      _nw40[(int)(4476)] = 154;
      _nw40[(int)(4477)] = 179;
      _nw40[(int)(4478)] = 12;
      _nw40[(int)(4479)] = 210;
      _nw40[(int)(4480)] = 230;
      _nw40[(int)(4481)] = 21;
      _nw40[(int)(4482)] = 138;
      _nw40[(int)(4483)] = 204;
      _nw40[(int)(4484)] = 252;
      _nw40[(int)(4485)] = 192;
      _nw40[(int)(4486)] = 137;
      _nw40[(int)(4487)] = 97;
      _nw40[(int)(4488)] = 144;
      _nw40[(int)(4489)] = 250;
      _nw40[(int)(4490)] = 248;
      _nw40[(int)(4491)] = 193;
      _nw40[(int)(4492)] = 75;
      _nw40[(int)(4493)] = 156;
      _nw40[(int)(4494)] = 56;
      _nw40[(int)(4495)] = 114;
      _nw40[(int)(4496)] = 218;
      _nw40[(int)(4497)] = 127;
      _nw40[(int)(4498)] = 118;
      _nw40[(int)(4499)] = 36;
      _nw40[(int)(4500)] = 110;
      _nw40[(int)(4501)] = 103;
      _nw40[(int)(4502)] = 85;
      _nw40[(int)(4503)] = 191;
      _nw40[(int)(4504)] = 229;
      _nw40[(int)(4505)] = 197;
      _nw40[(int)(4506)] = 41;
      _nw40[(int)(4507)] = 250;
      _nw40[(int)(4508)] = 28;
      _nw40[(int)(4509)] = 220;
      _nw40[(int)(4510)] = 177;
      _nw40[(int)(4511)] = 227;
      _nw40[(int)(4512)] = 156;
      _nw40[(int)(4513)] = 50;
      _nw40[(int)(4514)] = 100;
      _nw40[(int)(4515)] = 219;
      _nw40[(int)(4516)] = 46;
      _nw40[(int)(4517)] = 126;
      _nw40[(int)(4518)] = 80;
      _nw40[(int)(4519)] = 107;
      _nw40[(int)(4520)] = 17;
      _nw40[(int)(4521)] = 157;
      _nw40[(int)(4522)] = 0;
      _nw40[(int)(4523)] = 140;
      _nw40[(int)(4524)] = 173;
      _nw40[(int)(4525)] = 46;
      _nw40[(int)(4526)] = 147;
      _nw40[(int)(4527)] = 36;
      _nw40[(int)(4528)] = 251;
      _nw40[(int)(4529)] = 155;
      _nw40[(int)(4530)] = 255;
      _nw40[(int)(4531)] = 123;
      _nw40[(int)(4532)] = 51;
      _nw40[(int)(4533)] = 136;
      _nw40[(int)(4534)] = 27;
      _nw40[(int)(4535)] = 120;
      _nw40[(int)(4536)] = 242;
      _nw40[(int)(4537)] = 39;
      _nw40[(int)(4538)] = 117;
      _nw40[(int)(4539)] = 241;
      _nw40[(int)(4540)] = 26;
      _nw40[(int)(4541)] = 161;
      _nw40[(int)(4542)] = 67;
      _nw40[(int)(4543)] = 213;
      _nw40[(int)(4544)] = 3;
      _nw40[(int)(4545)] = 101;
      _nw40[(int)(4546)] = 192;
      _nw40[(int)(4547)] = 129;
      _nw40[(int)(4548)] = 137;
      _nw40[(int)(4549)] = 165;
      _nw40[(int)(4550)] = 160;
      _nw40[(int)(4551)] = 124;
      _nw40[(int)(4552)] = 94;
      _nw40[(int)(4553)] = 214;
      _nw40[(int)(4554)] = 4;
      _nw40[(int)(4555)] = 215;
      _nw40[(int)(4556)] = 112;
      _nw40[(int)(4557)] = 187;
      _nw40[(int)(4558)] = 75;
      _nw40[(int)(4559)] = 189;
      _nw40[(int)(4560)] = 158;
      _nw40[(int)(4561)] = 88;
      _nw40[(int)(4562)] = 116;
      _nw40[(int)(4563)] = 170;
      _nw40[(int)(4564)] = 135;
      _nw40[(int)(4565)] = 129;
      _nw40[(int)(4566)] = 164;
      _nw40[(int)(4567)] = 191;
      _nw40[(int)(4568)] = 65;
      _nw40[(int)(4569)] = 71;
      _nw40[(int)(4570)] = 238;
      _nw40[(int)(4571)] = 201;
      _nw40[(int)(4572)] = 87;
      _nw40[(int)(4573)] = 207;
      _nw40[(int)(4574)] = 148;
      _nw40[(int)(4575)] = 246;
      _nw40[(int)(4576)] = 134;
      _nw40[(int)(4577)] = 175;
      _nw40[(int)(4578)] = 203;
      _nw40[(int)(4579)] = 122;
      _nw40[(int)(4580)] = 51;
      _nw40[(int)(4581)] = 193;
      _nw40[(int)(4582)] = 35;
      _nw40[(int)(4583)] = 50;
      _nw40[(int)(4584)] = 69;
      _nw40[(int)(4585)] = 203;
      _nw40[(int)(4586)] = 214;
      _nw40[(int)(4587)] = 44;
      _nw40[(int)(4588)] = 145;
      _nw40[(int)(4589)] = 121;
      _nw40[(int)(4590)] = 80;
      _nw40[(int)(4591)] = 25;
      _nw40[(int)(4592)] = 14;
      _nw40[(int)(4593)] = 249;
      _nw40[(int)(4594)] = 41;
      _nw40[(int)(4595)] = 246;
      _nw40[(int)(4596)] = 89;
      _nw40[(int)(4597)] = 245;
      _nw40[(int)(4598)] = 101;
      _nw40[(int)(4599)] = 46;
      _nw40[(int)(4600)] = 98;
      _nw40[(int)(4601)] = 93;
      _nw40[(int)(4602)] = 106;
      _nw40[(int)(4603)] = 193;
      _nw40[(int)(4604)] = 240;
      _nw40[(int)(4605)] = 42;
      _nw40[(int)(4606)] = 164;
      _nw40[(int)(4607)] = 112;
      _nw40[(int)(4608)] = 233;
      _nw40[(int)(4609)] = 198;
      _nw40[(int)(4610)] = 2;
      _nw40[(int)(4611)] = 162;
      _nw40[(int)(4612)] = 138;
      _nw40[(int)(4613)] = 207;
      _nw40[(int)(4614)] = 16;
      _nw40[(int)(4615)] = 86;
      _nw40[(int)(4616)] = 191;
      _nw40[(int)(4617)] = 83;
      _nw40[(int)(4618)] = 73;
      _nw40[(int)(4619)] = 32;
      _nw40[(int)(4620)] = 229;
      _nw40[(int)(4621)] = 77;
      _nw40[(int)(4622)] = 181;
      _nw40[(int)(4623)] = 69;
      _nw40[(int)(4624)] = 100;
      _nw40[(int)(4625)] = 158;
      _nw40[(int)(4626)] = 207;
      _nw40[(int)(4627)] = 26;
      _nw40[(int)(4628)] = 9;
      _nw40[(int)(4629)] = 190;
      _nw40[(int)(4630)] = 139;
      _nw40[(int)(4631)] = 223;
      _nw40[(int)(4632)] = 195;
      _nw40[(int)(4633)] = 17;
      _nw40[(int)(4634)] = 115;
      _nw40[(int)(4635)] = 22;
      _nw40[(int)(4636)] = 54;
      _nw40[(int)(4637)] = 150;
      _nw40[(int)(4638)] = 220;
      _nw40[(int)(4639)] = 28;
      _nw40[(int)(4640)] = 141;
      _nw40[(int)(4641)] = 110;
      _nw40[(int)(4642)] = 123;
      _nw40[(int)(4643)] = 80;
      _nw40[(int)(4644)] = 202;
      _nw40[(int)(4645)] = 130;
      _nw40[(int)(4646)] = 108;
      _nw40[(int)(4647)] = 86;
      _nw40[(int)(4648)] = 205;
      _nw40[(int)(4649)] = 60;
      _nw40[(int)(4650)] = 48;
      _nw40[(int)(4651)] = 75;
      _nw40[(int)(4652)] = 206;
      _nw40[(int)(4653)] = 38;
      _nw40[(int)(4654)] = 113;
      _nw40[(int)(4655)] = 44;
      _nw40[(int)(4656)] = 237;
      _nw40[(int)(4657)] = 245;
      _nw40[(int)(4658)] = 69;
      _nw40[(int)(4659)] = 21;
      _nw40[(int)(4660)] = 255;
      _nw40[(int)(4661)] = 85;
      _nw40[(int)(4662)] = 162;
      _nw40[(int)(4663)] = 137;
      _nw40[(int)(4664)] = 197;
      _nw40[(int)(4665)] = 107;
      _nw40[(int)(4666)] = 196;
      _nw40[(int)(4667)] = 103;
      _nw40[(int)(4668)] = 164;
      _nw40[(int)(4669)] = 68;
      _nw40[(int)(4670)] = 248;
      _nw40[(int)(4671)] = 46;
      _nw40[(int)(4672)] = 9;
      _nw40[(int)(4673)] = 178;
      _nw40[(int)(4674)] = 183;
      _nw40[(int)(4675)] = 231;
      _nw40[(int)(4676)] = 147;
      _nw40[(int)(4677)] = 97;
      _nw40[(int)(4678)] = 84;
      _nw40[(int)(4679)] = 56;
      _nw40[(int)(4680)] = 245;
      _nw40[(int)(4681)] = 75;
      _nw40[(int)(4682)] = 63;
      _nw40[(int)(4683)] = 24;
      _nw40[(int)(4684)] = 153;
      _nw40[(int)(4685)] = 169;
      _nw40[(int)(4686)] = 81;
      _nw40[(int)(4687)] = 103;
      _nw40[(int)(4688)] = 167;
      _nw40[(int)(4689)] = 74;
      _nw40[(int)(4690)] = 239;
      _nw40[(int)(4691)] = 19;
      _nw40[(int)(4692)] = 25;
      _nw40[(int)(4693)] = 151;
      _nw40[(int)(4694)] = 7;
      _nw40[(int)(4695)] = 17;
      _nw40[(int)(4696)] = 141;
      _nw40[(int)(4697)] = 185;
      _nw40[(int)(4698)] = 180;
      _nw40[(int)(4699)] = 251;
      _nw40[(int)(4700)] = 132;
      _nw40[(int)(4701)] = 211;
      _nw40[(int)(4702)] = 154;
      _nw40[(int)(4703)] = 156;
      _nw40[(int)(4704)] = 37;
      _nw40[(int)(4705)] = 3;
      _nw40[(int)(4706)] = 61;
      _nw40[(int)(4707)] = 109;
      _nw40[(int)(4708)] = 155;
      _nw40[(int)(4709)] = 12;
      _nw40[(int)(4710)] = 37;
      _nw40[(int)(4711)] = 132;
      _nw40[(int)(4712)] = 156;
      _nw40[(int)(4713)] = 195;
      _nw40[(int)(4714)] = 97;
      _nw40[(int)(4715)] = 150;
      _nw40[(int)(4716)] = 139;
      _nw40[(int)(4717)] = 175;
      _nw40[(int)(4718)] = 189;
      _nw40[(int)(4719)] = 199;
      _nw40[(int)(4720)] = 106;
      _nw40[(int)(4721)] = 74;
      _nw40[(int)(4722)] = 38;
      _nw40[(int)(4723)] = 212;
      _nw40[(int)(4724)] = 79;
      _nw40[(int)(4725)] = 64;
      _nw40[(int)(4726)] = 235;
      _nw40[(int)(4727)] = 192;
      _nw40[(int)(4728)] = 78;
      _nw40[(int)(4729)] = 135;
      _nw40[(int)(4730)] = 213;
      _nw40[(int)(4731)] = 217;
      _nw40[(int)(4732)] = 176;
      _nw40[(int)(4733)] = 172;
      _nw40[(int)(4734)] = 73;
      _nw40[(int)(4735)] = 182;
      _nw40[(int)(4736)] = 61;
      _nw40[(int)(4737)] = 86;
      _nw40[(int)(4738)] = 153;
      _nw40[(int)(4739)] = 227;
      _nw40[(int)(4740)] = 190;
      _nw40[(int)(4741)] = 174;
      _nw40[(int)(4742)] = 212;
      _nw40[(int)(4743)] = 239;
      _nw40[(int)(4744)] = 76;
      _nw40[(int)(4745)] = 71;
      _nw40[(int)(4746)] = 109;
      _nw40[(int)(4747)] = 177;
      _nw40[(int)(4748)] = 141;
      _nw40[(int)(4749)] = 193;
      _nw40[(int)(4750)] = 156;
      _nw40[(int)(4751)] = 161;
      _nw40[(int)(4752)] = 73;
      _nw40[(int)(4753)] = 182;
      _nw40[(int)(4754)] = 150;
      _nw40[(int)(4755)] = 29;
      _nw40[(int)(4756)] = 223;
      _nw40[(int)(4757)] = 86;
      _nw40[(int)(4758)] = 59;
      _nw40[(int)(4759)] = 170;
      _nw40[(int)(4760)] = 241;
      _nw40[(int)(4761)] = 209;
      _nw40[(int)(4762)] = 21;
      _nw40[(int)(4763)] = 188;
      _nw40[(int)(4764)] = 84;
      _nw40[(int)(4765)] = 23;
      _nw40[(int)(4766)] = 237;
      _nw40[(int)(4767)] = 233;
      _nw40[(int)(4768)] = 180;
      _nw40[(int)(4769)] = 92;
      _nw40[(int)(4770)] = 69;
      _nw40[(int)(4771)] = 72;
      _nw40[(int)(4772)] = 23;
      _nw40[(int)(4773)] = 253;
      _nw40[(int)(4774)] = 175;
      _nw40[(int)(4775)] = 180;
      _nw40[(int)(4776)] = 141;
      _nw40[(int)(4777)] = 120;
      _nw40[(int)(4778)] = 1;
      _nw40[(int)(4779)] = 148;
      _nw40[(int)(4780)] = 213;
      _nw40[(int)(4781)] = 168;
      _nw40[(int)(4782)] = 148;
      _nw40[(int)(4783)] = 62;
      _nw40[(int)(4784)] = 238;
      _nw40[(int)(4785)] = 243;
      _nw40[(int)(4786)] = 60;
      _nw40[(int)(4787)] = 113;
      _nw40[(int)(4788)] = 110;
      _nw40[(int)(4789)] = 244;
      _nw40[(int)(4790)] = 102;
      _nw40[(int)(4791)] = 62;
      _nw40[(int)(4792)] = 35;
      _nw40[(int)(4793)] = 122;
      _nw40[(int)(4794)] = 136;
      _nw40[(int)(4795)] = 179;
      _nw40[(int)(4796)] = 207;
      _nw40[(int)(4797)] = 240;
      _nw40[(int)(4798)] = 188;
      _nw40[(int)(4799)] = 67;
      _nw40[(int)(4800)] = 137;
      _nw40[(int)(4801)] = 28;
      _nw40[(int)(4802)] = 91;
      _nw40[(int)(4803)] = 74;
      _nw40[(int)(4804)] = 201;
      _nw40[(int)(4805)] = 240;
      _nw40[(int)(4806)] = 202;
      _nw40[(int)(4807)] = 178;
      _nw40[(int)(4808)] = 95;
      _nw40[(int)(4809)] = 224;
      _nw40[(int)(4810)] = 230;
      _nw40[(int)(4811)] = 232;
      _nw40[(int)(4812)] = 221;
      _nw40[(int)(4813)] = 14;
      _nw40[(int)(4814)] = 209;
      _nw40[(int)(4815)] = 174;
      _nw40[(int)(4816)] = 221;
      _nw40[(int)(4817)] = 111;
      _nw40[(int)(4818)] = 119;
      _nw40[(int)(4819)] = 122;
      _nw40[(int)(4820)] = 253;
      _nw40[(int)(4821)] = 237;
      _nw40[(int)(4822)] = 131;
      _nw40[(int)(4823)] = 104;
      _nw40[(int)(4824)] = 78;
      _nw40[(int)(4825)] = 200;
      _nw40[(int)(4826)] = 147;
      _nw40[(int)(4827)] = 247;
      _nw40[(int)(4828)] = 161;
      _nw40[(int)(4829)] = 197;
      _nw40[(int)(4830)] = 96;
      _nw40[(int)(4831)] = 16;
      _nw40[(int)(4832)] = 26;
      _nw40[(int)(4833)] = 249;
      _nw40[(int)(4834)] = 0;
      _nw40[(int)(4835)] = 125;
      _nw40[(int)(4836)] = 205;
      _nw40[(int)(4837)] = 247;
      _nw40[(int)(4838)] = 252;
      _nw40[(int)(4839)] = 159;
      _nw40[(int)(4840)] = 174;
      _nw40[(int)(4841)] = 189;
      _nw40[(int)(4842)] = 129;
      _nw40[(int)(4843)] = 176;
      _nw40[(int)(4844)] = 66;
      _nw40[(int)(4845)] = 212;
      _nw40[(int)(4846)] = 187;
      _nw40[(int)(4847)] = 13;
      _nw40[(int)(4848)] = 17;
      _nw40[(int)(4849)] = 174;
      _nw40[(int)(4850)] = 207;
      _nw40[(int)(4851)] = 237;
      _nw40[(int)(4852)] = 207;
      _nw40[(int)(4853)] = 28;
      _nw40[(int)(4854)] = 164;
      _nw40[(int)(4855)] = 168;
      _nw40[(int)(4856)] = 234;
      _nw40[(int)(4857)] = 52;
      _nw40[(int)(4858)] = 200;
      _nw40[(int)(4859)] = 253;
      _nw40[(int)(4860)] = 153;
      _nw40[(int)(4861)] = 237;
      _nw40[(int)(4862)] = 117;
      _nw40[(int)(4863)] = 111;
      _nw40[(int)(4864)] = 145;
      _nw40[(int)(4865)] = 66;
      _nw40[(int)(4866)] = 50;
      _nw40[(int)(4867)] = 245;
      _nw40[(int)(4868)] = 59;
      _nw40[(int)(4869)] = 90;
      _nw40[(int)(4870)] = 73;
      _nw40[(int)(4871)] = 234;
      _nw40[(int)(4872)] = 18;
      _nw40[(int)(4873)] = 188;
      _nw40[(int)(4874)] = 81;
      _nw40[(int)(4875)] = 212;
      _nw40[(int)(4876)] = 190;
      _nw40[(int)(4877)] = 26;
      _nw40[(int)(4878)] = 31;
      _nw40[(int)(4879)] = 107;
      _nw40[(int)(4880)] = 98;
      _nw40[(int)(4881)] = 37;
      _nw40[(int)(4882)] = 39;
      _nw40[(int)(4883)] = 98;
      _nw40[(int)(4884)] = 244;
      _nw40[(int)(4885)] = 191;
      _nw40[(int)(4886)] = 191;
      _nw40[(int)(4887)] = 178;
      _nw40[(int)(4888)] = 199;
      _nw40[(int)(4889)] = 16;
      _nw40[(int)(4890)] = 214;
      _nw40[(int)(4891)] = 85;
      _nw40[(int)(4892)] = 15;
      _nw40[(int)(4893)] = 5;
      _nw40[(int)(4894)] = 211;
      _nw40[(int)(4895)] = 23;
      _nw40[(int)(4896)] = 229;
      _nw40[(int)(4897)] = 144;
      _nw40[(int)(4898)] = 98;
      _nw40[(int)(4899)] = 90;
      _nw40[(int)(4900)] = 209;
      _nw40[(int)(4901)] = 59;
      _nw40[(int)(4902)] = 198;
      _nw40[(int)(4903)] = 215;
      _nw40[(int)(4904)] = 54;
      _nw40[(int)(4905)] = 195;
      _nw40[(int)(4906)] = 39;
      _nw40[(int)(4907)] = 124;
      _nw40[(int)(4908)] = 177;
      _nw40[(int)(4909)] = 48;
      _nw40[(int)(4910)] = 60;
      _nw40[(int)(4911)] = 123;
      _nw40[(int)(4912)] = 143;
      _nw40[(int)(4913)] = 37;
      _nw40[(int)(4914)] = 190;
      _nw40[(int)(4915)] = 176;
      _nw40[(int)(4916)] = 105;
      _nw40[(int)(4917)] = 13;
      _nw40[(int)(4918)] = 19;
      _nw40[(int)(4919)] = 97;
      _nw40[(int)(4920)] = 65;
      _nw40[(int)(4921)] = 31;
      _nw40[(int)(4922)] = 0;
      _nw40[(int)(4923)] = 156;
      _nw40[(int)(4924)] = 27;
      _nw40[(int)(4925)] = 234;
      _nw40[(int)(4926)] = 36;
      _nw40[(int)(4927)] = 239;
      _nw40[(int)(4928)] = 68;
      _nw40[(int)(4929)] = 223;
      _nw40[(int)(4930)] = 209;
      _nw40[(int)(4931)] = 211;
      _nw40[(int)(4932)] = 244;
      _nw40[(int)(4933)] = 244;
      _nw40[(int)(4934)] = 69;
      _nw40[(int)(4935)] = 220;
      _nw40[(int)(4936)] = 190;
      _nw40[(int)(4937)] = 117;
      _nw40[(int)(4938)] = 107;
      _nw40[(int)(4939)] = 48;
      _nw40[(int)(4940)] = 88;
      _nw40[(int)(4941)] = 22;
      _nw40[(int)(4942)] = 153;
      _nw40[(int)(4943)] = 255;
      _nw40[(int)(4944)] = 70;
      _nw40[(int)(4945)] = 16;
      _nw40[(int)(4946)] = 13;
      _nw40[(int)(4947)] = 74;
      _nw40[(int)(4948)] = 128;
      _nw40[(int)(4949)] = 216;
      _nw40[(int)(4950)] = 241;
      _nw40[(int)(4951)] = 230;
      _nw40[(int)(4952)] = 43;
      _nw40[(int)(4953)] = 166;
      _nw40[(int)(4954)] = 53;
      _nw40[(int)(4955)] = 69;
      _nw40[(int)(4956)] = 48;
      _nw40[(int)(4957)] = 105;
      _nw40[(int)(4958)] = 11;
      _nw40[(int)(4959)] = 46;
      _nw40[(int)(4960)] = 192;
      _nw40[(int)(4961)] = 108;
      _nw40[(int)(4962)] = 184;
      _nw40[(int)(4963)] = 117;
      _nw40[(int)(4964)] = 49;
      _nw40[(int)(4965)] = 138;
      _nw40[(int)(4966)] = 5;
      _nw40[(int)(4967)] = 96;
      _nw40[(int)(4968)] = 150;
      _nw40[(int)(4969)] = 51;
      _nw40[(int)(4970)] = 105;
      _nw40[(int)(4971)] = 26;
      _nw40[(int)(4972)] = 167;
      _nw40[(int)(4973)] = 29;
      _nw40[(int)(4974)] = 189;
      _nw40[(int)(4975)] = 95;
      _nw40[(int)(4976)] = 119;
      _nw40[(int)(4977)] = 52;
      _nw40[(int)(4978)] = 247;
      _nw40[(int)(4979)] = 0;
      _nw40[(int)(4980)] = 246;
      _nw40[(int)(4981)] = 227;
      _nw40[(int)(4982)] = 168;
      _nw40[(int)(4983)] = 236;
      _nw40[(int)(4984)] = 226;
      _nw40[(int)(4985)] = 115;
      _nw40[(int)(4986)] = 170;
      _nw40[(int)(4987)] = 196;
      _nw40[(int)(4988)] = 114;
      _nw40[(int)(4989)] = 62;
      _nw40[(int)(4990)] = 50;
      _nw40[(int)(4991)] = 249;
      _nw40[(int)(4992)] = 224;
      _nw40[(int)(4993)] = 247;
      _nw40[(int)(4994)] = 45;
      _nw40[(int)(4995)] = 238;
      _nw40[(int)(4996)] = 98;
      _nw40[(int)(4997)] = 163;
      _nw40[(int)(4998)] = 192;
      _nw40[(int)(4999)] = 230;
      _nw40[(int)(5000)] = 244;
      _nw40[(int)(5001)] = 222;
      _nw40[(int)(5002)] = 174;
      _nw40[(int)(5003)] = 188;
      _nw40[(int)(5004)] = 252;
      _nw40[(int)(5005)] = 89;
      _nw40[(int)(5006)] = 15;
      _nw40[(int)(5007)] = 83;
      _nw40[(int)(5008)] = 126;
      _nw40[(int)(5009)] = 225;
      _nw40[(int)(5010)] = 134;
      _nw40[(int)(5011)] = 227;
      _nw40[(int)(5012)] = 89;
      _nw40[(int)(5013)] = 253;
      _nw40[(int)(5014)] = 210;
      _nw40[(int)(5015)] = 104;
      _nw40[(int)(5016)] = 171;
      _nw40[(int)(5017)] = 153;
      _nw40[(int)(5018)] = 92;
      _nw40[(int)(5019)] = 102;
      _nw40[(int)(5020)] = 247;
      _nw40[(int)(5021)] = 22;
      _nw40[(int)(5022)] = 209;
      _nw40[(int)(5023)] = 236;
      _nw40[(int)(5024)] = 203;
      _nw40[(int)(5025)] = 7;
      _nw40[(int)(5026)] = 238;
      _nw40[(int)(5027)] = 65;
      _nw40[(int)(5028)] = 19;
      _nw40[(int)(5029)] = 8;
      _nw40[(int)(5030)] = 189;
      _nw40[(int)(5031)] = 186;
      _nw40[(int)(5032)] = 28;
      _nw40[(int)(5033)] = 120;
      _nw40[(int)(5034)] = 191;
      _nw40[(int)(5035)] = 108;
      _nw40[(int)(5036)] = 245;
      _nw40[(int)(5037)] = 119;
      _nw40[(int)(5038)] = 163;
      _nw40[(int)(5039)] = 189;
      _nw40[(int)(5040)] = 85;
      _nw40[(int)(5041)] = 175;
      _nw40[(int)(5042)] = 38;
      _nw40[(int)(5043)] = 146;
      _nw40[(int)(5044)] = 162;
      _nw40[(int)(5045)] = 60;
      _nw40[(int)(5046)] = 144;
      _nw40[(int)(5047)] = 0;
      _nw40[(int)(5048)] = 207;
      _nw40[(int)(5049)] = 153;
      _nw40[(int)(5050)] = 96;
      _nw40[(int)(5051)] = 129;
      _nw40[(int)(5052)] = 196;
      _nw40[(int)(5053)] = 207;
      _nw40[(int)(5054)] = 209;
      _nw40[(int)(5055)] = 186;
      _nw40[(int)(5056)] = 159;
      _nw40[(int)(5057)] = 98;
      _nw40[(int)(5058)] = 183;
      _nw40[(int)(5059)] = 139;
      _nw40[(int)(5060)] = 20;
      _nw40[(int)(5061)] = 73;
      _nw40[(int)(5062)] = 79;
      _nw40[(int)(5063)] = 167;
      _nw40[(int)(5064)] = 108;
      _nw40[(int)(5065)] = 60;
      _nw40[(int)(5066)] = 200;
      _nw40[(int)(5067)] = 153;
      _nw40[(int)(5068)] = 172;
      _nw40[(int)(5069)] = 106;
      _nw40[(int)(5070)] = 105;
      _nw40[(int)(5071)] = 54;
      _nw40[(int)(5072)] = 94;
      _nw40[(int)(5073)] = 49;
      _nw40[(int)(5074)] = 108;
      _nw40[(int)(5075)] = 88;
      _nw40[(int)(5076)] = 195;
      _nw40[(int)(5077)] = 191;
      _nw40[(int)(5078)] = 72;
      _nw40[(int)(5079)] = 71;
      _nw40[(int)(5080)] = 206;
      _nw40[(int)(5081)] = 91;
      _nw40[(int)(5082)] = 26;
      _nw40[(int)(5083)] = 11;
      _nw40[(int)(5084)] = 181;
      _nw40[(int)(5085)] = 11;
      _nw40[(int)(5086)] = 240;
      _nw40[(int)(5087)] = 17;
      _nw40[(int)(5088)] = 103;
      _nw40[(int)(5089)] = 133;
      _nw40[(int)(5090)] = 27;
      _nw40[(int)(5091)] = 16;
      _nw40[(int)(5092)] = 51;
      _nw40[(int)(5093)] = 69;
      _nw40[(int)(5094)] = 57;
      _nw40[(int)(5095)] = 193;
      _nw40[(int)(5096)] = 65;
      _nw40[(int)(5097)] = 239;
      _nw40[(int)(5098)] = 166;
      _nw40[(int)(5099)] = 164;
      _nw40[(int)(5100)] = 21;
      _nw40[(int)(5101)] = 3;
      _nw40[(int)(5102)] = 182;
      _nw40[(int)(5103)] = 236;
      _nw40[(int)(5104)] = 9;
      _nw40[(int)(5105)] = 61;
      _nw40[(int)(5106)] = 95;
      _nw40[(int)(5107)] = 34;
      _nw40[(int)(5108)] = 169;
      _nw40[(int)(5109)] = 112;
      _nw40[(int)(5110)] = 131;
      _nw40[(int)(5111)] = 161;
      _nw40[(int)(5112)] = 115;
      _nw40[(int)(5113)] = 230;
      _nw40[(int)(5114)] = 235;
      _nw40[(int)(5115)] = 251;
      _nw40[(int)(5116)] = 163;
      _nw40[(int)(5117)] = 146;
      _nw40[(int)(5118)] = 245;
      _nw40[(int)(5119)] = 33;
      _nw40[(int)(5120)] = 189;
      _nw40[(int)(5121)] = 3;
      _nw40[(int)(5122)] = 25;
      _nw40[(int)(5123)] = 21;
      _nw40[(int)(5124)] = 177;
      _nw40[(int)(5125)] = 115;
      _nw40[(int)(5126)] = 194;
      _nw40[(int)(5127)] = 230;
      _nw40[(int)(5128)] = 68;
      _nw40[(int)(5129)] = 185;
      _nw40[(int)(5130)] = 48;
      _nw40[(int)(5131)] = 14;
      _nw40[(int)(5132)] = 57;
      _nw40[(int)(5133)] = 206;
      _nw40[(int)(5134)] = 231;
      _nw40[(int)(5135)] = 7;
      _nw40[(int)(5136)] = 73;
      _nw40[(int)(5137)] = 123;
      _nw40[(int)(5138)] = 109;
      _nw40[(int)(5139)] = 123;
      _nw40[(int)(5140)] = 2;
      _nw40[(int)(5141)] = 116;
      _nw40[(int)(5142)] = 167;
      _nw40[(int)(5143)] = 189;
      _nw40[(int)(5144)] = 56;
      _nw40[(int)(5145)] = 53;
      _nw40[(int)(5146)] = 179;
      _nw40[(int)(5147)] = 89;
      _nw40[(int)(5148)] = 58;
      _nw40[(int)(5149)] = 16;
      _nw40[(int)(5150)] = 107;
      _nw40[(int)(5151)] = 244;
      _nw40[(int)(5152)] = 242;
      _nw40[(int)(5153)] = 186;
      _nw40[(int)(5154)] = 212;
      _nw40[(int)(5155)] = 181;
      _nw40[(int)(5156)] = 191;
      _nw40[(int)(5157)] = 225;
      _nw40[(int)(5158)] = 30;
      _nw40[(int)(5159)] = 0;
      _nw40[(int)(5160)] = 237;
      _nw40[(int)(5161)] = 51;
      _nw40[(int)(5162)] = 47;
      _nw40[(int)(5163)] = 199;
      _nw40[(int)(5164)] = 243;
      _nw40[(int)(5165)] = 69;
      _nw40[(int)(5166)] = 70;
      _nw40[(int)(5167)] = 175;
      _nw40[(int)(5168)] = 185;
      _nw40[(int)(5169)] = 242;
      _nw40[(int)(5170)] = 226;
      _nw40[(int)(5171)] = 7;
      _nw40[(int)(5172)] = 74;
      _nw40[(int)(5173)] = 241;
      _nw40[(int)(5174)] = 206;
      _nw40[(int)(5175)] = 166;
      _nw40[(int)(5176)] = 135;
      _nw40[(int)(5177)] = 47;
      _nw40[(int)(5178)] = 235;
      _nw40[(int)(5179)] = 88;
      _nw40[(int)(5180)] = 51;
      _nw40[(int)(5181)] = 194;
      _nw40[(int)(5182)] = 83;
      _nw40[(int)(5183)] = 178;
      _nw40[(int)(5184)] = 210;
      _nw40[(int)(5185)] = 94;
      _nw40[(int)(5186)] = 93;
      _nw40[(int)(5187)] = 133;
      _nw40[(int)(5188)] = 149;
      _nw40[(int)(5189)] = 166;
      _nw40[(int)(5190)] = 204;
      _nw40[(int)(5191)] = 78;
      _nw40[(int)(5192)] = 57;
      _nw40[(int)(5193)] = 99;
      _nw40[(int)(5194)] = 102;
      _nw40[(int)(5195)] = 164;
      _nw40[(int)(5196)] = 178;
      _nw40[(int)(5197)] = 123;
      _nw40[(int)(5198)] = 190;
      _nw40[(int)(5199)] = 129;
      _nw40[(int)(5200)] = 133;
      _nw40[(int)(5201)] = 225;
      _nw40[(int)(5202)] = 175;
      _nw40[(int)(5203)] = 176;
      _nw40[(int)(5204)] = 98;
      _nw40[(int)(5205)] = 159;
      _nw40[(int)(5206)] = 113;
      _nw40[(int)(5207)] = 225;
      _nw40[(int)(5208)] = 122;
      _nw40[(int)(5209)] = 209;
      _nw40[(int)(5210)] = 167;
      _nw40[(int)(5211)] = 185;
      _nw40[(int)(5212)] = 180;
      _nw40[(int)(5213)] = 140;
      _nw40[(int)(5214)] = 16;
      _nw40[(int)(5215)] = 175;
      _nw40[(int)(5216)] = 104;
      _nw40[(int)(5217)] = 214;
      _nw40[(int)(5218)] = 177;
      _nw40[(int)(5219)] = 201;
      _nw40[(int)(5220)] = 131;
      _nw40[(int)(5221)] = 10;
      _nw40[(int)(5222)] = 206;
      _nw40[(int)(5223)] = 117;
      _nw40[(int)(5224)] = 115;
      _nw40[(int)(5225)] = 183;
      _nw40[(int)(5226)] = 24;
      _nw40[(int)(5227)] = 25;
      _nw40[(int)(5228)] = 145;
      _nw40[(int)(5229)] = 228;
      _nw40[(int)(5230)] = 43;
      _nw40[(int)(5231)] = 81;
      _nw40[(int)(5232)] = 45;
      _nw40[(int)(5233)] = 123;
      _nw40[(int)(5234)] = 162;
      _nw40[(int)(5235)] = 111;
      _nw40[(int)(5236)] = 251;
      _nw40[(int)(5237)] = 6;
      _nw40[(int)(5238)] = 102;
      _nw40[(int)(5239)] = 198;
      _nw40[(int)(5240)] = 175;
      _nw40[(int)(5241)] = 156;
      _nw40[(int)(5242)] = 187;
      _nw40[(int)(5243)] = 122;
      _nw40[(int)(5244)] = 201;
      _nw40[(int)(5245)] = 49;
      _nw40[(int)(5246)] = 9;
      _nw40[(int)(5247)] = 236;
      _nw40[(int)(5248)] = 11;
      _nw40[(int)(5249)] = 44;
      _nw40[(int)(5250)] = 87;
      _nw40[(int)(5251)] = 83;
      _nw40[(int)(5252)] = 236;
      _nw40[(int)(5253)] = 215;
      _nw40[(int)(5254)] = 131;
      _nw40[(int)(5255)] = 104;
      _nw40[(int)(5256)] = 177;
      _nw40[(int)(5257)] = 211;
      _nw40[(int)(5258)] = 58;
      _nw40[(int)(5259)] = 87;
      _nw40[(int)(5260)] = 255;
      _nw40[(int)(5261)] = 228;
      _nw40[(int)(5262)] = 87;
      _nw40[(int)(5263)] = 3;
      _nw40[(int)(5264)] = 161;
      _nw40[(int)(5265)] = 227;
      _nw40[(int)(5266)] = 85;
      _nw40[(int)(5267)] = 10;
      _nw40[(int)(5268)] = 226;
      _nw40[(int)(5269)] = 12;
      _nw40[(int)(5270)] = 185;
      _nw40[(int)(5271)] = 121;
      _nw40[(int)(5272)] = 134;
      _nw40[(int)(5273)] = 123;
      _nw40[(int)(5274)] = 246;
      _nw40[(int)(5275)] = 248;
      _nw40[(int)(5276)] = 130;
      _nw40[(int)(5277)] = 13;
      _nw40[(int)(5278)] = 184;
      _nw40[(int)(5279)] = 68;
      _nw40[(int)(5280)] = 182;
      _nw40[(int)(5281)] = 75;
      _nw40[(int)(5282)] = 61;
      _nw40[(int)(5283)] = 30;
      _nw40[(int)(5284)] = 43;
      _nw40[(int)(5285)] = 164;
      _nw40[(int)(5286)] = 168;
      _nw40[(int)(5287)] = 191;
      _nw40[(int)(5288)] = 232;
      _nw40[(int)(5289)] = 69;
      _nw40[(int)(5290)] = 196;
      _nw40[(int)(5291)] = 221;
      _nw40[(int)(5292)] = 203;
      _nw40[(int)(5293)] = 238;
      _nw40[(int)(5294)] = 0;
      _nw40[(int)(5295)] = 250;
      _nw40[(int)(5296)] = 43;
      _nw40[(int)(5297)] = 167;
      _nw40[(int)(5298)] = 226;
      _nw40[(int)(5299)] = 215;
      _nw40[(int)(5300)] = 167;
      _nw40[(int)(5301)] = 239;
      _nw40[(int)(5302)] = 126;
      _nw40[(int)(5303)] = 144;
      _nw40[(int)(5304)] = 128;
      _nw40[(int)(5305)] = 127;
      _nw40[(int)(5306)] = 89;
      _nw40[(int)(5307)] = 42;
      _nw40[(int)(5308)] = 153;
      _nw40[(int)(5309)] = 253;
      _nw40[(int)(5310)] = 81;
      _nw40[(int)(5311)] = 225;
      _nw40[(int)(5312)] = 237;
      _nw40[(int)(5313)] = 4;
      _nw40[(int)(5314)] = 164;
      _nw40[(int)(5315)] = 254;
      _nw40[(int)(5316)] = 61;
      _nw40[(int)(5317)] = 39;
      _nw40[(int)(5318)] = 150;
      _nw40[(int)(5319)] = 233;
      _nw40[(int)(5320)] = 180;
      _nw40[(int)(5321)] = 237;
      _nw40[(int)(5322)] = 239;
      _nw40[(int)(5323)] = 112;
      _nw40[(int)(5324)] = 35;
      _nw40[(int)(5325)] = 96;
      _nw40[(int)(5326)] = 94;
      _nw40[(int)(5327)] = 67;
      _nw40[(int)(5328)] = 44;
      _nw40[(int)(5329)] = 126;
      _nw40[(int)(5330)] = 177;
      _nw40[(int)(5331)] = 251;
      _nw40[(int)(5332)] = 165;
      _nw40[(int)(5333)] = 31;
      _nw40[(int)(5334)] = 93;
      _nw40[(int)(5335)] = 48;
      _nw40[(int)(5336)] = 210;
      _nw40[(int)(5337)] = 106;
      _nw40[(int)(5338)] = 71;
      _nw40[(int)(5339)] = 22;
      _nw40[(int)(5340)] = 17;
      _nw40[(int)(5341)] = 56;
      _nw40[(int)(5342)] = 7;
      _nw40[(int)(5343)] = 60;
      _nw40[(int)(5344)] = 1;
      _nw40[(int)(5345)] = 12;
      _nw40[(int)(5346)] = 94;
      _nw40[(int)(5347)] = 16;
      _nw40[(int)(5348)] = 19;
      _nw40[(int)(5349)] = 149;
      _nw40[(int)(5350)] = 85;
      _nw40[(int)(5351)] = 133;
      _nw40[(int)(5352)] = 234;
      _nw40[(int)(5353)] = 20;
      _nw40[(int)(5354)] = 248;
      _nw40[(int)(5355)] = 218;
      _nw40[(int)(5356)] = 144;
      _nw40[(int)(5357)] = 17;
      _nw40[(int)(5358)] = 180;
      _nw40[(int)(5359)] = 42;
      _nw40[(int)(5360)] = 99;
      _nw40[(int)(5361)] = 137;
      _nw40[(int)(5362)] = 9;
      _nw40[(int)(5363)] = 19;
      _nw40[(int)(5364)] = 28;
      _nw40[(int)(5365)] = 144;
      _nw40[(int)(5366)] = 77;
      _nw40[(int)(5367)] = 34;
      _nw40[(int)(5368)] = 57;
      _nw40[(int)(5369)] = 128;
      _nw40[(int)(5370)] = 223;
      _nw40[(int)(5371)] = 168;
      _nw40[(int)(5372)] = 205;
      _nw40[(int)(5373)] = 149;
      _nw40[(int)(5374)] = 115;
      _nw40[(int)(5375)] = 145;
      _nw40[(int)(5376)] = 175;
      _nw40[(int)(5377)] = 97;
      _nw40[(int)(5378)] = 177;
      _nw40[(int)(5379)] = 193;
      _nw40[(int)(5380)] = 203;
      _nw40[(int)(5381)] = 103;
      _nw40[(int)(5382)] = 15;
      _nw40[(int)(5383)] = 222;
      _nw40[(int)(5384)] = 211;
      _nw40[(int)(5385)] = 184;
      _nw40[(int)(5386)] = 255;
      _nw40[(int)(5387)] = 119;
      _nw40[(int)(5388)] = 20;
      _nw40[(int)(5389)] = 10;
      _nw40[(int)(5390)] = 45;
      _nw40[(int)(5391)] = 179;
      _nw40[(int)(5392)] = 95;
      _nw40[(int)(5393)] = 141;
      _nw40[(int)(5394)] = 198;
      _nw40[(int)(5395)] = 68;
      _nw40[(int)(5396)] = 147;
      _nw40[(int)(5397)] = 79;
      _nw40[(int)(5398)] = 134;
      _nw40[(int)(5399)] = 87;
      _nw40[(int)(5400)] = 108;
      _nw40[(int)(5401)] = 162;
      _nw40[(int)(5402)] = 165;
      _nw40[(int)(5403)] = 5;
      _nw40[(int)(5404)] = 61;
      _nw40[(int)(5405)] = 3;
      _nw40[(int)(5406)] = 210;
      _nw40[(int)(5407)] = 79;
      _nw40[(int)(5408)] = 133;
      _nw40[(int)(5409)] = 68;
      _nw40[(int)(5410)] = 79;
      _nw40[(int)(5411)] = 81;
      _nw40[(int)(5412)] = 85;
      _nw40[(int)(5413)] = 37;
      _nw40[(int)(5414)] = 253;
      _nw40[(int)(5415)] = 184;
      _nw40[(int)(5416)] = 105;
      _nw40[(int)(5417)] = 28;
      _nw40[(int)(5418)] = 114;
      _nw40[(int)(5419)] = 153;
      _nw40[(int)(5420)] = 13;
      _nw40[(int)(5421)] = 180;
      _nw40[(int)(5422)] = 37;
      _nw40[(int)(5423)] = 66;
      _nw40[(int)(5424)] = 217;
      _nw40[(int)(5425)] = 19;
      _nw40[(int)(5426)] = 12;
      _nw40[(int)(5427)] = 86;
      _nw40[(int)(5428)] = 80;
      _nw40[(int)(5429)] = 141;
      _nw40[(int)(5430)] = 111;
      _nw40[(int)(5431)] = 126;
      _nw40[(int)(5432)] = 202;
      _nw40[(int)(5433)] = 168;
      _nw40[(int)(5434)] = 32;
      _nw40[(int)(5435)] = 209;
      _nw40[(int)(5436)] = 241;
      _nw40[(int)(5437)] = 159;
      _nw40[(int)(5438)] = 187;
      _nw40[(int)(5439)] = 194;
      _nw40[(int)(5440)] = 19;
      _nw40[(int)(5441)] = 250;
      _nw40[(int)(5442)] = 43;
      _nw40[(int)(5443)] = 70;
      _nw40[(int)(5444)] = 1;
      _nw40[(int)(5445)] = 243;
      _nw40[(int)(5446)] = 231;
      _nw40[(int)(5447)] = 42;
      _nw40[(int)(5448)] = 37;
      _nw40[(int)(5449)] = 96;
      _nw40[(int)(5450)] = 246;
      _nw40[(int)(5451)] = 178;
      _nw40[(int)(5452)] = 181;
      _nw40[(int)(5453)] = 156;
      _nw40[(int)(5454)] = 130;
      _nw40[(int)(5455)] = 64;
      _nw40[(int)(5456)] = 194;
      _nw40[(int)(5457)] = 220;
      _nw40[(int)(5458)] = 60;
      _nw40[(int)(5459)] = 84;
      _nw40[(int)(5460)] = 56;
      _nw40[(int)(5461)] = 122;
      _nw40[(int)(5462)] = 126;
      _nw40[(int)(5463)] = 165;
      _nw40[(int)(5464)] = 61;
      _nw40[(int)(5465)] = 209;
      _nw40[(int)(5466)] = 245;
      _nw40[(int)(5467)] = 101;
      _nw40[(int)(5468)] = 124;
      _nw40[(int)(5469)] = 62;
      _nw40[(int)(5470)] = 146;
      _nw40[(int)(5471)] = 24;
      _nw40[(int)(5472)] = 164;
      _nw40[(int)(5473)] = 231;
      _nw40[(int)(5474)] = 43;
      _nw40[(int)(5475)] = 120;
      _nw40[(int)(5476)] = 148;
      _nw40[(int)(5477)] = 165;
      _nw40[(int)(5478)] = 31;
      _nw40[(int)(5479)] = 73;
      _nw40[(int)(5480)] = 97;
      _nw40[(int)(5481)] = 82;
      _nw40[(int)(5482)] = 67;
      _nw40[(int)(5483)] = 228;
      _nw40[(int)(5484)] = 34;
      _nw40[(int)(5485)] = 46;
      _nw40[(int)(5486)] = 129;
      _nw40[(int)(5487)] = 167;
      _nw40[(int)(5488)] = 29;
      _nw40[(int)(5489)] = 37;
      _nw40[(int)(5490)] = 140;
      _nw40[(int)(5491)] = 240;
      _nw40[(int)(5492)] = 191;
      _nw40[(int)(5493)] = 236;
      _nw40[(int)(5494)] = 240;
      _nw40[(int)(5495)] = 160;
      _nw40[(int)(5496)] = 163;
      _nw40[(int)(5497)] = 112;
      _nw40[(int)(5498)] = 215;
      _nw40[(int)(5499)] = 146;
      _nw40[(int)(5500)] = 47;
      _nw40[(int)(5501)] = 177;
      _nw40[(int)(5502)] = 101;
      _nw40[(int)(5503)] = 117;
      _nw40[(int)(5504)] = 228;
      _nw40[(int)(5505)] = 25;
      _nw40[(int)(5506)] = 37;
      _nw40[(int)(5507)] = 185;
      _nw40[(int)(5508)] = 56;
      _nw40[(int)(5509)] = 222;
      _nw40[(int)(5510)] = 194;
      _nw40[(int)(5511)] = 100;
      _nw40[(int)(5512)] = 100;
      _nw40[(int)(5513)] = 57;
      _nw40[(int)(5514)] = 68;
      _nw40[(int)(5515)] = 147;
      _nw40[(int)(5516)] = 192;
      _nw40[(int)(5517)] = 139;
      _nw40[(int)(5518)] = 99;
      _nw40[(int)(5519)] = 162;
      _nw40[(int)(5520)] = 215;
      _nw40[(int)(5521)] = 107;
      _nw40[(int)(5522)] = 78;
      _nw40[(int)(5523)] = 117;
      _nw40[(int)(5524)] = 247;
      _nw40[(int)(5525)] = 141;
      _nw40[(int)(5526)] = 63;
      _nw40[(int)(5527)] = 168;
      _nw40[(int)(5528)] = 71;
      _nw40[(int)(5529)] = 58;
      _nw40[(int)(5530)] = 189;
      _nw40[(int)(5531)] = 40;
      _nw40[(int)(5532)] = 200;
      _nw40[(int)(5533)] = 243;
      _nw40[(int)(5534)] = 132;
      _nw40[(int)(5535)] = 96;
      _nw40[(int)(5536)] = 169;
      _nw40[(int)(5537)] = 208;
      _nw40[(int)(5538)] = 117;
      _nw40[(int)(5539)] = 6;
      _nw40[(int)(5540)] = 62;
      _nw40[(int)(5541)] = 173;
      _nw40[(int)(5542)] = 52;
      _nw40[(int)(5543)] = 86;
      _nw40[(int)(5544)] = 202;
      _nw40[(int)(5545)] = 223;
      _nw40[(int)(5546)] = 140;
      _nw40[(int)(5547)] = 24;
      _nw40[(int)(5548)] = 45;
      _nw40[(int)(5549)] = 111;
      _nw40[(int)(5550)] = 198;
      _nw40[(int)(5551)] = 165;
      _nw40[(int)(5552)] = 139;
      _nw40[(int)(5553)] = 152;
      _nw40[(int)(5554)] = 10;
      _nw40[(int)(5555)] = 87;
      _nw40[(int)(5556)] = 126;
      _nw40[(int)(5557)] = 28;
      _nw40[(int)(5558)] = 114;
      _nw40[(int)(5559)] = 185;
      _nw40[(int)(5560)] = 254;
      _nw40[(int)(5561)] = 193;
      _nw40[(int)(5562)] = 100;
      _nw40[(int)(5563)] = 21;
      _nw40[(int)(5564)] = 144;
      _nw40[(int)(5565)] = 142;
      _nw40[(int)(5566)] = 8;
      _nw40[(int)(5567)] = 233;
      _nw40[(int)(5568)] = 193;
      _nw40[(int)(5569)] = 87;
      _nw40[(int)(5570)] = 110;
      _nw40[(int)(5571)] = 79;
      _nw40[(int)(5572)] = 60;
      _nw40[(int)(5573)] = 170;
      _nw40[(int)(5574)] = 160;
      _nw40[(int)(5575)] = 92;
      _nw40[(int)(5576)] = 212;
      _nw40[(int)(5577)] = 10;
      _nw40[(int)(5578)] = 163;
      _nw40[(int)(5579)] = 135;
      _nw40[(int)(5580)] = 34;
      _nw40[(int)(5581)] = 247;
      _nw40[(int)(5582)] = 128;
      _nw40[(int)(5583)] = 232;
      _nw40[(int)(5584)] = 212;
      _nw40[(int)(5585)] = 235;
      _nw40[(int)(5586)] = 142;
      _nw40[(int)(5587)] = 46;
      _nw40[(int)(5588)] = 14;
      _nw40[(int)(5589)] = 247;
      _nw40[(int)(5590)] = 15;
      _nw40[(int)(5591)] = 86;
      _nw40[(int)(5592)] = 69;
      _nw40[(int)(5593)] = 88;
      _nw40[(int)(5594)] = 7;
      _nw40[(int)(5595)] = 28;
      _nw40[(int)(5596)] = 88;
      _nw40[(int)(5597)] = 188;
      _nw40[(int)(5598)] = 200;
      _nw40[(int)(5599)] = 216;
      _nw40[(int)(5600)] = 209;
      _nw40[(int)(5601)] = 227;
      _nw40[(int)(5602)] = 65;
      _nw40[(int)(5603)] = 234;
      _nw40[(int)(5604)] = 39;
      _nw40[(int)(5605)] = 241;
      _nw40[(int)(5606)] = 83;
      _nw40[(int)(5607)] = 235;
      _nw40[(int)(5608)] = 154;
      _nw40[(int)(5609)] = 212;
      _nw40[(int)(5610)] = 118;
      _nw40[(int)(5611)] = 223;
      _nw40[(int)(5612)] = 13;
      _nw40[(int)(5613)] = 112;
      _nw40[(int)(5614)] = 217;
      _nw40[(int)(5615)] = 18;
      _nw40[(int)(5616)] = 240;
      _nw40[(int)(5617)] = 179;
      _nw40[(int)(5618)] = 97;
      _nw40[(int)(5619)] = 206;
      _nw40[(int)(5620)] = 249;
      _nw40[(int)(5621)] = 0;
      _nw40[(int)(5622)] = 228;
      _nw40[(int)(5623)] = 36;
      _nw40[(int)(5624)] = 30;
      _nw40[(int)(5625)] = 124;
      _nw40[(int)(5626)] = 211;
      _nw40[(int)(5627)] = 155;
      _nw40[(int)(5628)] = 228;
      _nw40[(int)(5629)] = 165;
      _nw40[(int)(5630)] = 229;
      _nw40[(int)(5631)] = 240;
      _nw40[(int)(5632)] = 93;
      _nw40[(int)(5633)] = 2;
      _nw40[(int)(5634)] = 91;
      _nw40[(int)(5635)] = 82;
      _nw40[(int)(5636)] = 223;
      _nw40[(int)(5637)] = 216;
      _nw40[(int)(5638)] = 18;
      _nw40[(int)(5639)] = 189;
      _nw40[(int)(5640)] = 236;
      _nw40[(int)(5641)] = 217;
      _nw40[(int)(5642)] = 103;
      _nw40[(int)(5643)] = 148;
      _nw40[(int)(5644)] = 182;
      _nw40[(int)(5645)] = 101;
      _nw40[(int)(5646)] = 49;
      _nw40[(int)(5647)] = 58;
      _nw40[(int)(5648)] = 190;
      _nw40[(int)(5649)] = 243;
      _nw40[(int)(5650)] = 186;
      _nw40[(int)(5651)] = 133;
      _nw40[(int)(5652)] = 198;
      _nw40[(int)(5653)] = 141;
      _nw40[(int)(5654)] = 90;
      _nw40[(int)(5655)] = 0;
      _nw40[(int)(5656)] = 62;
      _nw40[(int)(5657)] = 231;
      _nw40[(int)(5658)] = 227;
      _nw40[(int)(5659)] = 145;
      _nw40[(int)(5660)] = 96;
      _nw40[(int)(5661)] = 3;
      _nw40[(int)(5662)] = 248;
      _nw40[(int)(5663)] = 232;
      _nw40[(int)(5664)] = 120;
      _nw40[(int)(5665)] = 142;
      _nw40[(int)(5666)] = 33;
      _nw40[(int)(5667)] = 252;
      _nw40[(int)(5668)] = 94;
      _nw40[(int)(5669)] = 60;
      _nw40[(int)(5670)] = 86;
      _nw40[(int)(5671)] = 137;
      _nw40[(int)(5672)] = 214;
      _nw40[(int)(5673)] = 39;
      _nw40[(int)(5674)] = 122;
      _nw40[(int)(5675)] = 185;
      _nw40[(int)(5676)] = 185;
      _nw40[(int)(5677)] = 160;
      _nw40[(int)(5678)] = 41;
      _nw40[(int)(5679)] = 123;
      _nw40[(int)(5680)] = 147;
      _nw40[(int)(5681)] = 121;
      _nw40[(int)(5682)] = 22;
      _nw40[(int)(5683)] = 141;
      _nw40[(int)(5684)] = 227;
      _nw40[(int)(5685)] = 142;
      _nw40[(int)(5686)] = 143;
      _nw40[(int)(5687)] = 40;
      _nw40[(int)(5688)] = 177;
      _nw40[(int)(5689)] = 16;
      _nw40[(int)(5690)] = 218;
      _nw40[(int)(5691)] = 52;
      _nw40[(int)(5692)] = 185;
      _nw40[(int)(5693)] = 201;
      _nw40[(int)(5694)] = 205;
      _nw40[(int)(5695)] = 142;
      _nw40[(int)(5696)] = 102;
      _nw40[(int)(5697)] = 87;
      _nw40[(int)(5698)] = 101;
      _nw40[(int)(5699)] = 119;
      _nw40[(int)(5700)] = 45;
      _nw40[(int)(5701)] = 68;
      _nw40[(int)(5702)] = 22;
      _nw40[(int)(5703)] = 131;
      _nw40[(int)(5704)] = 160;
      _nw40[(int)(5705)] = 116;
      _nw40[(int)(5706)] = 87;
      _nw40[(int)(5707)] = 37;
      _nw40[(int)(5708)] = 96;
      _nw40[(int)(5709)] = 56;
      _nw40[(int)(5710)] = 58;
      _nw40[(int)(5711)] = 241;
      _nw40[(int)(5712)] = 159;
      _nw40[(int)(5713)] = 137;
      _nw40[(int)(5714)] = 43;
      _nw40[(int)(5715)] = 209;
      _nw40[(int)(5716)] = 22;
      _nw40[(int)(5717)] = 212;
      _nw40[(int)(5718)] = 2;
      _nw40[(int)(5719)] = 162;
      _nw40[(int)(5720)] = 117;
      _nw40[(int)(5721)] = 154;
      _nw40[(int)(5722)] = 78;
      _nw40[(int)(5723)] = 228;
      _nw40[(int)(5724)] = 76;
      _nw40[(int)(5725)] = 169;
      _nw40[(int)(5726)] = 53;
      _nw40[(int)(5727)] = 86;
      _nw40[(int)(5728)] = 235;
      _nw40[(int)(5729)] = 164;
      _nw40[(int)(5730)] = 244;
      _nw40[(int)(5731)] = 163;
      _nw40[(int)(5732)] = 44;
      _nw40[(int)(5733)] = 13;
      _nw40[(int)(5734)] = 165;
      _nw40[(int)(5735)] = 236;
      _nw40[(int)(5736)] = 88;
      _nw40[(int)(5737)] = 69;
      _nw40[(int)(5738)] = 229;
      _nw40[(int)(5739)] = 152;
      _nw40[(int)(5740)] = 187;
      _nw40[(int)(5741)] = 29;
      _nw40[(int)(5742)] = 245;
      _nw40[(int)(5743)] = 155;
      _nw40[(int)(5744)] = 166;
      _nw40[(int)(5745)] = 106;
      _nw40[(int)(5746)] = 42;
      _nw40[(int)(5747)] = 158;
      _nw40[(int)(5748)] = 21;
      _nw40[(int)(5749)] = 213;
      _nw40[(int)(5750)] = 9;
      _nw40[(int)(5751)] = 158;
      _nw40[(int)(5752)] = 86;
      _nw40[(int)(5753)] = 252;
      _nw40[(int)(5754)] = 174;
      _nw40[(int)(5755)] = 12;
      _nw40[(int)(5756)] = 77;
      _nw40[(int)(5757)] = 176;
      _nw40[(int)(5758)] = 158;
      _nw40[(int)(5759)] = 4;
      _nw40[(int)(5760)] = 28;
      _nw40[(int)(5761)] = 183;
      _nw40[(int)(5762)] = 210;
      _nw40[(int)(5763)] = 61;
      _nw40[(int)(5764)] = 232;
      _nw40[(int)(5765)] = 141;
      _nw40[(int)(5766)] = 233;
      _nw40[(int)(5767)] = 71;
      _nw40[(int)(5768)] = 3;
      _nw40[(int)(5769)] = 18;
      _nw40[(int)(5770)] = 35;
      _nw40[(int)(5771)] = 217;
      _nw40[(int)(5772)] = 171;
      _nw40[(int)(5773)] = 81;
      _nw40[(int)(5774)] = 240;
      _nw40[(int)(5775)] = 66;
      _nw40[(int)(5776)] = 202;
      _nw40[(int)(5777)] = 35;
      _nw40[(int)(5778)] = 25;
      _nw40[(int)(5779)] = 133;
      _nw40[(int)(5780)] = 192;
      _nw40[(int)(5781)] = 52;
      _nw40[(int)(5782)] = 215;
      _nw40[(int)(5783)] = 232;
      _nw40[(int)(5784)] = 11;
      _nw40[(int)(5785)] = 245;
      _nw40[(int)(5786)] = 45;
      _nw40[(int)(5787)] = 228;
      _nw40[(int)(5788)] = 205;
      _nw40[(int)(5789)] = 219;
      _nw40[(int)(5790)] = 109;
      _nw40[(int)(5791)] = 138;
      _nw40[(int)(5792)] = 103;
      _nw40[(int)(5793)] = 127;
      _nw40[(int)(5794)] = 205;
      _nw40[(int)(5795)] = 174;
      _nw40[(int)(5796)] = 88;
      _nw40[(int)(5797)] = 72;
      _nw40[(int)(5798)] = 85;
      _nw40[(int)(5799)] = 239;
      _nw40[(int)(5800)] = 53;
      _nw40[(int)(5801)] = 182;
      _nw40[(int)(5802)] = 192;
      _nw40[(int)(5803)] = 47;
      _nw40[(int)(5804)] = 92;
      _nw40[(int)(5805)] = 195;
      _nw40[(int)(5806)] = 235;
      _nw40[(int)(5807)] = 211;
      _nw40[(int)(5808)] = 174;
      _nw40[(int)(5809)] = 243;
      _nw40[(int)(5810)] = 56;
      _nw40[(int)(5811)] = 55;
      _nw40[(int)(5812)] = 71;
      _nw40[(int)(5813)] = 12;
      _nw40[(int)(5814)] = 164;
      _nw40[(int)(5815)] = 16;
      _nw40[(int)(5816)] = 178;
      _nw40[(int)(5817)] = 196;
      _nw40[(int)(5818)] = 128;
      _nw40[(int)(5819)] = 171;
      _nw40[(int)(5820)] = 147;
      _nw40[(int)(5821)] = 108;
      _nw40[(int)(5822)] = 10;
      _nw40[(int)(5823)] = 112;
      _nw40[(int)(5824)] = 172;
      _nw40[(int)(5825)] = 9;
      _nw40[(int)(5826)] = 223;
      _nw40[(int)(5827)] = 52;
      _nw40[(int)(5828)] = 199;
      _nw40[(int)(5829)] = 120;
      _nw40[(int)(5830)] = 133;
      _nw40[(int)(5831)] = 51;
      _nw40[(int)(5832)] = 174;
      _nw40[(int)(5833)] = 242;
      _nw40[(int)(5834)] = 137;
      _nw40[(int)(5835)] = 161;
      _nw40[(int)(5836)] = 243;
      _nw40[(int)(5837)] = 234;
      _nw40[(int)(5838)] = 213;
      _nw40[(int)(5839)] = 128;
      _nw40[(int)(5840)] = 80;
      _nw40[(int)(5841)] = 140;
      _nw40[(int)(5842)] = 121;
      _nw40[(int)(5843)] = 224;
      _nw40[(int)(5844)] = 146;
      _nw40[(int)(5845)] = 217;
      _nw40[(int)(5846)] = 70;
      _nw40[(int)(5847)] = 20;
      _nw40[(int)(5848)] = 203;
      _nw40[(int)(5849)] = 90;
      _nw40[(int)(5850)] = 13;
      _nw40[(int)(5851)] = 212;
      _nw40[(int)(5852)] = 219;
      _nw40[(int)(5853)] = 139;
      _nw40[(int)(5854)] = 167;
      _nw40[(int)(5855)] = 71;
      _nw40[(int)(5856)] = 3;
      _nw40[(int)(5857)] = 182;
      _nw40[(int)(5858)] = 140;
      _nw40[(int)(5859)] = 209;
      _nw40[(int)(5860)] = 145;
      _nw40[(int)(5861)] = 224;
      _nw40[(int)(5862)] = 215;
      _nw40[(int)(5863)] = 63;
      _nw40[(int)(5864)] = 115;
      _nw40[(int)(5865)] = 169;
      _nw40[(int)(5866)] = 1;
      _nw40[(int)(5867)] = 162;
      _nw40[(int)(5868)] = 225;
      _nw40[(int)(5869)] = 108;
      _nw40[(int)(5870)] = 134;
      _nw40[(int)(5871)] = 225;
      _nw40[(int)(5872)] = 197;
      _nw40[(int)(5873)] = 245;
      _nw40[(int)(5874)] = 153;
      _nw40[(int)(5875)] = 116;
      _nw40[(int)(5876)] = 153;
      _nw40[(int)(5877)] = 135;
      _nw40[(int)(5878)] = 72;
      _nw40[(int)(5879)] = 208;
      _nw40[(int)(5880)] = 235;
      _nw40[(int)(5881)] = 154;
      _nw40[(int)(5882)] = 230;
      _nw40[(int)(5883)] = 68;
      _nw40[(int)(5884)] = 212;
      _nw40[(int)(5885)] = 88;
      _nw40[(int)(5886)] = 111;
      _nw40[(int)(5887)] = 181;
      _nw40[(int)(5888)] = 43;
      _nw40[(int)(5889)] = 167;
      _nw40[(int)(5890)] = 91;
      _nw40[(int)(5891)] = 170;
      _nw40[(int)(5892)] = 203;
      _nw40[(int)(5893)] = 222;
      _nw40[(int)(5894)] = 195;
      _nw40[(int)(5895)] = 9;
      _nw40[(int)(5896)] = 184;
      _nw40[(int)(5897)] = 246;
      _nw40[(int)(5898)] = 82;
      _nw40[(int)(5899)] = 174;
      _nw40[(int)(5900)] = 247;
      _nw40[(int)(5901)] = 84;
      _nw40[(int)(5902)] = 196;
      _nw40[(int)(5903)] = 6;
      _nw40[(int)(5904)] = 46;
      _nw40[(int)(5905)] = 120;
      _nw40[(int)(5906)] = 238;
      _nw40[(int)(5907)] = 223;
      _nw40[(int)(5908)] = 148;
      _nw40[(int)(5909)] = 133;
      _nw40[(int)(5910)] = 167;
      _nw40[(int)(5911)] = 80;
      _nw40[(int)(5912)] = 7;
      _nw40[(int)(5913)] = 102;
      _nw40[(int)(5914)] = 233;
      _nw40[(int)(5915)] = 22;
      _nw40[(int)(5916)] = 133;
      _nw40[(int)(5917)] = 107;
      _nw40[(int)(5918)] = 221;
      _nw40[(int)(5919)] = 149;
      _nw40[(int)(5920)] = 195;
      _nw40[(int)(5921)] = 208;
      _nw40[(int)(5922)] = 94;
      _nw40[(int)(5923)] = 188;
      _nw40[(int)(5924)] = 185;
      _nw40[(int)(5925)] = 62;
      _nw40[(int)(5926)] = 199;
      _nw40[(int)(5927)] = 71;
      _nw40[(int)(5928)] = 41;
      _nw40[(int)(5929)] = 250;
      _nw40[(int)(5930)] = 57;
      _nw40[(int)(5931)] = 178;
      _nw40[(int)(5932)] = 203;
      _nw40[(int)(5933)] = 73;
      _nw40[(int)(5934)] = 221;
      _nw40[(int)(5935)] = 183;
      _nw40[(int)(5936)] = 203;
      _nw40[(int)(5937)] = 119;
      _nw40[(int)(5938)] = 180;
      _nw40[(int)(5939)] = 34;
      _nw40[(int)(5940)] = 207;
      _nw40[(int)(5941)] = 60;
      _nw40[(int)(5942)] = 141;
      _nw40[(int)(5943)] = 142;
      _nw40[(int)(5944)] = 28;
      _nw40[(int)(5945)] = 107;
      _nw40[(int)(5946)] = 114;
      _nw40[(int)(5947)] = 195;
      _nw40[(int)(5948)] = 161;
      _nw40[(int)(5949)] = 8;
      _nw40[(int)(5950)] = 156;
      _nw40[(int)(5951)] = 69;
      _nw40[(int)(5952)] = 123;
      _nw40[(int)(5953)] = 97;
      _nw40[(int)(5954)] = 205;
      _nw40[(int)(5955)] = 97;
      _nw40[(int)(5956)] = 95;
      _nw40[(int)(5957)] = 196;
      _nw40[(int)(5958)] = 196;
      _nw40[(int)(5959)] = 201;
      _nw40[(int)(5960)] = 249;
      _nw40[(int)(5961)] = 65;
      _nw40[(int)(5962)] = 153;
      _nw40[(int)(5963)] = 30;
      _nw40[(int)(5964)] = 84;
      _nw40[(int)(5965)] = 93;
      _nw40[(int)(5966)] = 164;
      _nw40[(int)(5967)] = 206;
      _nw40[(int)(5968)] = 83;
      _nw40[(int)(5969)] = 62;
      _nw40[(int)(5970)] = 56;
      _nw40[(int)(5971)] = 14;
      _nw40[(int)(5972)] = 167;
      _nw40[(int)(5973)] = 255;
      _nw40[(int)(5974)] = 12;
      _nw40[(int)(5975)] = 73;
      _nw40[(int)(5976)] = 123;
      _nw40[(int)(5977)] = 141;
      _nw40[(int)(5978)] = 72;
      _nw40[(int)(5979)] = 38;
      _nw40[(int)(5980)] = 186;
      _nw40[(int)(5981)] = 71;
      _nw40[(int)(5982)] = 205;
      _nw40[(int)(5983)] = 97;
      _nw40[(int)(5984)] = 240;
      _nw40[(int)(5985)] = 91;
      _nw40[(int)(5986)] = 255;
      _nw40[(int)(5987)] = 79;
      _nw40[(int)(5988)] = 119;
      _nw40[(int)(5989)] = 115;
      _nw40[(int)(5990)] = 248;
      _nw40[(int)(5991)] = 145;
      _nw40[(int)(5992)] = 163;
      _nw40[(int)(5993)] = 40;
      _nw40[(int)(5994)] = 58;
      _nw40[(int)(5995)] = 108;
      _nw40[(int)(5996)] = 185;
      _nw40[(int)(5997)] = 187;
      _nw40[(int)(5998)] = 206;
      _nw40[(int)(5999)] = 143;
      _nw40[(int)(6000)] = 46;
      _nw40[(int)(6001)] = 3;
      _nw40[(int)(6002)] = 255;
      _nw40[(int)(6003)] = 16;
      _nw40[(int)(6004)] = 4;
      _nw40[(int)(6005)] = 58;
      _nw40[(int)(6006)] = 142;
      _nw40[(int)(6007)] = 77;
      _nw40[(int)(6008)] = 212;
      _nw40[(int)(6009)] = 134;
      _nw40[(int)(6010)] = 52;
      _nw40[(int)(6011)] = 234;
      _nw40[(int)(6012)] = 142;
      _nw40[(int)(6013)] = 84;
      _nw40[(int)(6014)] = 191;
      _nw40[(int)(6015)] = 129;
      _nw40[(int)(6016)] = 226;
      _nw40[(int)(6017)] = 210;
      _nw40[(int)(6018)] = 101;
      _nw40[(int)(6019)] = 116;
      _nw40[(int)(6020)] = 155;
      _nw40[(int)(6021)] = 57;
      _nw40[(int)(6022)] = 1;
      _nw40[(int)(6023)] = 131;
      _nw40[(int)(6024)] = 208;
      _nw40[(int)(6025)] = 206;
      _nw40[(int)(6026)] = 64;
      _nw40[(int)(6027)] = 11;
      _nw40[(int)(6028)] = 149;
      _nw40[(int)(6029)] = 16;
      _nw40[(int)(6030)] = 174;
      _nw40[(int)(6031)] = 194;
      _nw40[(int)(6032)] = 107;
      _nw40[(int)(6033)] = 187;
      _nw40[(int)(6034)] = 61;
      _nw40[(int)(6035)] = 184;
      _nw40[(int)(6036)] = 206;
      _nw40[(int)(6037)] = 29;
      _nw40[(int)(6038)] = 222;
      _nw40[(int)(6039)] = 189;
      _nw40[(int)(6040)] = 120;
      _nw40[(int)(6041)] = 237;
      _nw40[(int)(6042)] = 56;
      _nw40[(int)(6043)] = 217;
      _nw40[(int)(6044)] = 207;
      _nw40[(int)(6045)] = 55;
      _nw40[(int)(6046)] = 116;
      _nw40[(int)(6047)] = 246;
      _nw40[(int)(6048)] = 122;
      _nw40[(int)(6049)] = 241;
      _nw40[(int)(6050)] = 54;
      _nw40[(int)(6051)] = 235;
      _nw40[(int)(6052)] = 214;
      _nw40[(int)(6053)] = 118;
      _nw40[(int)(6054)] = 72;
      _nw40[(int)(6055)] = 195;
      _nw40[(int)(6056)] = 157;
      _nw40[(int)(6057)] = 13;
      _nw40[(int)(6058)] = 77;
      _nw40[(int)(6059)] = 231;
      _nw40[(int)(6060)] = 92;
      _nw40[(int)(6061)] = 29;
      _nw40[(int)(6062)] = 41;
      _nw40[(int)(6063)] = 105;
      _nw40[(int)(6064)] = 93;
      _nw40[(int)(6065)] = 223;
      _nw40[(int)(6066)] = 170;
      _nw40[(int)(6067)] = 165;
      _nw40[(int)(6068)] = 51;
      _nw40[(int)(6069)] = 17;
      _nw40[(int)(6070)] = 92;
      _nw40[(int)(6071)] = 39;
      _nw40[(int)(6072)] = 179;
      _nw40[(int)(6073)] = 65;
      _nw40[(int)(6074)] = 248;
      _nw40[(int)(6075)] = 20;
      _nw40[(int)(6076)] = 136;
      _nw40[(int)(6077)] = 93;
      _nw40[(int)(6078)] = 16;
      _nw40[(int)(6079)] = 61;
      _nw40[(int)(6080)] = 118;
      _nw40[(int)(6081)] = 158;
      _nw40[(int)(6082)] = 157;
      _nw40[(int)(6083)] = 49;
      _nw40[(int)(6084)] = 131;
      _nw40[(int)(6085)] = 41;
      _nw40[(int)(6086)] = 142;
      _nw40[(int)(6087)] = 252;
      _nw40[(int)(6088)] = 87;
      _nw40[(int)(6089)] = 216;
      _nw40[(int)(6090)] = 66;
      _nw40[(int)(6091)] = 109;
      _nw40[(int)(6092)] = 186;
      _nw40[(int)(6093)] = 40;
      _nw40[(int)(6094)] = 137;
      _nw40[(int)(6095)] = 235;
      _nw40[(int)(6096)] = 248;
      _nw40[(int)(6097)] = 120;
      _nw40[(int)(6098)] = 213;
      _nw40[(int)(6099)] = 224;
      _nw40[(int)(6100)] = 20;
      _nw40[(int)(6101)] = 96;
      _nw40[(int)(6102)] = 236;
      _nw40[(int)(6103)] = 150;
      _nw40[(int)(6104)] = 29;
      _nw40[(int)(6105)] = 37;
      _nw40[(int)(6106)] = 52;
      _nw40[(int)(6107)] = 140;
      _nw40[(int)(6108)] = 168;
      _nw40[(int)(6109)] = 156;
      _nw40[(int)(6110)] = 197;
      _nw40[(int)(6111)] = 56;
      _nw40[(int)(6112)] = 227;
      _nw40[(int)(6113)] = 168;
      _nw40[(int)(6114)] = 222;
      _nw40[(int)(6115)] = 128;
      _nw40[(int)(6116)] = 43;
      _nw40[(int)(6117)] = 149;
      _nw40[(int)(6118)] = 153;
      _nw40[(int)(6119)] = 26;
      _nw40[(int)(6120)] = 95;
      _nw40[(int)(6121)] = 153;
      _nw40[(int)(6122)] = 16;
      _nw40[(int)(6123)] = 182;
      _nw40[(int)(6124)] = 23;
      _nw40[(int)(6125)] = 103;
      _nw40[(int)(6126)] = 156;
      _nw40[(int)(6127)] = 93;
      _nw40[(int)(6128)] = 30;
      _nw40[(int)(6129)] = 75;
      _nw40[(int)(6130)] = 145;
      _nw40[(int)(6131)] = 26;
      _nw40[(int)(6132)] = 116;
      _nw40[(int)(6133)] = 46;
      _nw40[(int)(6134)] = 115;
      _nw40[(int)(6135)] = 63;
      _nw40[(int)(6136)] = 213;
      _nw40[(int)(6137)] = 124;
      _nw40[(int)(6138)] = 193;
      _nw40[(int)(6139)] = 42;
      _nw40[(int)(6140)] = 175;
      _nw40[(int)(6141)] = 180;
      _nw40[(int)(6142)] = 160;
      _nw40[(int)(6143)] = 24;
      _nw40[(int)(6144)] = 220;
      _nw40[(int)(6145)] = 189;
      _nw40[(int)(6146)] = 70;
      _nw40[(int)(6147)] = 23;
      _nw40[(int)(6148)] = 141;
      _nw40[(int)(6149)] = 250;
      _nw40[(int)(6150)] = 104;
      _nw40[(int)(6151)] = 84;
      _nw40[(int)(6152)] = 41;
      _nw40[(int)(6153)] = 39;
      _nw40[(int)(6154)] = 167;
      _nw40[(int)(6155)] = 242;
      _nw40[(int)(6156)] = 63;
      _nw40[(int)(6157)] = 70;
      _nw40[(int)(6158)] = 205;
      _nw40[(int)(6159)] = 115;
      _nw40[(int)(6160)] = 64;
      _nw40[(int)(6161)] = 238;
      _nw40[(int)(6162)] = 185;
      _nw40[(int)(6163)] = 229;
      _nw40[(int)(6164)] = 193;
      _nw40[(int)(6165)] = 26;
      _nw40[(int)(6166)] = 178;
      _nw40[(int)(6167)] = 203;
      _nw40[(int)(6168)] = 213;
      _nw40[(int)(6169)] = 229;
      _nw40[(int)(6170)] = 145;
      _nw40[(int)(6171)] = 83;
      _nw40[(int)(6172)] = 40;
      _nw40[(int)(6173)] = 234;
      _nw40[(int)(6174)] = 75;
      _nw40[(int)(6175)] = 217;
      _nw40[(int)(6176)] = 115;
      _nw40[(int)(6177)] = 84;
      _nw40[(int)(6178)] = 110;
      _nw40[(int)(6179)] = 228;
      _nw40[(int)(6180)] = 114;
      _nw40[(int)(6181)] = 150;
      _nw40[(int)(6182)] = 251;
      _nw40[(int)(6183)] = 116;
      _nw40[(int)(6184)] = 69;
      _nw40[(int)(6185)] = 196;
      _nw40[(int)(6186)] = 252;
      _nw40[(int)(6187)] = 99;
      _nw40[(int)(6188)] = 18;
      _nw40[(int)(6189)] = 247;
      _nw40[(int)(6190)] = 156;
      _nw40[(int)(6191)] = 22;
      _nw40[(int)(6192)] = 104;
      _nw40[(int)(6193)] = 149;
      _nw40[(int)(6194)] = 57;
      _nw40[(int)(6195)] = 133;
      _nw40[(int)(6196)] = 255;
      _nw40[(int)(6197)] = 190;
      _nw40[(int)(6198)] = 251;
      _nw40[(int)(6199)] = 59;
      _nw40[(int)(6200)] = 32;
      _nw40[(int)(6201)] = 108;
      _nw40[(int)(6202)] = 12;
      _nw40[(int)(6203)] = 32;
      _nw40[(int)(6204)] = 211;
      _nw40[(int)(6205)] = 97;
      _nw40[(int)(6206)] = 250;
      _nw40[(int)(6207)] = 119;
      _nw40[(int)(6208)] = 90;
      _nw40[(int)(6209)] = 13;
      _nw40[(int)(6210)] = 80;
      _nw40[(int)(6211)] = 56;
      _nw40[(int)(6212)] = 164;
      _nw40[(int)(6213)] = 44;
      _nw40[(int)(6214)] = 140;
      _nw40[(int)(6215)] = 49;
      _nw40[(int)(6216)] = 239;
      _nw40[(int)(6217)] = 97;
      _nw40[(int)(6218)] = 59;
      _nw40[(int)(6219)] = 137;
      _nw40[(int)(6220)] = 66;
      _nw40[(int)(6221)] = 238;
      _nw40[(int)(6222)] = 192;
      _nw40[(int)(6223)] = 227;
      _nw40[(int)(6224)] = 173;
      _nw40[(int)(6225)] = 153;
      _nw40[(int)(6226)] = 216;
      _nw40[(int)(6227)] = 221;
      _nw40[(int)(6228)] = 172;
      _nw40[(int)(6229)] = 150;
      _nw40[(int)(6230)] = 9;
      _nw40[(int)(6231)] = 221;
      _nw40[(int)(6232)] = 30;
      _nw40[(int)(6233)] = 54;
      _nw40[(int)(6234)] = 8;
      _nw40[(int)(6235)] = 118;
      _nw40[(int)(6236)] = 96;
      _nw40[(int)(6237)] = 131;
      _nw40[(int)(6238)] = 244;
      _nw40[(int)(6239)] = 163;
      _nw40[(int)(6240)] = 56;
      _nw40[(int)(6241)] = 233;
      _nw40[(int)(6242)] = 74;
      _nw40[(int)(6243)] = 157;
      _nw40[(int)(6244)] = 10;
      _nw40[(int)(6245)] = 64;
      _nw40[(int)(6246)] = 47;
      _nw40[(int)(6247)] = 241;
      _nw40[(int)(6248)] = 182;
      _nw40[(int)(6249)] = 28;
      _nw40[(int)(6250)] = 123;
      _nw40[(int)(6251)] = 108;
      _nw40[(int)(6252)] = 203;
      _nw40[(int)(6253)] = 240;
      _nw40[(int)(6254)] = 186;
      _nw40[(int)(6255)] = 121;
      _nw40[(int)(6256)] = 82;
      _nw40[(int)(6257)] = 200;
      _nw40[(int)(6258)] = 45;
      _nw40[(int)(6259)] = 227;
      _nw40[(int)(6260)] = 62;
      _nw40[(int)(6261)] = 161;
      _nw40[(int)(6262)] = 130;
      _nw40[(int)(6263)] = 147;
      _nw40[(int)(6264)] = 3;
      _nw40[(int)(6265)] = 211;
      _nw40[(int)(6266)] = 8;
      _nw40[(int)(6267)] = 86;
      _nw40[(int)(6268)] = 2;
      _nw40[(int)(6269)] = 141;
      _nw40[(int)(6270)] = 29;
      _nw40[(int)(6271)] = 254;
      _nw40[(int)(6272)] = 136;
      _nw40[(int)(6273)] = 39;
      _nw40[(int)(6274)] = 205;
      _nw40[(int)(6275)] = 77;
      _nw40[(int)(6276)] = 51;
      _nw40[(int)(6277)] = 74;
      _nw40[(int)(6278)] = 89;
      _nw40[(int)(6279)] = 183;
      _nw40[(int)(6280)] = 137;
      _nw40[(int)(6281)] = 237;
      _nw40[(int)(6282)] = 215;
      _nw40[(int)(6283)] = 138;
      _nw40[(int)(6284)] = 157;
      _nw40[(int)(6285)] = 105;
      _nw40[(int)(6286)] = 184;
      _nw40[(int)(6287)] = 248;
      _nw40[(int)(6288)] = 146;
      _nw40[(int)(6289)] = 242;
      _nw40[(int)(6290)] = 50;
      _nw40[(int)(6291)] = 98;
      _nw40[(int)(6292)] = 46;
      _nw40[(int)(6293)] = 8;
      _nw40[(int)(6294)] = 89;
      _nw40[(int)(6295)] = 40;
      _nw40[(int)(6296)] = 62;
      _nw40[(int)(6297)] = 255;
      _nw40[(int)(6298)] = 158;
      _nw40[(int)(6299)] = 42;
      _nw40[(int)(6300)] = 253;
      _nw40[(int)(6301)] = 146;
      _nw40[(int)(6302)] = 164;
      _nw40[(int)(6303)] = 126;
      _nw40[(int)(6304)] = 98;
      _nw40[(int)(6305)] = 23;
      _nw40[(int)(6306)] = 238;
      _nw40[(int)(6307)] = 162;
      _nw40[(int)(6308)] = 163;
      _nw40[(int)(6309)] = 76;
      _nw40[(int)(6310)] = 148;
      _nw40[(int)(6311)] = 239;
      _nw40[(int)(6312)] = 98;
      _nw40[(int)(6313)] = 40;
      _nw40[(int)(6314)] = 61;
      _nw40[(int)(6315)] = 48;
      _nw40[(int)(6316)] = 164;
      _nw40[(int)(6317)] = 207;
      _nw40[(int)(6318)] = 19;
      _nw40[(int)(6319)] = 39;
      _nw40[(int)(6320)] = 238;
      _nw40[(int)(6321)] = 76;
      _nw40[(int)(6322)] = 199;
      _nw40[(int)(6323)] = 11;
      _nw40[(int)(6324)] = 114;
      _nw40[(int)(6325)] = 66;
      _nw40[(int)(6326)] = 80;
      _nw40[(int)(6327)] = 198;
      _nw40[(int)(6328)] = 110;
      _nw40[(int)(6329)] = 67;
      _nw40[(int)(6330)] = 10;
      _nw40[(int)(6331)] = 246;
      _nw40[(int)(6332)] = 159;
      _nw40[(int)(6333)] = 46;
      _nw40[(int)(6334)] = 61;
      _nw40[(int)(6335)] = 111;
      _nw40[(int)(6336)] = 185;
      _nw40[(int)(6337)] = 38;
      _nw40[(int)(6338)] = 178;
      _nw40[(int)(6339)] = 86;
      _nw40[(int)(6340)] = 153;
      _nw40[(int)(6341)] = 196;
      _nw40[(int)(6342)] = 117;
      _nw40[(int)(6343)] = 51;
      _nw40[(int)(6344)] = 96;
      _nw40[(int)(6345)] = 24;
      _nw40[(int)(6346)] = 247;
      _nw40[(int)(6347)] = 121;
      _nw40[(int)(6348)] = 71;
      _nw40[(int)(6349)] = 6;
      _nw40[(int)(6350)] = 220;
      _nw40[(int)(6351)] = 98;
      _nw40[(int)(6352)] = 226;
      _nw40[(int)(6353)] = 225;
      _nw40[(int)(6354)] = 69;
      _nw40[(int)(6355)] = 217;
      _nw40[(int)(6356)] = 166;
      _nw40[(int)(6357)] = 175;
      _nw40[(int)(6358)] = 98;
      _nw40[(int)(6359)] = 62;
      _nw40[(int)(6360)] = 50;
      _nw40[(int)(6361)] = 254;
      _nw40[(int)(6362)] = 248;
      _nw40[(int)(6363)] = 193;
      _nw40[(int)(6364)] = 177;
      _nw40[(int)(6365)] = 30;
      _nw40[(int)(6366)] = 183;
      _nw40[(int)(6367)] = 238;
      _nw40[(int)(6368)] = 95;
      _nw40[(int)(6369)] = 226;
      _nw40[(int)(6370)] = 82;
      _nw40[(int)(6371)] = 214;
      _nw40[(int)(6372)] = 128;
      _nw40[(int)(6373)] = 54;
      _nw40[(int)(6374)] = 147;
      _nw40[(int)(6375)] = 122;
      _nw40[(int)(6376)] = 120;
      _nw40[(int)(6377)] = 99;
      _nw40[(int)(6378)] = 9;
      _nw40[(int)(6379)] = 219;
      _nw40[(int)(6380)] = 113;
      _nw40[(int)(6381)] = 30;
      _nw40[(int)(6382)] = 104;
      _nw40[(int)(6383)] = 133;
      _nw40[(int)(6384)] = 12;
      _nw40[(int)(6385)] = 237;
      _nw40[(int)(6386)] = 135;
      _nw40[(int)(6387)] = 99;
      _nw40[(int)(6388)] = 31;
      _nw40[(int)(6389)] = 121;
      _nw40[(int)(6390)] = 91;
      _nw40[(int)(6391)] = 106;
      _nw40[(int)(6392)] = 0;
      _nw40[(int)(6393)] = 161;
      _nw40[(int)(6394)] = 97;
      _nw40[(int)(6395)] = 167;
      _nw40[(int)(6396)] = 238;
      _nw40[(int)(6397)] = 86;
      _nw40[(int)(6398)] = 117;
      _nw40[(int)(6399)] = 235;
      _nw40[(int)(6400)] = 87;
      _nw40[(int)(6401)] = 175;
      _nw40[(int)(6402)] = 27;
      _nw40[(int)(6403)] = 18;
      _nw40[(int)(6404)] = 174;
      _nw40[(int)(6405)] = 36;
      _nw40[(int)(6406)] = 220;
      _nw40[(int)(6407)] = 167;
      _nw40[(int)(6408)] = 135;
      _nw40[(int)(6409)] = 198;
      _nw40[(int)(6410)] = 157;
      _nw40[(int)(6411)] = 82;
      _nw40[(int)(6412)] = 63;
      _nw40[(int)(6413)] = 108;
      _nw40[(int)(6414)] = 147;
      _nw40[(int)(6415)] = 149;
      _nw40[(int)(6416)] = 197;
      _nw40[(int)(6417)] = 97;
      _nw40[(int)(6418)] = 89;
      _nw40[(int)(6419)] = 76;
      _nw40[(int)(6420)] = 26;
      _nw40[(int)(6421)] = 103;
      _nw40[(int)(6422)] = 16;
      _nw40[(int)(6423)] = 35;
      _nw40[(int)(6424)] = 188;
      _nw40[(int)(6425)] = 90;
      _nw40[(int)(6426)] = 145;
      _nw40[(int)(6427)] = 254;
      _nw40[(int)(6428)] = 230;
      _nw40[(int)(6429)] = 56;
      _nw40[(int)(6430)] = 233;
      _nw40[(int)(6431)] = 230;
      _nw40[(int)(6432)] = 74;
      _nw40[(int)(6433)] = 96;
      _nw40[(int)(6434)] = 238;
      _nw40[(int)(6435)] = 255;
      _nw40[(int)(6436)] = 26;
      _nw40[(int)(6437)] = 148;
      _nw40[(int)(6438)] = 20;
      _nw40[(int)(6439)] = 211;
      _nw40[(int)(6440)] = 50;
      _nw40[(int)(6441)] = 48;
      _nw40[(int)(6442)] = 22;
      _nw40[(int)(6443)] = 190;
      _nw40[(int)(6444)] = 79;
      _nw40[(int)(6445)] = 55;
      _nw40[(int)(6446)] = 202;
      _nw40[(int)(6447)] = 51;
      _nw40[(int)(6448)] = 220;
      _nw40[(int)(6449)] = 12;
      _nw40[(int)(6450)] = 3;
      _nw40[(int)(6451)] = 222;
      _nw40[(int)(6452)] = 91;
      _nw40[(int)(6453)] = 1;
      _nw40[(int)(6454)] = 86;
      _nw40[(int)(6455)] = 97;
      _nw40[(int)(6456)] = 216;
      _nw40[(int)(6457)] = 90;
      _nw40[(int)(6458)] = 3;
      _nw40[(int)(6459)] = 209;
      _nw40[(int)(6460)] = 88;
      _nw40[(int)(6461)] = 40;
      _nw40[(int)(6462)] = 68;
      _nw40[(int)(6463)] = 209;
      _nw40[(int)(6464)] = 71;
      _nw40[(int)(6465)] = 233;
      _nw40[(int)(6466)] = 239;
      _nw40[(int)(6467)] = 54;
      _nw40[(int)(6468)] = 21;
      _nw40[(int)(6469)] = 171;
      _nw40[(int)(6470)] = 11;
      _nw40[(int)(6471)] = 95;
      _nw40[(int)(6472)] = 2;
      _nw40[(int)(6473)] = 180;
      _nw40[(int)(6474)] = 95;
      _nw40[(int)(6475)] = 74;
      _nw40[(int)(6476)] = 13;
      _nw40[(int)(6477)] = 133;
      _nw40[(int)(6478)] = 134;
      _nw40[(int)(6479)] = 32;
      _nw40[(int)(6480)] = 227;
      _nw40[(int)(6481)] = 39;
      _nw40[(int)(6482)] = 247;
      _nw40[(int)(6483)] = 113;
      _nw40[(int)(6484)] = 46;
      _nw40[(int)(6485)] = 247;
      _nw40[(int)(6486)] = 177;
      _nw40[(int)(6487)] = 89;
      _nw40[(int)(6488)] = 46;
      _nw40[(int)(6489)] = 3;
      _nw40[(int)(6490)] = 166;
      _nw40[(int)(6491)] = 227;
      _nw40[(int)(6492)] = 23;
      _nw40[(int)(6493)] = 123;
      _nw40[(int)(6494)] = 155;
      _nw40[(int)(6495)] = 57;
      _nw40[(int)(6496)] = 44;
      _nw40[(int)(6497)] = 142;
      _nw40[(int)(6498)] = 37;
      _nw40[(int)(6499)] = 80;
      _nw40[(int)(6500)] = 3;
      _nw40[(int)(6501)] = 247;
      _nw40[(int)(6502)] = 30;
      _nw40[(int)(6503)] = 196;
      _nw40[(int)(6504)] = 127;
      _nw40[(int)(6505)] = 158;
      _nw40[(int)(6506)] = 21;
      _nw40[(int)(6507)] = 73;
      _nw40[(int)(6508)] = 177;
      _nw40[(int)(6509)] = 90;
      _nw40[(int)(6510)] = 241;
      _nw40[(int)(6511)] = 204;
      _nw40[(int)(6512)] = 1;
      _nw40[(int)(6513)] = 224;
      _nw40[(int)(6514)] = 84;
      _nw40[(int)(6515)] = 225;
      _nw40[(int)(6516)] = 193;
      _nw40[(int)(6517)] = 213;
      _nw40[(int)(6518)] = 249;
      _nw40[(int)(6519)] = 167;
      _nw40[(int)(6520)] = 238;
      _nw40[(int)(6521)] = 48;
      _nw40[(int)(6522)] = 108;
      _nw40[(int)(6523)] = 189;
      _nw40[(int)(6524)] = 248;
      _nw40[(int)(6525)] = 123;
      _nw40[(int)(6526)] = 96;
      _nw40[(int)(6527)] = 115;
      _nw40[(int)(6528)] = 232;
      _nw40[(int)(6529)] = 237;
      _nw40[(int)(6530)] = 103;
      _nw40[(int)(6531)] = 78;
      _nw40[(int)(6532)] = 167;
      _nw40[(int)(6533)] = 222;
      _nw40[(int)(6534)] = 77;
      _nw40[(int)(6535)] = 96;
      _nw40[(int)(6536)] = 10;
      _nw40[(int)(6537)] = 56;
      _nw40[(int)(6538)] = 31;
      _nw40[(int)(6539)] = 214;
      _nw40[(int)(6540)] = 159;
      _nw40[(int)(6541)] = 236;
      _nw40[(int)(6542)] = 51;
      _nw40[(int)(6543)] = 134;
      _nw40[(int)(6544)] = 53;
      _nw40[(int)(6545)] = 185;
      _nw40[(int)(6546)] = 175;
      _nw40[(int)(6547)] = 139;
      _nw40[(int)(6548)] = 177;
      _nw40[(int)(6549)] = 40;
      _nw40[(int)(6550)] = 145;
      _nw40[(int)(6551)] = 15;
      _nw40[(int)(6552)] = 196;
      _nw40[(int)(6553)] = 38;
      _nw40[(int)(6554)] = 205;
      _nw40[(int)(6555)] = 222;
      _nw40[(int)(6556)] = 242;
      _nw40[(int)(6557)] = 198;
      _nw40[(int)(6558)] = 23;
      _nw40[(int)(6559)] = 113;
      _nw40[(int)(6560)] = 62;
      _nw40[(int)(6561)] = 116;
      _nw40[(int)(6562)] = 102;
      _nw40[(int)(6563)] = 71;
      _nw40[(int)(6564)] = 166;
      _nw40[(int)(6565)] = 92;
      _nw40[(int)(6566)] = 173;
      _nw40[(int)(6567)] = 50;
      _nw40[(int)(6568)] = 64;
      _nw40[(int)(6569)] = 167;
      _nw40[(int)(6570)] = 58;
      _nw40[(int)(6571)] = 255;
      _nw40[(int)(6572)] = 39;
      _nw40[(int)(6573)] = 5;
      _nw40[(int)(6574)] = 146;
      _nw40[(int)(6575)] = 91;
      _nw40[(int)(6576)] = 58;
      _nw40[(int)(6577)] = 15;
      _nw40[(int)(6578)] = 195;
      _nw40[(int)(6579)] = 244;
      _nw40[(int)(6580)] = 51;
      _nw40[(int)(6581)] = 251;
      _nw40[(int)(6582)] = 4;
      _nw40[(int)(6583)] = 176;
      _nw40[(int)(6584)] = 10;
      _nw40[(int)(6585)] = 222;
      _nw40[(int)(6586)] = 6;
      _nw40[(int)(6587)] = 130;
      _nw40[(int)(6588)] = 1;
      _nw40[(int)(6589)] = 255;
      _nw40[(int)(6590)] = 46;
      _nw40[(int)(6591)] = 130;
      _nw40[(int)(6592)] = 4;
      _nw40[(int)(6593)] = 224;
      _nw40[(int)(6594)] = 200;
      _nw40[(int)(6595)] = 134;
      _nw40[(int)(6596)] = 227;
      _nw40[(int)(6597)] = 175;
      _nw40[(int)(6598)] = 73;
      _nw40[(int)(6599)] = 152;
      _nw40[(int)(6600)] = 80;
      _nw40[(int)(6601)] = 115;
      _nw40[(int)(6602)] = 138;
      _nw40[(int)(6603)] = 139;
      _nw40[(int)(6604)] = 152;
      _nw40[(int)(6605)] = 255;
      _nw40[(int)(6606)] = 13;
      _nw40[(int)(6607)] = 16;
      _nw40[(int)(6608)] = 34;
      _nw40[(int)(6609)] = 20;
      _nw40[(int)(6610)] = 236;
      _nw40[(int)(6611)] = 123;
      _nw40[(int)(6612)] = 180;
      _nw40[(int)(6613)] = 197;
      _nw40[(int)(6614)] = 221;
      _nw40[(int)(6615)] = 133;
      _nw40[(int)(6616)] = 52;
      _nw40[(int)(6617)] = 132;
      _nw40[(int)(6618)] = 25;
      _nw40[(int)(6619)] = 80;
      _nw40[(int)(6620)] = 251;
      _nw40[(int)(6621)] = 127;
      _nw40[(int)(6622)] = 132;
      _nw40[(int)(6623)] = 199;
      _nw40[(int)(6624)] = 146;
      _nw40[(int)(6625)] = 66;
      _nw40[(int)(6626)] = 148;
      _nw40[(int)(6627)] = 47;
      _nw40[(int)(6628)] = 24;
      _nw40[(int)(6629)] = 67;
      _nw40[(int)(6630)] = 62;
      _nw40[(int)(6631)] = 165;
      _nw40[(int)(6632)] = 186;
      _nw40[(int)(6633)] = 212;
      _nw40[(int)(6634)] = 187;
      _nw40[(int)(6635)] = 224;
      _nw40[(int)(6636)] = 62;
      _nw40[(int)(6637)] = 1;
      _nw40[(int)(6638)] = 187;
      _nw40[(int)(6639)] = 118;
      _nw40[(int)(6640)] = 229;
      _nw40[(int)(6641)] = 214;
      _nw40[(int)(6642)] = 69;
      _nw40[(int)(6643)] = 222;
      _nw40[(int)(6644)] = 223;
      _nw40[(int)(6645)] = 67;
      _nw40[(int)(6646)] = 81;
      _nw40[(int)(6647)] = 238;
      _nw40[(int)(6648)] = 143;
      _nw40[(int)(6649)] = 4;
      _nw40[(int)(6650)] = 246;
      _nw40[(int)(6651)] = 60;
      _nw40[(int)(6652)] = 65;
      _nw40[(int)(6653)] = 67;
      _nw40[(int)(6654)] = 43;
      _nw40[(int)(6655)] = 90;
      _nw40[(int)(6656)] = 184;
      _nw40[(int)(6657)] = 110;
      _nw40[(int)(6658)] = 73;
      _nw40[(int)(6659)] = 231;
      _nw40[(int)(6660)] = 255;
      _nw40[(int)(6661)] = 93;
      _nw40[(int)(6662)] = 115;
      _nw40[(int)(6663)] = 131;
      _nw40[(int)(6664)] = 87;
      _nw40[(int)(6665)] = 15;
      _nw40[(int)(6666)] = 159;
      _nw40[(int)(6667)] = 130;
      _nw40[(int)(6668)] = 220;
      _nw40[(int)(6669)] = 3;
      _nw40[(int)(6670)] = 34;
      _nw40[(int)(6671)] = 51;
      _nw40[(int)(6672)] = 101;
      _nw40[(int)(6673)] = 154;
      _nw40[(int)(6674)] = 219;
      _nw40[(int)(6675)] = 3;
      _nw40[(int)(6676)] = 250;
      _nw40[(int)(6677)] = 81;
      _nw40[(int)(6678)] = 105;
      _nw40[(int)(6679)] = 192;
      _nw40[(int)(6680)] = 10;
      _nw40[(int)(6681)] = 32;
      _nw40[(int)(6682)] = 16;
      _nw40[(int)(6683)] = 200;
      _nw40[(int)(6684)] = 208;
      _nw40[(int)(6685)] = 196;
      _nw40[(int)(6686)] = 97;
      _nw40[(int)(6687)] = 72;
      _nw40[(int)(6688)] = 189;
      _nw40[(int)(6689)] = 135;
      _nw40[(int)(6690)] = 191;
      _nw40[(int)(6691)] = 42;
      _nw40[(int)(6692)] = 25;
      _nw40[(int)(6693)] = 52;
      _nw40[(int)(6694)] = 119;
      _nw40[(int)(6695)] = 69;
      _nw40[(int)(6696)] = 15;
      _nw40[(int)(6697)] = 230;
      _nw40[(int)(6698)] = 197;
      _nw40[(int)(6699)] = 143;
      _nw40[(int)(6700)] = 51;
      _nw40[(int)(6701)] = 243;
      _nw40[(int)(6702)] = 100;
      _nw40[(int)(6703)] = 130;
      _nw40[(int)(6704)] = 171;
      _nw40[(int)(6705)] = 176;
      _nw40[(int)(6706)] = 97;
      _nw40[(int)(6707)] = 192;
      _nw40[(int)(6708)] = 125;
      _nw40[(int)(6709)] = 168;
      _nw40[(int)(6710)] = 35;
      _nw40[(int)(6711)] = 127;
      _nw40[(int)(6712)] = 180;
      _nw40[(int)(6713)] = 223;
      _nw40[(int)(6714)] = 208;
      _nw40[(int)(6715)] = 51;
      _nw40[(int)(6716)] = 127;
      _nw40[(int)(6717)] = 69;
      _nw40[(int)(6718)] = 142;
      _nw40[(int)(6719)] = 93;
      _nw40[(int)(6720)] = 188;
      _nw40[(int)(6721)] = 205;
      _nw40[(int)(6722)] = 223;
      _nw40[(int)(6723)] = 172;
      _nw40[(int)(6724)] = 96;
      _nw40[(int)(6725)] = 178;
      _nw40[(int)(6726)] = 236;
      _nw40[(int)(6727)] = 23;
      _nw40[(int)(6728)] = 59;
      _nw40[(int)(6729)] = 207;
      _nw40[(int)(6730)] = 119;
      _nw40[(int)(6731)] = 109;
      _nw40[(int)(6732)] = 162;
      _nw40[(int)(6733)] = 253;
      _nw40[(int)(6734)] = 5;
      _nw40[(int)(6735)] = 226;
      _nw40[(int)(6736)] = 152;
      _nw40[(int)(6737)] = 239;
      _nw40[(int)(6738)] = 228;
      _nw40[(int)(6739)] = 109;
      _nw40[(int)(6740)] = 146;
      _nw40[(int)(6741)] = 168;
      _nw40[(int)(6742)] = 147;
      _nw40[(int)(6743)] = 56;
      _nw40[(int)(6744)] = 7;
      _nw40[(int)(6745)] = 166;
      _nw40[(int)(6746)] = 118;
      _nw40[(int)(6747)] = 131;
      _nw40[(int)(6748)] = 130;
      _nw40[(int)(6749)] = 207;
      _nw40[(int)(6750)] = 115;
      _nw40[(int)(6751)] = 24;
      _nw40[(int)(6752)] = 206;
      _nw40[(int)(6753)] = 215;
      _nw40[(int)(6754)] = 104;
      _nw40[(int)(6755)] = 244;
      _nw40[(int)(6756)] = 109;
      _nw40[(int)(6757)] = 230;
      _nw40[(int)(6758)] = 132;
      _nw40[(int)(6759)] = 79;
      _nw40[(int)(6760)] = 188;
      _nw40[(int)(6761)] = 89;
      _nw40[(int)(6762)] = 210;
      _nw40[(int)(6763)] = 91;
      _nw40[(int)(6764)] = 210;
      _nw40[(int)(6765)] = 28;
      _nw40[(int)(6766)] = 204;
      _nw40[(int)(6767)] = 96;
      _nw40[(int)(6768)] = 173;
      _nw40[(int)(6769)] = 104;
      _nw40[(int)(6770)] = 121;
      _nw40[(int)(6771)] = 112;
      _nw40[(int)(6772)] = 116;
      _nw40[(int)(6773)] = 89;
      _nw40[(int)(6774)] = 6;
      _nw40[(int)(6775)] = 191;
      _nw40[(int)(6776)] = 172;
      _nw40[(int)(6777)] = 67;
      _nw40[(int)(6778)] = 153;
      _nw40[(int)(6779)] = 98;
      _nw40[(int)(6780)] = 236;
      _nw40[(int)(6781)] = 118;
      _nw40[(int)(6782)] = 151;
      _nw40[(int)(6783)] = 17;
      _nw40[(int)(6784)] = 154;
      _nw40[(int)(6785)] = 133;
      _nw40[(int)(6786)] = 212;
      _nw40[(int)(6787)] = 237;
      _nw40[(int)(6788)] = 246;
      _nw40[(int)(6789)] = 32;
      _nw40[(int)(6790)] = 46;
      _nw40[(int)(6791)] = 60;
      _nw40[(int)(6792)] = 146;
      _nw40[(int)(6793)] = 93;
      _nw40[(int)(6794)] = 98;
      _nw40[(int)(6795)] = 34;
      _nw40[(int)(6796)] = 68;
      _nw40[(int)(6797)] = 189;
      _nw40[(int)(6798)] = 178;
      _nw40[(int)(6799)] = 59;
      _nw40[(int)(6800)] = 100;
      _nw40[(int)(6801)] = 130;
      _nw40[(int)(6802)] = 99;
      _nw40[(int)(6803)] = 225;
      _nw40[(int)(6804)] = 57;
      _nw40[(int)(6805)] = 198;
      _nw40[(int)(6806)] = 105;
      _nw40[(int)(6807)] = 11;
      _nw40[(int)(6808)] = 100;
      _nw40[(int)(6809)] = 201;
      _nw40[(int)(6810)] = 112;
      _nw40[(int)(6811)] = 203;
      _nw40[(int)(6812)] = 2;
      _nw40[(int)(6813)] = 137;
      _nw40[(int)(6814)] = 229;
      _nw40[(int)(6815)] = 109;
      _nw40[(int)(6816)] = 177;
      _nw40[(int)(6817)] = 45;
      _nw40[(int)(6818)] = 81;
      _nw40[(int)(6819)] = 45;
      _nw40[(int)(6820)] = 221;
      _nw40[(int)(6821)] = 228;
      _nw40[(int)(6822)] = 73;
      _nw40[(int)(6823)] = 82;
      _nw40[(int)(6824)] = 189;
      _nw40[(int)(6825)] = 156;
      _nw40[(int)(6826)] = 165;
      _nw40[(int)(6827)] = 236;
      _nw40[(int)(6828)] = 162;
      _nw40[(int)(6829)] = 164;
      _nw40[(int)(6830)] = 114;
      _nw40[(int)(6831)] = 57;
      _nw40[(int)(6832)] = 142;
      _nw40[(int)(6833)] = 226;
      _nw40[(int)(6834)] = 191;
      _nw40[(int)(6835)] = 188;
      _nw40[(int)(6836)] = 71;
      _nw40[(int)(6837)] = 190;
      _nw40[(int)(6838)] = 143;
      _nw40[(int)(6839)] = 134;
      _nw40[(int)(6840)] = 138;
      _nw40[(int)(6841)] = 173;
      _nw40[(int)(6842)] = 224;
      _nw40[(int)(6843)] = 70;
      _nw40[(int)(6844)] = 87;
      _nw40[(int)(6845)] = 183;
      _nw40[(int)(6846)] = 128;
      _nw40[(int)(6847)] = 173;
      _nw40[(int)(6848)] = 142;
      _nw40[(int)(6849)] = 68;
      _nw40[(int)(6850)] = 50;
      _nw40[(int)(6851)] = 2;
      _nw40[(int)(6852)] = 127;
      _nw40[(int)(6853)] = 128;
      _nw40[(int)(6854)] = 112;
      _nw40[(int)(6855)] = 221;
      _nw40[(int)(6856)] = 254;
      _nw40[(int)(6857)] = 113;
      _nw40[(int)(6858)] = 212;
      _nw40[(int)(6859)] = 39;
      _nw40[(int)(6860)] = 62;
      _nw40[(int)(6861)] = 135;
      _nw40[(int)(6862)] = 70;
      _nw40[(int)(6863)] = 32;
      _nw40[(int)(6864)] = 68;
      _nw40[(int)(6865)] = 97;
      _nw40[(int)(6866)] = 192;
      _nw40[(int)(6867)] = 81;
      _nw40[(int)(6868)] = 25;
      _nw40[(int)(6869)] = 84;
      _nw40[(int)(6870)] = 185;
      _nw40[(int)(6871)] = 96;
      _nw40[(int)(6872)] = 86;
      _nw40[(int)(6873)] = 48;
      _nw40[(int)(6874)] = 227;
      _nw40[(int)(6875)] = 250;
      _nw40[(int)(6876)] = 3;
      _nw40[(int)(6877)] = 56;
      _nw40[(int)(6878)] = 212;
      _nw40[(int)(6879)] = 7;
      _nw40[(int)(6880)] = 195;
      _nw40[(int)(6881)] = 34;
      _nw40[(int)(6882)] = 243;
      _nw40[(int)(6883)] = 88;
      _nw40[(int)(6884)] = 142;
      _nw40[(int)(6885)] = 29;
      _nw40[(int)(6886)] = 33;
      _nw40[(int)(6887)] = 218;
      _nw40[(int)(6888)] = 79;
      _nw40[(int)(6889)] = 152;
      _nw40[(int)(6890)] = 245;
      _nw40[(int)(6891)] = 121;
      _nw40[(int)(6892)] = 227;
      _nw40[(int)(6893)] = 215;
      _nw40[(int)(6894)] = 69;
      _nw40[(int)(6895)] = 72;
      _nw40[(int)(6896)] = 17;
      _nw40[(int)(6897)] = 139;
      _nw40[(int)(6898)] = 52;
      _nw40[(int)(6899)] = 206;
      _nw40[(int)(6900)] = 204;
      _nw40[(int)(6901)] = 234;
      _nw40[(int)(6902)] = 252;
      _nw40[(int)(6903)] = 36;
      _nw40[(int)(6904)] = 251;
      _nw40[(int)(6905)] = 17;
      _nw40[(int)(6906)] = 244;
      _nw40[(int)(6907)] = 245;
      _nw40[(int)(6908)] = 250;
      _nw40[(int)(6909)] = 5;
      _nw40[(int)(6910)] = 36;
      _nw40[(int)(6911)] = 199;
      _nw40[(int)(6912)] = 93;
      _nw40[(int)(6913)] = 126;
      _nw40[(int)(6914)] = 58;
      _nw40[(int)(6915)] = 101;
      _nw40[(int)(6916)] = 69;
      _nw40[(int)(6917)] = 250;
      _nw40[(int)(6918)] = 144;
      _nw40[(int)(6919)] = 231;
      _nw40[(int)(6920)] = 190;
      _nw40[(int)(6921)] = 2;
      _nw40[(int)(6922)] = 149;
      _nw40[(int)(6923)] = 191;
      _nw40[(int)(6924)] = 204;
      _nw40[(int)(6925)] = 225;
      _nw40[(int)(6926)] = 217;
      _nw40[(int)(6927)] = 135;
      _nw40[(int)(6928)] = 66;
      _nw40[(int)(6929)] = 255;
      _nw40[(int)(6930)] = 80;
      _nw40[(int)(6931)] = 135;
      _nw40[(int)(6932)] = 95;
      _nw40[(int)(6933)] = 112;
      _nw40[(int)(6934)] = 20;
      _nw40[(int)(6935)] = 206;
      _nw40[(int)(6936)] = 190;
      _nw40[(int)(6937)] = 183;
      _nw40[(int)(6938)] = 119;
      _nw40[(int)(6939)] = 251;
      _nw40[(int)(6940)] = 195;
      _nw40[(int)(6941)] = 196;
      _nw40[(int)(6942)] = 137;
      _nw40[(int)(6943)] = 75;
      _nw40[(int)(6944)] = 218;
      _nw40[(int)(6945)] = 59;
      _nw40[(int)(6946)] = 117;
      _nw40[(int)(6947)] = 55;
      _nw40[(int)(6948)] = 182;
      _nw40[(int)(6949)] = 148;
      _nw40[(int)(6950)] = 20;
      _nw40[(int)(6951)] = 215;
      _nw40[(int)(6952)] = 31;
      _nw40[(int)(6953)] = 228;
      _nw40[(int)(6954)] = 177;
      _nw40[(int)(6955)] = 192;
      _nw40[(int)(6956)] = 69;
      _nw40[(int)(6957)] = 176;
      _nw40[(int)(6958)] = 207;
      _nw40[(int)(6959)] = 121;
      _nw40[(int)(6960)] = 47;
      _nw40[(int)(6961)] = 35;
      _nw40[(int)(6962)] = 125;
      _nw40[(int)(6963)] = 129;
      _nw40[(int)(6964)] = 249;
      _nw40[(int)(6965)] = 79;
      _nw40[(int)(6966)] = 54;
      _nw40[(int)(6967)] = 224;
      _nw40[(int)(6968)] = 70;
      _nw40[(int)(6969)] = 240;
      _nw40[(int)(6970)] = 78;
      _nw40[(int)(6971)] = 251;
      _nw40[(int)(6972)] = 250;
      _nw40[(int)(6973)] = 149;
      _nw40[(int)(6974)] = 56;
      _nw40[(int)(6975)] = 254;
      _nw40[(int)(6976)] = 247;
      _nw40[(int)(6977)] = 207;
      _nw40[(int)(6978)] = 63;
      _nw40[(int)(6979)] = 146;
      _nw40[(int)(6980)] = 192;
      _nw40[(int)(6981)] = 175;
      _nw40[(int)(6982)] = 86;
      _nw40[(int)(6983)] = 20;
      _nw40[(int)(6984)] = 49;
      _nw40[(int)(6985)] = 226;
      _nw40[(int)(6986)] = 42;
      _nw40[(int)(6987)] = 113;
      _nw40[(int)(6988)] = 98;
      _nw40[(int)(6989)] = 142;
      _nw40[(int)(6990)] = 52;
      _nw40[(int)(6991)] = 198;
      _nw40[(int)(6992)] = 8;
      _nw40[(int)(6993)] = 15;
      _nw40[(int)(6994)] = 164;
      _nw40[(int)(6995)] = 58;
      _nw40[(int)(6996)] = 3;
      _nw40[(int)(6997)] = 26;
      _nw40[(int)(6998)] = 253;
      _nw40[(int)(6999)] = 66;
      _nw40[(int)(7000)] = 168;
      _nw40[(int)(7001)] = 185;
      _nw40[(int)(7002)] = 81;
      _nw40[(int)(7003)] = 230;
      _nw40[(int)(7004)] = 143;
      _nw40[(int)(7005)] = 53;
      _nw40[(int)(7006)] = 8;
      _nw40[(int)(7007)] = 38;
      _nw40[(int)(7008)] = 61;
      _nw40[(int)(7009)] = 245;
      _nw40[(int)(7010)] = 99;
      _nw40[(int)(7011)] = 242;
      _nw40[(int)(7012)] = 24;
      _nw40[(int)(7013)] = 56;
      _nw40[(int)(7014)] = 169;
      _nw40[(int)(7015)] = 33;
      _nw40[(int)(7016)] = 108;
      _nw40[(int)(7017)] = 240;
      _nw40[(int)(7018)] = 57;
      _nw40[(int)(7019)] = 34;
      _nw40[(int)(7020)] = 141;
      _nw40[(int)(7021)] = 62;
      _nw40[(int)(7022)] = 169;
      _nw40[(int)(7023)] = 212;
      _nw40[(int)(7024)] = 135;
      _nw40[(int)(7025)] = 102;
      _nw40[(int)(7026)] = 246;
      _nw40[(int)(7027)] = 183;
      _nw40[(int)(7028)] = 114;
      _nw40[(int)(7029)] = 111;
      _nw40[(int)(7030)] = 171;
      _nw40[(int)(7031)] = 200;
      _nw40[(int)(7032)] = 10;
      _nw40[(int)(7033)] = 42;
      _nw40[(int)(7034)] = 108;
      _nw40[(int)(7035)] = 121;
      _nw40[(int)(7036)] = 91;
      _nw40[(int)(7037)] = 2;
      _nw40[(int)(7038)] = 138;
      _nw40[(int)(7039)] = 44;
      _nw40[(int)(7040)] = 181;
      _nw40[(int)(7041)] = 54;
      _nw40[(int)(7042)] = 119;
      _nw40[(int)(7043)] = 9;
      _nw40[(int)(7044)] = 183;
      _nw40[(int)(7045)] = 97;
      _nw40[(int)(7046)] = 202;
      _nw40[(int)(7047)] = 137;
      _nw40[(int)(7048)] = 88;
      _nw40[(int)(7049)] = 200;
      _nw40[(int)(7050)] = 189;
      _nw40[(int)(7051)] = 162;
      _nw40[(int)(7052)] = 33;
      _nw40[(int)(7053)] = 43;
      _nw40[(int)(7054)] = 254;
      _nw40[(int)(7055)] = 22;
      _nw40[(int)(7056)] = 12;
      _nw40[(int)(7057)] = 36;
      _nw40[(int)(7058)] = 109;
      _nw40[(int)(7059)] = 225;
      _nw40[(int)(7060)] = 112;
      _nw40[(int)(7061)] = 120;
      _nw40[(int)(7062)] = 106;
      _nw40[(int)(7063)] = 213;
      _nw40[(int)(7064)] = 98;
      _nw40[(int)(7065)] = 122;
      _nw40[(int)(7066)] = 254;
      _nw40[(int)(7067)] = 95;
      _nw40[(int)(7068)] = 99;
      _nw40[(int)(7069)] = 85;
      _nw40[(int)(7070)] = 223;
      _nw40[(int)(7071)] = 212;
      _nw40[(int)(7072)] = 209;
      _nw40[(int)(7073)] = 50;
      _nw40[(int)(7074)] = 70;
      _nw40[(int)(7075)] = 131;
      _nw40[(int)(7076)] = 156;
      _nw40[(int)(7077)] = 218;
      _nw40[(int)(7078)] = 180;
      _nw40[(int)(7079)] = 106;
      _nw40[(int)(7080)] = 113;
      _nw40[(int)(7081)] = 184;
      _nw40[(int)(7082)] = 198;
      _nw40[(int)(7083)] = 230;
      _nw40[(int)(7084)] = 206;
      _nw40[(int)(7085)] = 0;
      _nw40[(int)(7086)] = 189;
      _nw40[(int)(7087)] = 26;
      _nw40[(int)(7088)] = 0;
      _nw40[(int)(7089)] = 119;
      _nw40[(int)(7090)] = 138;
      _nw40[(int)(7091)] = 60;
      _nw40[(int)(7092)] = 88;
      _nw40[(int)(7093)] = 203;
      _nw40[(int)(7094)] = 23;
      _nw40[(int)(7095)] = 145;
      _nw40[(int)(7096)] = 233;
      _nw40[(int)(7097)] = 8;
      _nw40[(int)(7098)] = 72;
      _nw40[(int)(7099)] = 17;
      _nw40[(int)(7100)] = 94;
      _nw40[(int)(7101)] = 227;
      _nw40[(int)(7102)] = 42;
      _nw40[(int)(7103)] = 247;
      _nw40[(int)(7104)] = 251;
      _nw40[(int)(7105)] = 135;
      _nw40[(int)(7106)] = 217;
      _nw40[(int)(7107)] = 142;
      _nw40[(int)(7108)] = 232;
      _nw40[(int)(7109)] = 240;
      _nw40[(int)(7110)] = 12;
      _nw40[(int)(7111)] = 19;
      _nw40[(int)(7112)] = 219;
      _nw40[(int)(7113)] = 22;
      _nw40[(int)(7114)] = 180;
      _nw40[(int)(7115)] = 107;
      _nw40[(int)(7116)] = 174;
      _nw40[(int)(7117)] = 178;
      _nw40[(int)(7118)] = 236;
      _nw40[(int)(7119)] = 40;
      _nw40[(int)(7120)] = 94;
      _nw40[(int)(7121)] = 121;
      _nw40[(int)(7122)] = 140;
      _nw40[(int)(7123)] = 140;
      _nw40[(int)(7124)] = 191;
      _nw40[(int)(7125)] = 59;
      _nw40[(int)(7126)] = 224;
      _nw40[(int)(7127)] = 117;
      _nw40[(int)(7128)] = 156;
      _nw40[(int)(7129)] = 167;
      _nw40[(int)(7130)] = 113;
      _nw40[(int)(7131)] = 131;
      _nw40[(int)(7132)] = 70;
      _nw40[(int)(7133)] = 216;
      _nw40[(int)(7134)] = 255;
      _nw40[(int)(7135)] = 45;
      _nw40[(int)(7136)] = 36;
      _nw40[(int)(7137)] = 16;
      _nw40[(int)(7138)] = 184;
      _nw40[(int)(7139)] = 138;
      _nw40[(int)(7140)] = 30;
      _nw40[(int)(7141)] = 149;
      _nw40[(int)(7142)] = 58;
      _nw40[(int)(7143)] = 240;
      _nw40[(int)(7144)] = 220;
      _nw40[(int)(7145)] = 227;
      _nw40[(int)(7146)] = 248;
      _nw40[(int)(7147)] = 12;
      _nw40[(int)(7148)] = 167;
      _nw40[(int)(7149)] = 131;
      _nw40[(int)(7150)] = 65;
      _nw40[(int)(7151)] = 237;
      _nw40[(int)(7152)] = 78;
      _nw40[(int)(7153)] = 227;
      _nw40[(int)(7154)] = 245;
      _nw40[(int)(7155)] = 62;
      _nw40[(int)(7156)] = 7;
      _nw40[(int)(7157)] = 179;
      _nw40[(int)(7158)] = 189;
      _nw40[(int)(7159)] = 138;
      _nw40[(int)(7160)] = 219;
      _nw40[(int)(7161)] = 115;
      _nw40[(int)(7162)] = 65;
      _nw40[(int)(7163)] = 243;
      _nw40[(int)(7164)] = 180;
      _nw40[(int)(7165)] = 245;
      _nw40[(int)(7166)] = 251;
      _nw40[(int)(7167)] = 24;
      _nw40[(int)(7168)] = 67;
      _nw40[(int)(7169)] = 119;
      _nw40[(int)(7170)] = 128;
      _nw40[(int)(7171)] = 48;
      _nw40[(int)(7172)] = 11;
      _nw40[(int)(7173)] = 81;
      _nw40[(int)(7174)] = 11;
      _nw40[(int)(7175)] = 226;
      _nw40[(int)(7176)] = 241;
      _nw40[(int)(7177)] = 13;
      _nw40[(int)(7178)] = 16;
      _nw40[(int)(7179)] = 72;
      _nw40[(int)(7180)] = 171;
      _nw40[(int)(7181)] = 125;
      _nw40[(int)(7182)] = 54;
      _nw40[(int)(7183)] = 15;
      _nw40[(int)(7184)] = 152;
      _nw40[(int)(7185)] = 162;
      _nw40[(int)(7186)] = 66;
      _nw40[(int)(7187)] = 239;
      _nw40[(int)(7188)] = 206;
      _nw40[(int)(7189)] = 12;
      _nw40[(int)(7190)] = 141;
      _nw40[(int)(7191)] = 232;
      _nw40[(int)(7192)] = 167;
      _nw40[(int)(7193)] = 251;
      _nw40[(int)(7194)] = 56;
      _nw40[(int)(7195)] = 180;
      _nw40[(int)(7196)] = 132;
      _nw40[(int)(7197)] = 109;
      _nw40[(int)(7198)] = 65;
      _nw40[(int)(7199)] = 254;
      _nw40[(int)(7200)] = 177;
      _nw40[(int)(7201)] = 138;
      _nw40[(int)(7202)] = 144;
      _nw40[(int)(7203)] = 241;
      _nw40[(int)(7204)] = 72;
      _nw40[(int)(7205)] = 248;
      _nw40[(int)(7206)] = 72;
      _nw40[(int)(7207)] = 70;
      _nw40[(int)(7208)] = 154;
      _nw40[(int)(7209)] = 85;
      _nw40[(int)(7210)] = 55;
      _nw40[(int)(7211)] = 236;
      _nw40[(int)(7212)] = 61;
      _nw40[(int)(7213)] = 234;
      _nw40[(int)(7214)] = 118;
      _nw40[(int)(7215)] = 67;
      _nw40[(int)(7216)] = 175;
      _nw40[(int)(7217)] = 34;
      _nw40[(int)(7218)] = 191;
      _nw40[(int)(7219)] = 91;
      _nw40[(int)(7220)] = 43;
      _nw40[(int)(7221)] = 123;
      _nw40[(int)(7222)] = 26;
      _nw40[(int)(7223)] = 125;
      _nw40[(int)(7224)] = 206;
      _nw40[(int)(7225)] = 255;
      _nw40[(int)(7226)] = 137;
      _nw40[(int)(7227)] = 247;
      _nw40[(int)(7228)] = 188;
      _nw40[(int)(7229)] = 111;
      _nw40[(int)(7230)] = 134;
      _nw40[(int)(7231)] = 77;
      _nw40[(int)(7232)] = 174;
      _nw40[(int)(7233)] = 108;
      _nw40[(int)(7234)] = 21;
      _nw40[(int)(7235)] = 91;
      _nw40[(int)(7236)] = 3;
      _nw40[(int)(7237)] = 213;
      _nw40[(int)(7238)] = 252;
      _nw40[(int)(7239)] = 156;
      _nw40[(int)(7240)] = 133;
      _nw40[(int)(7241)] = 11;
      _nw40[(int)(7242)] = 208;
      _nw40[(int)(7243)] = 40;
      _nw40[(int)(7244)] = 180;
      _nw40[(int)(7245)] = 252;
      _nw40[(int)(7246)] = 60;
      _nw40[(int)(7247)] = 192;
      _nw40[(int)(7248)] = 150;
      _nw40[(int)(7249)] = 175;
      _nw40[(int)(7250)] = 77;
      _nw40[(int)(7251)] = 179;
      _nw40[(int)(7252)] = 124;
      _nw40[(int)(7253)] = 234;
      _nw40[(int)(7254)] = 167;
      _nw40[(int)(7255)] = 114;
      _nw40[(int)(7256)] = 84;
      _nw40[(int)(7257)] = 115;
      _nw40[(int)(7258)] = 66;
      _nw40[(int)(7259)] = 65;
      _nw40[(int)(7260)] = 170;
      _nw40[(int)(7261)] = 108;
      _nw40[(int)(7262)] = 36;
      _nw40[(int)(7263)] = 31;
      _nw40[(int)(7264)] = 192;
      _nw40[(int)(7265)] = 13;
      _nw40[(int)(7266)] = 236;
      _nw40[(int)(7267)] = 169;
      _nw40[(int)(7268)] = 176;
      _nw40[(int)(7269)] = 62;
      _nw40[(int)(7270)] = 156;
      _nw40[(int)(7271)] = 89;
      _nw40[(int)(7272)] = 59;
      _nw40[(int)(7273)] = 89;
      _nw40[(int)(7274)] = 150;
      _nw40[(int)(7275)] = 155;
      _nw40[(int)(7276)] = 133;
      _nw40[(int)(7277)] = 5;
      _nw40[(int)(7278)] = 108;
      _nw40[(int)(7279)] = 175;
      _nw40[(int)(7280)] = 254;
      _nw40[(int)(7281)] = 164;
      _nw40[(int)(7282)] = 56;
      _nw40[(int)(7283)] = 45;
      _nw40[(int)(7284)] = 201;
      _nw40[(int)(7285)] = 173;
      _nw40[(int)(7286)] = 101;
      _nw40[(int)(7287)] = 129;
      _nw40[(int)(7288)] = 73;
      _nw40[(int)(7289)] = 64;
      _nw40[(int)(7290)] = 233;
      _nw40[(int)(7291)] = 208;
      _nw40[(int)(7292)] = 64;
      _nw40[(int)(7293)] = 15;
      _nw40[(int)(7294)] = 21;
      _nw40[(int)(7295)] = 203;
      _nw40[(int)(7296)] = 104;
      _nw40[(int)(7297)] = 204;
      _nw40[(int)(7298)] = 136;
      _nw40[(int)(7299)] = 143;
      _nw40[(int)(7300)] = 175;
      _nw40[(int)(7301)] = 107;
      _nw40[(int)(7302)] = 48;
      _nw40[(int)(7303)] = 43;
      _nw40[(int)(7304)] = 41;
      _nw40[(int)(7305)] = 55;
      _nw40[(int)(7306)] = 207;
      _nw40[(int)(7307)] = 196;
      _nw40[(int)(7308)] = 78;
      _nw40[(int)(7309)] = 66;
      _nw40[(int)(7310)] = 251;
      _nw40[(int)(7311)] = 178;
      _nw40[(int)(7312)] = 97;
      _nw40[(int)(7313)] = 145;
      _nw40[(int)(7314)] = 110;
      _nw40[(int)(7315)] = 195;
      _nw40[(int)(7316)] = 43;
      _nw40[(int)(7317)] = 213;
      _nw40[(int)(7318)] = 109;
      _nw40[(int)(7319)] = 141;
      _nw40[(int)(7320)] = 126;
      _nw40[(int)(7321)] = 120;
      _nw40[(int)(7322)] = 63;
      _nw40[(int)(7323)] = 129;
      _nw40[(int)(7324)] = 212;
      _nw40[(int)(7325)] = 175;
      _nw40[(int)(7326)] = 137;
      _nw40[(int)(7327)] = 175;
      _nw40[(int)(7328)] = 47;
      _nw40[(int)(7329)] = 230;
      _nw40[(int)(7330)] = 122;
      _nw40[(int)(7331)] = 49;
      _nw40[(int)(7332)] = 73;
      _nw40[(int)(7333)] = 153;
      _nw40[(int)(7334)] = 229;
      _nw40[(int)(7335)] = 126;
      _nw40[(int)(7336)] = 76;
      _nw40[(int)(7337)] = 26;
      _nw40[(int)(7338)] = 14;
      _nw40[(int)(7339)] = 162;
      _nw40[(int)(7340)] = 26;
      _nw40[(int)(7341)] = 62;
      _nw40[(int)(7342)] = 202;
      _nw40[(int)(7343)] = 236;
      _nw40[(int)(7344)] = 77;
      _nw40[(int)(7345)] = 247;
      _nw40[(int)(7346)] = 100;
      _nw40[(int)(7347)] = 212;
      _nw40[(int)(7348)] = 69;
      _nw40[(int)(7349)] = 228;
      _nw40[(int)(7350)] = 47;
      _nw40[(int)(7351)] = 213;
      _nw40[(int)(7352)] = 244;
      _nw40[(int)(7353)] = 225;
      _nw40[(int)(7354)] = 41;
      _nw40[(int)(7355)] = 231;
      _nw40[(int)(7356)] = 116;
      _nw40[(int)(7357)] = 93;
      _nw40[(int)(7358)] = 84;
      _nw40[(int)(7359)] = 183;
      _nw40[(int)(7360)] = 62;
      _nw40[(int)(7361)] = 51;
      _nw40[(int)(7362)] = 39;
      _nw40[(int)(7363)] = 121;
      _nw40[(int)(7364)] = 235;
      _nw40[(int)(7365)] = 158;
      _nw40[(int)(7366)] = 147;
      _nw40[(int)(7367)] = 224;
      _nw40[(int)(7368)] = 126;
      _nw40[(int)(7369)] = 254;
      _nw40[(int)(7370)] = 156;
      _nw40[(int)(7371)] = 132;
      _nw40[(int)(7372)] = 191;
      _nw40[(int)(7373)] = 155;
      _nw40[(int)(7374)] = 106;
      _nw40[(int)(7375)] = 252;
      _nw40[(int)(7376)] = 164;
      _nw40[(int)(7377)] = 221;
      _nw40[(int)(7378)] = 99;
      _nw40[(int)(7379)] = 132;
      _nw40[(int)(7380)] = 234;
      _nw40[(int)(7381)] = 153;
      _nw40[(int)(7382)] = 63;
      _nw40[(int)(7383)] = 23;
      _nw40[(int)(7384)] = 216;
      _nw40[(int)(7385)] = 176;
      _nw40[(int)(7386)] = 246;
      _nw40[(int)(7387)] = 219;
      _nw40[(int)(7388)] = 22;
      _nw40[(int)(7389)] = 50;
      _nw40[(int)(7390)] = 87;
      _nw40[(int)(7391)] = 240;
      _nw40[(int)(7392)] = 125;
      _nw40[(int)(7393)] = 204;
      _nw40[(int)(7394)] = 3;
      _nw40[(int)(7395)] = 210;
      _nw40[(int)(7396)] = 7;
      _nw40[(int)(7397)] = 225;
      _nw40[(int)(7398)] = 96;
      _nw40[(int)(7399)] = 1;
      _nw40[(int)(7400)] = 241;
      _nw40[(int)(7401)] = 234;
      _nw40[(int)(7402)] = 225;
      _nw40[(int)(7403)] = 216;
      _nw40[(int)(7404)] = 10;
      _nw40[(int)(7405)] = 185;
      _nw40[(int)(7406)] = 18;
      _nw40[(int)(7407)] = 180;
      _nw40[(int)(7408)] = 220;
      _nw40[(int)(7409)] = 245;
      _nw40[(int)(7410)] = 128;
      _nw40[(int)(7411)] = 11;
      _nw40[(int)(7412)] = 137;
      _nw40[(int)(7413)] = 118;
      _nw40[(int)(7414)] = 93;
      _nw40[(int)(7415)] = 131;
      _nw40[(int)(7416)] = 209;
      _nw40[(int)(7417)] = 203;
      _nw40[(int)(7418)] = 232;
      _nw40[(int)(7419)] = 156;
      _nw40[(int)(7420)] = 213;
      _nw40[(int)(7421)] = 243;
      _nw40[(int)(7422)] = 30;
      _nw40[(int)(7423)] = 92;
      _nw40[(int)(7424)] = 126;
      _nw40[(int)(7425)] = 60;
      _nw40[(int)(7426)] = 176;
      _nw40[(int)(7427)] = 210;
      _nw40[(int)(7428)] = 227;
      _nw40[(int)(7429)] = 73;
      _nw40[(int)(7430)] = 185;
      _nw40[(int)(7431)] = 20;
      _nw40[(int)(7432)] = 165;
      _nw40[(int)(7433)] = 49;
      _nw40[(int)(7434)] = 182;
      _nw40[(int)(7435)] = 20;
      _nw40[(int)(7436)] = 104;
      _nw40[(int)(7437)] = 223;
      _nw40[(int)(7438)] = 117;
      _nw40[(int)(7439)] = 116;
      _nw40[(int)(7440)] = 158;
      _nw40[(int)(7441)] = 211;
      _nw40[(int)(7442)] = 73;
      _nw40[(int)(7443)] = 198;
      _nw40[(int)(7444)] = 46;
      _nw40[(int)(7445)] = 69;
      _nw40[(int)(7446)] = 150;
      _nw40[(int)(7447)] = 182;
      _nw40[(int)(7448)] = 174;
      _nw40[(int)(7449)] = 219;
      _nw40[(int)(7450)] = 54;
      _nw40[(int)(7451)] = 39;
      _nw40[(int)(7452)] = 223;
      _nw40[(int)(7453)] = 187;
      _nw40[(int)(7454)] = 78;
      _nw40[(int)(7455)] = 63;
      _nw40[(int)(7456)] = 20;
      _nw40[(int)(7457)] = 209;
      _nw40[(int)(7458)] = 14;
      _nw40[(int)(7459)] = 37;
      _nw40[(int)(7460)] = 209;
      _nw40[(int)(7461)] = 107;
      _nw40[(int)(7462)] = 7;
      _nw40[(int)(7463)] = 147;
      _nw40[(int)(7464)] = 195;
      _nw40[(int)(7465)] = 195;
      _nw40[(int)(7466)] = 247;
      _nw40[(int)(7467)] = 231;
      _nw40[(int)(7468)] = 122;
      _nw40[(int)(7469)] = 108;
      _nw40[(int)(7470)] = 89;
      _nw40[(int)(7471)] = 219;
      _nw40[(int)(7472)] = 205;
      _nw40[(int)(7473)] = 230;
      _nw40[(int)(7474)] = 186;
      _nw40[(int)(7475)] = 1;
      _nw40[(int)(7476)] = 8;
      _nw40[(int)(7477)] = 196;
      _nw40[(int)(7478)] = 194;
      _nw40[(int)(7479)] = 244;
      _nw40[(int)(7480)] = 206;
      _nw40[(int)(7481)] = 176;
      _nw40[(int)(7482)] = 73;
      _nw40[(int)(7483)] = 55;
      _nw40[(int)(7484)] = 163;
      _nw40[(int)(7485)] = 213;
      _nw40[(int)(7486)] = 78;
      _nw40[(int)(7487)] = 255;
      _nw40[(int)(7488)] = 232;
      _nw40[(int)(7489)] = 81;
      _nw40[(int)(7490)] = 148;
      _nw40[(int)(7491)] = 106;
      _nw40[(int)(7492)] = 50;
      _nw40[(int)(7493)] = 141;
      _nw40[(int)(7494)] = 160;
      _nw40[(int)(7495)] = 134;
      _nw40[(int)(7496)] = 27;
      _nw40[(int)(7497)] = 223;
      _nw40[(int)(7498)] = 15;
      _nw40[(int)(7499)] = 87;
      _nw40[(int)(7500)] = 66;
      _nw40[(int)(7501)] = 100;
      _nw40[(int)(7502)] = 210;
      _nw40[(int)(7503)] = 215;
      _nw40[(int)(7504)] = 43;
      _nw40[(int)(7505)] = 113;
      _nw40[(int)(7506)] = 3;
      _nw40[(int)(7507)] = 218;
      _nw40[(int)(7508)] = 182;
      _nw40[(int)(7509)] = 232;
      _nw40[(int)(7510)] = 203;
      _nw40[(int)(7511)] = 192;
      _nw40[(int)(7512)] = 225;
      _nw40[(int)(7513)] = 139;
      _nw40[(int)(7514)] = 163;
      _nw40[(int)(7515)] = 213;
      _nw40[(int)(7516)] = 49;
      _nw40[(int)(7517)] = 55;
      _nw40[(int)(7518)] = 114;
      _nw40[(int)(7519)] = 105;
      _nw40[(int)(7520)] = 236;
      _nw40[(int)(7521)] = 215;
      _nw40[(int)(7522)] = 165;
      _nw40[(int)(7523)] = 251;
      _nw40[(int)(7524)] = 150;
      _nw40[(int)(7525)] = 171;
      _nw40[(int)(7526)] = 17;
      _nw40[(int)(7527)] = 124;
      _nw40[(int)(7528)] = 143;
      _nw40[(int)(7529)] = 158;
      _nw40[(int)(7530)] = 206;
      _nw40[(int)(7531)] = 109;
      _nw40[(int)(7532)] = 150;
      _nw40[(int)(7533)] = 43;
      _nw40[(int)(7534)] = 229;
      _nw40[(int)(7535)] = 236;
      _nw40[(int)(7536)] = 35;
      _nw40[(int)(7537)] = 170;
      _nw40[(int)(7538)] = 14;
      _nw40[(int)(7539)] = 81;
      _nw40[(int)(7540)] = 10;
      _nw40[(int)(7541)] = 27;
      _nw40[(int)(7542)] = 249;
      _nw40[(int)(7543)] = 220;
      _nw40[(int)(7544)] = 134;
      _nw40[(int)(7545)] = 128;
      _nw40[(int)(7546)] = 255;
      _nw40[(int)(7547)] = 71;
      _nw40[(int)(7548)] = 12;
      _nw40[(int)(7549)] = 35;
      _nw40[(int)(7550)] = 250;
      _nw40[(int)(7551)] = 41;
      _nw40[(int)(7552)] = 72;
      _nw40[(int)(7553)] = 143;
      _nw40[(int)(7554)] = 34;
      _nw40[(int)(7555)] = 203;
      _nw40[(int)(7556)] = 0;
      _nw40[(int)(7557)] = 21;
      _nw40[(int)(7558)] = 169;
      _nw40[(int)(7559)] = 42;
      _nw40[(int)(7560)] = 210;
      _nw40[(int)(7561)] = 31;
      _nw40[(int)(7562)] = 23;
      _nw40[(int)(7563)] = 86;
      _nw40[(int)(7564)] = 48;
      _nw40[(int)(7565)] = 125;
      _nw40[(int)(7566)] = 164;
      _nw40[(int)(7567)] = 248;
      _nw40[(int)(7568)] = 77;
      _nw40[(int)(7569)] = 236;
      _nw40[(int)(7570)] = 25;
      _nw40[(int)(7571)] = 248;
      _nw40[(int)(7572)] = 233;
      _nw40[(int)(7573)] = 72;
      _nw40[(int)(7574)] = 196;
      _nw40[(int)(7575)] = 64;
      _nw40[(int)(7576)] = 20;
      _nw40[(int)(7577)] = 104;
      _nw40[(int)(7578)] = 97;
      _nw40[(int)(7579)] = 249;
      _nw40[(int)(7580)] = 75;
      _nw40[(int)(7581)] = 168;
      _nw40[(int)(7582)] = 68;
      _nw40[(int)(7583)] = 148;
      _nw40[(int)(7584)] = 102;
      _nw40[(int)(7585)] = 55;
      _nw40[(int)(7586)] = 217;
      _nw40[(int)(7587)] = 242;
      _nw40[(int)(7588)] = 63;
      _nw40[(int)(7589)] = 219;
      _nw40[(int)(7590)] = 102;
      _nw40[(int)(7591)] = 45;
      _nw40[(int)(7592)] = 90;
      _nw40[(int)(7593)] = 112;
      _nw40[(int)(7594)] = 55;
      _nw40[(int)(7595)] = 96;
      _nw40[(int)(7596)] = 230;
      _nw40[(int)(7597)] = 155;
      _nw40[(int)(7598)] = 9;
      _nw40[(int)(7599)] = 64;
      _nw40[(int)(7600)] = 96;
      _nw40[(int)(7601)] = 17;
      _nw40[(int)(7602)] = 20;
      _nw40[(int)(7603)] = 64;
      _nw40[(int)(7604)] = 129;
      _nw40[(int)(7605)] = 183;
      _nw40[(int)(7606)] = 46;
      _nw40[(int)(7607)] = 41;
      _nw40[(int)(7608)] = 2;
      _nw40[(int)(7609)] = 171;
      _nw40[(int)(7610)] = 141;
      _nw40[(int)(7611)] = 78;
      _nw40[(int)(7612)] = 91;
      _nw40[(int)(7613)] = 190;
      _nw40[(int)(7614)] = 85;
      _nw40[(int)(7615)] = 26;
      _nw40[(int)(7616)] = 254;
      _nw40[(int)(7617)] = 111;
      _nw40[(int)(7618)] = 221;
      _nw40[(int)(7619)] = 180;
      _nw40[(int)(7620)] = 11;
      _nw40[(int)(7621)] = 152;
      _nw40[(int)(7622)] = 212;
      _nw40[(int)(7623)] = 65;
      _nw40[(int)(7624)] = 166;
      _nw40[(int)(7625)] = 176;
      _nw40[(int)(7626)] = 80;
      _nw40[(int)(7627)] = 107;
      _nw40[(int)(7628)] = 58;
      _nw40[(int)(7629)] = 89;
      _nw40[(int)(7630)] = 180;
      _nw40[(int)(7631)] = 207;
      _nw40[(int)(7632)] = 123;
      _nw40[(int)(7633)] = 20;
      _nw40[(int)(7634)] = 38;
      _nw40[(int)(7635)] = 30;
      _nw40[(int)(7636)] = 14;
      _nw40[(int)(7637)] = 83;
      _nw40[(int)(7638)] = 215;
      _nw40[(int)(7639)] = 75;
      _nw40[(int)(7640)] = 41;
      _nw40[(int)(7641)] = 129;
      _nw40[(int)(7642)] = 55;
      _nw40[(int)(7643)] = 104;
      _nw40[(int)(7644)] = 187;
      _nw40[(int)(7645)] = 157;
      _nw40[(int)(7646)] = 72;
      _nw40[(int)(7647)] = 142;
      _nw40[(int)(7648)] = 167;
      _nw40[(int)(7649)] = 246;
      _nw40[(int)(7650)] = 127;
      _nw40[(int)(7651)] = 38;
      _nw40[(int)(7652)] = 153;
      _nw40[(int)(7653)] = 58;
      _nw40[(int)(7654)] = 147;
      _nw40[(int)(7655)] = 190;
      _nw40[(int)(7656)] = 59;
      _nw40[(int)(7657)] = 95;
      _nw40[(int)(7658)] = 183;
      _nw40[(int)(7659)] = 188;
      _nw40[(int)(7660)] = 246;
      _nw40[(int)(7661)] = 34;
      _nw40[(int)(7662)] = 34;
      _nw40[(int)(7663)] = 12;
      _nw40[(int)(7664)] = 5;
      _nw40[(int)(7665)] = 219;
      _nw40[(int)(7666)] = 110;
      _nw40[(int)(7667)] = 9;
      _nw40[(int)(7668)] = 14;
      _nw40[(int)(7669)] = 125;
      _nw40[(int)(7670)] = 75;
      _nw40[(int)(7671)] = 140;
      _nw40[(int)(7672)] = 46;
      _nw40[(int)(7673)] = 255;
      _nw40[(int)(7674)] = 205;
      _nw40[(int)(7675)] = 77;
      _nw40[(int)(7676)] = 91;
      _nw40[(int)(7677)] = 253;
      _nw40[(int)(7678)] = 238;
      _nw40[(int)(7679)] = 106;
      _nw40[(int)(7680)] = 198;
      _nw40[(int)(7681)] = 55;
      _nw40[(int)(7682)] = 234;
      _nw40[(int)(7683)] = 247;
      _nw40[(int)(7684)] = 192;
      _nw40[(int)(7685)] = 139;
      _nw40[(int)(7686)] = 89;
      _nw40[(int)(7687)] = 237;
      _nw40[(int)(7688)] = 193;
      _nw40[(int)(7689)] = 164;
      _nw40[(int)(7690)] = 90;
      _nw40[(int)(7691)] = 127;
      _nw40[(int)(7692)] = 195;
      _nw40[(int)(7693)] = 129;
      _nw40[(int)(7694)] = 41;
      _nw40[(int)(7695)] = 73;
      _nw40[(int)(7696)] = 123;
      _nw40[(int)(7697)] = 248;
      _nw40[(int)(7698)] = 53;
      _nw40[(int)(7699)] = 4;
      _nw40[(int)(7700)] = 84;
      _nw40[(int)(7701)] = 17;
      _nw40[(int)(7702)] = 59;
      _nw40[(int)(7703)] = 25;
      _nw40[(int)(7704)] = 24;
      _nw40[(int)(7705)] = 118;
      _nw40[(int)(7706)] = 127;
      _nw40[(int)(7707)] = 206;
      _nw40[(int)(7708)] = 6;
      _nw40[(int)(7709)] = 194;
      _nw40[(int)(7710)] = 149;
      _nw40[(int)(7711)] = 224;
      _nw40[(int)(7712)] = 46;
      _nw40[(int)(7713)] = 166;
      _nw40[(int)(7714)] = 228;
      _nw40[(int)(7715)] = 194;
      _nw40[(int)(7716)] = 87;
      _nw40[(int)(7717)] = 252;
      _nw40[(int)(7718)] = 151;
      _nw40[(int)(7719)] = 111;
      _nw40[(int)(7720)] = 182;
      _nw40[(int)(7721)] = 135;
      _nw40[(int)(7722)] = 207;
      _nw40[(int)(7723)] = 144;
      _nw40[(int)(7724)] = 37;
      _nw40[(int)(7725)] = 239;
      _nw40[(int)(7726)] = 184;
      _nw40[(int)(7727)] = 31;
      _nw40[(int)(7728)] = 198;
      _nw40[(int)(7729)] = 220;
      _nw40[(int)(7730)] = 141;
      _nw40[(int)(7731)] = 205;
      _nw40[(int)(7732)] = 33;
      _nw40[(int)(7733)] = 51;
      _nw40[(int)(7734)] = 167;
      _nw40[(int)(7735)] = 126;
      _nw40[(int)(7736)] = 163;
      _nw40[(int)(7737)] = 154;
      _nw40[(int)(7738)] = 67;
      _nw40[(int)(7739)] = 16;
      _nw40[(int)(7740)] = 56;
      _nw40[(int)(7741)] = 197;
      _nw40[(int)(7742)] = 144;
      _nw40[(int)(7743)] = 40;
      _nw40[(int)(7744)] = 214;
      _nw40[(int)(7745)] = 62;
      _nw40[(int)(7746)] = 122;
      _nw40[(int)(7747)] = 20;
      _nw40[(int)(7748)] = 206;
      _nw40[(int)(7749)] = 94;
      _nw40[(int)(7750)] = 2;
      _nw40[(int)(7751)] = 210;
      _nw40[(int)(7752)] = 127;
      _nw40[(int)(7753)] = 230;
      _nw40[(int)(7754)] = 19;
      _nw40[(int)(7755)] = 47;
      _nw40[(int)(7756)] = 251;
      _nw40[(int)(7757)] = 50;
      _nw40[(int)(7758)] = 140;
      _nw40[(int)(7759)] = 209;
      _nw40[(int)(7760)] = 236;
      _nw40[(int)(7761)] = 235;
      _nw40[(int)(7762)] = 217;
      _nw40[(int)(7763)] = 3;
      _nw40[(int)(7764)] = 34;
      _nw40[(int)(7765)] = 49;
      _nw40[(int)(7766)] = 140;
      _nw40[(int)(7767)] = 166;
      _nw40[(int)(7768)] = 204;
      _nw40[(int)(7769)] = 195;
      _nw40[(int)(7770)] = 18;
      _nw40[(int)(7771)] = 135;
      _nw40[(int)(7772)] = 18;
      _nw40[(int)(7773)] = 36;
      _nw40[(int)(7774)] = 107;
      _nw40[(int)(7775)] = 115;
      _nw40[(int)(7776)] = 121;
      _nw40[(int)(7777)] = 21;
      _nw40[(int)(7778)] = 199;
      _nw40[(int)(7779)] = 147;
      _nw40[(int)(7780)] = 4;
      _nw40[(int)(7781)] = 213;
      _nw40[(int)(7782)] = 80;
      _nw40[(int)(7783)] = 55;
      _nw40[(int)(7784)] = 139;
      _nw40[(int)(7785)] = 169;
      _nw40[(int)(7786)] = 223;
      _nw40[(int)(7787)] = 204;
      _nw40[(int)(7788)] = 33;
      _nw40[(int)(7789)] = 180;
      _nw40[(int)(7790)] = 186;
      _nw40[(int)(7791)] = 202;
      _nw40[(int)(7792)] = 209;
      _nw40[(int)(7793)] = 222;
      _nw40[(int)(7794)] = 134;
      _nw40[(int)(7795)] = 78;
      _nw40[(int)(7796)] = 29;
      _nw40[(int)(7797)] = 32;
      _nw40[(int)(7798)] = 238;
      _nw40[(int)(7799)] = 162;
      _nw40[(int)(7800)] = 27;
      _nw40[(int)(7801)] = 90;
      _nw40[(int)(7802)] = 197;
      _nw40[(int)(7803)] = 42;
      _nw40[(int)(7804)] = 124;
      _nw40[(int)(7805)] = 99;
      _nw40[(int)(7806)] = 210;
      _nw40[(int)(7807)] = 218;
      _nw40[(int)(7808)] = 186;
      _nw40[(int)(7809)] = 227;
      _nw40[(int)(7810)] = 167;
      _nw40[(int)(7811)] = 213;
      _nw40[(int)(7812)] = 55;
      _nw40[(int)(7813)] = 91;
      _nw40[(int)(7814)] = 239;
      _nw40[(int)(7815)] = 115;
      _nw40[(int)(7816)] = 200;
      _nw40[(int)(7817)] = 24;
      _nw40[(int)(7818)] = 13;
      _nw40[(int)(7819)] = 23;
      _nw40[(int)(7820)] = 239;
      _nw40[(int)(7821)] = 83;
      _nw40[(int)(7822)] = 188;
      _nw40[(int)(7823)] = 205;
      _nw40[(int)(7824)] = 50;
      _nw40[(int)(7825)] = 253;
      _nw40[(int)(7826)] = 193;
      _nw40[(int)(7827)] = 188;
      _nw40[(int)(7828)] = 167;
      _nw40[(int)(7829)] = 214;
      _nw40[(int)(7830)] = 168;
      _nw40[(int)(7831)] = 220;
      _nw40[(int)(7832)] = 184;
      _nw40[(int)(7833)] = 152;
      _nw40[(int)(7834)] = 168;
      _nw40[(int)(7835)] = 247;
      _nw40[(int)(7836)] = 110;
      _nw40[(int)(7837)] = 86;
      _nw40[(int)(7838)] = 134;
      _nw40[(int)(7839)] = 45;
      _nw40[(int)(7840)] = 38;
      _nw40[(int)(7841)] = 66;
      _nw40[(int)(7842)] = 70;
      _nw40[(int)(7843)] = 37;
      _nw40[(int)(7844)] = 22;
      _nw40[(int)(7845)] = 67;
      _nw40[(int)(7846)] = 54;
      _nw40[(int)(7847)] = 191;
      _nw40[(int)(7848)] = 252;
      _nw40[(int)(7849)] = 120;
      _nw40[(int)(7850)] = 220;
      _nw40[(int)(7851)] = 123;
      _nw40[(int)(7852)] = 53;
      _nw40[(int)(7853)] = 201;
      _nw40[(int)(7854)] = 226;
      _nw40[(int)(7855)] = 72;
      _nw40[(int)(7856)] = 53;
      _nw40[(int)(7857)] = 216;
      _nw40[(int)(7858)] = 82;
      _nw40[(int)(7859)] = 201;
      _nw40[(int)(7860)] = 117;
      _nw40[(int)(7861)] = 236;
      _nw40[(int)(7862)] = 79;
      _nw40[(int)(7863)] = 172;
      _nw40[(int)(7864)] = 147;
      _nw40[(int)(7865)] = 185;
      _nw40[(int)(7866)] = 29;
      _nw40[(int)(7867)] = 108;
      _nw40[(int)(7868)] = 222;
      _nw40[(int)(7869)] = 161;
      _nw40[(int)(7870)] = 33;
      _nw40[(int)(7871)] = 218;
      _nw40[(int)(7872)] = 15;
      _nw40[(int)(7873)] = 60;
      _nw40[(int)(7874)] = 73;
      _nw40[(int)(7875)] = 120;
      _nw40[(int)(7876)] = 128;
      _nw40[(int)(7877)] = 236;
      _nw40[(int)(7878)] = 161;
      _nw40[(int)(7879)] = 163;
      _nw40[(int)(7880)] = 65;
      _nw40[(int)(7881)] = 34;
      _nw40[(int)(7882)] = 231;
      _nw40[(int)(7883)] = 138;
      _nw40[(int)(7884)] = 206;
      _nw40[(int)(7885)] = 187;
      _nw40[(int)(7886)] = 182;
      _nw40[(int)(7887)] = 239;
      _nw40[(int)(7888)] = 98;
      _nw40[(int)(7889)] = 130;
      _nw40[(int)(7890)] = 217;
      _nw40[(int)(7891)] = 150;
      _nw40[(int)(7892)] = 102;
      _nw40[(int)(7893)] = 225;
      _nw40[(int)(7894)] = 111;
      _nw40[(int)(7895)] = 160;
      _nw40[(int)(7896)] = 7;
      _nw40[(int)(7897)] = 192;
      _nw40[(int)(7898)] = 28;
      _nw40[(int)(7899)] = 97;
      _nw40[(int)(7900)] = 212;
      _nw40[(int)(7901)] = 83;
      _nw40[(int)(7902)] = 35;
      _nw40[(int)(7903)] = 9;
      _nw40[(int)(7904)] = 212;
      _nw40[(int)(7905)] = 52;
      _nw40[(int)(7906)] = 190;
      _nw40[(int)(7907)] = 58;
      _nw40[(int)(7908)] = 169;
      _nw40[(int)(7909)] = 95;
      _nw40[(int)(7910)] = 82;
      _nw40[(int)(7911)] = 162;
      _nw40[(int)(7912)] = 125;
      _nw40[(int)(7913)] = 189;
      _nw40[(int)(7914)] = 194;
      _nw40[(int)(7915)] = 203;
      _nw40[(int)(7916)] = 113;
      _nw40[(int)(7917)] = 170;
      _nw40[(int)(7918)] = 166;
      _nw40[(int)(7919)] = 202;
      _nw40[(int)(7920)] = 26;
      _nw40[(int)(7921)] = 158;
      _nw40[(int)(7922)] = 116;
      _nw40[(int)(7923)] = 244;
      _nw40[(int)(7924)] = 132;
      _nw40[(int)(7925)] = 2;
      _nw40[(int)(7926)] = 252;
      _nw40[(int)(7927)] = 15;
      _nw40[(int)(7928)] = 176;
      _nw40[(int)(7929)] = 79;
      _nw40[(int)(7930)] = 157;
      _nw40[(int)(7931)] = 60;
      _nw40[(int)(7932)] = 53;
      _nw40[(int)(7933)] = 130;
      _nw40[(int)(7934)] = 4;
      _nw40[(int)(7935)] = 224;
      _nw40[(int)(7936)] = 136;
      _nw40[(int)(7937)] = 36;
      _nw40[(int)(7938)] = 147;
      _nw40[(int)(7939)] = 41;
      _nw40[(int)(7940)] = 150;
      _nw40[(int)(7941)] = 122;
      _nw40[(int)(7942)] = 184;
      _nw40[(int)(7943)] = 183;
      _nw40[(int)(7944)] = 233;
      _nw40[(int)(7945)] = 236;
      _nw40[(int)(7946)] = 135;
      _nw40[(int)(7947)] = 190;
      _nw40[(int)(7948)] = 117;
      _nw40[(int)(7949)] = 97;
      _nw40[(int)(7950)] = 86;
      _nw40[(int)(7951)] = 128;
      _nw40[(int)(7952)] = 221;
      _nw40[(int)(7953)] = 84;
      _nw40[(int)(7954)] = 128;
      _nw40[(int)(7955)] = 222;
      _nw40[(int)(7956)] = 64;
      _nw40[(int)(7957)] = 226;
      _nw40[(int)(7958)] = 99;
      _nw40[(int)(7959)] = 98;
      _nw40[(int)(7960)] = 75;
      _nw40[(int)(7961)] = 90;
      _nw40[(int)(7962)] = 99;
      _nw40[(int)(7963)] = 7;
      _nw40[(int)(7964)] = 119;
      _nw40[(int)(7965)] = 186;
      _nw40[(int)(7966)] = 11;
      _nw40[(int)(7967)] = 144;
      _nw40[(int)(7968)] = 119;
      _nw40[(int)(7969)] = 168;
      _nw40[(int)(7970)] = 198;
      _nw40[(int)(7971)] = 36;
      _nw40[(int)(7972)] = 141;
      _nw40[(int)(7973)] = 208;
      _nw40[(int)(7974)] = 130;
      _nw40[(int)(7975)] = 205;
      _nw40[(int)(7976)] = 236;
      _nw40[(int)(7977)] = 17;
      _nw40[(int)(7978)] = 248;
      _nw40[(int)(7979)] = 186;
      _nw40[(int)(7980)] = 214;
      _nw40[(int)(7981)] = 108;
      _nw40[(int)(7982)] = 241;
      _nw40[(int)(7983)] = 26;
      _nw40[(int)(7984)] = 144;
      _nw40[(int)(7985)] = 167;
      _nw40[(int)(7986)] = 253;
      _nw40[(int)(7987)] = 255;
      _nw40[(int)(7988)] = 97;
      _nw40[(int)(7989)] = 205;
      _nw40[(int)(7990)] = 72;
      _nw40[(int)(7991)] = 147;
      _nw40[(int)(7992)] = 131;
      _nw40[(int)(7993)] = 236;
      _nw40[(int)(7994)] = 46;
      _nw40[(int)(7995)] = 82;
      _nw40[(int)(7996)] = 63;
      _nw40[(int)(7997)] = 203;
      _nw40[(int)(7998)] = 10;
      _nw40[(int)(7999)] = 6;
      _nw40[(int)(8000)] = 254;
      _nw40[(int)(8001)] = 70;
      _nw40[(int)(8002)] = 95;
      _nw40[(int)(8003)] = 229;
      _nw40[(int)(8004)] = 136;
      _nw40[(int)(8005)] = 187;
      _nw40[(int)(8006)] = 199;
      _nw40[(int)(8007)] = 39;
      _nw40[(int)(8008)] = 22;
      _nw40[(int)(8009)] = 239;
      _nw40[(int)(8010)] = 146;
      _nw40[(int)(8011)] = 180;
      _nw40[(int)(8012)] = 30;
      _nw40[(int)(8013)] = 102;
      _nw40[(int)(8014)] = 103;
      _nw40[(int)(8015)] = 66;
      _nw40[(int)(8016)] = 225;
      _nw40[(int)(8017)] = 211;
      _nw40[(int)(8018)] = 21;
      _nw40[(int)(8019)] = 241;
      _nw40[(int)(8020)] = 88;
      _nw40[(int)(8021)] = 141;
      _nw40[(int)(8022)] = 142;
      _nw40[(int)(8023)] = 66;
      _nw40[(int)(8024)] = 219;
      _nw40[(int)(8025)] = 53;
      _nw40[(int)(8026)] = 234;
      _nw40[(int)(8027)] = 205;
      _nw40[(int)(8028)] = 64;
      _nw40[(int)(8029)] = 89;
      _nw40[(int)(8030)] = 58;
      _nw40[(int)(8031)] = 179;
      _nw40[(int)(8032)] = 154;
      _nw40[(int)(8033)] = 201;
      _nw40[(int)(8034)] = 30;
      _nw40[(int)(8035)] = 79;
      _nw40[(int)(8036)] = 89;
      _nw40[(int)(8037)] = 32;
      _nw40[(int)(8038)] = 3;
      _nw40[(int)(8039)] = 223;
      _nw40[(int)(8040)] = 237;
      _nw40[(int)(8041)] = 62;
      _nw40[(int)(8042)] = 215;
      _nw40[(int)(8043)] = 187;
      _nw40[(int)(8044)] = 15;
      _nw40[(int)(8045)] = 11;
      _nw40[(int)(8046)] = 187;
      _nw40[(int)(8047)] = 240;
      _nw40[(int)(8048)] = 162;
      _nw40[(int)(8049)] = 159;
      _nw40[(int)(8050)] = 173;
      _nw40[(int)(8051)] = 142;
      _nw40[(int)(8052)] = 100;
      _nw40[(int)(8053)] = 28;
      _nw40[(int)(8054)] = 68;
      _nw40[(int)(8055)] = 159;
      _nw40[(int)(8056)] = 19;
      _nw40[(int)(8057)] = 30;
      _nw40[(int)(8058)] = 167;
      _nw40[(int)(8059)] = 211;
      _nw40[(int)(8060)] = 140;
      _nw40[(int)(8061)] = 122;
      _nw40[(int)(8062)] = 214;
      _nw40[(int)(8063)] = 253;
      _nw40[(int)(8064)] = 159;
      _nw40[(int)(8065)] = 162;
      _nw40[(int)(8066)] = 240;
      _nw40[(int)(8067)] = 97;
      _nw40[(int)(8068)] = 254;
      _nw40[(int)(8069)] = 41;
      _nw40[(int)(8070)] = 216;
      _nw40[(int)(8071)] = 132;
      _nw40[(int)(8072)] = 86;
      _nw40[(int)(8073)] = 150;
      _nw40[(int)(8074)] = 218;
      _nw40[(int)(8075)] = 169;
      _nw40[(int)(8076)] = 130;
      _nw40[(int)(8077)] = 21;
      _nw40[(int)(8078)] = 246;
      _nw40[(int)(8079)] = 121;
      _nw40[(int)(8080)] = 248;
      _nw40[(int)(8081)] = 230;
      _nw40[(int)(8082)] = 213;
      _nw40[(int)(8083)] = 220;
      _nw40[(int)(8084)] = 224;
      _nw40[(int)(8085)] = 253;
      _nw40[(int)(8086)] = 119;
      _nw40[(int)(8087)] = 75;
      _nw40[(int)(8088)] = 26;
      _nw40[(int)(8089)] = 60;
      _nw40[(int)(8090)] = 126;
      _nw40[(int)(8091)] = 97;
      _nw40[(int)(8092)] = 62;
      _nw40[(int)(8093)] = 31;
      _nw40[(int)(8094)] = 243;
      _nw40[(int)(8095)] = 5;
      _nw40[(int)(8096)] = 252;
      _nw40[(int)(8097)] = 172;
      _nw40[(int)(8098)] = 52;
      _nw40[(int)(8099)] = 43;
      _nw40[(int)(8100)] = 240;
      _nw40[(int)(8101)] = 149;
      _nw40[(int)(8102)] = 71;
      _nw40[(int)(8103)] = 49;
      _nw40[(int)(8104)] = 99;
      _nw40[(int)(8105)] = 233;
      _nw40[(int)(8106)] = 159;
      _nw40[(int)(8107)] = 75;
      _nw40[(int)(8108)] = 157;
      _nw40[(int)(8109)] = 194;
      _nw40[(int)(8110)] = 68;
      _nw40[(int)(8111)] = 212;
      _nw40[(int)(8112)] = 195;
      _nw40[(int)(8113)] = 187;
      _nw40[(int)(8114)] = 101;
      _nw40[(int)(8115)] = 195;
      _nw40[(int)(8116)] = 159;
      _nw40[(int)(8117)] = 207;
      _nw40[(int)(8118)] = 62;
      _nw40[(int)(8119)] = 227;
      _nw40[(int)(8120)] = 153;
      _nw40[(int)(8121)] = 137;
      _nw40[(int)(8122)] = 51;
      _nw40[(int)(8123)] = 97;
      _nw40[(int)(8124)] = 70;
      _nw40[(int)(8125)] = 220;
      _nw40[(int)(8126)] = 183;
      _nw40[(int)(8127)] = 186;
      _nw40[(int)(8128)] = 118;
      _18519_tv__okm__desired = _nw40;
      Dafny.ISequence<byte> _18520_okm;
      Dafny.ISequence<byte> _out181;
      _out181 = HKDF_Compile.__default.Hkdf(@KeyDerivationAlgorithms.KeyDerivationAlgorithm.create_HKDF__WITH__SHA__256(), @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(Dafny.Helpers.SeqFromArray(_18517_tv__salt)), Dafny.Helpers.SeqFromArray(_18516_tv__ikm), Dafny.Helpers.SeqFromArray(_18518_tv__info), new BigInteger(8129));
      _18520_okm = _out181;
      if (!((Dafny.Helpers.SeqFromArray(_18519_tv__okm__desired)).Equals((_18520_okm)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/hkdf/HKDF.dfy(598,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
  }
} // end of namespace TestHKDF
namespace TestUtils {










  public abstract class SmallEncryptionContextVariation {
    public SmallEncryptionContextVariation() { }
    private static readonly SmallEncryptionContextVariation theDefault = create_Empty();
    public static SmallEncryptionContextVariation Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<TestUtils.SmallEncryptionContextVariation> _TYPE = new Dafny.TypeDescriptor<TestUtils.SmallEncryptionContextVariation>(TestUtils.SmallEncryptionContextVariation.Default());
    public static Dafny.TypeDescriptor<TestUtils.SmallEncryptionContextVariation> _TypeDescriptor() {
      return _TYPE;
    }
    public static SmallEncryptionContextVariation create_Empty() {
      return new SmallEncryptionContextVariation_Empty();
    }
    public static SmallEncryptionContextVariation create_A() {
      return new SmallEncryptionContextVariation_A();
    }
    public static SmallEncryptionContextVariation create_AB() {
      return new SmallEncryptionContextVariation_AB();
    }
    public static SmallEncryptionContextVariation create_BA() {
      return new SmallEncryptionContextVariation_BA();
    }
    public bool is_Empty { get { return this is SmallEncryptionContextVariation_Empty; } }
    public bool is_A { get { return this is SmallEncryptionContextVariation_A; } }
    public bool is_AB { get { return this is SmallEncryptionContextVariation_AB; } }
    public bool is_BA { get { return this is SmallEncryptionContextVariation_BA; } }
    public static System.Collections.Generic.IEnumerable<SmallEncryptionContextVariation> AllSingletonConstructors {
      get {
        yield return SmallEncryptionContextVariation.create_Empty();
        yield return SmallEncryptionContextVariation.create_A();
        yield return SmallEncryptionContextVariation.create_AB();
        yield return SmallEncryptionContextVariation.create_BA();
      }
    }
  }
  public class SmallEncryptionContextVariation_Empty : SmallEncryptionContextVariation {
    public SmallEncryptionContextVariation_Empty() {
    }
    public override bool Equals(object other) {
      var oth = other as TestUtils.SmallEncryptionContextVariation_Empty;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      return (int) hash;
    }
    public override string ToString() {
      string s = "TestUtils_Compile.SmallEncryptionContextVariation.Empty";
      return s;
    }
  }
  public class SmallEncryptionContextVariation_A : SmallEncryptionContextVariation {
    public SmallEncryptionContextVariation_A() {
    }
    public override bool Equals(object other) {
      var oth = other as TestUtils.SmallEncryptionContextVariation_A;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      return (int) hash;
    }
    public override string ToString() {
      string s = "TestUtils_Compile.SmallEncryptionContextVariation.A";
      return s;
    }
  }
  public class SmallEncryptionContextVariation_AB : SmallEncryptionContextVariation {
    public SmallEncryptionContextVariation_AB() {
    }
    public override bool Equals(object other) {
      var oth = other as TestUtils.SmallEncryptionContextVariation_AB;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 2;
      return (int) hash;
    }
    public override string ToString() {
      string s = "TestUtils_Compile.SmallEncryptionContextVariation.AB";
      return s;
    }
  }
  public class SmallEncryptionContextVariation_BA : SmallEncryptionContextVariation {
    public SmallEncryptionContextVariation_BA() {
    }
    public override bool Equals(object other) {
      var oth = other as TestUtils.SmallEncryptionContextVariation_BA;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 3;
      return (int) hash;
    }
    public override string ToString() {
      string s = "TestUtils_Compile.SmallEncryptionContextVariation.BA";
      return s;
    }
  }

  public partial class __default {
    public static Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> GenerateInvalidEncryptionContext()
    {
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encCtx = Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Empty;
      Dafny.ISequence<byte> _18521_validUTF8char = UTF8.ValidUTF8Bytes.Default();
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18522_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out182;
      _out182 = UTF8.__default.Encode(Dafny.Sequence<char>.FromString("a"));
      _18522_valueOrError0 = _out182;
      if (!(!((_18522_valueOrError0).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/TestUtils.dfy(36,43): " + _18522_valueOrError0);
      }
      _18521_validUTF8char = (_18522_valueOrError0).Extract();
      Dafny.ISequence<byte> _18523_key;
      _18523_key = Dafny.Sequence<byte>.FromElements();
      while ((new BigInteger((_18523_key).Count)) < (StandardLibrary_mUInt_Compile.__default.UINT16__LIMIT)) {
        _18523_key = Dafny.Sequence<byte>.Concat(_18523_key, _18521_validUTF8char);
      }
      encCtx = Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.FromElements(new Dafny.Pair<Dafny.ISequence<byte>,Dafny.ISequence<byte>>(_18523_key,Dafny.Sequence<byte>.FromElements(0)));
      return encCtx;
    }
    public static Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> GenerateLargeValidEncryptionContext()
    {
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> r = Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Empty;
      BigInteger _18524_numMaxPairs;
      _18524_numMaxPairs = new BigInteger(9361);
      Dafny.ISequence<byte> _18525_val = UTF8.ValidUTF8Bytes.Default();
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18526_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out183;
      _out183 = UTF8.__default.Encode(Dafny.Sequence<char>.FromString("a"));
      _18526_valueOrError0 = _out183;
      if (!(!((_18526_valueOrError0).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/TestUtils.dfy(62,12): " + _18526_valueOrError0);
      }
      _18525_val = (_18526_valueOrError0).Extract();
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _18527_encCtx;
      _18527_encCtx = Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.FromElements();
      BigInteger _18528_i;
      _18528_i = BigInteger.Zero;
      while (((new BigInteger((_18527_encCtx).Count)) < (_18524_numMaxPairs)) && ((_18528_i) < (new BigInteger(65536)))) {
        Dafny.ISequence<byte> _18529_key;
        _18529_key = StandardLibrary_mUInt_Compile.__default.UInt16ToSeq((ushort)(_18528_i));
        if (UTF8.__default.ValidUTF8Seq(_18529_key)) {
          _18527_encCtx = Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Update(_18527_encCtx,_18529_key, _18525_val);
        }
        _18528_i = (_18528_i) + (BigInteger.One);
      }
      if (!((new BigInteger((_18527_encCtx).Count)) == (_18524_numMaxPairs))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/TestUtils.dfy(79,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      r = _18527_encCtx;
      return r;
      return r;
    }
    public static void ExpectSerializableEncryptionContext(Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encCtx)
    {
      bool _18530_valid;
      bool _out184;
      _out184 = EncryptionContext.__default.CheckSerializable(encCtx);
      _18530_valid = _out184;
      if (!(_18530_valid)) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/TestUtils.dfy(97,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    public static void ExpectNonSerializableEncryptionContext(Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encCtx)
    {
      bool _18531_valid;
      bool _out185;
      _out185 = EncryptionContext.__default.CheckSerializable(encCtx);
      _18531_valid = _out185;
      if (!(!(_18531_valid))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/TestUtils.dfy(102,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    public static Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> SmallEncryptionContext(TestUtils.SmallEncryptionContextVariation v)
    {
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext = Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Empty;
      Dafny.ISequence<byte> _18532_keyA = UTF8.ValidUTF8Bytes.Default();
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18533_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out186;
      _out186 = UTF8.__default.Encode(Dafny.Sequence<char>.FromString("keyA"));
      _18533_valueOrError0 = _out186;
      if (!(!((_18533_valueOrError0).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/TestUtils.dfy(111,13): " + _18533_valueOrError0);
      }
      _18532_keyA = (_18533_valueOrError0).Extract();
      Dafny.ISequence<byte> _18534_valA = UTF8.ValidUTF8Bytes.Default();
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18535_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out187;
      _out187 = UTF8.__default.Encode(Dafny.Sequence<char>.FromString("valA"));
      _18535_valueOrError1 = _out187;
      if (!(!((_18535_valueOrError1).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/TestUtils.dfy(112,13): " + _18535_valueOrError1);
      }
      _18534_valA = (_18535_valueOrError1).Extract();
      Dafny.ISequence<byte> _18536_keyB = UTF8.ValidUTF8Bytes.Default();
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18537_valueOrError2 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out188;
      _out188 = UTF8.__default.Encode(Dafny.Sequence<char>.FromString("keyB"));
      _18537_valueOrError2 = _out188;
      if (!(!((_18537_valueOrError2).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/TestUtils.dfy(113,13): " + _18537_valueOrError2);
      }
      _18536_keyB = (_18537_valueOrError2).Extract();
      Dafny.ISequence<byte> _18538_valB = UTF8.ValidUTF8Bytes.Default();
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18539_valueOrError3 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out189;
      _out189 = UTF8.__default.Encode(Dafny.Sequence<char>.FromString("valB"));
      _18539_valueOrError3 = _out189;
      if (!(!((_18539_valueOrError3).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/TestUtils.dfy(114,13): " + _18539_valueOrError3);
      }
      _18538_valB = (_18539_valueOrError3).Extract();
      TestUtils.SmallEncryptionContextVariation _source29 = v;
      if (_source29.is_Empty) {
        {
          encryptionContext = Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.FromElements();
        }
      } else if (_source29.is_A) {
        {
          encryptionContext = Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.FromElements(new Dafny.Pair<Dafny.ISequence<byte>,Dafny.ISequence<byte>>(_18532_keyA,_18534_valA));
        }
      } else if (_source29.is_AB) {
        {
          encryptionContext = Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.FromElements(new Dafny.Pair<Dafny.ISequence<byte>,Dafny.ISequence<byte>>(_18532_keyA,_18534_valA), new Dafny.Pair<Dafny.ISequence<byte>,Dafny.ISequence<byte>>(_18536_keyB,_18538_valB));
        }
      } else {
        {
          encryptionContext = Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.FromElements(new Dafny.Pair<Dafny.ISequence<byte>,Dafny.ISequence<byte>>(_18536_keyB,_18538_valB), new Dafny.Pair<Dafny.ISequence<byte>,Dafny.ISequence<byte>>(_18532_keyA,_18534_valA));
        }
      }
      return encryptionContext;
    }
    public static Wrappers_Compile.Result<RawAESKeyringDef.RawAESKeyring, Dafny.ISequence<char>> MakeAESKeyring()
    {
      Wrappers_Compile.Result<RawAESKeyringDef.RawAESKeyring, Dafny.ISequence<char>> res = default(Wrappers_Compile.Result<RawAESKeyringDef.RawAESKeyring, Dafny.ISequence<char>>);
      Dafny.ISequence<byte> _18540_namespace = UTF8.ValidUTF8Bytes.Default();
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18541_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out190;
      _out190 = UTF8.__default.Encode(Dafny.Sequence<char>.FromString("namespace"));
      _18541_valueOrError0 = _out190;
      if ((_18541_valueOrError0).IsFailure()) {
        res = (_18541_valueOrError0).PropagateFailure<RawAESKeyringDef.RawAESKeyring>();
        return res;
      }
      _18540_namespace = (_18541_valueOrError0).Extract();
      Dafny.ISequence<byte> _18542_name = UTF8.ValidUTF8Bytes.Default();
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18543_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out191;
      _out191 = UTF8.__default.Encode(Dafny.Sequence<char>.FromString("MyKeyring"));
      _18543_valueOrError1 = _out191;
      if ((_18543_valueOrError1).IsFailure()) {
        res = (_18543_valueOrError1).PropagateFailure<RawAESKeyringDef.RawAESKeyring>();
        return res;
      }
      _18542_name = (_18543_valueOrError1).Extract();
      RawAESKeyringDef.RawAESKeyring _18544_keyring;
      RawAESKeyringDef.RawAESKeyring _nw41 = new RawAESKeyringDef.RawAESKeyring();
      _nw41.__ctor(_18540_namespace, _18542_name, ((System.Func<Dafny.ISequence<byte>>) (() => {
        BigInteger dim12 = new BigInteger(32);
        var arr12 = new byte[Dafny.Helpers.ToIntChecked(dim12,"C# array size must not be larger than max 32-bit int")];
        for (int i12 = 0; i12 < dim12; i12++) {
          var _18545_i = (BigInteger) i12;
          arr12[(int)(_18545_i)] = 0;
        }
        return Dafny.Sequence<byte>.FromArray(arr12);
      }))(), EncryptionSuites.__default.AES__GCM__256);
      _18544_keyring = _nw41;
      res = @Wrappers_Compile.Result<RawAESKeyringDef.RawAESKeyring, Dafny.ISequence<char>>.create_Success(_18544_keyring);
      return res;
      return res;
    }
    public static void NamespaceAndName(BigInteger n, out Dafny.ISequence<byte> @namespace, out Dafny.ISequence<byte> name)
    {
      @namespace = UTF8.ValidUTF8Bytes.Default();
      name = UTF8.ValidUTF8Bytes.Default();
      Dafny.ISequence<char> _18546_s;
      _18546_s = Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("child"), Dafny.Sequence<char>.FromElements((char)(((char)(n)) + ('0'))));
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18547_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out192;
      _out192 = UTF8.__default.Encode(Dafny.Sequence<char>.Concat(_18546_s, Dafny.Sequence<char>.FromString(" Namespace")));
      _18547_valueOrError0 = _out192;
      if (!(!((_18547_valueOrError0).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/TestUtils.dfy(174,14): " + _18547_valueOrError0);
      }
      @namespace = (_18547_valueOrError0).Extract();
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18548_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out193;
      _out193 = UTF8.__default.Encode(Dafny.Sequence<char>.Concat(_18546_s, Dafny.Sequence<char>.FromString(" Name")));
      _18548_valueOrError1 = _out193;
      if (!(!((_18548_valueOrError1).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/TestUtils.dfy(175,9): " + _18548_valueOrError1);
      }
      name = (_18548_valueOrError1).Extract();
    }
    public static Dafny.ISequence<char> SHARED__TEST__KEY__ARN { get {
      return Dafny.Sequence<char>.FromString("arn:aws:kms:us-west-2:658956600833:key/b3537ef1-d8dc-4780-9f5a-55776cbb2f7f");
    } }
  }
} // end of namespace TestUtils
namespace TestAESKeyring_Compile {













  public partial class __default {
    [Xunit.Fact]
    public static void TestOnEncryptOnDecryptGenerateDataKey()
    {
      Dafny.ISequence<byte> _18549_namespace;
      Dafny.ISequence<byte> _18550_name;
      Dafny.ISequence<byte> _out194;
      Dafny.ISequence<byte> _out195;
      TestUtils.__default.NamespaceAndName(BigInteger.Zero, out _out194, out _out195);
      _18549_namespace = _out194;
      _18550_name = _out195;
      RawAESKeyringDef.RawAESKeyring _18551_rawAESKeyring;
      RawAESKeyringDef.RawAESKeyring _nw42 = new RawAESKeyringDef.RawAESKeyring();
      _nw42.__ctor(_18549_namespace, _18550_name, ((System.Func<Dafny.ISequence<byte>>) (() => {
        BigInteger dim13 = new BigInteger(32);
        var arr13 = new byte[Dafny.Helpers.ToIntChecked(dim13,"C# array size must not be larger than max 32-bit int")];
        for (int i13 = 0; i13 < dim13; i13++) {
          var _18552_i = (BigInteger) i13;
          arr13[(int)(_18552_i)] = 0;
        }
        return Dafny.Sequence<byte>.FromArray(arr13);
      }))(), EncryptionSuites.__default.AES__GCM__256);
      _18551_rawAESKeyring = _nw42;
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _18553_encryptionContext;
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _out196;
      _out196 = TestUtils.__default.SmallEncryptionContext(@TestUtils.SmallEncryptionContextVariation.create_A());
      _18553_encryptionContext = _out196;
      TestUtils.__default.ExpectSerializableEncryptionContext(_18553_encryptionContext);
      Dafny.Aws.Crypto.AlgorithmSuiteId _18554_wrappingAlgorithmID;
      _18554_wrappingAlgorithmID = @Dafny.Aws.Crypto.AlgorithmSuiteId.create_ALG__AES__256__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384();
      Dafny.ISequence<byte> _18555_signingKey;
      _18555_signingKey = ((System.Func<Dafny.ISequence<byte>>) (() => {
        BigInteger dim14 = new BigInteger(32);
        var arr14 = new byte[Dafny.Helpers.ToIntChecked(dim14,"C# array size must not be larger than max 32-bit int")];
        for (int i14 = 0; i14 < dim14; i14++) {
          var _18556_i = (BigInteger) i14;
          arr14[(int)(_18556_i)] = 0;
        }
        return Dafny.Sequence<byte>.FromArray(arr14);
      }))();
      Dafny.Aws.Crypto.EncryptionMaterials _18557_encryptionMaterialsIn;
      _18557_encryptionMaterialsIn = @Dafny.Aws.Crypto.EncryptionMaterials.create(_18554_wrappingAlgorithmID, _18553_encryptionContext, Dafny.Sequence<Dafny.Aws.Crypto.EncryptedDataKey>.FromElements(), @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_None(), @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(_18555_signingKey));
      Dafny.Aws.Crypto.OnEncryptOutput _18558_encryptionMaterialsOut = Dafny.Aws.Crypto.OnEncryptOutput.Default();
      Wrappers_Compile.Result<Dafny.Aws.Crypto.OnEncryptOutput, Dafny.ISequence<char>> _18559_valueOrError0 = Wrappers_Compile.Result<Dafny.Aws.Crypto.OnEncryptOutput, Dafny.ISequence<char>>.Default(Dafny.Aws.Crypto.OnEncryptOutput.Default());
      Wrappers_Compile.Result<Dafny.Aws.Crypto.OnEncryptOutput, Dafny.ISequence<char>> _out197;
      _out197 = (_18551_rawAESKeyring).OnEncrypt(@Dafny.Aws.Crypto.OnEncryptInput.create(_18557_encryptionMaterialsIn));
      _18559_valueOrError0 = _out197;
      if (!(!((_18559_valueOrError0).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/SDK/Keyring/RawAESKeyring.dfy(47,31): " + _18559_valueOrError0);
      }
      _18558_encryptionMaterialsOut = (_18559_valueOrError0).Extract();
      if (!((new BigInteger((((_18558_encryptionMaterialsOut).dtor_materials).dtor_encryptedDataKeys).Count)) == (BigInteger.One))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/SDK/Keyring/RawAESKeyring.dfy(59,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      Wrappers_Compile.Option<Dafny.ISequence<byte>> _18560_pdk;
      _18560_pdk = ((_18558_encryptionMaterialsOut).dtor_materials).dtor_plaintextDataKey;
      Dafny.Aws.Crypto.EncryptedDataKey _18561_edk;
      _18561_edk = (((_18558_encryptionMaterialsOut).dtor_materials).dtor_encryptedDataKeys).Select(BigInteger.Zero);
      Dafny.ISequence<byte> _18562_verificationKey;
      _18562_verificationKey = ((System.Func<Dafny.ISequence<byte>>) (() => {
        BigInteger dim15 = new BigInteger(32);
        var arr15 = new byte[Dafny.Helpers.ToIntChecked(dim15,"C# array size must not be larger than max 32-bit int")];
        for (int i15 = 0; i15 < dim15; i15++) {
          var _18563_i = (BigInteger) i15;
          arr15[(int)(_18563_i)] = 0;
        }
        return Dafny.Sequence<byte>.FromArray(arr15);
      }))();
      Dafny.Aws.Crypto.DecryptionMaterials _18564_decryptionMaterialsIn;
      _18564_decryptionMaterialsIn = @Dafny.Aws.Crypto.DecryptionMaterials.create(_18554_wrappingAlgorithmID, _18553_encryptionContext, @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_None(), @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(_18562_verificationKey));
      Dafny.Aws.Crypto.OnDecryptOutput _18565_decryptionMaterialsOut = Dafny.Aws.Crypto.OnDecryptOutput.Default();
      Wrappers_Compile.Result<Dafny.Aws.Crypto.OnDecryptOutput, Dafny.ISequence<char>> _18566_valueOrError1 = Wrappers_Compile.Result<Dafny.Aws.Crypto.OnDecryptOutput, Dafny.ISequence<char>>.Default(Dafny.Aws.Crypto.OnDecryptOutput.Default());
      Wrappers_Compile.Result<Dafny.Aws.Crypto.OnDecryptOutput, Dafny.ISequence<char>> _out198;
      _out198 = (_18551_rawAESKeyring).OnDecrypt(@Dafny.Aws.Crypto.OnDecryptInput.create(_18564_decryptionMaterialsIn, Dafny.Sequence<Dafny.Aws.Crypto.EncryptedDataKey>.FromElements(_18561_edk)));
      _18566_valueOrError1 = _out198;
      if (!(!((_18566_valueOrError1).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/SDK/Keyring/RawAESKeyring.dfy(71,31): " + _18566_valueOrError1);
      }
      _18565_decryptionMaterialsOut = (_18566_valueOrError1).Extract();
      if (!(object.Equals(((_18558_encryptionMaterialsOut).dtor_materials).dtor_plaintextDataKey, _18560_pdk))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/SDK/Keyring/RawAESKeyring.dfy(78,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestOnEncryptOnDecryptSuppliedDataKey()
    {
      Dafny.ISequence<byte> _18567_namespace;
      Dafny.ISequence<byte> _18568_name;
      Dafny.ISequence<byte> _out199;
      Dafny.ISequence<byte> _out200;
      TestUtils.__default.NamespaceAndName(BigInteger.Zero, out _out199, out _out200);
      _18567_namespace = _out199;
      _18568_name = _out200;
      RawAESKeyringDef.RawAESKeyring _18569_rawAESKeyring;
      RawAESKeyringDef.RawAESKeyring _nw43 = new RawAESKeyringDef.RawAESKeyring();
      _nw43.__ctor(_18567_namespace, _18568_name, ((System.Func<Dafny.ISequence<byte>>) (() => {
        BigInteger dim16 = new BigInteger(32);
        var arr16 = new byte[Dafny.Helpers.ToIntChecked(dim16,"C# array size must not be larger than max 32-bit int")];
        for (int i16 = 0; i16 < dim16; i16++) {
          var _18570_i = (BigInteger) i16;
          arr16[(int)(_18570_i)] = 0;
        }
        return Dafny.Sequence<byte>.FromArray(arr16);
      }))(), EncryptionSuites.__default.AES__GCM__256);
      _18569_rawAESKeyring = _nw43;
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _18571_encryptionContext;
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _out201;
      _out201 = TestUtils.__default.SmallEncryptionContext(@TestUtils.SmallEncryptionContextVariation.create_A());
      _18571_encryptionContext = _out201;
      TestUtils.__default.ExpectSerializableEncryptionContext(_18571_encryptionContext);
      Dafny.ISequence<byte> _18572_pdk;
      _18572_pdk = ((System.Func<Dafny.ISequence<byte>>) (() => {
        BigInteger dim17 = new BigInteger(32);
        var arr17 = new byte[Dafny.Helpers.ToIntChecked(dim17,"C# array size must not be larger than max 32-bit int")];
        for (int i17 = 0; i17 < dim17; i17++) {
          var _18573_i = (BigInteger) i17;
          arr17[(int)(_18573_i)] = 0;
        }
        return Dafny.Sequence<byte>.FromArray(arr17);
      }))();
      Dafny.Aws.Crypto.AlgorithmSuiteId _18574_wrappingAlgorithmID;
      _18574_wrappingAlgorithmID = @Dafny.Aws.Crypto.AlgorithmSuiteId.create_ALG__AES__256__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384();
      Dafny.ISequence<byte> _18575_signingKey;
      _18575_signingKey = ((System.Func<Dafny.ISequence<byte>>) (() => {
        BigInteger dim18 = new BigInteger(32);
        var arr18 = new byte[Dafny.Helpers.ToIntChecked(dim18,"C# array size must not be larger than max 32-bit int")];
        for (int i18 = 0; i18 < dim18; i18++) {
          var _18576_i = (BigInteger) i18;
          arr18[(int)(_18576_i)] = 0;
        }
        return Dafny.Sequence<byte>.FromArray(arr18);
      }))();
      Dafny.Aws.Crypto.EncryptionMaterials _18577_encryptionMaterialsIn;
      _18577_encryptionMaterialsIn = @Dafny.Aws.Crypto.EncryptionMaterials.create(_18574_wrappingAlgorithmID, _18571_encryptionContext, Dafny.Sequence<Dafny.Aws.Crypto.EncryptedDataKey>.FromElements(), @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(_18572_pdk), @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(_18575_signingKey));
      Dafny.Aws.Crypto.OnEncryptOutput _18578_encryptionMaterialsOut = Dafny.Aws.Crypto.OnEncryptOutput.Default();
      Wrappers_Compile.Result<Dafny.Aws.Crypto.OnEncryptOutput, Dafny.ISequence<char>> _18579_valueOrError0 = Wrappers_Compile.Result<Dafny.Aws.Crypto.OnEncryptOutput, Dafny.ISequence<char>>.Default(Dafny.Aws.Crypto.OnEncryptOutput.Default());
      Wrappers_Compile.Result<Dafny.Aws.Crypto.OnEncryptOutput, Dafny.ISequence<char>> _out202;
      _out202 = (_18569_rawAESKeyring).OnEncrypt(@Dafny.Aws.Crypto.OnEncryptInput.create(_18577_encryptionMaterialsIn));
      _18579_valueOrError0 = _out202;
      if (!(!((_18579_valueOrError0).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/SDK/Keyring/RawAESKeyring.dfy(99,31): " + _18579_valueOrError0);
      }
      _18578_encryptionMaterialsOut = (_18579_valueOrError0).Extract();
      if (!((new BigInteger((((_18578_encryptionMaterialsOut).dtor_materials).dtor_encryptedDataKeys).Count)) == (BigInteger.One))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/SDK/Keyring/RawAESKeyring.dfy(100,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      Dafny.Aws.Crypto.EncryptedDataKey _18580_edk;
      _18580_edk = (((_18578_encryptionMaterialsOut).dtor_materials).dtor_encryptedDataKeys).Select(BigInteger.Zero);
      Dafny.ISequence<byte> _18581_verificationKey;
      _18581_verificationKey = ((System.Func<Dafny.ISequence<byte>>) (() => {
        BigInteger dim19 = new BigInteger(32);
        var arr19 = new byte[Dafny.Helpers.ToIntChecked(dim19,"C# array size must not be larger than max 32-bit int")];
        for (int i19 = 0; i19 < dim19; i19++) {
          var _18582_i = (BigInteger) i19;
          arr19[(int)(_18582_i)] = 0;
        }
        return Dafny.Sequence<byte>.FromArray(arr19);
      }))();
      Dafny.Aws.Crypto.DecryptionMaterials _18583_decryptionMaterialsIn;
      _18583_decryptionMaterialsIn = @Dafny.Aws.Crypto.DecryptionMaterials.create(_18574_wrappingAlgorithmID, _18571_encryptionContext, @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_None(), @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(_18581_verificationKey));
      Dafny.Aws.Crypto.OnDecryptOutput _18584_decryptionMaterialsOut = Dafny.Aws.Crypto.OnDecryptOutput.Default();
      Wrappers_Compile.Result<Dafny.Aws.Crypto.OnDecryptOutput, Dafny.ISequence<char>> _18585_valueOrError1 = Wrappers_Compile.Result<Dafny.Aws.Crypto.OnDecryptOutput, Dafny.ISequence<char>>.Default(Dafny.Aws.Crypto.OnDecryptOutput.Default());
      Wrappers_Compile.Result<Dafny.Aws.Crypto.OnDecryptOutput, Dafny.ISequence<char>> _out203;
      _out203 = (_18569_rawAESKeyring).OnDecrypt(@Dafny.Aws.Crypto.OnDecryptInput.create(_18583_decryptionMaterialsIn, Dafny.Sequence<Dafny.Aws.Crypto.EncryptedDataKey>.FromElements(_18580_edk)));
      _18585_valueOrError1 = _out203;
      if (!(!((_18585_valueOrError1).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/SDK/Keyring/RawAESKeyring.dfy(111,31): " + _18585_valueOrError1);
      }
      _18584_decryptionMaterialsOut = (_18585_valueOrError1).Extract();
      if (!(object.Equals(((_18584_decryptionMaterialsOut).dtor_materials).dtor_plaintextDataKey, @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(_18572_pdk)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/SDK/Keyring/RawAESKeyring.dfy(118,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestOnDecryptKeyNameMismatch()
    {
      Dafny.ISequence<byte> _18586_namespace;
      Dafny.ISequence<byte> _18587_name;
      Dafny.ISequence<byte> _out204;
      Dafny.ISequence<byte> _out205;
      TestUtils.__default.NamespaceAndName(BigInteger.Zero, out _out204, out _out205);
      _18586_namespace = _out204;
      _18587_name = _out205;
      RawAESKeyringDef.RawAESKeyring _18588_rawAESKeyring;
      RawAESKeyringDef.RawAESKeyring _nw44 = new RawAESKeyringDef.RawAESKeyring();
      _nw44.__ctor(_18586_namespace, _18587_name, ((System.Func<Dafny.ISequence<byte>>) (() => {
        BigInteger dim20 = new BigInteger(32);
        var arr20 = new byte[Dafny.Helpers.ToIntChecked(dim20,"C# array size must not be larger than max 32-bit int")];
        for (int i20 = 0; i20 < dim20; i20++) {
          var _18589_i = (BigInteger) i20;
          arr20[(int)(_18589_i)] = 0;
        }
        return Dafny.Sequence<byte>.FromArray(arr20);
      }))(), EncryptionSuites.__default.AES__GCM__256);
      _18588_rawAESKeyring = _nw44;
      Dafny.ISequence<byte> _18590_mismatchName = UTF8.ValidUTF8Bytes.Default();
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18591_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out206;
      _out206 = UTF8.__default.Encode(Dafny.Sequence<char>.FromString("mismatched"));
      _18591_valueOrError0 = _out206;
      if (!(!((_18591_valueOrError0).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/SDK/Keyring/RawAESKeyring.dfy(126,21): " + _18591_valueOrError0);
      }
      _18590_mismatchName = (_18591_valueOrError0).Extract();
      RawAESKeyringDef.RawAESKeyring _18592_mismatchedAESKeyring;
      RawAESKeyringDef.RawAESKeyring _nw45 = new RawAESKeyringDef.RawAESKeyring();
      _nw45.__ctor(_18586_namespace, _18590_mismatchName, ((System.Func<Dafny.ISequence<byte>>) (() => {
        BigInteger dim21 = new BigInteger(32);
        var arr21 = new byte[Dafny.Helpers.ToIntChecked(dim21,"C# array size must not be larger than max 32-bit int")];
        for (int i21 = 0; i21 < dim21; i21++) {
          var _18593_i = (BigInteger) i21;
          arr21[(int)(_18593_i)] = 0;
        }
        return Dafny.Sequence<byte>.FromArray(arr21);
      }))(), EncryptionSuites.__default.AES__GCM__256);
      _18592_mismatchedAESKeyring = _nw45;
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _18594_encryptionContext;
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _out207;
      _out207 = TestUtils.__default.SmallEncryptionContext(@TestUtils.SmallEncryptionContextVariation.create_A());
      _18594_encryptionContext = _out207;
      TestUtils.__default.ExpectSerializableEncryptionContext(_18594_encryptionContext);
      Dafny.ISequence<byte> _18595_pdk;
      _18595_pdk = ((System.Func<Dafny.ISequence<byte>>) (() => {
        BigInteger dim22 = new BigInteger(32);
        var arr22 = new byte[Dafny.Helpers.ToIntChecked(dim22,"C# array size must not be larger than max 32-bit int")];
        for (int i22 = 0; i22 < dim22; i22++) {
          var _18596_i = (BigInteger) i22;
          arr22[(int)(_18596_i)] = 0;
        }
        return Dafny.Sequence<byte>.FromArray(arr22);
      }))();
      Dafny.Aws.Crypto.AlgorithmSuiteId _18597_wrappingAlgorithmID;
      _18597_wrappingAlgorithmID = @Dafny.Aws.Crypto.AlgorithmSuiteId.create_ALG__AES__256__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384();
      Dafny.ISequence<byte> _18598_signingKey;
      _18598_signingKey = ((System.Func<Dafny.ISequence<byte>>) (() => {
        BigInteger dim23 = new BigInteger(32);
        var arr23 = new byte[Dafny.Helpers.ToIntChecked(dim23,"C# array size must not be larger than max 32-bit int")];
        for (int i23 = 0; i23 < dim23; i23++) {
          var _18599_i = (BigInteger) i23;
          arr23[(int)(_18599_i)] = 0;
        }
        return Dafny.Sequence<byte>.FromArray(arr23);
      }))();
      Dafny.Aws.Crypto.EncryptionMaterials _18600_encryptionMaterialsIn;
      _18600_encryptionMaterialsIn = @Dafny.Aws.Crypto.EncryptionMaterials.create(_18597_wrappingAlgorithmID, _18594_encryptionContext, Dafny.Sequence<Dafny.Aws.Crypto.EncryptedDataKey>.FromElements(), @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(_18595_pdk), @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(_18598_signingKey));
      Dafny.Aws.Crypto.OnEncryptOutput _18601_encryptionMaterialsOut = Dafny.Aws.Crypto.OnEncryptOutput.Default();
      Wrappers_Compile.Result<Dafny.Aws.Crypto.OnEncryptOutput, Dafny.ISequence<char>> _18602_valueOrError1 = Wrappers_Compile.Result<Dafny.Aws.Crypto.OnEncryptOutput, Dafny.ISequence<char>>.Default(Dafny.Aws.Crypto.OnEncryptOutput.Default());
      Wrappers_Compile.Result<Dafny.Aws.Crypto.OnEncryptOutput, Dafny.ISequence<char>> _out208;
      _out208 = (_18592_mismatchedAESKeyring).OnEncrypt(@Dafny.Aws.Crypto.OnEncryptInput.create(_18600_encryptionMaterialsIn));
      _18602_valueOrError1 = _out208;
      if (!(!((_18602_valueOrError1).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/SDK/Keyring/RawAESKeyring.dfy(143,31): " + _18602_valueOrError1);
      }
      _18601_encryptionMaterialsOut = (_18602_valueOrError1).Extract();
      if (!((new BigInteger((((_18601_encryptionMaterialsOut).dtor_materials).dtor_encryptedDataKeys).Count)) == (BigInteger.One))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/SDK/Keyring/RawAESKeyring.dfy(144,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      Dafny.Aws.Crypto.EncryptedDataKey _18603_edk;
      _18603_edk = (((_18601_encryptionMaterialsOut).dtor_materials).dtor_encryptedDataKeys).Select(BigInteger.Zero);
      Dafny.ISequence<byte> _18604_verificationKey;
      _18604_verificationKey = ((System.Func<Dafny.ISequence<byte>>) (() => {
        BigInteger dim24 = new BigInteger(32);
        var arr24 = new byte[Dafny.Helpers.ToIntChecked(dim24,"C# array size must not be larger than max 32-bit int")];
        for (int i24 = 0; i24 < dim24; i24++) {
          var _18605_i = (BigInteger) i24;
          arr24[(int)(_18605_i)] = 0;
        }
        return Dafny.Sequence<byte>.FromArray(arr24);
      }))();
      Dafny.Aws.Crypto.DecryptionMaterials _18606_decryptionMaterialsIn;
      _18606_decryptionMaterialsIn = @Dafny.Aws.Crypto.DecryptionMaterials.create(_18597_wrappingAlgorithmID, _18594_encryptionContext, @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_None(), @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(_18604_verificationKey));
      Dafny.Aws.Crypto.OnDecryptOutput _18607_decryptionMaterialsOut = Dafny.Aws.Crypto.OnDecryptOutput.Default();
      Wrappers_Compile.Result<Dafny.Aws.Crypto.OnDecryptOutput, Dafny.ISequence<char>> _18608_valueOrError2 = Wrappers_Compile.Result<Dafny.Aws.Crypto.OnDecryptOutput, Dafny.ISequence<char>>.Default(Dafny.Aws.Crypto.OnDecryptOutput.Default());
      Wrappers_Compile.Result<Dafny.Aws.Crypto.OnDecryptOutput, Dafny.ISequence<char>> _out209;
      _out209 = (_18588_rawAESKeyring).OnDecrypt(@Dafny.Aws.Crypto.OnDecryptInput.create(_18606_decryptionMaterialsIn, Dafny.Sequence<Dafny.Aws.Crypto.EncryptedDataKey>.FromElements(_18603_edk)));
      _18608_valueOrError2 = _out209;
      if (!(!((_18608_valueOrError2).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/SDK/Keyring/RawAESKeyring.dfy(155,31): " + _18608_valueOrError2);
      }
      _18607_decryptionMaterialsOut = (_18608_valueOrError2).Extract();
      if (!((((_18607_decryptionMaterialsOut).dtor_materials).dtor_plaintextDataKey).is_None)) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/SDK/Keyring/RawAESKeyring.dfy(156,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestOnDecryptNoEDKs()
    {
      Dafny.ISequence<byte> _18609_namespace;
      Dafny.ISequence<byte> _18610_name;
      Dafny.ISequence<byte> _out210;
      Dafny.ISequence<byte> _out211;
      TestUtils.__default.NamespaceAndName(BigInteger.Zero, out _out210, out _out211);
      _18609_namespace = _out210;
      _18610_name = _out211;
      RawAESKeyringDef.RawAESKeyring _18611_rawAESKeyring;
      RawAESKeyringDef.RawAESKeyring _nw46 = new RawAESKeyringDef.RawAESKeyring();
      _nw46.__ctor(_18609_namespace, _18610_name, ((System.Func<Dafny.ISequence<byte>>) (() => {
        BigInteger dim25 = new BigInteger(32);
        var arr25 = new byte[Dafny.Helpers.ToIntChecked(dim25,"C# array size must not be larger than max 32-bit int")];
        for (int i25 = 0; i25 < dim25; i25++) {
          var _18612_i = (BigInteger) i25;
          arr25[(int)(_18612_i)] = 0;
        }
        return Dafny.Sequence<byte>.FromArray(arr25);
      }))(), EncryptionSuites.__default.AES__GCM__256);
      _18611_rawAESKeyring = _nw46;
      Dafny.Aws.Crypto.AlgorithmSuiteId _18613_wrappingAlgorithmID;
      _18613_wrappingAlgorithmID = @Dafny.Aws.Crypto.AlgorithmSuiteId.create_ALG__AES__256__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384();
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _18614_encryptionContext;
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _out212;
      _out212 = TestUtils.__default.SmallEncryptionContext(@TestUtils.SmallEncryptionContextVariation.create_A());
      _18614_encryptionContext = _out212;
      Dafny.ISequence<byte> _18615_verificationKey;
      _18615_verificationKey = ((System.Func<Dafny.ISequence<byte>>) (() => {
        BigInteger dim26 = new BigInteger(32);
        var arr26 = new byte[Dafny.Helpers.ToIntChecked(dim26,"C# array size must not be larger than max 32-bit int")];
        for (int i26 = 0; i26 < dim26; i26++) {
          var _18616_i = (BigInteger) i26;
          arr26[(int)(_18616_i)] = 0;
        }
        return Dafny.Sequence<byte>.FromArray(arr26);
      }))();
      Dafny.Aws.Crypto.DecryptionMaterials _18617_decryptionMaterialsIn;
      _18617_decryptionMaterialsIn = @Dafny.Aws.Crypto.DecryptionMaterials.create(_18613_wrappingAlgorithmID, _18614_encryptionContext, @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_None(), @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(_18615_verificationKey));
      Dafny.Aws.Crypto.OnDecryptOutput _18618_decryptionMaterialsOut = Dafny.Aws.Crypto.OnDecryptOutput.Default();
      Wrappers_Compile.Result<Dafny.Aws.Crypto.OnDecryptOutput, Dafny.ISequence<char>> _18619_valueOrError0 = Wrappers_Compile.Result<Dafny.Aws.Crypto.OnDecryptOutput, Dafny.ISequence<char>>.Default(Dafny.Aws.Crypto.OnDecryptOutput.Default());
      Wrappers_Compile.Result<Dafny.Aws.Crypto.OnDecryptOutput, Dafny.ISequence<char>> _out213;
      _out213 = (_18611_rawAESKeyring).OnDecrypt(@Dafny.Aws.Crypto.OnDecryptInput.create(_18617_decryptionMaterialsIn, Dafny.Sequence<Dafny.Aws.Crypto.EncryptedDataKey>.FromElements()));
      _18619_valueOrError0 = _out213;
      if (!(!((_18619_valueOrError0).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/SDK/Keyring/RawAESKeyring.dfy(184,31): " + _18619_valueOrError0);
      }
      _18618_decryptionMaterialsOut = (_18619_valueOrError0).Extract();
      if (!((((_18618_decryptionMaterialsOut).dtor_materials).dtor_plaintextDataKey).is_None)) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/SDK/Keyring/RawAESKeyring.dfy(185,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestOnEncryptUnserializableEC()
    {
      Dafny.ISequence<byte> _18620_namespace;
      Dafny.ISequence<byte> _18621_name;
      Dafny.ISequence<byte> _out214;
      Dafny.ISequence<byte> _out215;
      TestUtils.__default.NamespaceAndName(BigInteger.Zero, out _out214, out _out215);
      _18620_namespace = _out214;
      _18621_name = _out215;
      RawAESKeyringDef.RawAESKeyring _18622_rawAESKeyring;
      RawAESKeyringDef.RawAESKeyring _nw47 = new RawAESKeyringDef.RawAESKeyring();
      _nw47.__ctor(_18620_namespace, _18621_name, ((System.Func<Dafny.ISequence<byte>>) (() => {
        BigInteger dim27 = new BigInteger(32);
        var arr27 = new byte[Dafny.Helpers.ToIntChecked(dim27,"C# array size must not be larger than max 32-bit int")];
        for (int i27 = 0; i27 < dim27; i27++) {
          var _18623_i = (BigInteger) i27;
          arr27[(int)(_18623_i)] = 0;
        }
        return Dafny.Sequence<byte>.FromArray(arr27);
      }))(), EncryptionSuites.__default.AES__GCM__256);
      _18622_rawAESKeyring = _nw47;
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _18624_unserializableEncryptionContext;
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _out216;
      _out216 = TestAESKeyring_Compile.__default.generateUnserializableEncryptionContext();
      _18624_unserializableEncryptionContext = _out216;
      TestUtils.__default.ExpectNonSerializableEncryptionContext(_18624_unserializableEncryptionContext);
      Dafny.Aws.Crypto.AlgorithmSuiteId _18625_wrappingAlgorithmID;
      _18625_wrappingAlgorithmID = @Dafny.Aws.Crypto.AlgorithmSuiteId.create_ALG__AES__256__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384();
      Dafny.ISequence<byte> _18626_signingKey;
      _18626_signingKey = ((System.Func<Dafny.ISequence<byte>>) (() => {
        BigInteger dim28 = new BigInteger(32);
        var arr28 = new byte[Dafny.Helpers.ToIntChecked(dim28,"C# array size must not be larger than max 32-bit int")];
        for (int i28 = 0; i28 < dim28; i28++) {
          var _18627_i = (BigInteger) i28;
          arr28[(int)(_18627_i)] = 0;
        }
        return Dafny.Sequence<byte>.FromArray(arr28);
      }))();
      Dafny.Aws.Crypto.EncryptionMaterials _18628_encryptionMaterialsIn;
      _18628_encryptionMaterialsIn = @Dafny.Aws.Crypto.EncryptionMaterials.create(_18625_wrappingAlgorithmID, _18624_unserializableEncryptionContext, Dafny.Sequence<Dafny.Aws.Crypto.EncryptedDataKey>.FromElements(), @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_None(), @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(_18626_signingKey));
      Wrappers_Compile.Result<Dafny.Aws.Crypto.OnEncryptOutput, Dafny.ISequence<char>> _18629_encryptionMaterialsOut;
      Wrappers_Compile.Result<Dafny.Aws.Crypto.OnEncryptOutput, Dafny.ISequence<char>> _out217;
      _out217 = (_18622_rawAESKeyring).OnEncrypt(@Dafny.Aws.Crypto.OnEncryptInput.create(_18628_encryptionMaterialsIn));
      _18629_encryptionMaterialsOut = _out217;
      if (!((_18629_encryptionMaterialsOut).is_Failure)) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/SDK/Keyring/RawAESKeyring.dfy(213,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestOnDecryptUnserializableEC()
    {
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _18630_encryptionContext;
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _out218;
      _out218 = TestUtils.__default.SmallEncryptionContext(@TestUtils.SmallEncryptionContextVariation.create_A());
      _18630_encryptionContext = _out218;
      Dafny.ISequence<byte> _18631_namespace;
      Dafny.ISequence<byte> _18632_name;
      Dafny.ISequence<byte> _out219;
      Dafny.ISequence<byte> _out220;
      TestUtils.__default.NamespaceAndName(BigInteger.Zero, out _out219, out _out220);
      _18631_namespace = _out219;
      _18632_name = _out220;
      RawAESKeyringDef.RawAESKeyring _18633_rawAESKeyring;
      RawAESKeyringDef.RawAESKeyring _nw48 = new RawAESKeyringDef.RawAESKeyring();
      _nw48.__ctor(_18631_namespace, _18632_name, ((System.Func<Dafny.ISequence<byte>>) (() => {
        BigInteger dim29 = new BigInteger(32);
        var arr29 = new byte[Dafny.Helpers.ToIntChecked(dim29,"C# array size must not be larger than max 32-bit int")];
        for (int i29 = 0; i29 < dim29; i29++) {
          var _18634_i = (BigInteger) i29;
          arr29[(int)(_18634_i)] = 0;
        }
        return Dafny.Sequence<byte>.FromArray(arr29);
      }))(), EncryptionSuites.__default.AES__GCM__256);
      _18633_rawAESKeyring = _nw48;
      Dafny.Aws.Crypto.AlgorithmSuiteId _18635_wrappingAlgorithmID;
      _18635_wrappingAlgorithmID = @Dafny.Aws.Crypto.AlgorithmSuiteId.create_ALG__AES__256__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384();
      Dafny.ISequence<byte> _18636_signingKey;
      _18636_signingKey = ((System.Func<Dafny.ISequence<byte>>) (() => {
        BigInteger dim30 = new BigInteger(32);
        var arr30 = new byte[Dafny.Helpers.ToIntChecked(dim30,"C# array size must not be larger than max 32-bit int")];
        for (int i30 = 0; i30 < dim30; i30++) {
          var _18637_i = (BigInteger) i30;
          arr30[(int)(_18637_i)] = 0;
        }
        return Dafny.Sequence<byte>.FromArray(arr30);
      }))();
      Dafny.Aws.Crypto.EncryptionMaterials _18638_encryptionMaterialsIn;
      _18638_encryptionMaterialsIn = @Dafny.Aws.Crypto.EncryptionMaterials.create(_18635_wrappingAlgorithmID, _18630_encryptionContext, Dafny.Sequence<Dafny.Aws.Crypto.EncryptedDataKey>.FromElements(), @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_None(), @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(_18636_signingKey));
      Dafny.Aws.Crypto.OnEncryptOutput _18639_encryptionMaterialsOut = Dafny.Aws.Crypto.OnEncryptOutput.Default();
      Wrappers_Compile.Result<Dafny.Aws.Crypto.OnEncryptOutput, Dafny.ISequence<char>> _18640_valueOrError0 = Wrappers_Compile.Result<Dafny.Aws.Crypto.OnEncryptOutput, Dafny.ISequence<char>>.Default(Dafny.Aws.Crypto.OnEncryptOutput.Default());
      Wrappers_Compile.Result<Dafny.Aws.Crypto.OnEncryptOutput, Dafny.ISequence<char>> _out221;
      _out221 = (_18633_rawAESKeyring).OnEncrypt(@Dafny.Aws.Crypto.OnEncryptInput.create(_18638_encryptionMaterialsIn));
      _18640_valueOrError0 = _out221;
      if (!(!((_18640_valueOrError0).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/SDK/Keyring/RawAESKeyring.dfy(238,31): " + _18640_valueOrError0);
      }
      _18639_encryptionMaterialsOut = (_18640_valueOrError0).Extract();
      if (!((((_18639_encryptionMaterialsOut).dtor_materials).dtor_plaintextDataKey).is_Some)) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/SDK/Keyring/RawAESKeyring.dfy(239,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!((new BigInteger((((_18639_encryptionMaterialsOut).dtor_materials).dtor_encryptedDataKeys).Count)) == (BigInteger.One))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/SDK/Keyring/RawAESKeyring.dfy(240,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      Dafny.Aws.Crypto.EncryptedDataKey _18641_edk;
      _18641_edk = (((_18639_encryptionMaterialsOut).dtor_materials).dtor_encryptedDataKeys).Select(BigInteger.Zero);
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _18642_unserializableEncryptionContext;
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _out222;
      _out222 = TestAESKeyring_Compile.__default.generateUnserializableEncryptionContext();
      _18642_unserializableEncryptionContext = _out222;
      TestUtils.__default.ExpectNonSerializableEncryptionContext(_18642_unserializableEncryptionContext);
      Dafny.ISequence<byte> _18643_verificationKey;
      _18643_verificationKey = ((System.Func<Dafny.ISequence<byte>>) (() => {
        BigInteger dim31 = new BigInteger(32);
        var arr31 = new byte[Dafny.Helpers.ToIntChecked(dim31,"C# array size must not be larger than max 32-bit int")];
        for (int i31 = 0; i31 < dim31; i31++) {
          var _18644_i = (BigInteger) i31;
          arr31[(int)(_18644_i)] = 0;
        }
        return Dafny.Sequence<byte>.FromArray(arr31);
      }))();
      Dafny.Aws.Crypto.DecryptionMaterials _18645_decryptionMaterialsIn;
      _18645_decryptionMaterialsIn = @Dafny.Aws.Crypto.DecryptionMaterials.create(_18635_wrappingAlgorithmID, _18642_unserializableEncryptionContext, @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_None(), @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(_18643_verificationKey));
      Wrappers_Compile.Result<Dafny.Aws.Crypto.OnDecryptOutput, Dafny.ISequence<char>> _18646_decryptionMaterialsOut;
      Wrappers_Compile.Result<Dafny.Aws.Crypto.OnDecryptOutput, Dafny.ISequence<char>> _out223;
      _out223 = (_18633_rawAESKeyring).OnDecrypt(@Dafny.Aws.Crypto.OnDecryptInput.create(_18645_decryptionMaterialsIn, Dafny.Sequence<Dafny.Aws.Crypto.EncryptedDataKey>.FromElements(_18641_edk)));
      _18646_decryptionMaterialsOut = _out223;
      if (!((_18646_decryptionMaterialsOut).is_Failure)) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/SDK/Keyring/RawAESKeyring.dfy(255,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestDeserializeEDKCiphertext()
    {
      Dafny.ISequence<byte> _18647_ciphertext;
      _18647_ciphertext = Dafny.Sequence<byte>.FromElements(0, 1, 2, 3);
      Dafny.ISequence<byte> _18648_authTag;
      _18648_authTag = Dafny.Sequence<byte>.FromElements(4, 5, 6, 7);
      Dafny.ISequence<byte> _18649_serializedEDKCiphertext;
      _18649_serializedEDKCiphertext = Dafny.Sequence<byte>.Concat(_18647_ciphertext, _18648_authTag);
      AESEncryption.EncryptionOutput _18650_encOutput;
      _18650_encOutput = RawAESKeyringDef.__default.DeserializeEDKCiphertext(_18649_serializedEDKCiphertext, new BigInteger((_18648_authTag).Count));
      if (!(((_18650_encOutput).dtor_cipherText).Equals((_18647_ciphertext)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/SDK/Keyring/RawAESKeyring.dfy(264,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!(((_18650_encOutput).dtor_authTag).Equals((_18648_authTag)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/SDK/Keyring/RawAESKeyring.dfy(265,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestSerializeEDKCiphertext()
    {
      Dafny.ISequence<byte> _18651_ciphertext;
      _18651_ciphertext = Dafny.Sequence<byte>.FromElements(0, 1, 2, 3);
      Dafny.ISequence<byte> _18652_authTag;
      _18652_authTag = Dafny.Sequence<byte>.FromElements(4, 5, 6, 7);
      AESEncryption.EncryptionOutput _18653_encOutput;
      _18653_encOutput = @AESEncryption.EncryptionOutput.create(_18651_ciphertext, _18652_authTag);
      Dafny.ISequence<byte> _18654_serializedEDKCiphertext;
      _18654_serializedEDKCiphertext = RawAESKeyringDef.__default.SerializeEDKCiphertext(_18653_encOutput);
      if (!((_18654_serializedEDKCiphertext).Equals((Dafny.Sequence<byte>.Concat(_18651_ciphertext, _18652_authTag))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/SDK/Keyring/RawAESKeyring.dfy(274,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    public static Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> generateUnserializableEncryptionContext()
    {
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encCtx = Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Empty;
      Dafny.ISequence<byte> _18655_keyA = UTF8.ValidUTF8Bytes.Default();
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18656_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out224;
      _out224 = UTF8.__default.Encode(Dafny.Sequence<char>.FromString("keyA"));
      _18656_valueOrError0 = _out224;
      if (!(!((_18656_valueOrError0).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/SDK/Keyring/RawAESKeyring.dfy(279,13): " + _18656_valueOrError0);
      }
      _18655_keyA = (_18656_valueOrError0).Extract();
      Dafny.ISequence<byte> _18657_invalidVal;
      _18657_invalidVal = ((System.Func<Dafny.ISequence<byte>>) (() => {
        BigInteger dim32 = new BigInteger(65536);
        var arr32 = new byte[Dafny.Helpers.ToIntChecked(dim32,"C# array size must not be larger than max 32-bit int")];
        for (int i32 = 0; i32 < dim32; i32++) {
          var _18658___v0 = (BigInteger) i32;
          arr32[(int)(_18658___v0)] = 0;
        }
        return Dafny.Sequence<byte>.FromArray(arr32);
      }))();
      encCtx = Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.FromElements(new Dafny.Pair<Dafny.ISequence<byte>,Dafny.ISequence<byte>>(_18655_keyA,_18657_invalidVal));
      return encCtx;
      return encCtx;
    }
  }
} // end of namespace TestAESKeyring_Compile
namespace TestMessageHeader_Compile {








  public partial class __default {
    [Xunit.Fact]
    public static void TestKVPairSequenceToMapEmpty()
    {
      Dafny.ISequence<_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>> _18659_kvPairs;
      _18659_kvPairs = Dafny.Sequence<_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>>.FromElements();
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _18660_output;
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _out225;
      _out225 = EncryptionContext.__default.LinearToMap(_18659_kvPairs);
      _18660_output = _out225;
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _18661_expected;
      _18661_expected = Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.FromElements();
      if (!((_18660_output).Equals((_18661_expected)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/SDK/MessageHeader.dfy(24,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestKVPairSequenceToMap()
    {
      Dafny.ISequence<byte> _18662_keyA = UTF8.ValidUTF8Bytes.Default();
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18663_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out226;
      _out226 = UTF8.__default.Encode(Dafny.Sequence<char>.FromString("keyA"));
      _18663_valueOrError0 = _out226;
      if (!(!((_18663_valueOrError0).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/SDK/MessageHeader.dfy(28,13): " + _18663_valueOrError0);
      }
      _18662_keyA = (_18663_valueOrError0).Extract();
      Dafny.ISequence<byte> _18664_valA = UTF8.ValidUTF8Bytes.Default();
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18665_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out227;
      _out227 = UTF8.__default.Encode(Dafny.Sequence<char>.FromString("valA"));
      _18665_valueOrError1 = _out227;
      if (!(!((_18665_valueOrError1).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/SDK/MessageHeader.dfy(29,13): " + _18665_valueOrError1);
      }
      _18664_valA = (_18665_valueOrError1).Extract();
      Dafny.ISequence<byte> _18666_keyB = UTF8.ValidUTF8Bytes.Default();
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18667_valueOrError2 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out228;
      _out228 = UTF8.__default.Encode(Dafny.Sequence<char>.FromString("keyB"));
      _18667_valueOrError2 = _out228;
      if (!(!((_18667_valueOrError2).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/SDK/MessageHeader.dfy(30,13): " + _18667_valueOrError2);
      }
      _18666_keyB = (_18667_valueOrError2).Extract();
      Dafny.ISequence<byte> _18668_valB = UTF8.ValidUTF8Bytes.Default();
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18669_valueOrError3 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out229;
      _out229 = UTF8.__default.Encode(Dafny.Sequence<char>.FromString("valB"));
      _18669_valueOrError3 = _out229;
      if (!(!((_18669_valueOrError3).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/SDK/MessageHeader.dfy(31,13): " + _18669_valueOrError3);
      }
      _18668_valB = (_18669_valueOrError3).Extract();
      Dafny.ISequence<_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>> _18670_kvPairs;
      _18670_kvPairs = Dafny.Sequence<_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>>.FromElements(@_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.create(_18662_keyA, _18664_valA), @_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.create(_18666_keyB, _18668_valB));
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _18671_output;
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _out230;
      _out230 = EncryptionContext.__default.LinearToMap(_18670_kvPairs);
      _18671_output = _out230;
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _18672_expected;
      _18672_expected = Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.FromElements(new Dafny.Pair<Dafny.ISequence<byte>,Dafny.ISequence<byte>>(_18662_keyA,_18664_valA), new Dafny.Pair<Dafny.ISequence<byte>,Dafny.ISequence<byte>>(_18666_keyB,_18668_valB));
      if (!((_18671_output).Equals((_18672_expected)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/SDK/MessageHeader.dfy(35,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestCheckSerializableEmpty()
    {
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _18673_encCtx;
      _18673_encCtx = Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.FromElements();
      TestUtils.__default.ExpectSerializableEncryptionContext(_18673_encCtx);
    }
    [Xunit.Fact]
    public static void TestCheckSerializableOnePair()
    {
      Dafny.ISequence<byte> _18674_keyA = UTF8.ValidUTF8Bytes.Default();
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18675_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out231;
      _out231 = UTF8.__default.Encode(Dafny.Sequence<char>.FromString("keyA"));
      _18675_valueOrError0 = _out231;
      if (!(!((_18675_valueOrError0).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/SDK/MessageHeader.dfy(44,13): " + _18675_valueOrError0);
      }
      _18674_keyA = (_18675_valueOrError0).Extract();
      Dafny.ISequence<byte> _18676_valA = UTF8.ValidUTF8Bytes.Default();
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18677_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out232;
      _out232 = UTF8.__default.Encode(Dafny.Sequence<char>.FromString("valA"));
      _18677_valueOrError1 = _out232;
      if (!(!((_18677_valueOrError1).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/SDK/MessageHeader.dfy(45,13): " + _18677_valueOrError1);
      }
      _18676_valA = (_18677_valueOrError1).Extract();
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _18678_encCtx;
      _18678_encCtx = Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.FromElements(new Dafny.Pair<Dafny.ISequence<byte>,Dafny.ISequence<byte>>(_18674_keyA,_18676_valA));
      TestUtils.__default.ExpectSerializableEncryptionContext(_18678_encCtx);
    }
    [Xunit.Fact]
    public static void TestCheckSerializableOnePairMaxSize()
    {
      Dafny.ISequence<byte> _18679_keyA = UTF8.ValidUTF8Bytes.Default();
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18680_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out233;
      _out233 = UTF8.__default.Encode(Dafny.Sequence<char>.FromString("A"));
      _18680_valueOrError0 = _out233;
      if (!(!((_18680_valueOrError0).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/SDK/MessageHeader.dfy(51,13): " + _18680_valueOrError0);
      }
      _18679_keyA = (_18680_valueOrError0).Extract();
      Dafny.ISequence<byte> _18681_largeVal;
      _18681_largeVal = ((System.Func<Dafny.ISequence<byte>>) (() => {
        BigInteger dim33 = new BigInteger(65528);
        var arr33 = new byte[Dafny.Helpers.ToIntChecked(dim33,"C# array size must not be larger than max 32-bit int")];
        for (int i33 = 0; i33 < dim33; i33++) {
          var _18682___v0 = (BigInteger) i33;
          arr33[(int)(_18682___v0)] = 0;
        }
        return Dafny.Sequence<byte>.FromArray(arr33);
      }))();
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _18683_encCtx;
      _18683_encCtx = Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.FromElements(new Dafny.Pair<Dafny.ISequence<byte>,Dafny.ISequence<byte>>(_18679_keyA,_18681_largeVal));
      TestUtils.__default.ExpectSerializableEncryptionContext(_18683_encCtx);
    }
    [Xunit.Fact]
    public static void TestCheckSerializableTooLarge()
    {
      Dafny.ISequence<byte> _18684_keyA = UTF8.ValidUTF8Bytes.Default();
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18685_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out234;
      _out234 = UTF8.__default.Encode(Dafny.Sequence<char>.FromString("keyA"));
      _18685_valueOrError0 = _out234;
      if (!(!((_18685_valueOrError0).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/SDK/MessageHeader.dfy(61,13): " + _18685_valueOrError0);
      }
      _18684_keyA = (_18685_valueOrError0).Extract();
      Dafny.ISequence<byte> _18686_keyB = UTF8.ValidUTF8Bytes.Default();
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18687_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out235;
      _out235 = UTF8.__default.Encode(Dafny.Sequence<char>.FromString("keyB"));
      _18687_valueOrError1 = _out235;
      if (!(!((_18687_valueOrError1).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/SDK/MessageHeader.dfy(62,13): " + _18687_valueOrError1);
      }
      _18686_keyB = (_18687_valueOrError1).Extract();
      Dafny.ISequence<byte> _18688_invalidVal;
      _18688_invalidVal = ((System.Func<Dafny.ISequence<byte>>) (() => {
        BigInteger dim34 = new BigInteger(65528);
        var arr34 = new byte[Dafny.Helpers.ToIntChecked(dim34,"C# array size must not be larger than max 32-bit int")];
        for (int i34 = 0; i34 < dim34; i34++) {
          var _18689___v1 = (BigInteger) i34;
          arr34[(int)(_18689___v1)] = 0;
        }
        return Dafny.Sequence<byte>.FromArray(arr34);
      }))();
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _18690_encCtx;
      _18690_encCtx = Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.FromElements(new Dafny.Pair<Dafny.ISequence<byte>,Dafny.ISequence<byte>>(_18684_keyA,_18688_invalidVal), new Dafny.Pair<Dafny.ISequence<byte>,Dafny.ISequence<byte>>(_18686_keyB,_18688_invalidVal));
      TestUtils.__default.ExpectNonSerializableEncryptionContext(_18690_encCtx);
    }
    [Xunit.Fact]
    public static void TestCheckSerializablePairTooBig()
    {
      Dafny.ISequence<byte> _18691_key = UTF8.ValidUTF8Bytes.Default();
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18692_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out236;
      _out236 = UTF8.__default.Encode(Dafny.Sequence<char>.FromString("keyA"));
      _18692_valueOrError0 = _out236;
      if (!(!((_18692_valueOrError0).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/SDK/MessageHeader.dfy(71,12): " + _18692_valueOrError0);
      }
      _18691_key = (_18692_valueOrError0).Extract();
      Dafny.ISequence<byte> _18693_invalidVal;
      _18693_invalidVal = ((System.Func<Dafny.ISequence<byte>>) (() => {
        BigInteger dim35 = new BigInteger(65536);
        var arr35 = new byte[Dafny.Helpers.ToIntChecked(dim35,"C# array size must not be larger than max 32-bit int")];
        for (int i35 = 0; i35 < dim35; i35++) {
          var _18694___v2 = (BigInteger) i35;
          arr35[(int)(_18694___v2)] = 0;
        }
        return Dafny.Sequence<byte>.FromArray(arr35);
      }))();
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _18695_encCtx;
      _18695_encCtx = Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.FromElements(new Dafny.Pair<Dafny.ISequence<byte>,Dafny.ISequence<byte>>(_18691_key,_18693_invalidVal));
      TestUtils.__default.ExpectNonSerializableEncryptionContext(_18695_encCtx);
    }
    [Xunit.Fact]
    public static void TestComputeKVPairsLengthEmpty()
    {
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _18696_encCtx;
      _18696_encCtx = Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.FromElements();
      BigInteger _18697_len;
      BigInteger _out237;
      _out237 = EncryptionContext.__default.ComputeLength(_18696_encCtx);
      _18697_len = _out237;
      if (!((_18697_len).Sign == 0)) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/SDK/MessageHeader.dfy(82,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestComputeKVPairsLengthOnePair()
    {
      Dafny.ISequence<byte> _18698_keyA = UTF8.ValidUTF8Bytes.Default();
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18699_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out238;
      _out238 = UTF8.__default.Encode(Dafny.Sequence<char>.FromString("keyA"));
      _18699_valueOrError0 = _out238;
      if (!(!((_18699_valueOrError0).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/SDK/MessageHeader.dfy(86,13): " + _18699_valueOrError0);
      }
      _18698_keyA = (_18699_valueOrError0).Extract();
      Dafny.ISequence<byte> _18700_valA = UTF8.ValidUTF8Bytes.Default();
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18701_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out239;
      _out239 = UTF8.__default.Encode(Dafny.Sequence<char>.FromString("valA"));
      _18701_valueOrError1 = _out239;
      if (!(!((_18701_valueOrError1).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/SDK/MessageHeader.dfy(87,13): " + _18701_valueOrError1);
      }
      _18700_valA = (_18701_valueOrError1).Extract();
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _18702_encCtx;
      _18702_encCtx = Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.FromElements(new Dafny.Pair<Dafny.ISequence<byte>,Dafny.ISequence<byte>>(_18698_keyA,_18700_valA));
      Dafny.ISequence<BigInteger> _18703_expectedSerialization;
      _18703_expectedSerialization = Dafny.Sequence<BigInteger>.FromElements(BigInteger.Zero, BigInteger.One, BigInteger.Zero, new BigInteger(4), new BigInteger(107), new BigInteger(101), new BigInteger(121), new BigInteger(65), BigInteger.Zero, new BigInteger(4), new BigInteger(118), new BigInteger(97), new BigInteger(108), new BigInteger(65));
      BigInteger _18704_len;
      BigInteger _out240;
      _out240 = EncryptionContext.__default.ComputeLength(_18702_encCtx);
      _18704_len = _out240;
      if (!((_18704_len) == (new BigInteger((_18703_expectedSerialization).Count)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/SDK/MessageHeader.dfy(92,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestComputeKVPairsLengthLong()
    {
      Dafny.ISequence<byte> _18705_keyA = UTF8.ValidUTF8Bytes.Default();
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18706_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out241;
      _out241 = UTF8.__default.Encode(Dafny.Sequence<char>.FromString("A"));
      _18706_valueOrError0 = _out241;
      if (!(!((_18706_valueOrError0).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/SDK/MessageHeader.dfy(96,13): " + _18706_valueOrError0);
      }
      _18705_keyA = (_18706_valueOrError0).Extract();
      Dafny.ISequence<byte> _18707_largeVal;
      _18707_largeVal = ((System.Func<Dafny.ISequence<byte>>) (() => {
        BigInteger dim36 = new BigInteger(65536);
        var arr36 = new byte[Dafny.Helpers.ToIntChecked(dim36,"C# array size must not be larger than max 32-bit int")];
        for (int i36 = 0; i36 < dim36; i36++) {
          var _18708___v3 = (BigInteger) i36;
          arr36[(int)(_18708___v3)] = 0;
        }
        return Dafny.Sequence<byte>.FromArray(arr36);
      }))();
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _18709_encCtx;
      _18709_encCtx = Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.FromElements(new Dafny.Pair<Dafny.ISequence<byte>,Dafny.ISequence<byte>>(_18705_keyA,_18707_largeVal));
      BigInteger _18710_len;
      BigInteger _out242;
      _out242 = EncryptionContext.__default.ComputeLength(_18709_encCtx);
      _18710_len = _out242;
      if (!((_18710_len) == ((new BigInteger(7)) + (new BigInteger((_18707_largeVal).Count))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/SDK/MessageHeader.dfy(102,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestComputeOpoerationsOnLargeValidEC()
    {
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _18711_encCtx;
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _out243;
      _out243 = TestUtils.__default.GenerateLargeValidEncryptionContext();
      _18711_encCtx = _out243;
      BigInteger _18712_len;
      BigInteger _out244;
      _out244 = EncryptionContext.__default.ComputeLength(_18711_encCtx);
      _18712_len = _out244;
      if (!((_18712_len) == ((new BigInteger(2)) + ((new BigInteger((_18711_encCtx).Count)) * (new BigInteger(7)))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/SDK/MessageHeader.dfy(109,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      TestUtils.__default.ExpectSerializableEncryptionContext(_18711_encCtx);
    }
  }
} // end of namespace TestMessageHeader_Compile
namespace TestClient {













  public partial class __default {
    [Xunit.Fact]
    public static void HappyPath()
    {
      Dafny.Aws.Crypto.AwsCryptographicMaterialProvidersClient.AwsCryptographicMaterialProvidersClient _18713_materialsClient;
      Dafny.Aws.Crypto.AwsCryptographicMaterialProvidersClient.AwsCryptographicMaterialProvidersClient _nw49 = new Dafny.Aws.Crypto.AwsCryptographicMaterialProvidersClient.AwsCryptographicMaterialProvidersClient();
      _nw49.__ctor();
      _18713_materialsClient = _nw49;
      Dafny.Aws.Crypto.IKeyring _18714_rawAESKeyring;
      Dafny.Aws.Crypto.IKeyring _out245;
      _out245 = (_18713_materialsClient).CreateRawAesKeyring(@Dafny.Aws.Crypto.CreateRawAesKeyringInput.create(Dafny.Sequence<char>.FromString("someNamespace"), Dafny.Sequence<char>.FromString("someName"), ((System.Func<Dafny.ISequence<byte>>) (() => {
  BigInteger dim37 = new BigInteger(32);
  var arr37 = new byte[Dafny.Helpers.ToIntChecked(dim37,"C# array size must not be larger than max 32-bit int")];
  for (int i37 = 0; i37 < dim37; i37++) {
    var _18715_i = (BigInteger) i37;
    arr37[(int)(_18715_i)] = 0;
  }
  return Dafny.Sequence<byte>.FromArray(arr37);
}))(), @Dafny.Aws.Crypto.AesWrappingAlg.create_ALG__AES256__GCM__IV12__TAG16()));
      _18714_rawAESKeyring = _out245;
      Dafny.Aws.Crypto.ICryptographicMaterialsManager _18716_cmm;
      Dafny.Aws.Crypto.ICryptographicMaterialsManager _out246;
      _out246 = (_18713_materialsClient).CreateDefaultCryptographicMaterialsManager(@Dafny.Aws.Crypto.CreateDefaultCryptographicMaterialsManagerInput.create(_18714_rawAESKeyring));
      _18716_cmm = _out246;
      Dafny.Aws.Esdk.AwsEncryptionSdkClient.AwsEncryptionSdkClient _18717_client;
      Dafny.Aws.Esdk.AwsEncryptionSdkClient.AwsEncryptionSdkClient _nw50 = new Dafny.Aws.Esdk.AwsEncryptionSdkClient.AwsEncryptionSdkClient();
      _nw50.__ctor();
      _18717_client = _nw50;
      Dafny.ISequence<byte> _18718_plaintext = UTF8.ValidUTF8Bytes.Default();
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18719_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out247;
      _out247 = UTF8.__default.Encode(Dafny.Sequence<char>.FromString("hello"));
      _18719_valueOrError0 = _out247;
      if (!(!((_18719_valueOrError0).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/SDK/POCEncryptDecrypt.dfy(57,18): " + _18719_valueOrError0);
      }
      _18718_plaintext = (_18719_valueOrError0).Extract();
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _18720_encryptionContext;
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _out248;
      _out248 = TestUtils.__default.SmallEncryptionContext(@TestUtils.SmallEncryptionContextVariation.create_A());
      _18720_encryptionContext = _out248;
      Dafny.Aws.Esdk.EncryptInput _18721_input;
      _18721_input = @Dafny.Aws.Esdk.EncryptInput.create(_18718_plaintext, _18720_encryptionContext, _18716_cmm, @Wrappers_Compile.Option<Dafny.Aws.Crypto.AlgorithmSuiteId>.create_None());
      Dafny.Aws.Esdk.EncryptOutput _18722_res = Dafny.Aws.Esdk.EncryptOutput.Default();
      Wrappers_Compile.Result<Dafny.Aws.Esdk.EncryptOutput, Dafny.ISequence<char>> _18723_valueOrError1 = Wrappers_Compile.Result<Dafny.Aws.Esdk.EncryptOutput, Dafny.ISequence<char>>.Default(Dafny.Aws.Esdk.EncryptOutput.Default());
      Wrappers_Compile.Result<Dafny.Aws.Esdk.EncryptOutput, Dafny.ISequence<char>> _out249;
      _out249 = (_18717_client).Encrypt(_18721_input);
      _18723_valueOrError1 = _out249;
      if (!(!((_18723_valueOrError1).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/SDK/POCEncryptDecrypt.dfy(64,12): " + _18723_valueOrError1);
      }
      _18722_res = (_18723_valueOrError1).Extract();
      Dafny.Aws.Esdk.DecryptInput _18724_decryptInput;
      _18724_decryptInput = @Dafny.Aws.Esdk.DecryptInput.create((_18722_res).dtor_ciphertext, _18716_cmm);
      Dafny.Aws.Esdk.DecryptOutput _18725_d = Dafny.Aws.Esdk.DecryptOutput.Default();
      Wrappers_Compile.Result<Dafny.Aws.Esdk.DecryptOutput, Dafny.ISequence<char>> _18726_valueOrError2 = Wrappers_Compile.Result<Dafny.Aws.Esdk.DecryptOutput, Dafny.ISequence<char>>.Default(Dafny.Aws.Esdk.DecryptOutput.Default());
      Wrappers_Compile.Result<Dafny.Aws.Esdk.DecryptOutput, Dafny.ISequence<char>> _out250;
      _out250 = (_18717_client).Decrypt(_18724_decryptInput);
      _18726_valueOrError2 = _out250;
      if (!(!((_18726_valueOrError2).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/SDK/POCEncryptDecrypt.dfy(68,10): " + _18726_valueOrError2);
      }
      _18725_d = (_18726_valueOrError2).Extract();
      if (!((_18718_plaintext).Equals(((_18725_d).dtor_plaintext)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/SDK/POCEncryptDecrypt.dfy(71,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
  }
} // end of namespace TestClient
namespace TestSerialize_Compile {







  public partial class __default {
    [Xunit.Fact]
    public static void TestSerializeAAD()
    {
      Streams_Compile.ByteWriter _18727_wr;
      Streams_Compile.ByteWriter _nw51 = new Streams_Compile.ByteWriter();
      _nw51.__ctor();
      _18727_wr = _nw51;
      Dafny.ISequence<byte> _18728_keyA = UTF8.ValidUTF8Bytes.Default();
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18729_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out251;
      _out251 = UTF8.__default.Encode(Dafny.Sequence<char>.FromString("keyA"));
      _18729_valueOrError0 = _out251;
      if (!(!((_18729_valueOrError0).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/SDK/Serialize.dfy(19,13): " + _18729_valueOrError0);
      }
      _18728_keyA = (_18729_valueOrError0).Extract();
      Dafny.ISequence<byte> _18730_valA = UTF8.ValidUTF8Bytes.Default();
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18731_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out252;
      _out252 = UTF8.__default.Encode(Dafny.Sequence<char>.FromString("valA"));
      _18731_valueOrError1 = _out252;
      if (!(!((_18731_valueOrError1).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/SDK/Serialize.dfy(20,13): " + _18731_valueOrError1);
      }
      _18730_valA = (_18731_valueOrError1).Extract();
      Dafny.ISequence<byte> _18732_keyB = UTF8.ValidUTF8Bytes.Default();
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18733_valueOrError2 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out253;
      _out253 = UTF8.__default.Encode(Dafny.Sequence<char>.FromString("keyB"));
      _18733_valueOrError2 = _out253;
      if (!(!((_18733_valueOrError2).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/SDK/Serialize.dfy(21,13): " + _18733_valueOrError2);
      }
      _18732_keyB = (_18733_valueOrError2).Extract();
      Dafny.ISequence<byte> _18734_valB = UTF8.ValidUTF8Bytes.Default();
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18735_valueOrError3 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out254;
      _out254 = UTF8.__default.Encode(Dafny.Sequence<char>.FromString("valB"));
      _18735_valueOrError3 = _out254;
      if (!(!((_18735_valueOrError3).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/SDK/Serialize.dfy(22,13): " + _18735_valueOrError3);
      }
      _18734_valB = (_18735_valueOrError3).Extract();
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _18736_encryptionContext;
      _18736_encryptionContext = Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.FromElements(new Dafny.Pair<Dafny.ISequence<byte>,Dafny.ISequence<byte>>(_18732_keyB,_18734_valB), new Dafny.Pair<Dafny.ISequence<byte>,Dafny.ISequence<byte>>(_18728_keyA,_18730_valA));
      Dafny.ISequence<byte> _18737_expectedSerializedAAD;
      _18737_expectedSerializedAAD = Dafny.Sequence<byte>.FromElements(0, 26, 0, 2, 0, 4, 107, 101, 121, 65, 0, 4, 118, 97, 108, 65, 0, 4, 107, 101, 121, 66, 0, 4, 118, 97, 108, 66);
      BigInteger _18738_len = BigInteger.Zero;
      Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>> _18739_valueOrError4 = Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>>.Default(BigInteger.Zero);
      Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>> _out255;
      _out255 = Serialize_Compile.__default.SerializeAAD(_18727_wr, _18736_encryptionContext);
      _18739_valueOrError4 = _out255;
      if (!(!((_18739_valueOrError4).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/SDK/Serialize.dfy(28,12): " + _18739_valueOrError4);
      }
      _18738_len = (_18739_valueOrError4).Extract();
      if (!(((_18727_wr).GetDataWritten()).Equals((_18737_expectedSerializedAAD)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/SDK/Serialize.dfy(29,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestSerializeAADEmpty()
    {
      Streams_Compile.ByteWriter _18740_wr;
      Streams_Compile.ByteWriter _nw52 = new Streams_Compile.ByteWriter();
      _nw52.__ctor();
      _18740_wr = _nw52;
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _18741_encryptionContext;
      _18741_encryptionContext = Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.FromElements();
      Dafny.ISequence<byte> _18742_expectedSerializedAAD;
      _18742_expectedSerializedAAD = Dafny.Sequence<byte>.FromElements(0, 0);
      BigInteger _18743_len = BigInteger.Zero;
      Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>> _18744_valueOrError0 = Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>>.Default(BigInteger.Zero);
      Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>> _out256;
      _out256 = Serialize_Compile.__default.SerializeAAD(_18740_wr, _18741_encryptionContext);
      _18744_valueOrError0 = _out256;
      if (!(!((_18744_valueOrError0).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/SDK/Serialize.dfy(39,12): " + _18744_valueOrError0);
      }
      _18743_len = (_18744_valueOrError0).Extract();
      if (!(((_18740_wr).GetDataWritten()).Equals((_18742_expectedSerializedAAD)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/SDK/Serialize.dfy(40,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestSerializeLargeValidEC()
    {
      Streams_Compile.ByteWriter _18745_wr;
      Streams_Compile.ByteWriter _nw53 = new Streams_Compile.ByteWriter();
      _nw53.__ctor();
      _18745_wr = _nw53;
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _18746_encCtx;
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _out257;
      _out257 = TestUtils.__default.GenerateLargeValidEncryptionContext();
      _18746_encCtx = _out257;
      BigInteger _18747_len = BigInteger.Zero;
      Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>> _18748_valueOrError0 = Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>>.Default(BigInteger.Zero);
      Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>> _out258;
      _out258 = Serialize_Compile.__default.SerializeAAD(_18745_wr, _18746_encCtx);
      _18748_valueOrError0 = _out258;
      if (!(!((_18748_valueOrError0).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/SDK/Serialize.dfy(47,12): " + _18748_valueOrError0);
      }
      _18747_len = (_18748_valueOrError0).Extract();
      if (!((_18747_len) == ((new BigInteger(4)) + ((new BigInteger((_18746_encCtx).Count)) * (new BigInteger(7)))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/SDK/Serialize.dfy(48,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestSerializeKVPairs()
    {
      Streams_Compile.ByteWriter _18749_wr;
      Streams_Compile.ByteWriter _nw54 = new Streams_Compile.ByteWriter();
      _nw54.__ctor();
      _18749_wr = _nw54;
      Dafny.ISequence<byte> _18750_keyA = UTF8.ValidUTF8Bytes.Default();
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18751_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out259;
      _out259 = UTF8.__default.Encode(Dafny.Sequence<char>.FromString("keyA"));
      _18751_valueOrError0 = _out259;
      if (!(!((_18751_valueOrError0).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/SDK/Serialize.dfy(53,13): " + _18751_valueOrError0);
      }
      _18750_keyA = (_18751_valueOrError0).Extract();
      Dafny.ISequence<byte> _18752_valA = UTF8.ValidUTF8Bytes.Default();
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18753_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out260;
      _out260 = UTF8.__default.Encode(Dafny.Sequence<char>.FromString("valA"));
      _18753_valueOrError1 = _out260;
      if (!(!((_18753_valueOrError1).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/SDK/Serialize.dfy(54,13): " + _18753_valueOrError1);
      }
      _18752_valA = (_18753_valueOrError1).Extract();
      Dafny.ISequence<byte> _18754_keyB = UTF8.ValidUTF8Bytes.Default();
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18755_valueOrError2 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out261;
      _out261 = UTF8.__default.Encode(Dafny.Sequence<char>.FromString("keyB"));
      _18755_valueOrError2 = _out261;
      if (!(!((_18755_valueOrError2).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/SDK/Serialize.dfy(55,13): " + _18755_valueOrError2);
      }
      _18754_keyB = (_18755_valueOrError2).Extract();
      Dafny.ISequence<byte> _18756_valB = UTF8.ValidUTF8Bytes.Default();
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18757_valueOrError3 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out262;
      _out262 = UTF8.__default.Encode(Dafny.Sequence<char>.FromString("valB"));
      _18757_valueOrError3 = _out262;
      if (!(!((_18757_valueOrError3).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/SDK/Serialize.dfy(56,13): " + _18757_valueOrError3);
      }
      _18756_valB = (_18757_valueOrError3).Extract();
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _18758_encryptionContext;
      _18758_encryptionContext = Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.FromElements(new Dafny.Pair<Dafny.ISequence<byte>,Dafny.ISequence<byte>>(_18754_keyB,_18756_valB), new Dafny.Pair<Dafny.ISequence<byte>,Dafny.ISequence<byte>>(_18750_keyA,_18752_valA));
      Dafny.ISequence<byte> _18759_expectedSerializedAAD;
      _18759_expectedSerializedAAD = Dafny.Sequence<byte>.FromElements(0, 2, 0, 4, 107, 101, 121, 65, 0, 4, 118, 97, 108, 65, 0, 4, 107, 101, 121, 66, 0, 4, 118, 97, 108, 66);
      BigInteger _18760_len = BigInteger.Zero;
      Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>> _18761_valueOrError4 = Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>>.Default(BigInteger.Zero);
      Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>> _out263;
      _out263 = Serialize_Compile.__default.SerializeKVPairs(_18749_wr, _18758_encryptionContext);
      _18761_valueOrError4 = _out263;
      if (!(!((_18761_valueOrError4).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/SDK/Serialize.dfy(62,12): " + _18761_valueOrError4);
      }
      _18760_len = (_18761_valueOrError4).Extract();
      if (!(((_18749_wr).GetDataWritten()).Equals((_18759_expectedSerializedAAD)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/SDK/Serialize.dfy(63,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestSerializeKVPairsEmpty()
    {
      Streams_Compile.ByteWriter _18762_wr;
      Streams_Compile.ByteWriter _nw55 = new Streams_Compile.ByteWriter();
      _nw55.__ctor();
      _18762_wr = _nw55;
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _18763_encryptionContext;
      _18763_encryptionContext = Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.FromElements();
      Dafny.ISequence<byte> _18764_expectedSerializedAAD;
      _18764_expectedSerializedAAD = Dafny.Sequence<byte>.FromElements();
      BigInteger _18765_len = BigInteger.Zero;
      Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>> _18766_valueOrError0 = Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>>.Default(BigInteger.Zero);
      Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>> _out264;
      _out264 = Serialize_Compile.__default.SerializeKVPairs(_18762_wr, _18763_encryptionContext);
      _18766_valueOrError0 = _out264;
      if (!(!((_18766_valueOrError0).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/SDK/Serialize.dfy(73,12): " + _18766_valueOrError0);
      }
      _18765_len = (_18766_valueOrError0).Extract();
      if (!(((_18762_wr).GetDataWritten()).Equals((_18764_expectedSerializedAAD)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/SDK/Serialize.dfy(74,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
  }
} // end of namespace TestSerialize_Compile
namespace TestBase64_Compile {




  public partial class __default {
    [Xunit.Fact]
    public static void TestIsBase64CharSuccess()
    {
      if (!(Dafny.Helpers.Quantifier<char>((TestBase64_Compile.__default.BASE64__CHARS).UniqueElements, true, (((_18767_c) => {
        return !((TestBase64_Compile.__default.BASE64__CHARS).Contains((_18767_c))) || (Base64_Compile.__default.IsBase64Char(_18767_c));
      }))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/Base64.dfy(30,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestIsBase64CharFailure()
    {
      if (!(Dafny.Helpers.Quantifier<char>(Dafny.Helpers.AllChars(), true, (((_18768_c) => {
        return !(!(TestBase64_Compile.__default.BASE64__CHARS).Contains((_18768_c))) || (!(Base64_Compile.__default.IsBase64Char(_18768_c)));
      }))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/Base64.dfy(34,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestIsUnpaddedBase64StringSuccess()
    {
      if (!(Base64_Compile.__default.IsUnpaddedBase64String(Dafny.Sequence<char>.FromString("VGVz")))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/Base64.dfy(38,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestIsUnpaddedBase64StringTooShort()
    {
      if (!(!(Base64_Compile.__default.IsUnpaddedBase64String(Dafny.Sequence<char>.FromString("VGV"))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/Base64.dfy(42,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestIsUnpaddedBase64StringNotBase64()
    {
      if (!(!(Base64_Compile.__default.IsUnpaddedBase64String(Dafny.Sequence<char>.FromString("VGV$"))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/Base64.dfy(46,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestIndexToChar63()
    {
      if (!((Base64_Compile.__default.IndexToChar(63)) == ('/'))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/Base64.dfy(50,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestIndexToChar62()
    {
      if (!((Base64_Compile.__default.IndexToChar(62)) == ('+'))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/Base64.dfy(54,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestIndexToCharDigits()
    {
      Dafny.ISequence<char> _18769_digits;
      _18769_digits = Dafny.Sequence<char>.FromString("0123456789");
      if (!(Dafny.Helpers.Id<Func<Dafny.ISequence<char>, bool>>((_18770_digits) => Dafny.Helpers.Quantifier<byte>(Base64_Compile.index.IntegerRange(BigInteger.Zero, new BigInteger(64)), true, (((_18771_i) => {
        return !(((52) <= (_18771_i)) && ((_18771_i) <= (61))) || ((_18770_digits).Contains((Base64_Compile.__default.IndexToChar(_18771_i))));
      }))))(_18769_digits))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/Base64.dfy(59,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestIndexToCharLowercase()
    {
      Dafny.ISequence<char> _18772_lowercase;
      _18772_lowercase = Dafny.Sequence<char>.FromString("abcdefghijklmnopqrstuvwxyz");
      if (!(Dafny.Helpers.Id<Func<Dafny.ISequence<char>, bool>>((_18773_lowercase) => Dafny.Helpers.Quantifier<byte>(Base64_Compile.index.IntegerRange(BigInteger.Zero, new BigInteger(64)), true, (((_18774_i) => {
        return !(((26) <= (_18774_i)) && ((_18774_i) <= (51))) || ((_18773_lowercase).Contains((Base64_Compile.__default.IndexToChar(_18774_i))));
      }))))(_18772_lowercase))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/Base64.dfy(64,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestIndexToCharUppercase()
    {
      Dafny.ISequence<char> _18775_uppercase;
      _18775_uppercase = Dafny.Sequence<char>.FromString("ABCDEFGHIJKLMNOPQRSTUVWXYZ");
      if (!(Dafny.Helpers.Id<Func<Dafny.ISequence<char>, bool>>((_18776_uppercase) => Dafny.Helpers.Quantifier<byte>(Base64_Compile.index.IntegerRange(BigInteger.Zero, new BigInteger(64)), true, (((_18777_i) => {
        return !(((0) <= (_18777_i)) && ((_18777_i) <= (25))) || ((_18776_uppercase).Contains((Base64_Compile.__default.IndexToChar(_18777_i))));
      }))))(_18775_uppercase))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/Base64.dfy(69,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestCharToIndex63()
    {
      if (!((Base64_Compile.__default.CharToIndex('/')) == (63))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/Base64.dfy(73,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestCharToIndex62()
    {
      if (!((Base64_Compile.__default.CharToIndex('+')) == (62))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/Base64.dfy(77,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestCharToIndexDigits()
    {
      Dafny.ISequence<char> _18778_digits;
      _18778_digits = Dafny.Sequence<char>.FromString("0123456789");
      if (!(Dafny.Helpers.Id<Func<Dafny.ISequence<char>, bool>>((_18779_digits) => Dafny.Helpers.Quantifier<BigInteger>(Dafny.Helpers.IntegerRange(BigInteger.Zero, new BigInteger((_18779_digits).Count)), true, (((_18780_i) => {
        return !(((_18780_i).Sign != -1) && ((_18780_i) < (new BigInteger((_18779_digits).Count)))) || ((Base64_Compile.__default.CharToIndex((_18779_digits).Select(_18780_i))) == ((byte)((_18780_i) + (new BigInteger(52)))));
      }))))(_18778_digits))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/Base64.dfy(82,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestCharToIndexLowercase()
    {
      Dafny.ISequence<char> _18781_lowercase;
      _18781_lowercase = Dafny.Sequence<char>.FromString("abcdefghijklmnopqrstuvwxyz");
      if (!(Dafny.Helpers.Id<Func<Dafny.ISequence<char>, bool>>((_18782_lowercase) => Dafny.Helpers.Quantifier<BigInteger>(Dafny.Helpers.IntegerRange(BigInteger.Zero, new BigInteger((_18782_lowercase).Count)), true, (((_18783_i) => {
        return !(((_18783_i).Sign != -1) && ((_18783_i) < (new BigInteger((_18782_lowercase).Count)))) || ((Base64_Compile.__default.CharToIndex((_18782_lowercase).Select(_18783_i))) == ((byte)((_18783_i) + (new BigInteger(26)))));
      }))))(_18781_lowercase))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/Base64.dfy(87,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestCharToIndexUppercase()
    {
      Dafny.ISequence<char> _18784_uppercase;
      _18784_uppercase = Dafny.Sequence<char>.FromString("ABCDEFGHIJKLMNOPQRSTUVWXYZ");
      if (!(Dafny.Helpers.Id<Func<Dafny.ISequence<char>, bool>>((_18785_uppercase) => Dafny.Helpers.Quantifier<BigInteger>(Dafny.Helpers.IntegerRange(BigInteger.Zero, new BigInteger((_18785_uppercase).Count)), true, (((_18786_i) => {
        return !(((_18786_i).Sign != -1) && ((_18786_i) < (new BigInteger((_18785_uppercase).Count)))) || ((Base64_Compile.__default.CharToIndex((_18785_uppercase).Select(_18786_i))) == ((byte)(_18786_i)));
      }))))(_18784_uppercase))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/Base64.dfy(92,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestUInt24ToSeq()
    {
      uint _18787_input;
      _18787_input = 1048833U;
      Dafny.ISequence<byte> _18788_output;
      _18788_output = Dafny.Sequence<byte>.FromElements(16, 1, 1);
      if (!((_18788_output).Equals((Base64_Compile.__default.UInt24ToSeq(_18787_input))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/Base64.dfy(98,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestSeqToUInt24()
    {
      Dafny.ISequence<byte> _18789_input;
      _18789_input = Dafny.Sequence<byte>.FromElements(16, 1, 1);
      uint _18790_output;
      _18790_output = 1048833U;
      if (!((_18790_output) == (Base64_Compile.__default.SeqToUInt24(_18789_input)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/Base64.dfy(104,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestUInt24ToIndexSeq()
    {
      uint _18791_input;
      _18791_input = 1048833U;
      Dafny.ISequence<byte> _18792_output;
      _18792_output = Dafny.Sequence<byte>.FromElements(4, 0, 4, 1);
      if (!((_18792_output).Equals((Base64_Compile.__default.UInt24ToIndexSeq(_18791_input))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/Base64.dfy(110,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestIndexSeqToUInt24()
    {
      Dafny.ISequence<byte> _18793_input;
      _18793_input = Dafny.Sequence<byte>.FromElements(4, 0, 4, 1);
      uint _18794_output;
      _18794_output = 1048833U;
      if (!((_18794_output) == (Base64_Compile.__default.IndexSeqToUInt24(_18793_input)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/Base64.dfy(116,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestDecodeBlock()
    {
      Dafny.ISequence<byte> _18795_input;
      _18795_input = Dafny.Sequence<byte>.FromElements(4, 0, 4, 1);
      Dafny.ISequence<byte> _18796_output;
      _18796_output = Dafny.Sequence<byte>.FromElements(16, 1, 1);
      if (!((_18796_output).Equals((Base64_Compile.__default.DecodeBlock(_18795_input))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/Base64.dfy(122,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestEncodeBlock()
    {
      Dafny.ISequence<byte> _18797_input;
      _18797_input = Dafny.Sequence<byte>.FromElements(16, 1, 1);
      Dafny.ISequence<byte> _18798_output;
      _18798_output = Dafny.Sequence<byte>.FromElements(4, 0, 4, 1);
      if (!((_18798_output).Equals((Base64_Compile.__default.EncodeBlock(_18797_input))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/Base64.dfy(128,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestDecodeRecursively()
    {
      Dafny.ISequence<byte> _18799_input;
      _18799_input = Dafny.Sequence<byte>.FromElements(4, 0, 4, 1, 4, 0, 4, 1);
      Dafny.ISequence<byte> _18800_output;
      _18800_output = Dafny.Sequence<byte>.FromElements(16, 1, 1, 16, 1, 1);
      if (!((_18800_output).Equals((Base64_Compile.__default.DecodeRecursively(_18799_input))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/Base64.dfy(134,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestEncodeRecursively()
    {
      Dafny.ISequence<byte> _18801_input;
      _18801_input = Dafny.Sequence<byte>.FromElements(16, 1, 1, 16, 1, 1);
      Dafny.ISequence<byte> _18802_output;
      _18802_output = Dafny.Sequence<byte>.FromElements(4, 0, 4, 1, 4, 0, 4, 1);
      if (!((_18802_output).Equals((Base64_Compile.__default.EncodeRecursively(_18801_input))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/Base64.dfy(140,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestFromCharsToIndices()
    {
      Dafny.ISequence<char> _18803_input;
      _18803_input = Dafny.Sequence<char>.FromString("aA1+/");
      Dafny.ISequence<byte> _18804_output;
      _18804_output = Dafny.Sequence<byte>.FromElements(26, 0, 53, 62, 63);
      if (!((_18804_output).Equals((Base64_Compile.__default.FromCharsToIndices(_18803_input))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/Base64.dfy(146,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestFromIndicesToChars()
    {
      Dafny.ISequence<byte> _18805_input;
      _18805_input = Dafny.Sequence<byte>.FromElements(26, 0, 53, 62, 63);
      Dafny.ISequence<char> _18806_output;
      _18806_output = Dafny.Sequence<char>.FromString("aA1+/");
      if (!((_18806_output).Equals((Base64_Compile.__default.FromIndicesToChars(_18805_input))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/Base64.dfy(152,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestDecodeUnpadded()
    {
      Dafny.ISequence<char> _18807_input;
      _18807_input = Dafny.Sequence<char>.FromString("VGVzdGluZysx");
      Dafny.ISequence<byte> _18808_output;
      _18808_output = Dafny.Sequence<byte>.FromElements(84, 101, 115, 116, 105, 110, 103, 43, 49);
      if (!((_18808_output).Equals((Base64_Compile.__default.DecodeUnpadded(_18807_input))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/Base64.dfy(158,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestEncodeUnpadded()
    {
      Dafny.ISequence<byte> _18809_input;
      _18809_input = Dafny.Sequence<byte>.FromElements(84, 101, 115, 116, 105, 110, 103, 43, 49);
      Dafny.ISequence<char> _18810_output;
      _18810_output = Dafny.Sequence<char>.FromString("VGVzdGluZysx");
      if (!((_18810_output).Equals((Base64_Compile.__default.EncodeUnpadded(_18809_input))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/Base64.dfy(164,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestDecodeUnpaddedEmpty()
    {
      if (!((Dafny.Sequence<byte>.FromElements()).Equals((Base64_Compile.__default.DecodeUnpadded(Dafny.Sequence<char>.FromElements()))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/Base64.dfy(168,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestEncodeUnpaddedEmpty()
    {
      if (!((Dafny.Sequence<char>.FromElements()).Equals((Base64_Compile.__default.EncodeUnpadded(Dafny.Sequence<byte>.FromElements()))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/Base64.dfy(172,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestIs1PaddingSuccess()
    {
      if (!(Base64_Compile.__default.Is1Padding(Dafny.Sequence<char>.FromString("VGU=")))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/Base64.dfy(176,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestIs1PaddingTooShort()
    {
      if (!(!(Base64_Compile.__default.Is1Padding(Dafny.Sequence<char>.FromString("VG="))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/Base64.dfy(180,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestIs1PaddingTooLong()
    {
      if (!(!(Base64_Compile.__default.Is1Padding(Dafny.Sequence<char>.FromString("VGUU="))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/Base64.dfy(184,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestIs1PaddingInvalidChar0()
    {
      if (!(!(Base64_Compile.__default.Is1Padding(Dafny.Sequence<char>.FromString("$GU="))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/Base64.dfy(188,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestIs1PaddingInvalidChar1()
    {
      if (!(!(Base64_Compile.__default.Is1Padding(Dafny.Sequence<char>.FromString("V$U="))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/Base64.dfy(192,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestIs1PaddingInvalidChar2()
    {
      if (!(!(Base64_Compile.__default.Is1Padding(Dafny.Sequence<char>.FromString("VG$="))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/Base64.dfy(196,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestIs1PaddingInvalidChar3()
    {
      if (!(!(Base64_Compile.__default.Is1Padding(Dafny.Sequence<char>.FromString("VGVz"))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/Base64.dfy(200,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestIs1PaddingInvalidChar2Modulus()
    {
      if (!(!(Base64_Compile.__default.Is1Padding(Dafny.Sequence<char>.FromString("VGV="))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/Base64.dfy(204,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestDecode1Padding()
    {
      Dafny.ISequence<char> _18811_input;
      _18811_input = Dafny.Sequence<char>.FromString("VGU=");
      Dafny.ISequence<byte> _18812_output;
      _18812_output = Dafny.Sequence<byte>.FromElements(84, 101);
      if (!((_18812_output).Equals((Base64_Compile.__default.Decode1Padding(_18811_input))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/Base64.dfy(210,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestEncode1Padding()
    {
      Dafny.ISequence<byte> _18813_input;
      _18813_input = Dafny.Sequence<byte>.FromElements(84, 101);
      Dafny.ISequence<char> _18814_output;
      _18814_output = Dafny.Sequence<char>.FromString("VGU=");
      if (!((_18814_output).Equals((Base64_Compile.__default.Encode1Padding(_18813_input))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/Base64.dfy(216,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestIs2PaddingSuccess()
    {
      if (!(Base64_Compile.__default.Is2Padding(Dafny.Sequence<char>.FromString("VA==")))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/Base64.dfy(220,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestIs2PaddingTooShort()
    {
      if (!(!(Base64_Compile.__default.Is2Padding(Dafny.Sequence<char>.FromString("VA="))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/Base64.dfy(224,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestIs2PaddingTooLong()
    {
      if (!(!(Base64_Compile.__default.Is2Padding(Dafny.Sequence<char>.FromString("VAA=="))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/Base64.dfy(228,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestIs2PaddingInvalidChar0()
    {
      if (!(!(Base64_Compile.__default.Is2Padding(Dafny.Sequence<char>.FromString("$A=="))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/Base64.dfy(232,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestIs2PaddingInvalidChar1()
    {
      if (!(!(Base64_Compile.__default.Is2Padding(Dafny.Sequence<char>.FromString("V$=="))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/Base64.dfy(236,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestIs2PaddingInvalidChar2()
    {
      if (!(!(Base64_Compile.__default.Is2Padding(Dafny.Sequence<char>.FromString("VAA="))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/Base64.dfy(240,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestIs2PaddingInvalidChar3()
    {
      if (!(!(Base64_Compile.__default.Is2Padding(Dafny.Sequence<char>.FromString("VA=A"))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/Base64.dfy(244,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestIs2PaddingInvalidChar1Modulus()
    {
      if (!(!(Base64_Compile.__default.Is2Padding(Dafny.Sequence<char>.FromString("VB=="))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/Base64.dfy(248,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestDecode2Padding()
    {
      Dafny.ISequence<char> _18815_input;
      _18815_input = Dafny.Sequence<char>.FromString("VA==");
      Dafny.ISequence<byte> _18816_output;
      _18816_output = Dafny.Sequence<byte>.FromElements(84);
      if (!((_18816_output).Equals((Base64_Compile.__default.Decode2Padding(_18815_input))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/Base64.dfy(254,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestEncode2Padding()
    {
      Dafny.ISequence<byte> _18817_input;
      _18817_input = Dafny.Sequence<byte>.FromElements(84);
      Dafny.ISequence<char> _18818_output;
      _18818_output = Dafny.Sequence<char>.FromString("VA==");
      if (!((_18818_output).Equals((Base64_Compile.__default.Encode2Padding(_18817_input))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/Base64.dfy(260,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestIsBase64StringTestVectors()
    {
      if (!(Dafny.Helpers.Quantifier<Dafny.ISequence<char>>((TestBase64_Compile.__default.BASE64__TEST__VECTORS__ENCODED).UniqueElements, true, (((_18819_i) => {
        return !((TestBase64_Compile.__default.BASE64__TEST__VECTORS__ENCODED).Contains((_18819_i))) || ((Base64_Compile.__default.IsBase64String(_18819_i)) == (true));
      }))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/Base64.dfy(264,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestIsBase64StringBadLength()
    {
      if (!(!(Base64_Compile.__default.IsBase64String(Dafny.Sequence<char>.FromString("VG="))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/Base64.dfy(268,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestIsBase64StringBadString()
    {
      if (!(!(Base64_Compile.__default.IsBase64String(Dafny.Sequence<char>.FromString("VC=="))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/Base64.dfy(272,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestSanityCheckDecodedTestVectors()
    {
      BigInteger _18820_testVectorIndex;
      _18820_testVectorIndex = BigInteger.Zero;
      while ((_18820_testVectorIndex) < (new BigInteger((TestBase64_Compile.__default.BASE64__TEST__VECTORS__DECODED).Count))) {
        Dafny.ISequence<byte> _18821_uint8Message;
        _18821_uint8Message = Dafny.Sequence<byte>.FromElements();
        Dafny.ISequence<char> _18822_strMessage;
        _18822_strMessage = (TestBase64_Compile.__default.BASE64__TEST__VECTORS__DECODED).Select(_18820_testVectorIndex);
        BigInteger _18823_msgIndex;
        _18823_msgIndex = BigInteger.Zero;
        while ((_18823_msgIndex) < (new BigInteger((_18822_strMessage).Count))) {
          _18821_uint8Message = Dafny.Sequence<byte>.Concat(_18821_uint8Message, Dafny.Sequence<byte>.FromElements((byte)((_18822_strMessage).Select(_18823_msgIndex))));
          _18823_msgIndex = (_18823_msgIndex) + (BigInteger.One);
        }
        if (!(((TestBase64_Compile.__default.BASE64__TEST__VECTORS__DECODED__UINT8).Select(_18820_testVectorIndex)).Equals((_18821_uint8Message)))) {
          throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/Base64.dfy(290,6): " + Dafny.Sequence<char>.FromString("expectation violation"));
        }
        _18820_testVectorIndex = (_18820_testVectorIndex) + (BigInteger.One);
      }
    }
    [Xunit.Fact]
    public static void TestDecodeValidTestVectors()
    {
      if (!(Dafny.Helpers.Quantifier<BigInteger>(Dafny.Helpers.IntegerRange(BigInteger.Zero, new BigInteger((TestBase64_Compile.__default.BASE64__TEST__VECTORS__ENCODED).Count)), true, (((_18824_i) => {
        return !(((_18824_i).Sign != -1) && ((_18824_i) < (new BigInteger((TestBase64_Compile.__default.BASE64__TEST__VECTORS__ENCODED).Count)))) || ((Base64_Compile.__default.DecodeValid((TestBase64_Compile.__default.BASE64__TEST__VECTORS__ENCODED).Select(_18824_i))).Equals(((TestBase64_Compile.__default.BASE64__TEST__VECTORS__DECODED__UINT8).Select(_18824_i))));
      }))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/Base64.dfy(296,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestDecodeTestVectors()
    {
      if (!(Dafny.Helpers.Quantifier<BigInteger>(Dafny.Helpers.IntegerRange(BigInteger.Zero, new BigInteger((TestBase64_Compile.__default.BASE64__TEST__VECTORS__ENCODED).Count)), true, (((_18825_i) => {
        return !(((_18825_i).Sign != -1) && ((_18825_i) < (new BigInteger((TestBase64_Compile.__default.BASE64__TEST__VECTORS__ENCODED).Count)))) || (object.Equals(Base64_Compile.__default.Decode((TestBase64_Compile.__default.BASE64__TEST__VECTORS__ENCODED).Select(_18825_i)), @Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.create_Success((TestBase64_Compile.__default.BASE64__TEST__VECTORS__DECODED__UINT8).Select(_18825_i))));
      }))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/Base64.dfy(301,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestDecodeFailure()
    {
      if (!(object.Equals(@Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("The encoding is malformed")), Base64_Compile.__default.Decode(Dafny.Sequence<char>.FromString("$"))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/Base64.dfy(306,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestEncode()
    {
      if (!(Dafny.Helpers.Quantifier<BigInteger>(Dafny.Helpers.IntegerRange(BigInteger.Zero, new BigInteger((TestBase64_Compile.__default.BASE64__TEST__VECTORS__DECODED__UINT8).Count)), true, (((_18826_i) => {
        return !(((_18826_i).Sign != -1) && ((_18826_i) < (new BigInteger((TestBase64_Compile.__default.BASE64__TEST__VECTORS__DECODED__UINT8).Count)))) || ((Base64_Compile.__default.Encode((TestBase64_Compile.__default.BASE64__TEST__VECTORS__DECODED__UINT8).Select(_18826_i))).Equals(((TestBase64_Compile.__default.BASE64__TEST__VECTORS__ENCODED).Select(_18826_i))));
      }))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/Base64.dfy(310,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestEncodeDecode()
    {
      if (!(Dafny.Helpers.Quantifier<BigInteger>(Dafny.Helpers.IntegerRange(BigInteger.Zero, new BigInteger((TestBase64_Compile.__default.BASE64__TEST__VECTORS__DECODED__UINT8).Count)), true, (((_18827_i) => {
        return !(((_18827_i).Sign != -1) && ((_18827_i) < (new BigInteger((TestBase64_Compile.__default.BASE64__TEST__VECTORS__DECODED__UINT8).Count)))) || (object.Equals(Base64_Compile.__default.Decode(Base64_Compile.__default.Encode((TestBase64_Compile.__default.BASE64__TEST__VECTORS__DECODED__UINT8).Select(_18827_i))), @Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.create_Success((TestBase64_Compile.__default.BASE64__TEST__VECTORS__DECODED__UINT8).Select(_18827_i))));
      }))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/Base64.dfy(315,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestDecodeEncode()
    {
      if (!(Dafny.Helpers.Quantifier<BigInteger>(Dafny.Helpers.IntegerRange(BigInteger.Zero, new BigInteger((TestBase64_Compile.__default.BASE64__TEST__VECTORS__ENCODED).Count)), true, (((_18828_i) => {
        return !(((_18828_i).Sign != -1) && ((_18828_i) < (new BigInteger((TestBase64_Compile.__default.BASE64__TEST__VECTORS__ENCODED).Count)))) || (((Base64_Compile.__default.Decode((TestBase64_Compile.__default.BASE64__TEST__VECTORS__ENCODED).Select(_18828_i))).is_Success) && ((Base64_Compile.__default.Encode((Base64_Compile.__default.Decode((TestBase64_Compile.__default.BASE64__TEST__VECTORS__ENCODED).Select(_18828_i))).dtor_value)).Equals(((TestBase64_Compile.__default.BASE64__TEST__VECTORS__ENCODED).Select(_18828_i)))));
      }))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/Base64.dfy(320,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    public static Dafny.ISequence<Dafny.ISequence<byte>> BASE64__TEST__VECTORS__DECODED__UINT8 { get {
      return Dafny.Sequence<Dafny.ISequence<byte>>.FromElements(Dafny.Sequence<byte>.FromElements(), Dafny.Sequence<byte>.FromElements(84), Dafny.Sequence<byte>.FromElements(84, 101), Dafny.Sequence<byte>.FromElements(84, 101, 115), Dafny.Sequence<byte>.FromElements(84, 101, 115, 116), Dafny.Sequence<byte>.FromElements(84, 101, 115, 116, 105), Dafny.Sequence<byte>.FromElements(84, 101, 115, 116, 105, 110), Dafny.Sequence<byte>.FromElements(84, 101, 115, 116, 105, 110, 103), Dafny.Sequence<byte>.FromElements(84, 101, 115, 116, 105, 110, 103, 43), Dafny.Sequence<byte>.FromElements(84, 101, 115, 116, 105, 110, 103, 43, 49));
    } }
    public static Dafny.ISequence<Dafny.ISequence<char>> BASE64__TEST__VECTORS__ENCODED { get {
      return Dafny.Sequence<Dafny.ISequence<char>>.FromElements(Dafny.Sequence<char>.FromString(""), Dafny.Sequence<char>.FromString("VA=="), Dafny.Sequence<char>.FromString("VGU="), Dafny.Sequence<char>.FromString("VGVz"), Dafny.Sequence<char>.FromString("VGVzdA=="), Dafny.Sequence<char>.FromString("VGVzdGk="), Dafny.Sequence<char>.FromString("VGVzdGlu"), Dafny.Sequence<char>.FromString("VGVzdGluZw=="), Dafny.Sequence<char>.FromString("VGVzdGluZys="), Dafny.Sequence<char>.FromString("VGVzdGluZysx"));
    } }
    public static Dafny.ISequence<Dafny.ISequence<char>> BASE64__TEST__VECTORS__DECODED { get {
      return Dafny.Sequence<Dafny.ISequence<char>>.FromElements(Dafny.Sequence<char>.FromString(""), Dafny.Sequence<char>.FromString("T"), Dafny.Sequence<char>.FromString("Te"), Dafny.Sequence<char>.FromString("Tes"), Dafny.Sequence<char>.FromString("Test"), Dafny.Sequence<char>.FromString("Testi"), Dafny.Sequence<char>.FromString("Testin"), Dafny.Sequence<char>.FromString("Testing"), Dafny.Sequence<char>.FromString("Testing+"), Dafny.Sequence<char>.FromString("Testing+1"));
    } }
    public static Dafny.ISequence<char> BASE64__CHARS { get {
      return Dafny.Sequence<char>.FromString("+/0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz");
    } }
  }
} // end of namespace TestBase64_Compile
namespace TestStandardLibrary_Compile {



  public partial class __default {
    [Xunit.Fact]
    public static void TestJoinMultiElementSeq()
    {
      Dafny.ISequence<Dafny.ISequence<char>> _18829_input;
      _18829_input = Dafny.Sequence<Dafny.ISequence<char>>.FromElements(Dafny.Sequence<char>.FromString("comma"), Dafny.Sequence<char>.FromString("separated"), Dafny.Sequence<char>.FromString("list"));
      Dafny.ISequence<char> _18830_output;
      _18830_output = StandardLibrary_Compile.__default.Join<char>(_18829_input, Dafny.Sequence<char>.FromString(","));
      if (!((Dafny.Sequence<char>.FromString("comma,separated,list")).Equals((_18830_output)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/StandardLibrary.dfy(13,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestJoinSingleElementSeq()
    {
      Dafny.ISequence<Dafny.ISequence<char>> _18831_input;
      _18831_input = Dafny.Sequence<Dafny.ISequence<char>>.FromElements(Dafny.Sequence<char>.FromString("one"));
      Dafny.ISequence<char> _18832_output;
      _18832_output = StandardLibrary_Compile.__default.Join<char>(_18831_input, Dafny.Sequence<char>.FromString(","));
      if (!((Dafny.Sequence<char>.FromString("one")).Equals((_18832_output)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/StandardLibrary.dfy(19,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestJoinSplit()
    {
      Dafny.ISequence<char> _18833_input;
      _18833_input = Dafny.Sequence<char>.FromString("comma,separated,list");
      Dafny.ISequence<char> _18834_output;
      _18834_output = StandardLibrary_Compile.__default.Join<char>(StandardLibrary_Compile.__default.Split<char>(_18833_input, ','), Dafny.Sequence<char>.FromString(","));
      if (!((_18833_input).Equals((_18834_output)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/StandardLibrary.dfy(25,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestSplitJoin()
    {
      Dafny.ISequence<Dafny.ISequence<char>> _18835_input;
      _18835_input = Dafny.Sequence<Dafny.ISequence<char>>.FromElements(Dafny.Sequence<char>.FromString("comma"), Dafny.Sequence<char>.FromString("separated"), Dafny.Sequence<char>.FromString("list"));
      Dafny.ISequence<Dafny.ISequence<char>> _18836_output;
      _18836_output = StandardLibrary_Compile.__default.Split<char>(StandardLibrary_Compile.__default.Join<char>(_18835_input, Dafny.Sequence<char>.FromString(",")), ',');
      if (!((_18835_input).Equals((_18836_output)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/StandardLibrary.dfy(31,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestSplitByteSeq()
    {
      Dafny.ISequence<char> _18837_input;
      _18837_input = Dafny.Sequence<char>.FromString("comma,separated,list");
      Dafny.ISequence<Dafny.ISequence<char>> _18838_output;
      _18838_output = StandardLibrary_Compile.__default.Split<char>(_18837_input, ',');
      if (!((Dafny.Sequence<Dafny.ISequence<char>>.FromElements(Dafny.Sequence<char>.FromString("comma"), Dafny.Sequence<char>.FromString("separated"), Dafny.Sequence<char>.FromString("list"))).Equals((_18838_output)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/StandardLibrary.dfy(37,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestSplitNumSeq()
    {
      Dafny.ISequence<BigInteger> _18839_input;
      _18839_input = Dafny.Sequence<BigInteger>.FromElements(BigInteger.One, new BigInteger(2), new BigInteger(3), BigInteger.Zero, BigInteger.One, new BigInteger(2), new BigInteger(3));
      Dafny.ISequence<Dafny.ISequence<BigInteger>> _18840_output;
      _18840_output = StandardLibrary_Compile.__default.Split<BigInteger>(_18839_input, BigInteger.Zero);
      if (!((Dafny.Sequence<Dafny.ISequence<BigInteger>>.FromElements(Dafny.Sequence<BigInteger>.FromElements(BigInteger.One, new BigInteger(2), new BigInteger(3)), Dafny.Sequence<BigInteger>.FromElements(BigInteger.One, new BigInteger(2), new BigInteger(3)))).Equals((_18840_output)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/StandardLibrary.dfy(43,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestSplitFinalElementDelim()
    {
      Dafny.ISequence<char> _18841_input;
      _18841_input = Dafny.Sequence<char>.FromString("one,");
      Dafny.ISequence<Dafny.ISequence<char>> _18842_output;
      _18842_output = StandardLibrary_Compile.__default.Split<char>(_18841_input, ',');
      if (!((Dafny.Sequence<Dafny.ISequence<char>>.FromElements(Dafny.Sequence<char>.FromString("one"), Dafny.Sequence<char>.FromString(""))).Equals((_18842_output)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/StandardLibrary.dfy(49,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestSplitNoDelim()
    {
      Dafny.ISequence<char> _18843_input;
      _18843_input = Dafny.Sequence<char>.FromString("no comma");
      Dafny.ISequence<Dafny.ISequence<char>> _18844_output;
      _18844_output = StandardLibrary_Compile.__default.Split<char>(_18843_input, ',');
      if (!((Dafny.Sequence<Dafny.ISequence<char>>.FromElements(Dafny.Sequence<char>.FromString("no comma"))).Equals((_18844_output)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/StandardLibrary.dfy(55,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestSplitOnlyElemIsDelim()
    {
      Dafny.ISequence<char> _18845_input;
      _18845_input = Dafny.Sequence<char>.FromString(",");
      Dafny.ISequence<Dafny.ISequence<char>> _18846_output;
      _18846_output = StandardLibrary_Compile.__default.Split<char>(_18845_input, ',');
      if (!((Dafny.Sequence<Dafny.ISequence<char>>.FromElements(Dafny.Sequence<char>.FromString(""), Dafny.Sequence<char>.FromString(""))).Equals((_18846_output)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/StandardLibrary.dfy(61,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestSplitEmpty()
    {
      Dafny.ISequence<char> _18847_input;
      _18847_input = Dafny.Sequence<char>.FromString("");
      Dafny.ISequence<Dafny.ISequence<char>> _18848_output;
      _18848_output = StandardLibrary_Compile.__default.Split<char>(_18847_input, ',');
      if (!((Dafny.Sequence<Dafny.ISequence<char>>.FromElements(Dafny.Sequence<char>.FromString(""))).Equals((_18848_output)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/StandardLibrary.dfy(67,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestFindIndexMatchingSimple()
    {
      Dafny.ISequence<char> _18849_input;
      _18849_input = Dafny.Sequence<char>.FromString("abcd");
      Wrappers_Compile.Option<BigInteger> _18850_output;
      _18850_output = StandardLibrary_Compile.__default.FindIndexMatching<char>(_18849_input, 'c', BigInteger.Zero);
      if (!(object.Equals(@Wrappers_Compile.Option<BigInteger>.create_Some(new BigInteger(2)), _18850_output))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/StandardLibrary.dfy(73,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestFindIndexMatchingDuplicates()
    {
      Dafny.ISequence<char> _18851_input;
      _18851_input = Dafny.Sequence<char>.FromString("abcdc");
      Wrappers_Compile.Option<BigInteger> _18852_output;
      _18852_output = StandardLibrary_Compile.__default.FindIndexMatching<char>(_18851_input, 'c', BigInteger.Zero);
      if (!(object.Equals(@Wrappers_Compile.Option<BigInteger>.create_Some(new BigInteger(2)), _18852_output))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/StandardLibrary.dfy(79,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestFindIndexMatchingNone()
    {
      Dafny.ISequence<char> _18853_input;
      _18853_input = Dafny.Sequence<char>.FromString("abcd");
      Wrappers_Compile.Option<BigInteger> _18854_output;
      _18854_output = StandardLibrary_Compile.__default.FindIndexMatching<char>(_18853_input, 'e', BigInteger.Zero);
      if (!(object.Equals(@Wrappers_Compile.Option<BigInteger>.create_None(), _18854_output))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/StandardLibrary.dfy(85,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestFindIndexSimple()
    {
      Dafny.ISequence<char> _18855_input;
      _18855_input = Dafny.Sequence<char>.FromString("abcd");
      Wrappers_Compile.Option<BigInteger> _18856_output;
      _18856_output = StandardLibrary_Compile.__default.FindIndex<char>(_18855_input, ((System.Func<char, bool>)((_18857_x) => {
        return (_18857_x) == ('c');
      })), BigInteger.Zero);
      if (!(object.Equals(@Wrappers_Compile.Option<BigInteger>.create_Some(new BigInteger(2)), _18856_output))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/StandardLibrary.dfy(92,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestFindIndexComplex()
    {
      Dafny.ISequence<char> _18858_input;
      _18858_input = Dafny.Sequence<char>.FromString("abcd");
      Wrappers_Compile.Option<BigInteger> _18859_output;
      _18859_output = StandardLibrary_Compile.__default.FindIndex<char>(_18858_input, ((System.Func<char, bool>)((_18860_x) => {
        return (Dafny.Sequence<char>.FromString("crepe")).Contains((_18860_x));
      })), BigInteger.Zero);
      if (!(object.Equals(@Wrappers_Compile.Option<BigInteger>.create_Some(new BigInteger(2)), _18859_output))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/StandardLibrary.dfy(99,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestFindIndexDuplicates()
    {
      Dafny.ISequence<char> _18861_input;
      _18861_input = Dafny.Sequence<char>.FromString("abcdc");
      Wrappers_Compile.Option<BigInteger> _18862_output;
      _18862_output = StandardLibrary_Compile.__default.FindIndex<char>(_18861_input, ((System.Func<char, bool>)((_18863_x) => {
        return (_18863_x) == ('c');
      })), BigInteger.Zero);
      if (!(object.Equals(@Wrappers_Compile.Option<BigInteger>.create_Some(new BigInteger(2)), _18862_output))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/StandardLibrary.dfy(106,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestFindIndexNone()
    {
      Dafny.ISequence<char> _18864_input;
      _18864_input = Dafny.Sequence<char>.FromString("abcd");
      Wrappers_Compile.Option<BigInteger> _18865_output;
      _18865_output = StandardLibrary_Compile.__default.FindIndex<char>(_18864_input, ((System.Func<char, bool>)((_18866_x) => {
        return false;
      })), BigInteger.Zero);
      if (!(object.Equals(@Wrappers_Compile.Option<BigInteger>.create_None(), _18865_output))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/StandardLibrary.dfy(113,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    public static bool TestFilterPredicate(Dafny.ISequence<char> entry) {
      return (Dafny.Sequence<Dafny.ISequence<char>>.FromElements(Dafny.Sequence<char>.FromString("a"))).Contains((entry));
    }
    [Xunit.Fact]
    public static void TestFilterSomeValid()
    {
      Dafny.ISequence<Dafny.ISequence<char>> _18867_input;
      _18867_input = Dafny.Sequence<Dafny.ISequence<char>>.FromElements(Dafny.Sequence<char>.FromString("a"), Dafny.Sequence<char>.FromString("b"), Dafny.Sequence<char>.FromString("a"));
      Dafny.ISequence<Dafny.ISequence<char>> _18868_output;
      _18868_output = StandardLibrary_Compile.__default.Filter<Dafny.ISequence<char>>(_18867_input, TestStandardLibrary_Compile.__default.TestFilterPredicate);
      if (!((Dafny.Sequence<Dafny.ISequence<char>>.FromElements(Dafny.Sequence<char>.FromString("a"), Dafny.Sequence<char>.FromString("a"))).Equals((_18868_output)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/StandardLibrary.dfy(123,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestFilterNoneValid()
    {
      Dafny.ISequence<Dafny.ISequence<char>> _18869_input;
      _18869_input = Dafny.Sequence<Dafny.ISequence<char>>.FromElements(Dafny.Sequence<char>.FromString("c"), Dafny.Sequence<char>.FromString("b"), Dafny.Sequence<char>.FromString("c"));
      Dafny.ISequence<Dafny.ISequence<char>> _18870_output;
      _18870_output = StandardLibrary_Compile.__default.Filter<Dafny.ISequence<char>>(_18869_input, TestStandardLibrary_Compile.__default.TestFilterPredicate);
      if (!((Dafny.Sequence<Dafny.ISequence<char>>.FromElements()).Equals((_18870_output)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/StandardLibrary.dfy(129,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestFilterNothing()
    {
      Dafny.ISequence<Dafny.ISequence<char>> _18871_input;
      _18871_input = Dafny.Sequence<Dafny.ISequence<char>>.FromElements();
      Dafny.ISequence<Dafny.ISequence<char>> _18872_output;
      _18872_output = StandardLibrary_Compile.__default.Filter<Dafny.ISequence<char>>(_18871_input, TestStandardLibrary_Compile.__default.TestFilterPredicate);
      if (!((Dafny.Sequence<Dafny.ISequence<char>>.FromElements()).Equals((_18872_output)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/StandardLibrary.dfy(135,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestFillZero()
    {
      Dafny.ISequence<BigInteger> _18873_output;
      _18873_output = StandardLibrary_Compile.__default.Fill<BigInteger>(BigInteger.Zero, new BigInteger(50));
      if (!((((System.Func<Dafny.ISequence<BigInteger>>) (() => {
        BigInteger dim38 = new BigInteger(50);
        var arr38 = new BigInteger[Dafny.Helpers.ToIntChecked(dim38,"C# array size must not be larger than max 32-bit int")];
        for (int i38 = 0; i38 < dim38; i38++) {
          var _18874___v0 = (BigInteger) i38;
          arr38[(int)(_18874___v0)] = BigInteger.Zero;
        }
        return Dafny.Sequence<BigInteger>.FromArray(arr38);
      }))()).Equals((_18873_output)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/StandardLibrary.dfy(140,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestFillChars()
    {
      Dafny.ISequence<Dafny.ISequence<char>> _18875_output;
      _18875_output = StandardLibrary_Compile.__default.Fill<Dafny.ISequence<char>>(Dafny.Sequence<char>.FromString("a"), new BigInteger(25));
      if (!((((System.Func<Dafny.ISequence<Dafny.ISequence<char>>>) (() => {
        BigInteger dim39 = new BigInteger(25);
        var arr39 = new Dafny.ISequence<char>[Dafny.Helpers.ToIntChecked(dim39,"C# array size must not be larger than max 32-bit int")];
        for (int i39 = 0; i39 < dim39; i39++) {
          var _18876___v1 = (BigInteger) i39;
          arr39[(int)(_18876___v1)] = Dafny.Sequence<char>.FromString("a");
        }
        return Dafny.Sequence<Dafny.ISequence<char>>.FromArray(arr39);
      }))()).Equals((_18875_output)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/StandardLibrary.dfy(145,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestMinPositives()
    {
      if (!((BigInteger.One) == (StandardLibrary_Compile.__default.Min(BigInteger.One, new BigInteger(2))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/StandardLibrary.dfy(149,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestMinNegatives()
    {
      if (!((new BigInteger(-2)) == (StandardLibrary_Compile.__default.Min(new BigInteger(-1), new BigInteger(-2))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/StandardLibrary.dfy(153,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestMinPositivesNegatives()
    {
      if (!((new BigInteger(-1)) == (StandardLibrary_Compile.__default.Min(new BigInteger(-1), BigInteger.One)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/StandardLibrary.dfy(157,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestMinDuplicateNumber()
    {
      if (!((StandardLibrary_Compile.__default.Min(BigInteger.Zero, BigInteger.Zero)).Sign == 0)) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/StandardLibrary.dfy(161,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestSeqToArray()
    {
      Dafny.ISequence<BigInteger> _18877_input;
      _18877_input = Dafny.Sequence<BigInteger>.FromElements(BigInteger.One, new BigInteger(2), new BigInteger(3));
      BigInteger[] _18878_output;
      BigInteger[] _out265;
      _out265 = StandardLibrary_Compile.__default.SeqToArray<BigInteger>(_18877_input);
      _18878_output = _out265;
      BigInteger[] _18879_expected;
      BigInteger[] _nw56 = new BigInteger[Dafny.Helpers.ToIntChecked(Dafny.Helpers.ToIntChecked(new BigInteger(3), "C# arrays may not be larger than the max 32-bit integer"),"C# array size must not be larger than max 32-bit int")];
      Func<BigInteger, BigInteger> _arrayinit2 = ((System.Func<BigInteger, BigInteger>)((_18880_i) => {
        return (_18880_i) + (BigInteger.One);
      }));
      for (var _arrayinit_02 = 0; _arrayinit_02 < new BigInteger(_nw56.Length); _arrayinit_02++) {
        _nw56[(int)(_arrayinit_02)] = _arrayinit2(_arrayinit_02);
      }
      _18879_expected = _nw56;
      if (!((new BigInteger((_18879_expected).Length)) == (new BigInteger((_18878_output).Length)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/StandardLibrary.dfy(172,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!(((_18879_expected)[(int)(BigInteger.Zero)]) == ((_18878_output)[(int)(BigInteger.Zero)]))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/StandardLibrary.dfy(173,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!(((_18879_expected)[(int)(BigInteger.One)]) == ((_18878_output)[(int)(BigInteger.One)]))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/StandardLibrary.dfy(174,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!(((_18879_expected)[(int)(new BigInteger(2))]) == ((_18878_output)[(int)(new BigInteger(2))]))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/StandardLibrary.dfy(175,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestSeqToArrayEmpty()
    {
      Dafny.ISequence<char> _18881_input;
      _18881_input = Dafny.Sequence<char>.FromElements();
      char[] _18882_output;
      char[] _out266;
      _out266 = StandardLibrary_Compile.__default.SeqToArray<char>(_18881_input);
      _18882_output = _out266;
      if (!((new BigInteger((_18882_output).Length)).Sign == 0)) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/StandardLibrary.dfy(181,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    public static bool TestStandardLibraryLessPredicate(BigInteger a, BigInteger b)
    {
      return (a) < (b);
    }
    [Xunit.Fact]
    public static void TestLexicographicLessOrEqualTrue()
    {
      Dafny.ISequence<BigInteger> _18883_a;
      _18883_a = Dafny.Sequence<BigInteger>.FromElements(BigInteger.One, new BigInteger(2), new BigInteger(3));
      Dafny.ISequence<BigInteger> _18884_b;
      _18884_b = Dafny.Sequence<BigInteger>.FromElements(BigInteger.One, new BigInteger(2), new BigInteger(4));
      if (!(StandardLibrary_Compile.__default.LexicographicLessOrEqual<BigInteger>(_18883_a, _18884_b, TestStandardLibrary_Compile.__default.TestStandardLibraryLessPredicate))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/StandardLibrary.dfy(189,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestLexicographicLessOrEqualFalse()
    {
      Dafny.ISequence<BigInteger> _18885_a;
      _18885_a = Dafny.Sequence<BigInteger>.FromElements(BigInteger.One, new BigInteger(2), new BigInteger(3));
      Dafny.ISequence<BigInteger> _18886_b;
      _18886_b = Dafny.Sequence<BigInteger>.FromElements(BigInteger.One, new BigInteger(2), new BigInteger(4));
      if (!(!(StandardLibrary_Compile.__default.LexicographicLessOrEqual<BigInteger>(_18886_b, _18885_a, TestStandardLibrary_Compile.__default.TestStandardLibraryLessPredicate)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/StandardLibrary.dfy(195,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestLexicographicLessOrEqualAllEqual()
    {
      Dafny.ISequence<BigInteger> _18887_a;
      _18887_a = Dafny.Sequence<BigInteger>.FromElements(BigInteger.One, new BigInteger(2), new BigInteger(3));
      Dafny.ISequence<BigInteger> _18888_b;
      _18888_b = Dafny.Sequence<BigInteger>.FromElements(BigInteger.One, new BigInteger(2), new BigInteger(3));
      if (!(StandardLibrary_Compile.__default.LexicographicLessOrEqual<BigInteger>(_18887_a, _18888_b, TestStandardLibrary_Compile.__default.TestStandardLibraryLessPredicate))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/StandardLibrary.dfy(201,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestLexicographicLessOrEqualNoneEqual()
    {
      Dafny.ISequence<BigInteger> _18889_a;
      _18889_a = Dafny.Sequence<BigInteger>.FromElements(BigInteger.One);
      Dafny.ISequence<BigInteger> _18890_b;
      _18890_b = Dafny.Sequence<BigInteger>.FromElements(new BigInteger(2));
      if (!(StandardLibrary_Compile.__default.LexicographicLessOrEqual<BigInteger>(_18889_a, _18890_b, TestStandardLibrary_Compile.__default.TestStandardLibraryLessPredicate))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/StandardLibrary.dfy(207,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestLexicographicLessOrEqualEmpty()
    {
      Dafny.ISequence<BigInteger> _18891_a;
      _18891_a = Dafny.Sequence<BigInteger>.FromElements();
      Dafny.ISequence<BigInteger> _18892_b;
      _18892_b = Dafny.Sequence<BigInteger>.FromElements();
      if (!(StandardLibrary_Compile.__default.LexicographicLessOrEqual<BigInteger>(_18891_a, _18892_b, TestStandardLibrary_Compile.__default.TestStandardLibraryLessPredicate))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/StandardLibrary.dfy(213,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
  }
} // end of namespace TestStandardLibrary_Compile
namespace TestUInt_Compile {


  public partial class __default {
    [Xunit.Fact]
    public static void TestUInt16ToSeq()
    {
      ushort _18893_x;
      _18893_x = 290;
      if (!((Dafny.Sequence<byte>.FromElements(1, 34)).Equals((StandardLibrary_mUInt_Compile.__default.UInt16ToSeq(_18893_x))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/UInt.dfy(12,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestSeqToUInt16()
    {
      Dafny.ISequence<byte> _18894_s;
      _18894_s = Dafny.Sequence<byte>.FromElements(1, 34);
      if (!(((ushort)(290)) == (StandardLibrary_mUInt_Compile.__default.SeqToUInt16(_18894_s)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/UInt.dfy(17,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestUInt32ToSeq()
    {
      uint _18895_x;
      _18895_x = 16920644U;
      if (!((Dafny.Sequence<byte>.FromElements(1, 2, 48, 68)).Equals((StandardLibrary_mUInt_Compile.__default.UInt32ToSeq(_18895_x))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/UInt.dfy(22,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestSeqToUInt32()
    {
      Dafny.ISequence<byte> _18896_s;
      _18896_s = Dafny.Sequence<byte>.FromElements(1, 2, 48, 68);
      if (!(((uint)(16920644U)) == (StandardLibrary_mUInt_Compile.__default.SeqToUInt32(_18896_s)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/UInt.dfy(27,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestUInt64ToSeq()
    {
      ulong _18897_x;
      _18897_x = 72673614040037256UL;
      if (!((Dafny.Sequence<byte>.FromElements(1, 2, 48, 68, 85, 102, 119, 136)).Equals((StandardLibrary_mUInt_Compile.__default.UInt64ToSeq(_18897_x))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/UInt.dfy(32,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestSeqToUInt64()
    {
      Dafny.ISequence<byte> _18898_s;
      _18898_s = Dafny.Sequence<byte>.FromElements(1, 2, 48, 68, 85, 102, 119, 136);
      if (!(((ulong)(72673614040037256UL)) == (StandardLibrary_mUInt_Compile.__default.SeqToUInt64(_18898_s)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/StandardLibrary/UInt.dfy(37,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
  }
} // end of namespace TestUInt_Compile
namespace TestSeqReaderReadElements_Compile {




  public partial class __default {
    [Xunit.Fact]
    public static void TestSetToOrderedSequenceEmpty()
    {
      Dafny.ISequence<Dafny.ISequence<byte>> _18899_output;
      Dafny.ISequence<Dafny.ISequence<byte>> _out267;
      _out267 = Sets.__default.SetToOrderedSequence<byte>(Dafny.Set<Dafny.ISequence<byte>>.FromElements(), StandardLibrary_mUInt_Compile.__default.UInt8Less);
      _18899_output = _out267;
      Dafny.ISequence<Dafny.ISequence<byte>> _18900_expected;
      _18900_expected = Dafny.Sequence<Dafny.ISequence<byte>>.FromElements();
      if (!((_18899_output).Equals((_18900_expected)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/Sets.dfy(15,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestSetToOrderedSequenceOneItem()
    {
      Dafny.ISet<Dafny.ISequence<byte>> _18901_a;
      _18901_a = Dafny.Set<Dafny.ISequence<byte>>.FromElements(Dafny.Sequence<byte>.FromElements(0));
      Dafny.ISequence<Dafny.ISequence<byte>> _18902_output;
      Dafny.ISequence<Dafny.ISequence<byte>> _out268;
      _out268 = Sets.__default.SetToOrderedSequence<byte>(_18901_a, StandardLibrary_mUInt_Compile.__default.UInt8Less);
      _18902_output = _out268;
      Dafny.ISequence<Dafny.ISequence<byte>> _18903_expected;
      _18903_expected = Dafny.Sequence<Dafny.ISequence<byte>>.FromElements(Dafny.Sequence<byte>.FromElements(0));
      if (!((_18902_output).Equals((_18903_expected)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/Sets.dfy(22,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestSetToOrderedSequenceSimple()
    {
      Dafny.ISet<Dafny.ISequence<byte>> _18904_a;
      _18904_a = Dafny.Set<Dafny.ISequence<byte>>.FromElements(Dafny.Sequence<byte>.FromElements(0, 2), Dafny.Sequence<byte>.FromElements(0, 1));
      Dafny.ISequence<Dafny.ISequence<byte>> _18905_output;
      Dafny.ISequence<Dafny.ISequence<byte>> _out269;
      _out269 = Sets.__default.SetToOrderedSequence<byte>(_18904_a, StandardLibrary_mUInt_Compile.__default.UInt8Less);
      _18905_output = _out269;
      Dafny.ISequence<Dafny.ISequence<byte>> _18906_expected;
      _18906_expected = Dafny.Sequence<Dafny.ISequence<byte>>.FromElements(Dafny.Sequence<byte>.FromElements(0, 1), Dafny.Sequence<byte>.FromElements(0, 2));
      if (!((_18905_output).Equals((_18906_expected)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/Sets.dfy(29,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestSetToOrderedSequencePrefix()
    {
      Dafny.ISet<Dafny.ISequence<byte>> _18907_a;
      _18907_a = Dafny.Set<Dafny.ISequence<byte>>.FromElements(Dafny.Sequence<byte>.FromElements(0, 1, 2), Dafny.Sequence<byte>.FromElements(0, 1));
      Dafny.ISequence<Dafny.ISequence<byte>> _18908_output;
      Dafny.ISequence<Dafny.ISequence<byte>> _out270;
      _out270 = Sets.__default.SetToOrderedSequence<byte>(_18907_a, StandardLibrary_mUInt_Compile.__default.UInt8Less);
      _18908_output = _out270;
      Dafny.ISequence<Dafny.ISequence<byte>> _18909_expected;
      _18909_expected = Dafny.Sequence<Dafny.ISequence<byte>>.FromElements(Dafny.Sequence<byte>.FromElements(0, 1), Dafny.Sequence<byte>.FromElements(0, 1, 2));
      if (!((_18908_output).Equals((_18909_expected)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/Sets.dfy(36,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestSetToOrderedSequenceComplex()
    {
      Dafny.ISet<Dafny.ISequence<byte>> _18910_a;
      _18910_a = Dafny.Set<Dafny.ISequence<byte>>.FromElements(Dafny.Sequence<byte>.FromElements(0, 1, 2), Dafny.Sequence<byte>.FromElements(1, 1, 2), Dafny.Sequence<byte>.FromElements(0, 1));
      Dafny.ISequence<Dafny.ISequence<byte>> _18911_output;
      Dafny.ISequence<Dafny.ISequence<byte>> _out271;
      _out271 = Sets.__default.SetToOrderedSequence<byte>(_18910_a, StandardLibrary_mUInt_Compile.__default.UInt8Less);
      _18911_output = _out271;
      Dafny.ISequence<Dafny.ISequence<byte>> _18912_expected;
      _18912_expected = Dafny.Sequence<Dafny.ISequence<byte>>.FromElements(Dafny.Sequence<byte>.FromElements(0, 1), Dafny.Sequence<byte>.FromElements(0, 1, 2), Dafny.Sequence<byte>.FromElements(1, 1, 2));
      if (!((_18911_output).Equals((_18912_expected)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/Sets.dfy(43,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestSetToOrderedSequenceManyItems()
    {
      Dafny.ISet<Dafny.ISequence<byte>> _18913_a;
      _18913_a = ((System.Func<Dafny.ISet<Dafny.ISequence<byte>>>)(() => {
        var _coll2 = new System.Collections.Generic.List<Dafny.ISequence<byte>>();
        foreach (ushort _compr_2 in StandardLibrary_mUInt_Compile.uint16.IntegerRange(BigInteger.Zero, new BigInteger(65536))) {
          ushort _18914_x = (ushort)_compr_2;
          if (((0) <= (_18914_x)) && ((_18914_x) < (65535))) {
            _coll2.Add(StandardLibrary_mUInt_Compile.__default.UInt16ToSeq(_18914_x));
          }
        }
        return Dafny.Set<Dafny.ISequence<byte>>.FromCollection(_coll2);
      }))();
      Dafny.ISequence<Dafny.ISequence<byte>> _18915_output;
      Dafny.ISequence<Dafny.ISequence<byte>> _out272;
      _out272 = Sets.__default.SetToOrderedSequence<byte>(_18913_a, StandardLibrary_mUInt_Compile.__default.UInt8Less);
      _18915_output = _out272;
      Dafny.ISequence<Dafny.ISequence<byte>> _18916_expected;
      _18916_expected = ((System.Func<Dafny.ISequence<Dafny.ISequence<byte>>>) (() => {
        BigInteger dim40 = new BigInteger(65535);
        var arr40 = new Dafny.ISequence<byte>[Dafny.Helpers.ToIntChecked(dim40,"C# array size must not be larger than max 32-bit int")];
        for (int i40 = 0; i40 < dim40; i40++) {
          var _18917_i = (BigInteger) i40;
          arr40[(int)(_18917_i)] = StandardLibrary_mUInt_Compile.__default.UInt16ToSeq((ushort)(_18917_i));
        }
        return Dafny.Sequence<Dafny.ISequence<byte>>.FromArray(arr40);
      }))();
      if (!((_18915_output).Equals((_18916_expected)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/Sets.dfy(50,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
  }
} // end of namespace TestSeqReaderReadElements_Compile
namespace TestStreams_Compile {



  public partial class __default {
    [Xunit.Fact]
    public static void TestSeqReaderReadElements()
    {
      Dafny.ISequence<BigInteger> _18918_s;
      _18918_s = Dafny.Sequence<BigInteger>.FromElements(BigInteger.Zero, new BigInteger(100), new BigInteger(200), new BigInteger(300), new BigInteger(400));
      Streams_Compile.SeqReader<BigInteger> _18919_reader;
      Streams_Compile.SeqReader<BigInteger> _nw57 = new Streams_Compile.SeqReader<BigInteger>();
      _nw57.__ctor(_18918_s);
      _18919_reader = _nw57;
      Dafny.ISequence<BigInteger> _18920_res;
      Dafny.ISequence<BigInteger> _out273;
      _out273 = (_18919_reader).ReadElements(new BigInteger(3));
      _18920_res = _out273;
      if (!((Dafny.Sequence<BigInteger>.FromElements(BigInteger.Zero, new BigInteger(100), new BigInteger(200))).Equals((_18920_res)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/Streams.dfy(16,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      Dafny.ISequence<BigInteger> _out274;
      _out274 = (_18919_reader).ReadElements(BigInteger.Zero);
      _18920_res = _out274;
      if (!((Dafny.Sequence<BigInteger>.FromElements()).Equals((_18920_res)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/Streams.dfy(19,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      Dafny.ISequence<BigInteger> _out275;
      _out275 = (_18919_reader).ReadElements(new BigInteger(2));
      _18920_res = _out275;
      if (!((Dafny.Sequence<BigInteger>.FromElements(new BigInteger(300), new BigInteger(400))).Equals((_18920_res)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/Streams.dfy(22,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestSeqReaderReadExact()
    {
      Dafny.ISequence<BigInteger> _18921_s;
      _18921_s = Dafny.Sequence<BigInteger>.FromElements(BigInteger.Zero, new BigInteger(100), new BigInteger(200), new BigInteger(300), new BigInteger(400));
      Streams_Compile.SeqReader<BigInteger> _18922_reader;
      Streams_Compile.SeqReader<BigInteger> _nw58 = new Streams_Compile.SeqReader<BigInteger>();
      _nw58.__ctor(_18921_s);
      _18922_reader = _nw58;
      Dafny.ISequence<BigInteger> _18923_res = Dafny.Sequence<BigInteger>.Empty;
      Wrappers_Compile.Result<Dafny.ISequence<BigInteger>, Dafny.ISequence<char>> _18924_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<BigInteger>, Dafny.ISequence<char>>.Default(Dafny.Sequence<BigInteger>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<BigInteger>, Dafny.ISequence<char>> _out276;
      _out276 = (_18922_reader).ReadExact(new BigInteger(3));
      _18924_valueOrError0 = _out276;
      if (!(!((_18924_valueOrError0).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/Streams.dfy(29,12): " + _18924_valueOrError0);
      }
      _18923_res = (_18924_valueOrError0).Extract();
      if (!((Dafny.Sequence<BigInteger>.FromElements(BigInteger.Zero, new BigInteger(100), new BigInteger(200))).Equals((_18923_res)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/Streams.dfy(30,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      Wrappers_Compile.Result<Dafny.ISequence<BigInteger>, Dafny.ISequence<char>> _18925_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<BigInteger>, Dafny.ISequence<char>>.Default(Dafny.Sequence<BigInteger>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<BigInteger>, Dafny.ISequence<char>> _out277;
      _out277 = (_18922_reader).ReadExact(BigInteger.Zero);
      _18925_valueOrError1 = _out277;
      if (!(!((_18925_valueOrError1).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/Streams.dfy(32,8): " + _18925_valueOrError1);
      }
      _18923_res = (_18925_valueOrError1).Extract();
      if (!((Dafny.Sequence<BigInteger>.FromElements()).Equals((_18923_res)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/Streams.dfy(33,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      Wrappers_Compile.Result<Dafny.ISequence<BigInteger>, Dafny.ISequence<char>> _18926_valueOrError2 = Wrappers_Compile.Result<Dafny.ISequence<BigInteger>, Dafny.ISequence<char>>.Default(Dafny.Sequence<BigInteger>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<BigInteger>, Dafny.ISequence<char>> _out278;
      _out278 = (_18922_reader).ReadExact(new BigInteger(2));
      _18926_valueOrError2 = _out278;
      if (!(!((_18926_valueOrError2).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/Streams.dfy(35,8): " + _18926_valueOrError2);
      }
      _18923_res = (_18926_valueOrError2).Extract();
      if (!((Dafny.Sequence<BigInteger>.FromElements(new BigInteger(300), new BigInteger(400))).Equals((_18923_res)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/Streams.dfy(36,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      Wrappers_Compile.Result<Dafny.ISequence<BigInteger>, Dafny.ISequence<char>> _18927_isFailure;
      Wrappers_Compile.Result<Dafny.ISequence<BigInteger>, Dafny.ISequence<char>> _out279;
      _out279 = (_18922_reader).ReadExact(BigInteger.One);
      _18927_isFailure = _out279;
      if (!((_18927_isFailure).is_Failure)) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/Streams.dfy(39,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestByteReader()
    {
      Dafny.ISequence<byte> _18928_s;
      _18928_s = Dafny.Sequence<byte>.FromElements(0, 3, 10, 20, 50, 100, 150, 200, 250, 255);
      Streams_Compile.ByteReader _18929_reader;
      Streams_Compile.ByteReader _nw59 = new Streams_Compile.ByteReader();
      _nw59.__ctor(_18928_s);
      _18929_reader = _nw59;
      byte _18930_uint8Res = 0;
      Wrappers_Compile.Result<byte, Dafny.ISequence<char>> _18931_valueOrError0 = Wrappers_Compile.Result<byte, Dafny.ISequence<char>>.Default(0);
      Wrappers_Compile.Result<byte, Dafny.ISequence<char>> _out280;
      _out280 = (_18929_reader).ReadByte();
      _18931_valueOrError0 = _out280;
      if (!(!((_18931_valueOrError0).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/Streams.dfy(46,17): " + _18931_valueOrError0);
      }
      _18930_uint8Res = (_18931_valueOrError0).Extract();
      BigInteger _18932_sizeRead;
      BigInteger _out281;
      _out281 = (_18929_reader).GetSizeRead();
      _18932_sizeRead = _out281;
      bool _18933_isDoneReading;
      bool _out282;
      _out282 = (_18929_reader).IsDoneReading();
      _18933_isDoneReading = _out282;
      if (!((0) == (_18930_uint8Res))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/Streams.dfy(49,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!((BigInteger.One) == (_18932_sizeRead))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/Streams.dfy(50,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!(!(_18933_isDoneReading))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/Streams.dfy(51,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      Dafny.ISequence<byte> _18934_sRes = Dafny.Sequence<byte>.Empty;
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18935_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out283;
      _out283 = (_18929_reader).ReadBytes(BigInteger.Zero);
      _18935_valueOrError1 = _out283;
      if (!(!((_18935_valueOrError1).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/Streams.dfy(53,13): " + _18935_valueOrError1);
      }
      _18934_sRes = (_18935_valueOrError1).Extract();
      BigInteger _out284;
      _out284 = (_18929_reader).GetSizeRead();
      _18932_sizeRead = _out284;
      bool _out285;
      _out285 = (_18929_reader).IsDoneReading();
      _18933_isDoneReading = _out285;
      if (!((Dafny.Sequence<byte>.FromElements()).Equals((_18934_sRes)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/Streams.dfy(56,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!((BigInteger.One) == (_18932_sizeRead))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/Streams.dfy(57,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!(!(_18933_isDoneReading))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/Streams.dfy(58,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18936_valueOrError2 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out286;
      _out286 = (_18929_reader).ReadBytes(new BigInteger(3));
      _18936_valueOrError2 = _out286;
      if (!(!((_18936_valueOrError2).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/Streams.dfy(60,9): " + _18936_valueOrError2);
      }
      _18934_sRes = (_18936_valueOrError2).Extract();
      BigInteger _out287;
      _out287 = (_18929_reader).GetSizeRead();
      _18932_sizeRead = _out287;
      bool _out288;
      _out288 = (_18929_reader).IsDoneReading();
      _18933_isDoneReading = _out288;
      if (!((Dafny.Sequence<byte>.FromElements(3, 10, 20)).Equals((_18934_sRes)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/Streams.dfy(63,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!((new BigInteger(4)) == (_18932_sizeRead))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/Streams.dfy(64,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!(!(_18933_isDoneReading))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/Streams.dfy(65,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      ushort _18937_uint16 = 0;
      Wrappers_Compile.Result<ushort, Dafny.ISequence<char>> _18938_valueOrError3 = Wrappers_Compile.Result<ushort, Dafny.ISequence<char>>.Default(0);
      Wrappers_Compile.Result<ushort, Dafny.ISequence<char>> _out289;
      _out289 = (_18929_reader).ReadUInt16();
      _18938_valueOrError3 = _out289;
      if (!(!((_18938_valueOrError3).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/Streams.dfy(67,15): " + _18938_valueOrError3);
      }
      _18937_uint16 = (_18938_valueOrError3).Extract();
      ushort _18939_expectedUint16;
      _18939_expectedUint16 = StandardLibrary_mUInt_Compile.__default.SeqToUInt16(Dafny.Sequence<byte>.FromElements(50, 100));
      BigInteger _out290;
      _out290 = (_18929_reader).GetSizeRead();
      _18932_sizeRead = _out290;
      bool _out291;
      _out291 = (_18929_reader).IsDoneReading();
      _18933_isDoneReading = _out291;
      if (!((_18939_expectedUint16) == (_18937_uint16))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/Streams.dfy(71,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!((new BigInteger(6)) == (_18932_sizeRead))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/Streams.dfy(72,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!(!(_18933_isDoneReading))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/Streams.dfy(73,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      uint _18940_uint32 = 0;
      Wrappers_Compile.Result<uint, Dafny.ISequence<char>> _18941_valueOrError4 = Wrappers_Compile.Result<uint, Dafny.ISequence<char>>.Default(0);
      Wrappers_Compile.Result<uint, Dafny.ISequence<char>> _out292;
      _out292 = (_18929_reader).ReadUInt32();
      _18941_valueOrError4 = _out292;
      if (!(!((_18941_valueOrError4).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/Streams.dfy(75,15): " + _18941_valueOrError4);
      }
      _18940_uint32 = (_18941_valueOrError4).Extract();
      uint _18942_expectedUint32;
      _18942_expectedUint32 = StandardLibrary_mUInt_Compile.__default.SeqToUInt32(Dafny.Sequence<byte>.FromElements(150, 200, 250, 255));
      BigInteger _out293;
      _out293 = (_18929_reader).GetSizeRead();
      _18932_sizeRead = _out293;
      bool _out294;
      _out294 = (_18929_reader).IsDoneReading();
      _18933_isDoneReading = _out294;
      if (!((_18942_expectedUint32) == (_18940_uint32))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/Streams.dfy(79,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!((new BigInteger(10)) == (_18932_sizeRead))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/Streams.dfy(80,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!(_18933_isDoneReading)) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/Streams.dfy(81,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      Wrappers_Compile.Result<byte, Dafny.ISequence<char>> _18943_isByteFailure;
      Wrappers_Compile.Result<byte, Dafny.ISequence<char>> _out295;
      _out295 = (_18929_reader).ReadByte();
      _18943_isByteFailure = _out295;
      BigInteger _out296;
      _out296 = (_18929_reader).GetSizeRead();
      _18932_sizeRead = _out296;
      bool _out297;
      _out297 = (_18929_reader).IsDoneReading();
      _18933_isDoneReading = _out297;
      if (!((_18943_isByteFailure).is_Failure)) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/Streams.dfy(86,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!((new BigInteger(10)) == (_18932_sizeRead))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/Streams.dfy(87,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!(_18933_isDoneReading)) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/Streams.dfy(88,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18944_isBytesFailure;
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out298;
      _out298 = (_18929_reader).ReadBytes(BigInteger.One);
      _18944_isBytesFailure = _out298;
      BigInteger _out299;
      _out299 = (_18929_reader).GetSizeRead();
      _18932_sizeRead = _out299;
      bool _out300;
      _out300 = (_18929_reader).IsDoneReading();
      _18933_isDoneReading = _out300;
      if (!((_18944_isBytesFailure).is_Failure)) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/Streams.dfy(93,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!((new BigInteger(10)) == (_18932_sizeRead))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/Streams.dfy(94,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!(_18933_isDoneReading)) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/Streams.dfy(95,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      Wrappers_Compile.Result<ushort, Dafny.ISequence<char>> _18945_isUint16Failure;
      Wrappers_Compile.Result<ushort, Dafny.ISequence<char>> _out301;
      _out301 = (_18929_reader).ReadUInt16();
      _18945_isUint16Failure = _out301;
      BigInteger _out302;
      _out302 = (_18929_reader).GetSizeRead();
      _18932_sizeRead = _out302;
      bool _out303;
      _out303 = (_18929_reader).IsDoneReading();
      _18933_isDoneReading = _out303;
      if (!((_18945_isUint16Failure).is_Failure)) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/Streams.dfy(100,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!((new BigInteger(10)) == (_18932_sizeRead))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/Streams.dfy(101,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!(_18933_isDoneReading)) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/Streams.dfy(102,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      Wrappers_Compile.Result<uint, Dafny.ISequence<char>> _18946_isUint32Failure;
      Wrappers_Compile.Result<uint, Dafny.ISequence<char>> _out304;
      _out304 = (_18929_reader).ReadUInt32();
      _18946_isUint32Failure = _out304;
      BigInteger _out305;
      _out305 = (_18929_reader).GetSizeRead();
      _18932_sizeRead = _out305;
      bool _out306;
      _out306 = (_18929_reader).IsDoneReading();
      _18933_isDoneReading = _out306;
      if (!((_18946_isUint32Failure).is_Failure)) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/Streams.dfy(107,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!((new BigInteger(10)) == (_18932_sizeRead))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/Streams.dfy(108,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!(_18933_isDoneReading)) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/Streams.dfy(109,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestSeqWriter()
    {
      Streams_Compile.SeqWriter<BigInteger> _18947_writer;
      Streams_Compile.SeqWriter<BigInteger> _nw60 = new Streams_Compile.SeqWriter<BigInteger>();
      _nw60.__ctor();
      _18947_writer = _nw60;
      if (!((Dafny.Sequence<BigInteger>.FromElements()).Equals((_18947_writer.data)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/Streams.dfy(114,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      BigInteger _18948_elemSize;
      BigInteger _out307;
      _out307 = (_18947_writer).WriteElements(Dafny.Sequence<BigInteger>.FromElements());
      _18948_elemSize = _out307;
      if (!((_18948_elemSize).Sign == 0)) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/Streams.dfy(117,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!((Dafny.Sequence<BigInteger>.FromElements()).Equals((_18947_writer.data)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/Streams.dfy(118,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      BigInteger _out308;
      _out308 = (_18947_writer).WriteElements(Dafny.Sequence<BigInteger>.FromElements(BigInteger.Zero, new BigInteger(100), new BigInteger(200)));
      _18948_elemSize = _out308;
      if (!((new BigInteger(3)) == (_18948_elemSize))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/Streams.dfy(121,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!((Dafny.Sequence<BigInteger>.FromElements(BigInteger.Zero, new BigInteger(100), new BigInteger(200))).Equals((_18947_writer.data)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/Streams.dfy(122,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      BigInteger _out309;
      _out309 = (_18947_writer).WriteElements(Dafny.Sequence<BigInteger>.FromElements(new BigInteger(300), new BigInteger(400), new BigInteger(500), new BigInteger(600)));
      _18948_elemSize = _out309;
      if (!((new BigInteger(4)) == (_18948_elemSize))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/Streams.dfy(125,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!((Dafny.Sequence<BigInteger>.FromElements(BigInteger.Zero, new BigInteger(100), new BigInteger(200), new BigInteger(300), new BigInteger(400), new BigInteger(500), new BigInteger(600))).Equals((_18947_writer.data)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/Streams.dfy(126,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestByteWriter()
    {
      Streams_Compile.ByteWriter _18949_writer;
      Streams_Compile.ByteWriter _nw61 = new Streams_Compile.ByteWriter();
      _nw61.__ctor();
      _18949_writer = _nw61;
      Dafny.ISequence<byte> _18950_dataWritten;
      _18950_dataWritten = (_18949_writer).GetDataWritten();
      if (!((Dafny.Sequence<byte>.FromElements()).Equals((_18950_dataWritten)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/Streams.dfy(132,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      BigInteger _18951_sizeWritten;
      _18951_sizeWritten = (_18949_writer).GetSizeWritten();
      if (!((_18951_sizeWritten).Sign == 0)) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/Streams.dfy(134,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      BigInteger _18952_res;
      BigInteger _out310;
      _out310 = (_18949_writer).WriteByte(0);
      _18952_res = _out310;
      if (!((BigInteger.One) == (_18952_res))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/Streams.dfy(137,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      _18950_dataWritten = (_18949_writer).GetDataWritten();
      if (!((Dafny.Sequence<byte>.FromElements(0)).Equals((_18950_dataWritten)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/Streams.dfy(139,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      _18951_sizeWritten = (_18949_writer).GetSizeWritten();
      if (!((BigInteger.One) == (_18951_sizeWritten))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/Streams.dfy(141,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      BigInteger _out311;
      _out311 = (_18949_writer).WriteBytes(Dafny.Sequence<byte>.FromElements());
      _18952_res = _out311;
      if (!((_18952_res).Sign == 0)) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/Streams.dfy(144,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      _18950_dataWritten = (_18949_writer).GetDataWritten();
      if (!((Dafny.Sequence<byte>.FromElements(0)).Equals((_18950_dataWritten)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/Streams.dfy(146,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      _18951_sizeWritten = (_18949_writer).GetSizeWritten();
      if (!((BigInteger.One) == (_18951_sizeWritten))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/Streams.dfy(148,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      BigInteger _out312;
      _out312 = (_18949_writer).WriteBytes(Dafny.Sequence<byte>.FromElements(5, 50, 100));
      _18952_res = _out312;
      if (!((new BigInteger(3)) == (_18952_res))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/Streams.dfy(151,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      _18950_dataWritten = (_18949_writer).GetDataWritten();
      if (!((Dafny.Sequence<byte>.FromElements(0, 5, 50, 100)).Equals((_18950_dataWritten)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/Streams.dfy(153,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      _18951_sizeWritten = (_18949_writer).GetSizeWritten();
      if (!((new BigInteger(4)) == (_18951_sizeWritten))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/Streams.dfy(155,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      ushort _18953_uint16Written;
      _18953_uint16Written = StandardLibrary_mUInt_Compile.__default.SeqToUInt16(Dafny.Sequence<byte>.FromElements(150, 200));
      BigInteger _out313;
      _out313 = (_18949_writer).WriteUInt16(_18953_uint16Written);
      _18952_res = _out313;
      if (!((new BigInteger(2)) == (_18952_res))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/Streams.dfy(159,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      _18950_dataWritten = (_18949_writer).GetDataWritten();
      if (!((Dafny.Sequence<byte>.FromElements(0, 5, 50, 100, 150, 200)).Equals((_18950_dataWritten)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/Streams.dfy(161,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      _18951_sizeWritten = (_18949_writer).GetSizeWritten();
      if (!((new BigInteger(6)) == (_18951_sizeWritten))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/Streams.dfy(163,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      uint _18954_uint32Written;
      _18954_uint32Written = StandardLibrary_mUInt_Compile.__default.SeqToUInt32(Dafny.Sequence<byte>.FromElements(50, 150, 200, 255));
      BigInteger _out314;
      _out314 = (_18949_writer).WriteUInt32(_18954_uint32Written);
      _18952_res = _out314;
      if (!((new BigInteger(4)) == (_18952_res))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/Streams.dfy(167,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      _18950_dataWritten = (_18949_writer).GetDataWritten();
      if (!((Dafny.Sequence<byte>.FromElements(0, 5, 50, 100, 150, 200, 50, 150, 200, 255)).Equals((_18950_dataWritten)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/Streams.dfy(169,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      _18951_sizeWritten = (_18949_writer).GetSizeWritten();
      if (!((new BigInteger(10)) == (_18951_sizeWritten))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/Streams.dfy(171,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
  }
} // end of namespace TestStreams_Compile
namespace TestUTF8_Compile {



  public partial class __default {
    [Xunit.Fact]
    public static void TestEncodeHappyCase()
    {
      Dafny.ISequence<char> _18955_unicodeString;
      _18955_unicodeString = Dafny.Sequence<char>.FromString("abc\u0306\u01FD\u03B2");
      Dafny.ISequence<byte> _18956_expectedBytes;
      _18956_expectedBytes = Dafny.Sequence<byte>.FromElements(97, 98, 99, 204, 134, 199, 189, 206, 178);
      Dafny.ISequence<byte> _18957_encoded = UTF8.ValidUTF8Bytes.Default();
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18958_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out315;
      _out315 = UTF8.__default.Encode(_18955_unicodeString);
      _18958_valueOrError0 = _out315;
      if (!(!((_18958_valueOrError0).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(14,16): " + _18958_valueOrError0);
      }
      _18957_encoded = (_18958_valueOrError0).Extract();
      if (!((_18956_expectedBytes).Equals((_18957_encoded)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(15,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestEncodeInvalidUnicode()
    {
      Dafny.ISequence<char> _18959_invalidUnicode;
      _18959_invalidUnicode = Dafny.Sequence<char>.FromString("abc\uD800");
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18960_encoded;
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out316;
      _out316 = UTF8.__default.Encode(_18959_invalidUnicode);
      _18960_encoded = _out316;
      if (!((_18960_encoded).is_Failure)) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(22,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestDecodeHappyCase()
    {
      Dafny.ISequence<byte> _18961_unicodeBytes;
      _18961_unicodeBytes = Dafny.Sequence<byte>.FromElements(97, 98, 99, 204, 134, 199, 189, 206, 178);
      Dafny.ISequence<char> _18962_expectedString;
      _18962_expectedString = Dafny.Sequence<char>.FromString("abc\u0306\u01FD\u03B2");
      Dafny.ISequence<char> _18963_decoded = Dafny.Sequence<char>.Empty;
      Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>> _18964_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.Default(Dafny.Sequence<char>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>> _out317;
      _out317 = UTF8.__default.Decode(_18961_unicodeBytes);
      _18964_valueOrError0 = _out317;
      if (!(!((_18964_valueOrError0).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(30,16): " + _18964_valueOrError0);
      }
      _18963_decoded = (_18964_valueOrError0).Extract();
      if (!((_18962_expectedString).Equals((_18963_decoded)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(31,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestDecodeInvalidUnicode()
    {
      Dafny.ISequence<byte> _18965_invalidUnicode;
      _18965_invalidUnicode = Dafny.Sequence<byte>.FromElements(97, 98, 99, 237, 160, 128);
      if (!(!(UTF8.__default.ValidUTF8Seq(_18965_invalidUnicode)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(37,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void Test1Byte()
    {
      Dafny.ISequence<char> _18966_decoded;
      _18966_decoded = Dafny.Sequence<char>.FromString("\u0000");
      Dafny.ISequence<byte> _18967_encoded = UTF8.ValidUTF8Bytes.Default();
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18968_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out318;
      _out318 = UTF8.__default.Encode(_18966_decoded);
      _18968_valueOrError0 = _out318;
      if (!(!((_18968_valueOrError0).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(43,16): " + _18968_valueOrError0);
      }
      _18967_encoded = (_18968_valueOrError0).Extract();
      if (!((Dafny.Sequence<byte>.FromElements(0)).Equals((_18967_encoded)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(44,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!(UTF8.__default.Uses1Byte(_18967_encoded))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(45,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      Dafny.ISequence<char> _18969_redecoded = Dafny.Sequence<char>.Empty;
      Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>> _18970_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.Default(Dafny.Sequence<char>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>> _out319;
      _out319 = UTF8.__default.Decode(_18967_encoded);
      _18970_valueOrError1 = _out319;
      if (!(!((_18970_valueOrError1).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(46,18): " + _18970_valueOrError1);
      }
      _18969_redecoded = (_18970_valueOrError1).Extract();
      if (!((_18966_decoded).Equals((_18969_redecoded)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(47,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      _18966_decoded = Dafny.Sequence<char>.FromString("\u0020");
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18971_valueOrError2 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out320;
      _out320 = UTF8.__default.Encode(_18966_decoded);
      _18971_valueOrError2 = _out320;
      if (!(!((_18971_valueOrError2).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(51,12): " + _18971_valueOrError2);
      }
      _18967_encoded = (_18971_valueOrError2).Extract();
      if (!((Dafny.Sequence<byte>.FromElements(32)).Equals((_18967_encoded)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(52,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!(UTF8.__default.Uses1Byte(_18967_encoded))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(53,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>> _18972_valueOrError3 = Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.Default(Dafny.Sequence<char>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>> _out321;
      _out321 = UTF8.__default.Decode(_18967_encoded);
      _18972_valueOrError3 = _out321;
      if (!(!((_18972_valueOrError3).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(54,14): " + _18972_valueOrError3);
      }
      _18969_redecoded = (_18972_valueOrError3).Extract();
      if (!((_18966_decoded).Equals((_18969_redecoded)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(55,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      _18966_decoded = Dafny.Sequence<char>.FromString("$");
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18973_valueOrError4 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out322;
      _out322 = UTF8.__default.Encode(_18966_decoded);
      _18973_valueOrError4 = _out322;
      if (!(!((_18973_valueOrError4).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(58,12): " + _18973_valueOrError4);
      }
      _18967_encoded = (_18973_valueOrError4).Extract();
      if (!((Dafny.Sequence<byte>.FromElements(36)).Equals((_18967_encoded)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(59,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!(UTF8.__default.Uses1Byte(_18967_encoded))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(60,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>> _18974_valueOrError5 = Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.Default(Dafny.Sequence<char>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>> _out323;
      _out323 = UTF8.__default.Decode(_18967_encoded);
      _18974_valueOrError5 = _out323;
      if (!(!((_18974_valueOrError5).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(61,14): " + _18974_valueOrError5);
      }
      _18969_redecoded = (_18974_valueOrError5).Extract();
      if (!((_18966_decoded).Equals((_18969_redecoded)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(62,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      _18966_decoded = Dafny.Sequence<char>.FromString("0");
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18975_valueOrError6 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out324;
      _out324 = UTF8.__default.Encode(_18966_decoded);
      _18975_valueOrError6 = _out324;
      if (!(!((_18975_valueOrError6).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(65,12): " + _18975_valueOrError6);
      }
      _18967_encoded = (_18975_valueOrError6).Extract();
      if (!((Dafny.Sequence<byte>.FromElements(48)).Equals((_18967_encoded)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(66,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!(UTF8.__default.Uses1Byte(_18967_encoded))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(67,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>> _18976_valueOrError7 = Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.Default(Dafny.Sequence<char>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>> _out325;
      _out325 = UTF8.__default.Decode(_18967_encoded);
      _18976_valueOrError7 = _out325;
      if (!(!((_18976_valueOrError7).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(68,14): " + _18976_valueOrError7);
      }
      _18969_redecoded = (_18976_valueOrError7).Extract();
      if (!((_18966_decoded).Equals((_18969_redecoded)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(69,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      _18966_decoded = Dafny.Sequence<char>.FromString("A");
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18977_valueOrError8 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out326;
      _out326 = UTF8.__default.Encode(_18966_decoded);
      _18977_valueOrError8 = _out326;
      if (!(!((_18977_valueOrError8).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(72,12): " + _18977_valueOrError8);
      }
      _18967_encoded = (_18977_valueOrError8).Extract();
      if (!((Dafny.Sequence<byte>.FromElements(65)).Equals((_18967_encoded)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(73,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!(UTF8.__default.Uses1Byte(_18967_encoded))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(74,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>> _18978_valueOrError9 = Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.Default(Dafny.Sequence<char>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>> _out327;
      _out327 = UTF8.__default.Decode(_18967_encoded);
      _18978_valueOrError9 = _out327;
      if (!(!((_18978_valueOrError9).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(75,14): " + _18978_valueOrError9);
      }
      _18969_redecoded = (_18978_valueOrError9).Extract();
      if (!((_18966_decoded).Equals((_18969_redecoded)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(76,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      _18966_decoded = Dafny.Sequence<char>.FromString("a");
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18979_valueOrError10 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out328;
      _out328 = UTF8.__default.Encode(_18966_decoded);
      _18979_valueOrError10 = _out328;
      if (!(!((_18979_valueOrError10).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(79,12): " + _18979_valueOrError10);
      }
      _18967_encoded = (_18979_valueOrError10).Extract();
      if (!((Dafny.Sequence<byte>.FromElements(97)).Equals((_18967_encoded)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(80,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!(UTF8.__default.Uses1Byte(_18967_encoded))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(81,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>> _18980_valueOrError11 = Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.Default(Dafny.Sequence<char>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>> _out329;
      _out329 = UTF8.__default.Decode(_18967_encoded);
      _18980_valueOrError11 = _out329;
      if (!(!((_18980_valueOrError11).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(82,14): " + _18980_valueOrError11);
      }
      _18969_redecoded = (_18980_valueOrError11).Extract();
      if (!((_18966_decoded).Equals((_18969_redecoded)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(83,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void Test2Bytes()
    {
      Dafny.ISequence<char> _18981_decoded;
      _18981_decoded = Dafny.Sequence<char>.FromString("\u00A3");
      Dafny.ISequence<byte> _18982_encoded = UTF8.ValidUTF8Bytes.Default();
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18983_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out330;
      _out330 = UTF8.__default.Encode(_18981_decoded);
      _18983_valueOrError0 = _out330;
      if (!(!((_18983_valueOrError0).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(89,16): " + _18983_valueOrError0);
      }
      _18982_encoded = (_18983_valueOrError0).Extract();
      if (!((Dafny.Sequence<byte>.FromElements(194, 163)).Equals((_18982_encoded)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(90,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!(UTF8.__default.Uses2Bytes(_18982_encoded))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(91,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      Dafny.ISequence<char> _18984_redecoded = Dafny.Sequence<char>.Empty;
      Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>> _18985_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.Default(Dafny.Sequence<char>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>> _out331;
      _out331 = UTF8.__default.Decode(_18982_encoded);
      _18985_valueOrError1 = _out331;
      if (!(!((_18985_valueOrError1).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(92,18): " + _18985_valueOrError1);
      }
      _18984_redecoded = (_18985_valueOrError1).Extract();
      if (!((_18981_decoded).Equals((_18984_redecoded)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(93,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      _18981_decoded = Dafny.Sequence<char>.FromString("\u00A9");
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18986_valueOrError2 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out332;
      _out332 = UTF8.__default.Encode(_18981_decoded);
      _18986_valueOrError2 = _out332;
      if (!(!((_18986_valueOrError2).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(97,12): " + _18986_valueOrError2);
      }
      _18982_encoded = (_18986_valueOrError2).Extract();
      if (!((Dafny.Sequence<byte>.FromElements(194, 169)).Equals((_18982_encoded)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(98,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!(UTF8.__default.Uses2Bytes(_18982_encoded))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(99,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>> _18987_valueOrError3 = Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.Default(Dafny.Sequence<char>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>> _out333;
      _out333 = UTF8.__default.Decode(_18982_encoded);
      _18987_valueOrError3 = _out333;
      if (!(!((_18987_valueOrError3).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(100,14): " + _18987_valueOrError3);
      }
      _18984_redecoded = (_18987_valueOrError3).Extract();
      if (!((_18981_decoded).Equals((_18984_redecoded)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(101,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      _18981_decoded = Dafny.Sequence<char>.FromString("\u00AE");
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18988_valueOrError4 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out334;
      _out334 = UTF8.__default.Encode(_18981_decoded);
      _18988_valueOrError4 = _out334;
      if (!(!((_18988_valueOrError4).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(105,12): " + _18988_valueOrError4);
      }
      _18982_encoded = (_18988_valueOrError4).Extract();
      if (!((Dafny.Sequence<byte>.FromElements(194, 174)).Equals((_18982_encoded)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(106,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!(UTF8.__default.Uses2Bytes(_18982_encoded))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(107,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>> _18989_valueOrError5 = Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.Default(Dafny.Sequence<char>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>> _out335;
      _out335 = UTF8.__default.Decode(_18982_encoded);
      _18989_valueOrError5 = _out335;
      if (!(!((_18989_valueOrError5).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(108,14): " + _18989_valueOrError5);
      }
      _18984_redecoded = (_18989_valueOrError5).Extract();
      if (!((_18981_decoded).Equals((_18984_redecoded)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(109,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      _18981_decoded = Dafny.Sequence<char>.FromString("\u03C0");
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18990_valueOrError6 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out336;
      _out336 = UTF8.__default.Encode(_18981_decoded);
      _18990_valueOrError6 = _out336;
      if (!(!((_18990_valueOrError6).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(113,12): " + _18990_valueOrError6);
      }
      _18982_encoded = (_18990_valueOrError6).Extract();
      if (!((Dafny.Sequence<byte>.FromElements(207, 128)).Equals((_18982_encoded)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(114,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!(UTF8.__default.Uses2Bytes(_18982_encoded))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(115,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>> _18991_valueOrError7 = Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.Default(Dafny.Sequence<char>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>> _out337;
      _out337 = UTF8.__default.Decode(_18982_encoded);
      _18991_valueOrError7 = _out337;
      if (!(!((_18991_valueOrError7).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(116,14): " + _18991_valueOrError7);
      }
      _18984_redecoded = (_18991_valueOrError7).Extract();
      if (!((_18981_decoded).Equals((_18984_redecoded)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(117,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void Test3Bytes()
    {
      Dafny.ISequence<char> _18992_decoded;
      _18992_decoded = Dafny.Sequence<char>.FromString("\u2386");
      Dafny.ISequence<byte> _18993_encoded = UTF8.ValidUTF8Bytes.Default();
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18994_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out338;
      _out338 = UTF8.__default.Encode(_18992_decoded);
      _18994_valueOrError0 = _out338;
      if (!(!((_18994_valueOrError0).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(123,16): " + _18994_valueOrError0);
      }
      _18993_encoded = (_18994_valueOrError0).Extract();
      if (!((Dafny.Sequence<byte>.FromElements(226, 142, 134)).Equals((_18993_encoded)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(124,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!(UTF8.__default.Uses3Bytes(_18993_encoded))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(125,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      Dafny.ISequence<char> _18995_redecoded = Dafny.Sequence<char>.Empty;
      Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>> _18996_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.Default(Dafny.Sequence<char>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>> _out339;
      _out339 = UTF8.__default.Decode(_18993_encoded);
      _18996_valueOrError1 = _out339;
      if (!(!((_18996_valueOrError1).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(126,18): " + _18996_valueOrError1);
      }
      _18995_redecoded = (_18996_valueOrError1).Extract();
      if (!((_18992_decoded).Equals((_18995_redecoded)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(127,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      _18992_decoded = Dafny.Sequence<char>.FromString("\u2387");
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18997_valueOrError2 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out340;
      _out340 = UTF8.__default.Encode(_18992_decoded);
      _18997_valueOrError2 = _out340;
      if (!(!((_18997_valueOrError2).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(131,12): " + _18997_valueOrError2);
      }
      _18993_encoded = (_18997_valueOrError2).Extract();
      if (!((Dafny.Sequence<byte>.FromElements(226, 142, 135)).Equals((_18993_encoded)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(132,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!(UTF8.__default.Uses3Bytes(_18993_encoded))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(133,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>> _18998_valueOrError3 = Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.Default(Dafny.Sequence<char>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>> _out341;
      _out341 = UTF8.__default.Decode(_18993_encoded);
      _18998_valueOrError3 = _out341;
      if (!(!((_18998_valueOrError3).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(134,14): " + _18998_valueOrError3);
      }
      _18995_redecoded = (_18998_valueOrError3).Extract();
      if (!((_18992_decoded).Equals((_18995_redecoded)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(135,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      _18992_decoded = Dafny.Sequence<char>.FromString("\u231B");
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _18999_valueOrError4 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out342;
      _out342 = UTF8.__default.Encode(_18992_decoded);
      _18999_valueOrError4 = _out342;
      if (!(!((_18999_valueOrError4).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(139,12): " + _18999_valueOrError4);
      }
      _18993_encoded = (_18999_valueOrError4).Extract();
      if (!((Dafny.Sequence<byte>.FromElements(226, 140, 155)).Equals((_18993_encoded)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(140,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!(UTF8.__default.Uses3Bytes(_18993_encoded))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(141,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>> _19000_valueOrError5 = Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.Default(Dafny.Sequence<char>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>> _out343;
      _out343 = UTF8.__default.Decode(_18993_encoded);
      _19000_valueOrError5 = _out343;
      if (!(!((_19000_valueOrError5).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(142,14): " + _19000_valueOrError5);
      }
      _18995_redecoded = (_19000_valueOrError5).Extract();
      if (!((_18992_decoded).Equals((_18995_redecoded)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(143,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      _18992_decoded = Dafny.Sequence<char>.FromString("\u1D78");
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _19001_valueOrError6 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out344;
      _out344 = UTF8.__default.Encode(_18992_decoded);
      _19001_valueOrError6 = _out344;
      if (!(!((_19001_valueOrError6).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(147,12): " + _19001_valueOrError6);
      }
      _18993_encoded = (_19001_valueOrError6).Extract();
      if (!((Dafny.Sequence<byte>.FromElements(225, 181, 184)).Equals((_18993_encoded)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(148,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!(UTF8.__default.Uses3Bytes(_18993_encoded))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(149,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>> _19002_valueOrError7 = Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.Default(Dafny.Sequence<char>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>> _out345;
      _out345 = UTF8.__default.Decode(_18993_encoded);
      _19002_valueOrError7 = _out345;
      if (!(!((_19002_valueOrError7).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(150,14): " + _19002_valueOrError7);
      }
      _18995_redecoded = (_19002_valueOrError7).Extract();
      if (!((_18992_decoded).Equals((_18995_redecoded)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(151,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      _18992_decoded = Dafny.Sequence<char>.FromString("\u732B");
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _19003_valueOrError8 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out346;
      _out346 = UTF8.__default.Encode(_18992_decoded);
      _19003_valueOrError8 = _out346;
      if (!(!((_19003_valueOrError8).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(155,12): " + _19003_valueOrError8);
      }
      _18993_encoded = (_19003_valueOrError8).Extract();
      if (!((Dafny.Sequence<byte>.FromElements(231, 140, 171)).Equals((_18993_encoded)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(156,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!(UTF8.__default.Uses3Bytes(_18993_encoded))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(157,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>> _19004_valueOrError9 = Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.Default(Dafny.Sequence<char>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>> _out347;
      _out347 = UTF8.__default.Decode(_18993_encoded);
      _19004_valueOrError9 = _out347;
      if (!(!((_19004_valueOrError9).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(158,14): " + _19004_valueOrError9);
      }
      _18995_redecoded = (_19004_valueOrError9).Extract();
      if (!((_18992_decoded).Equals((_18995_redecoded)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(159,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void Test4Bytes()
    {
      Dafny.ISequence<char> _19005_decoded;
      _19005_decoded = Dafny.Sequence<char>.FromString("\uD808\uDC00");
      Dafny.ISequence<byte> _19006_encoded = UTF8.ValidUTF8Bytes.Default();
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _19007_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out348;
      _out348 = UTF8.__default.Encode(_19005_decoded);
      _19007_valueOrError0 = _out348;
      if (!(!((_19007_valueOrError0).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(165,16): " + _19007_valueOrError0);
      }
      _19006_encoded = (_19007_valueOrError0).Extract();
      if (!((Dafny.Sequence<byte>.FromElements(240, 146, 128, 128)).Equals((_19006_encoded)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(166,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!(UTF8.__default.Uses4Bytes(_19006_encoded))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(167,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      Dafny.ISequence<char> _19008_redecoded = Dafny.Sequence<char>.Empty;
      Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>> _19009_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.Default(Dafny.Sequence<char>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>> _out349;
      _out349 = UTF8.__default.Decode(_19006_encoded);
      _19009_valueOrError1 = _out349;
      if (!(!((_19009_valueOrError1).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(168,18): " + _19009_valueOrError1);
      }
      _19008_redecoded = (_19009_valueOrError1).Extract();
      if (!((_19005_decoded).Equals((_19008_redecoded)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(169,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      _19005_decoded = Dafny.Sequence<char>.FromString("\uD835\uDFC1");
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _19010_valueOrError2 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out350;
      _out350 = UTF8.__default.Encode(_19005_decoded);
      _19010_valueOrError2 = _out350;
      if (!(!((_19010_valueOrError2).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(173,12): " + _19010_valueOrError2);
      }
      _19006_encoded = (_19010_valueOrError2).Extract();
      if (!((Dafny.Sequence<byte>.FromElements(240, 157, 159, 129)).Equals((_19006_encoded)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(174,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!(UTF8.__default.Uses4Bytes(_19006_encoded))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(175,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>> _19011_valueOrError3 = Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.Default(Dafny.Sequence<char>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>> _out351;
      _out351 = UTF8.__default.Decode(_19006_encoded);
      _19011_valueOrError3 = _out351;
      if (!(!((_19011_valueOrError3).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(176,14): " + _19011_valueOrError3);
      }
      _19008_redecoded = (_19011_valueOrError3).Extract();
      if (!((_19005_decoded).Equals((_19008_redecoded)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-dafny/test/Util/UTF8.dfy(177,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
  }
} // end of namespace TestUTF8_Compile
namespace _module {




























































} // end of namespace _module
