// Dafny program the_program compiled into C#
// To recompile, you will need the libraries
//     System.Runtime.Numerics.dll System.Collections.Immutable.dll
// but the 'dotnet' tool in net5.0 should pick those up automatically.
// Optionally, you may want to include compiler switches like
//     /debug /nowarn:162,164,168,183,219,436,1717,1718

using System;
using System.Numerics;
[assembly: DafnyAssembly.DafnySourceAttribute(@"
// Dafny 3.2.0.30713
// Command Line Options: /out:obj/Debug/netcoreapp3.0/GeneratedFromDafny.cs ../Dafny/src/Crypto/AESEncryption.dfy ../Dafny/src/Crypto/Datatypes.dfy ../Dafny/src/Crypto/Digest.dfy ../Dafny/src/Crypto/EncryptionSuites.dfy ../Dafny/src/Crypto/HKDF/HKDF.dfy ../Dafny/src/Crypto/HKDF/HMAC.dfy ../Dafny/src/Crypto/KeyDerivationAlgorithms.dfy ../Dafny/src/Crypto/Random.dfy ../Dafny/src/Crypto/RSAEncryption.dfy ../Dafny/src/Crypto/Signature.dfy ../Dafny/src/KMS/AmazonKeyManagementService.dfy ../Dafny/src/KMS/AwsKmsArnParsing.dfy ../Dafny/src/KMS/KMSUtils.dfy ../Dafny/src/SDK/AlgorithmSuite.dfy ../Dafny/src/SDK/Client.dfy ../Dafny/src/SDK/CMM/CachingCMM.dfy ../Dafny/src/SDK/CMM/DefaultCMM.dfy ../Dafny/src/SDK/CMM/Defs.dfy ../Dafny/src/SDK/Deserialize.dfy ../Dafny/src/SDK/EncryptionContext.dfy ../Dafny/src/SDK/Keyring/AwsKms/AwsKmsMrkAreUnique.dfy ../Dafny/src/SDK/Keyring/AwsKms/AwsKmsMrkAwareSymmetricKeyring.dfy ../Dafny/src/SDK/Keyring/AwsKms/AwsKmsMrkMatchForDecrypt.dfy ../Dafny/src/SDK/Keyring/AwsKms/Constants.dfy ../Dafny/src/SDK/Keyring/Defs.dfy ../Dafny/src/SDK/Keyring/KMSKeyring.dfy ../Dafny/src/SDK/Keyring/MultiKeyring.dfy ../Dafny/src/SDK/Keyring/RawAESKeyring.dfy ../Dafny/src/SDK/Keyring/RawRSAKeyring.dfy ../Dafny/src/SDK/Materials.dfy ../Dafny/src/SDK/MessageBody.dfy ../Dafny/src/SDK/MessageHeader.dfy ../Dafny/src/SDK/Serialize.dfy ../Dafny/src/StandardLibrary/Actions.dfy ../Dafny/src/StandardLibrary/Base64.dfy ../Dafny/src/StandardLibrary/Base64Lemmas.dfy ../Dafny/src/StandardLibrary/StandardLibrary.dfy ../Dafny/src/StandardLibrary/UInt.dfy ../Dafny/src/Util/Sets.dfy ../Dafny/src/Util/Sorting.dfy ../Dafny/src/Util/Streams.dfy ../Dafny/src/Util/Time.dfy ../Dafny/src/Util/UTF8.dfy ../Dafny/test/Crypto/Digest.dfy ../Dafny/test/Crypto/Signature.dfy ../Dafny/test/hkdf/HKDF.dfy ../Dafny/test/Keyring/KMSKeyring.dfy ../Dafny/test/KMS/Integration.dfy ../Dafny/test/SDK/Client.dfy ../Dafny/test/SDK/CMM/CachingCMM.dfy ../Dafny/test/SDK/DefaultCMM.dfy ../Dafny/test/SDK/Keyring/MultiKeyring.dfy ../Dafny/test/SDK/Keyring/RawAESKeyring.dfy ../Dafny/test/SDK/Keyring/RawRSAKeyring.dfy ../Dafny/test/SDK/Keyring/TestKeyrings.dfy ../Dafny/test/SDK/Materials.dfy ../Dafny/test/SDK/MessageHeader.dfy ../Dafny/test/SDK/Serialize.dfy ../Dafny/test/StandardLibrary/Base64.dfy ../Dafny/test/StandardLibrary/StandardLibrary.dfy ../Dafny/test/StandardLibrary/UInt.dfy ../Dafny/test/Util/Sets.dfy ../Dafny/test/Util/Streams.dfy ../Dafny/test/Util/TestUtils.dfy ../Dafny/test/Util/UTF8.dfy /compile:0 /spillTargetCode:3 /noVerify
// the_program


module {:extern ""AESEncryption""} AESEncryption {

  import EncryptionSuites = EncryptionSuites

  import opened Wrappers = Wrappers

  import opened UInt = StandardLibrary.UInt

  export
    provides AESDecrypt, AESEncrypt, AESDecryptExtern, AESEncryptExtern, EncryptionSuites, Wrappers, UInt, PlaintextDecryptedWithAAD, EncryptionOutputEncryptedWithAAD, CiphertextGeneratedWithPlaintext, EncryptedWithKey, DecryptedWithKey
    reveals EncryptionOutput

  datatype EncryptionOutput = EncryptionOutput(cipherText: seq<uint8>, authTag: seq<uint8>)

  predicate {:axiom} PlaintextDecryptedWithAAD(plaintext: seq<uint8>, aad: seq<uint8>)
    decreases plaintext, aad

  predicate {:axiom} EncryptionOutputEncryptedWithAAD(ciphertext: EncryptionOutput, aad: seq<uint8>)
    decreases ciphertext, aad

  predicate {:axiom} CiphertextGeneratedWithPlaintext(ciphertext: seq<uint8>, plaintext: seq<uint8>)
    decreases ciphertext, plaintext

  predicate {:axiom} EncryptedWithKey(ciphertext: seq<uint8>, key: seq<uint8>)
    decreases ciphertext, key

  predicate {:axiom} DecryptedWithKey(key: seq<uint8>, plaintext: seq<uint8>)
    decreases key, plaintext

  function method EncryptionOutputFromByteSeq(s: seq<uint8>, encAlg: EncryptionSuites.EncryptionSuite): (encArt: EncryptionOutput)
    requires encAlg.Valid()
    requires |s| >= encAlg.tagLen as int
    ensures |encArt.cipherText + encArt.authTag| == |s|
    ensures |encArt.authTag| == encAlg.tagLen as int
    decreases s, encAlg
  {
    EncryptionOutput(s[..|s| - encAlg.tagLen as int], s[|s| - encAlg.tagLen as int..])
  }

  method {:extern ""AESEncryption.AES_GCM"", ""AESEncryptExtern""} AESEncryptExtern(encAlg: EncryptionSuites.EncryptionSuite, iv: seq<uint8>, key: seq<uint8>, msg: seq<uint8>, aad: seq<uint8>)
      returns (res: Result<EncryptionOutput, string>)
    requires encAlg.Valid()
    requires encAlg.alg.AES?
    requires encAlg.alg.mode.GCM?
    requires |iv| == encAlg.ivLen as int
    requires |key| == encAlg.keyLen as int
    ensures res.Success? ==> EncryptionOutputEncryptedWithAAD(res.value, aad)
    ensures res.Success? ==> CiphertextGeneratedWithPlaintext(res.value.cipherText, msg)
    ensures res.Success? ==> EncryptedWithKey(res.value.cipherText, key)
    decreases encAlg, iv, key, msg, aad

  method AESEncrypt(encAlg: EncryptionSuites.EncryptionSuite, iv: seq<uint8>, key: seq<uint8>, msg: seq<uint8>, aad: seq<uint8>)
      returns (res: Result<EncryptionOutput, string>)
    requires encAlg.Valid()
    requires encAlg.alg.AES?
    requires encAlg.alg.mode.GCM?
    requires |iv| == encAlg.ivLen as int
    requires |key| == encAlg.keyLen as int
    ensures res.Success? ==> |res.value.cipherText| == |msg| && |res.value.authTag| == encAlg.tagLen as int
    ensures res.Success? ==> EncryptionOutputEncryptedWithAAD(res.value, aad)
    ensures res.Success? ==> CiphertextGeneratedWithPlaintext(res.value.cipherText, msg)
    ensures res.Success? ==> EncryptedWithKey(res.value.cipherText, key)
    decreases encAlg, iv, key, msg, aad
  {
    res := AESEncryptExtern(encAlg, iv, key, msg, aad);
    if res.Success? && |res.value.cipherText| != |msg| {
      res := Failure(""AESEncrypt did not return cipherText of expected length"");
    }
    if res.Success? && |res.value.authTag| != encAlg.tagLen as int {
      res := Failure(""AESEncryption did not return valid tag"");
    }
  }

  method {:extern ""AESEncryption.AES_GCM"", ""AESDecryptExtern""} AESDecryptExtern(encAlg: EncryptionSuites.EncryptionSuite, key: seq<uint8>, cipherTxt: seq<uint8>, authTag: seq<uint8>, iv: seq<uint8>, aad: seq<uint8>)
      returns (res: Result<seq<uint8>, string>)
    requires encAlg.Valid()
    requires encAlg.alg.AES?
    requires encAlg.alg.mode.GCM?
    requires |key| == encAlg.keyLen as int
    requires |iv| == encAlg.ivLen as int
    requires |authTag| == encAlg.tagLen as int
    ensures res.Success? ==> PlaintextDecryptedWithAAD(res.value, aad)
    ensures res.Success? ==> CiphertextGeneratedWithPlaintext(cipherTxt, res.value)
    ensures res.Success? ==> DecryptedWithKey(key, res.value)
    decreases encAlg, key, cipherTxt, authTag, iv, aad

  method AESDecrypt(encAlg: EncryptionSuites.EncryptionSuite, key: seq<uint8>, cipherTxt: seq<uint8>, authTag: seq<uint8>, iv: seq<uint8>, aad: seq<uint8>)
      returns (res: Result<seq<uint8>, string>)
    requires encAlg.Valid()
    requires encAlg.alg.AES?
    requires encAlg.alg.mode.GCM?
    requires |key| == encAlg.keyLen as int
    requires |iv| == encAlg.ivLen as int
    requires |authTag| == encAlg.tagLen as int
    ensures res.Success? ==> |res.value| == |cipherTxt|
    ensures res.Success? ==> PlaintextDecryptedWithAAD(res.value, aad)
    ensures res.Success? ==> CiphertextGeneratedWithPlaintext(cipherTxt, res.value)
    ensures res.Success? ==> DecryptedWithKey(key, res.value)
    decreases encAlg, key, cipherTxt, authTag, iv, aad
  {
    res := AESDecryptExtern(encAlg, key, cipherTxt, authTag, iv, aad);
    if res.Success? && |cipherTxt| != |res.value| {
      res := Failure(""AESDecrypt did not return plaintext of expected length"");
    }
  }
}

module CryptoDatatypes {
  datatype DigestAlgorithm = SHA_512
}

module Digest {

  import opened Wrappers = Wrappers

  import opened UInt = StandardLibrary.UInt

  import CryptoDatatypes = CryptoDatatypes

  import ExternDigest = ExternDigest
  function method Length(alg: CryptoDatatypes.DigestAlgorithm): nat
    decreases alg
  {
    match alg
    case SHA_512() =>
      64
  }

  method Digest(alg: CryptoDatatypes.DigestAlgorithm, msg: seq<uint8>) returns (res: Result<seq<uint8>, string>)
    ensures res.Success? ==> |res.value| == Length(alg)
    decreases alg, msg
  {
    var result := ExternDigest.Digest(alg, msg);
    if result.Success? && |result.value| != Length(alg) {
      return Failure(""Incorrect length digest from ExternDigest."");
    }
    return result;
  }
}

module {:extern ""ExternDigest""} ExternDigest {

  import opened Wrappers = Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened CryptoDatatypes = CryptoDatatypes
  method {:extern} Digest(alg: CryptoDatatypes.DigestAlgorithm, msg: seq<uint8>) returns (res: Result<seq<uint8>, string>)
    decreases alg, msg
}

module {:extern ""EncryptionSuites""} EncryptionSuites {

  import opened UInt = StandardLibrary.UInt
  datatype EncryptionAlgorithm = AES(mode: AESMode)

  datatype AESMode = GCM

  datatype EncryptionSuite = EncryptionSuite(alg: EncryptionAlgorithm, keyLen: uint8, tagLen: uint8, ivLen: uint8) {
    predicate Valid()
      decreases this
    {
      match alg
      case AES(mode) =>
        keyLen as int in AES_CIPHER_KEY_LENGTHS &&
        tagLen == AES_TAG_LEN &&
        ivLen == AES_IV_LEN &&
        mode == GCM
    }
  }

  const AES_MAX_KEY_LEN := 32
  const AES_CIPHER_KEY_LENGTHS := {32, 24, 16}
  const AES_TAG_LEN := 16 as uint8
  const AES_IV_LEN := 12 as uint8
  const AES_GCM_128 := EncryptionSuite(AES(GCM), 16, AES_TAG_LEN, AES_IV_LEN)
  const AES_GCM_192 := EncryptionSuite(AES(GCM), 24, AES_TAG_LEN, AES_IV_LEN)
  const AES_GCM_256 := EncryptionSuite(AES(GCM), 32, AES_TAG_LEN, AES_IV_LEN)
}

module HKDF {

  import opened HMAC = HMAC

  import opened KeyDerivationAlgorithms = KeyDerivationAlgorithms

  import opened Wrappers = Wrappers

  import opened UInt = StandardLibrary.UInt
  function method GetHMACDigestFromHKDFAlgorithm(algorithm: HKDFAlgorithms): Digests
    decreases algorithm
  {
    match algorithm
    case HKDF_WITH_SHA_256() =>
      SHA_256
    case HKDF_WITH_SHA_384() =>
      SHA_384
  }

  method Extract(hmac: HMac, salt: seq<uint8>, ikm: seq<uint8>, ghost digest: Digests)
      returns (prk: seq<uint8>)
    requires hmac.GetDigest() == digest
    requires |salt| != 0
    requires |ikm| < INT32_MAX_LIMIT
    modifies hmac
    ensures GetHashLength(hmac.GetDigest()) == |prk|
    ensures hmac.GetKey() == salt
    ensures hmac.GetDigest() == digest
    decreases hmac, salt, ikm, digest
  {
    hmac.Init(salt);
    hmac.Update(ikm);
    assert hmac.GetInputSoFar() == ikm;
    prk := hmac.GetResult();
    return prk;
  }

  predicate T(hmac: HMac, info: seq<uint8>, n: nat, res: seq<uint8>)
    requires 0 <= n < 256
    decreases n
  {
    if n == 0 then
      [] == res
    else
      ghost var nMinusOne: int := n - 1; exists prev1: seq<uint8>, prev2: seq<uint8> :: T(hmac, info, nMinusOne, prev1) && Ti(hmac, info, n, prev2) && prev1 + prev2 == res
  }

  predicate Ti(hmac: HMac, info: seq<uint8>, n: nat, res: seq<uint8>)
    requires 0 <= n < 256
    decreases n, 1
  {
    if n == 0 then
      res == []
    else
      exists prev: seq<uint8> :: PreTi(hmac, info, n, prev) && hmac.HashSignature(prev, res)
  }

  predicate PreTi(hmac: HMac, info: seq<uint8>, n: nat, res: seq<uint8>)
    requires 1 <= n < 256
    decreases n, 0
  {
    ghost var nMinusOne: int := n - 1;
    exists prev: seq<uint8> | Ti(hmac, info, nMinusOne, prev) :: 
      res == prev + info + [n as uint8]
  }

  method Expand(hmac: HMac, prk: seq<uint8>, info: seq<uint8>, expectedLength: int, digest: Digests, ghost salt: seq<uint8>)
      returns (okm: seq<uint8>, ghost okmUnabridged: seq<uint8>)
    requires hmac.GetDigest() == digest
    requires 1 <= expectedLength <= 255 * GetHashLength(hmac.GetDigest())
    requires |salt| != 0
    requires hmac.GetKey() == salt
    requires |info| < INT32_MAX_LIMIT
    requires GetHashLength(hmac.GetDigest()) == |prk|
    modifies hmac
    ensures |okm| == expectedLength
    ensures hmac.GetKey() == prk
    ensures var n: int := (GetHashLength(digest) + expectedLength - 1) / GetHashLength(digest); T(hmac, info, n, okmUnabridged) && (|okmUnabridged| <= expectedLength ==> okm == okmUnabridged) && (expectedLength < |okmUnabridged| ==> okm == okmUnabridged[..expectedLength])
    decreases hmac, prk, info, expectedLength, digest, salt
  {
    var hashLength := GetHashLength(digest);
    var n := (hashLength + expectedLength - 1) / hashLength;
    assert 0 <= n < 256;
    hmac.Init(prk);
    var t_prev := [];
    var t_n := t_prev;
    var i := 1;
    while i <= n
      invariant 1 <= i <= n + 1
      invariant |t_prev| == if i == 1 then 0 else hashLength
      invariant hashLength == |prk|
      invariant |t_n| == (i - 1) * hashLength
      invariant hmac.GetKey() == prk
      invariant hmac.GetDigest() == digest
      invariant hmac.GetInputSoFar() == []
      invariant T(hmac, info, i - 1, t_n)
      invariant Ti(hmac, info, i - 1, t_prev)
      decreases n - i
    {
      hmac.Update(t_prev);
      hmac.Update(info);
      hmac.Update([i as uint8]);
      assert hmac.GetInputSoFar() == t_prev + info + [i as uint8];
      t_prev := hmac.GetResult();
      assert Ti(hmac, info, i, t_prev);
      t_n := t_n + t_prev;
      i := i + 1;
      assert T(hmac, info, i - 1, t_n);
    }
    okm := t_n;
    okmUnabridged := okm;
    assert T(hmac, info, n, okmUnabridged);
    if expectedLength < |okm| {
      okm := okm[..expectedLength];
    }
  }

  method Hkdf(algorithm: HKDFAlgorithms, salt: Option<seq<uint8>>, ikm: seq<uint8>, info: seq<uint8>, L: int)
      returns (okm: seq<uint8>)
    requires 0 <= L <= 255 * GetHashLength(GetHMACDigestFromHKDFAlgorithm(algorithm))
    requires salt.None? || |salt.value| != 0
    requires |info| < INT32_MAX_LIMIT
    requires |ikm| < INT32_MAX_LIMIT
    ensures |okm| == L
    decreases algorithm, salt, ikm, info, L
  {
    if L == 0 {
      return [];
    }
    var digest := GetHMACDigestFromHKDFAlgorithm(algorithm);
    var hmac := new HMac(digest);
    var hashLength := GetHashLength(digest);
    var nonEmptySalt: seq<uint8>;
    match salt {
      case {:split false} None() =>
        nonEmptySalt := StandardLibrary.Fill(0, hashLength);
      case {:split false} Some(s) =>
        nonEmptySalt := s;
    }
    var prk := Extract(hmac, nonEmptySalt, ikm, digest);
    ghost var okmUnabridged;
    okm, okmUnabridged := Expand(hmac, prk, info, L, digest, nonEmptySalt);
  }
}

module {:extern ""HMAC""} HMAC {

  import opened KeyDerivationAlgorithms = KeyDerivationAlgorithms

  import opened StandardLibrary = StandardLibrary

  import opened UInt = StandardLibrary.UInt
  datatype {:extern ""Digests""} Digests = SHA_256 | SHA_384

  class {:extern ""HMac""} HMac {
    function {:extern} GetKey(): seq<uint8>
      reads this
      decreases {this}

    function {:extern} GetDigest(): Digests
      reads this
      decreases {this}

    function {:extern} GetInputSoFar(): seq<uint8>
      reads this
      decreases {this}

    constructor {:extern} (digest: Digests)
      ensures this.GetDigest() == digest
      ensures this.GetInputSoFar() == []
      decreases digest

    method {:extern ""Init""} Init(key: seq<uint8>)
      modifies this
      ensures this.GetKey() == key
      ensures this.GetDigest() == old(this.GetDigest())
      ensures this.GetInputSoFar() == []
      decreases key

    method {:extern ""BlockUpdate""} Update(input: seq<uint8>)
      requires |this.GetKey()| > 0
      requires |input| < INT32_MAX_LIMIT
      modifies this
      ensures this.GetInputSoFar() == old(this.GetInputSoFar()) + input
      ensures this.GetDigest() == old(this.GetDigest())
      ensures this.GetKey() == old(this.GetKey())
      decreases input

    method {:extern ""GetResult""} GetResult() returns (s: seq<uint8>)
      requires |this.GetKey()| > 0
      modifies this
      ensures |s| == GetHashLength(this.GetDigest())
      ensures this.GetInputSoFar() == []
      ensures this.GetDigest() == old(this.GetDigest())
      ensures this.GetKey() == old(this.GetKey())
      ensures this.HashSignature(old(this.GetInputSoFar()), s)

    predicate {:axiom} HashSignature(message: seq<uint8>, s: seq<uint8>)
      decreases message, s
  }

  function method GetHashLength(digest: Digests): int
    decreases digest
  {
    match digest
    case SHA_256() =>
      32
    case SHA_384() =>
      48
  }
}

module {:extern ""KeyDerivationAlgorithms""} KeyDerivationAlgorithms {

  import opened UInt = StandardLibrary.UInt
  datatype KeyDerivationAlgorithm = HKDF_WITH_SHA_384 | HKDF_WITH_SHA_256 | IDENTITY

  type HKDFAlgorithms = a: KeyDerivationAlgorithm
    | a != KeyDerivationAlgorithm.IDENTITY
    witness KeyDerivationAlgorithm.HKDF_WITH_SHA_384

  type IdentityAlgorithm = a: KeyDerivationAlgorithm
    | a == KeyDerivationAlgorithm.IDENTITY
    witness KeyDerivationAlgorithm.IDENTITY
}

module Random {

  export
    provides GenerateBytes, Wrappers, UInt


  import opened Wrappers = Wrappers

  import opened UInt = StandardLibrary.UInt

  import ExternRandom = ExternRandom
  method GenerateBytes(i: int32) returns (res: Result<seq<uint8>, string>)
    requires 0 <= i
    ensures res.Success? ==> |res.value| == i as int
    decreases i
  {
    var result := ExternRandom.GenerateBytes(i);
    if result.Success? && |result.value| != i as int {
      return Failure(""Incorrect length from ExternRandom."");
    }
    return result;
  }
}

module {:extern ""ExternRandom""} ExternRandom {

  import opened Wrappers = Wrappers

  import opened UInt = StandardLibrary.UInt
  method {:extern} GenerateBytes(i: int32) returns (res: Result<seq<uint8>, string>)
    decreases i
}

module {:extern ""RSAEncryption""} RSAEncryption {

  import opened Wrappers = Wrappers

  import opened UInt = StandardLibrary.UInt
  datatype {:extern ""PaddingMode""} PaddingMode = PKCS1 | OAEP_SHA1 | OAEP_SHA256 | OAEP_SHA384 | OAEP_SHA512

  newtype {:nativeType ""int"", ""number""} StrengthBits = x: int
    | 81 <= x < 2147483648
    witness 81

  trait {:termination false} Key {
    ghost var Repr: set<object>
    ghost const strength: StrengthBits
    ghost const padding: PaddingMode
    const pem: seq<uint8>

    predicate Valid()
      reads this, Repr
      ensures Valid() ==> this in Repr
      decreases Repr + {this}
    {
      this in Repr &&
      |pem| > 0 &&
      GetBytes(strength) >= MinStrengthBytes(padding) &&
      PEMGeneratedWithStrength(pem, strength) &&
      PEMGeneratedWithPadding(pem, padding)
    }
  }

  class PrivateKey extends Key {
    constructor (pem: seq<uint8>, ghost strength: StrengthBits, ghost padding: PaddingMode)
      requires |pem| > 0
      requires GetBytes(strength) >= MinStrengthBytes(padding)
      requires PEMGeneratedWithStrength(pem, strength)
      requires PEMGeneratedWithPadding(pem, padding)
      ensures this.pem == pem
      ensures this.strength == strength
      ensures this.padding == padding
      ensures Valid() && fresh(Repr)
      decreases pem, strength, padding
    {
      this.pem := pem;
      this.strength := strength;
      this.padding := padding;
      Repr := {this};
    }
  }

  class PublicKey extends Key {
    constructor (pem: seq<uint8>, ghost strength: StrengthBits, ghost padding: PaddingMode)
      requires |pem| > 0
      requires GetBytes(strength) >= MinStrengthBytes(padding)
      requires PEMGeneratedWithStrength(pem, strength)
      requires PEMGeneratedWithPadding(pem, padding)
      ensures this.pem == pem
      ensures this.strength == strength
      ensures this.padding == padding
      ensures Valid() && fresh(Repr)
      decreases pem, strength, padding
    {
      this.pem := pem;
      this.strength := strength;
      this.padding := padding;
      Repr := {this};
    }
  }

  predicate {:axiom} PEMGeneratedWithStrength(pem: seq<uint8>, strength: StrengthBits)
    decreases pem, strength

  predicate {:axiom} PEMGeneratedWithPadding(pem: seq<uint8>, padding: PaddingMode)
    decreases pem, padding

  const SHA1_HASH_BYTES := 20
  const SHA256_HASH_BYTES := 32
  const SHA384_HASH_BYTES := 48
  const SHA512_HASH_BYTES := 64

  function GetBytes(bits: StrengthBits): nat
    decreases bits
  {
    (bits as nat + 7) / 8
  }

  function MinStrengthBytes(padding: PaddingMode): nat
    decreases padding
  {
    match padding {
      case PKCS1() =>
        11
      case OAEP_SHA1() =>
        2 * SHA1_HASH_BYTES + 2
      case OAEP_SHA256() =>
        2 * SHA256_HASH_BYTES + 2
      case OAEP_SHA384() =>
        2 * SHA384_HASH_BYTES + 2
      case OAEP_SHA512() =>
        2 * SHA512_HASH_BYTES + 2
    }
  }

  function MaxPlaintextBytes(padding: PaddingMode, strength: StrengthBits): nat
    requires GetBytes(strength) >= MinStrengthBytes(padding)
    decreases padding, strength
  {
    match padding {
      case PKCS1() =>
        GetBytes(strength) - 11
      case OAEP_SHA1() =>
        GetBytes(strength) - 2 * SHA1_HASH_BYTES - 2
      case OAEP_SHA256() =>
        GetBytes(strength) - 2 * SHA256_HASH_BYTES - 2
      case OAEP_SHA384() =>
        GetBytes(strength) - 2 * SHA384_HASH_BYTES - 2
      case OAEP_SHA512() =>
        GetBytes(strength) - 2 * SHA512_HASH_BYTES - 2
    }
  }

  method GenerateKeyPair(strength: StrengthBits, padding: PaddingMode)
      returns (publicKey: PublicKey, privateKey: PrivateKey)
    requires GetBytes(strength) >= MinStrengthBytes(padding)
    ensures privateKey.Valid() && fresh(privateKey.Repr)
    ensures privateKey.strength == strength
    ensures privateKey.padding == padding
    ensures publicKey.Valid() && fresh(publicKey.Repr)
    ensures publicKey.strength == strength
    ensures publicKey.padding == padding
    ensures GetBytes(publicKey.strength) >= MinStrengthBytes(publicKey.padding)
    ensures GetBytes(privateKey.strength) >= MinStrengthBytes(privateKey.padding)
    decreases strength, padding
  {
    var pemPublic, pemPrivate := GenerateKeyPairExtern(strength, padding);
    privateKey := new PrivateKey(pemPrivate, strength, padding);
    publicKey := new PublicKey(pemPublic, strength, padding);
  }

  method Decrypt(padding: PaddingMode, privateKey: PrivateKey, cipherText: seq<uint8>)
      returns (res: Result<seq<uint8>, string>)
    requires privateKey.Valid()
    requires 0 < |cipherText|
    requires padding == privateKey.padding
    ensures privateKey.Valid()
    decreases padding, privateKey, cipherText
  {
    res := DecryptExtern(padding, privateKey.pem, cipherText);
  }

  method Encrypt(padding: PaddingMode, publicKey: PublicKey, plaintextData: seq<uint8>)
      returns (res: Result<seq<uint8>, string>)
    requires publicKey.Valid()
    requires GetBytes(publicKey.strength) >= MinStrengthBytes(padding)
    requires 0 < |plaintextData|
    requires padding == publicKey.padding
    ensures publicKey.Valid()
    decreases padding, publicKey, plaintextData
  {
    res := EncryptExtern(padding, publicKey.pem, plaintextData);
  }

  method {:extern ""RSAEncryption.RSA"", ""GenerateKeyPairExtern""} GenerateKeyPairExtern(strength: StrengthBits, padding: PaddingMode)
      returns (publicKey: seq<uint8>, privateKey: seq<uint8>)
    requires GetBytes(strength) >= MinStrengthBytes(padding)
    ensures |publicKey| > 0
    ensures |privateKey| > 0
    ensures PEMGeneratedWithStrength(publicKey, strength)
    ensures PEMGeneratedWithStrength(privateKey, strength)
    ensures PEMGeneratedWithPadding(publicKey, padding)
    ensures PEMGeneratedWithPadding(privateKey, padding)
    decreases strength, padding

  method {:extern ""RSAEncryption.RSA"", ""DecryptExtern""} DecryptExtern(padding: PaddingMode, privateKey: seq<uint8>, cipherText: seq<uint8>)
      returns (res: Result<seq<uint8>, string>)
    requires |privateKey| > 0
    requires |cipherText| > 0
    decreases padding, privateKey, cipherText

  method {:extern ""RSAEncryption.RSA"", ""EncryptExtern""} EncryptExtern(padding: PaddingMode, publicKey: seq<uint8>, plaintextData: seq<uint8>)
      returns (res: Result<seq<uint8>, string>)
    requires |publicKey| > 0
    requires |plaintextData| > 0
    decreases padding, publicKey, plaintextData
}

module {:extern ""Signature""} Signature {

  export
    reveals SignatureKeyPair, ECDSAParams, ECDSAParams.SignatureLength, ECDSAParams.FieldSize
    provides KeyGen, Sign, Verify, IsSigned, Wrappers, UInt


  import opened Wrappers = Wrappers

  import opened UInt = StandardLibrary.UInt
  datatype SignatureKeyPair = SignatureKeyPair(verificationKey: seq<uint8>, signingKey: seq<uint8>)

  datatype ECDSAParams = ECDSA_P384 | ECDSA_P256 {
    function method SignatureLength(): uint16
      decreases this
    {
      match this
      case ECDSA_P256() =>
        71
      case ECDSA_P384() =>
        103
    }

    function method FieldSize(): nat
      decreases this
    {
      match this
      case ECDSA_P256() =>
        assert 1 + (256 + 7) / 8 == 33; 33
      case ECDSA_P384() =>
        assert 1 + (384 + 7) / 8 == 49;
        49
    }
  }

  predicate {:axiom} IsSigned(key: seq<uint8>, msg: seq<uint8>, signature: seq<uint8>)
    decreases key, msg, signature

  method KeyGen(s: ECDSAParams) returns (res: Result<SignatureKeyPair, string>)
    ensures match res { case Success(_mcc#0) => (var sigKeyPair := _mcc#0; |sigKeyPair.verificationKey| == s.FieldSize()) case Failure(_mcc#1) => true }
    decreases s
  {
    var sigKeyPair :- ExternKeyGen(s);
    if |sigKeyPair.verificationKey| == s.FieldSize() {
      return Success(sigKeyPair);
    } else {
      return Failure(""Incorrect verification-key length from ExternKeyGen."");
    }
  }

  method {:extern ""Signature.ECDSA"", ""ExternKeyGen""} ExternKeyGen(s: ECDSAParams) returns (res: Result<SignatureKeyPair, string>)
    decreases s

  method {:extern ""Signature.ECDSA"", ""Sign""} Sign(s: ECDSAParams, key: seq<uint8>, msg: seq<uint8>)
      returns (sig: Result<seq<uint8>, string>)
    ensures sig.Success? ==> IsSigned(key, msg, sig.value)
    decreases s, key, msg

  method {:extern ""Signature.ECDSA"", ""Verify""} Verify(s: ECDSAParams, key: seq<uint8>, msg: seq<uint8>, sig: seq<uint8>)
      returns (res: Result<bool, string>)
    decreases s, key, msg, sig
}

module {:extern ""Amazon.KeyManagementService""} AmazonKeyManagementService {
  class {:extern ""IAmazonKeyManagementService""} IAmazonKeyManagementService { }
}

module AwsKmsArnParsing {

  import opened StandardLibrary = StandardLibrary

  import opened Wrappers = Wrappers

  import opened Seq = Seq

  import UTF8 = UTF8
  datatype AwsResource = AwsResource(resourceType: string, value: string) {
    predicate method Valid()
      decreases this
    {
      true &&
      0 < |value|
    }

    function method ToString(): string
      decreases this
    {
      resourceType + ""/"" + value
    }
  }

  datatype AwsArn = AwsArn(arnLiteral: string, partition: string, service: string, region: string, account: string, resource: AwsResource) {
    predicate method Valid()
      decreases this
    {
      arnLiteral == ""arn"" &&
      0 < |partition| &&
      0 < |service| &&
      0 < |region| &&
      0 < |account| &&
      resource.Valid()
    }

    function method ToString(): string
      requires this.Valid()
      decreases this
    {
      ToArnString(None)
    }

    function method ToArnString(customRegion: Option<string>): string
      requires this.Valid()
      decreases if customRegion.None? then 1 else 0
    {
      match customRegion {
        case None() =>
          ToArnString(Some(region))
        case Some(customRegion) =>
          Join([arnLiteral, partition, service, customRegion, account, resource.ToString()], "":"")
      }
    }
  }

  type AwsKmsArn = a: AwsArn
    | ValidAwsKmsArn(a)
    witness *

  type AwsKmsResource = r: AwsResource
    | ValidAwsKmsResource(r)
    witness *

  datatype AwsKmsIdentifier = AwsKmsArnIdentifier(a: AwsKmsArn) | AwsKmsRawResourceIdentifier(r: AwsKmsResource) {
    function method ToString(): string
      decreases this
    {
      match this {
        case AwsKmsArnIdentifier(a) =>
          a.ToString()
        case AwsKmsRawResourceIdentifier(r) =>
          r.ToString()
      }
    }
  }

  type AwsKmsIdentifierString = s: string
    | ParseAwsKmsIdentifier(s).Success? && UTF8.IsASCIIString(s) && 0 < |s| <= MAX_AWS_KMS_IDENTIFIER_LENGTH
    witness *

  const MAX_AWS_KMS_IDENTIFIER_LENGTH := 2048

  predicate method ValidAwsKmsResource(resource: AwsResource)
    decreases resource
  {
    resource.Valid() &&
    (resource.resourceType == ""key"" || resource.resourceType == ""alias"")
  }

  predicate method ValidAwsKmsArn(arn: AwsArn)
    decreases arn
  {
    arn.Valid() &&
    arn.service == ""kms"" &&
    ValidAwsKmsResource(arn.resource)
  }

  function method ParseAwsKmsRawResources(identifier: string): (result: Result<AwsKmsResource, string>)
    decreases identifier
  {
    var info: seq<seq<char>> := Split(identifier, '/');
    Need(info[0] != ""key"", ""Malformed raw key id: "" + identifier); if |info| == 1 then ParseAwsKmsResources(""key/"" + identifier) else ParseAwsKmsResources(identifier)
  }

  function method ParseAwsKmsResources(identifier: string): (result: Result<AwsKmsResource, string>)
    decreases identifier
  {
    var info: seq<seq<char>> := Split(identifier, '/');
    Need(|info| > 1, ""Malformed resource: "" + identifier); var resourceType: seq<char> := info[0]; var value: seq<char> := Join(info[1..], ""/""); var resource: AwsResource := AwsResource(resourceType, value); Need(ValidAwsKmsResource(resource), ""Malformed resource: "" + identifier); Success(resource)
  }

  lemma /*{:_induction identifier}*/ ParseAwsKmsResourcesCorrect(identifier: string)
    ensures ParseAwsKmsResources(identifier).Success? ==> ghost var info: seq<seq<char>> := Split(identifier, '/'); ghost var r: Result<AwsResource, seq<char>> := ParseAwsKmsResources(identifier); |info| > 1 && Join([r.value.resourceType, r.value.value], ""/"") == identifier
    ensures ParseAwsKmsResources(identifier).Success? ==> ghost var resourceType: seq<char> := Split(identifier, '/')[0]; ""key"" == resourceType || ""alias"" == resourceType
    ensures ParseAwsKmsResources(identifier).Success? ==> ghost var info: seq<seq<char>> := Split(identifier, '/'); |Join(info[1..], ""/"")| > 0
    decreases identifier
  {
  }

  function method ParseAwsKmsArn(identifier: string): (result: Result<AwsKmsArn, string>)
    decreases identifier
  {
    var components: seq<seq<char>> := Split(identifier, ':');
    Need(6 == |components|, ""Malformed arn: "" + identifier); var resource: AwsKmsResource :- ParseAwsKmsResources(components[5]); var arn: AwsArn := AwsArn(components[0], components[1], components[2], components[3], components[4], resource); Need(ValidAwsKmsArn(arn), ""Malformed Arn:"" + identifier); Success(arn)
  }

  lemma /*{:_induction identifier}*/ ParseAwsKmsArnCorrect(identifier: string)
    ensures ParseAwsKmsArn(identifier).Success? ==> ""arn"" <= identifier
    ensures ParseAwsKmsArn(identifier).Success? ==> |Split(identifier, ':')| == 6
    ensures ParseAwsKmsArn(identifier).Success? ==> |Split(identifier, ':')[1]| > 0
    ensures ParseAwsKmsArn(identifier).Success? ==> Split(identifier, ':')[2] == ""kms""
    ensures ParseAwsKmsArn(identifier).Success? ==> |Split(identifier, ':')[3]| > 0
    ensures ParseAwsKmsArn(identifier).Success? ==> |Split(identifier, ':')[4]| > 0
    decreases identifier
  {
  }

  function method ParseAwsKmsIdentifier(identifier: string): (result: Result<AwsKmsIdentifier, string>)
    decreases identifier
  {
    if ""arn:"" <= identifier then
      var arn: AwsKmsArn :- ParseAwsKmsArn(identifier); Success(AwsKmsArnIdentifier(arn))
    else
      var r: AwsKmsResource :- ParseAwsKmsRawResources(identifier); Success(AwsKmsRawResourceIdentifier(r))
  }

  predicate method IsMultiRegionAwsKmsArn(arn: AwsKmsArn)
    decreases arn
  {
    IsMultiRegionAwsKmsResource(arn.resource)
  }

  lemma IsMultiRegionAwsKmsArnCorrectness(arn: AwsKmsArn)
    ensures !IsMultiRegionAwsKmsArn(arn) <== arn.resource.resourceType == ""alias""
    ensures !IsMultiRegionAwsKmsArn(arn) <== arn.resource.resourceType == ""key"" && !(""mrk-"" <= arn.resource.value)
    ensures IsMultiRegionAwsKmsArn(arn) <== arn.resource.resourceType == ""key"" && ""mrk-"" <= arn.resource.value
    decreases arn
  {
  }

  predicate method IsMultiRegionAwsKmsIdentifier(identifier: AwsKmsIdentifier)
    decreases identifier
  {
    match identifier {
      case AwsKmsArnIdentifier(arn) =>
        IsMultiRegionAwsKmsArn(arn)
      case AwsKmsRawResourceIdentifier(r) =>
        IsMultiRegionAwsKmsResource(r)
    }
  }

  lemma IsMultiRegionAwsKmsIdentifierCorrect(s: string)
    ensures ""arn:"" <= s && ParseAwsKmsArn(s).Success? ==> ghost var arn: Result<AwsKmsArn, seq<char>> := ParseAwsKmsArn(s); ghost var arnIdentifier: AwsKmsIdentifier := AwsKmsArnIdentifier(arn.value); IsMultiRegionAwsKmsIdentifier(arnIdentifier) == IsMultiRegionAwsKmsArn(arn.value)
    ensures ""alias/"" <= s && ParseAwsKmsResources(s).Success? ==> ghost var resource: Result<AwsKmsResource, seq<char>> := ParseAwsKmsResources(s); ghost var resourceIdentifier: AwsKmsIdentifier := AwsKmsRawResourceIdentifier(resource.value); !IsMultiRegionAwsKmsIdentifier(resourceIdentifier)
    ensures ""mrk-"" <= s && ParseAwsKmsResources(s).Success? ==> ghost var resource: Result<AwsKmsResource, seq<char>> := ParseAwsKmsResources(s); ghost var resourceIdentifier: AwsKmsIdentifier := AwsKmsRawResourceIdentifier(resource.value); IsMultiRegionAwsKmsIdentifier(resourceIdentifier)
    ensures !(""arn:"" <= s) && !(""alias/"" <= s) && !(""mrk-"" <= s) && ParseAwsKmsIdentifier(s).Success? ==> ghost var resourceIdentifier: Result<AwsKmsIdentifier, string> := ParseAwsKmsIdentifier(s); !IsMultiRegionAwsKmsIdentifier(resourceIdentifier.value)
    decreases s
  {
  }

  predicate method IsMultiRegionAwsKmsResource(resource: AwsKmsResource)
    decreases resource
  {
    resource.resourceType == ""key"" &&
    ""mrk-"" <= resource.value
  }

  function method GetRegion(identifier: AwsKmsIdentifier): (res: Option<string>)
    decreases identifier
  {
    match identifier {
      case AwsKmsArnIdentifier(a) =>
        Some(a.region)
      case AwsKmsRawResourceIdentifier(_v0) =>
        None()
    }
  }
}

module {:extern ""KMSUtils""} KMSUtils {

  import EncryptionContext = EncryptionContext

  import opened AmazonKeyManagementService = AmazonKeyManagementService

  import opened StandardLibrary = StandardLibrary

  import opened Wrappers = Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened AwsKmsArnParsing = AwsKmsArnParsing

  import UTF8 = UTF8
  type CustomerMasterKey = AwsKmsIdentifierString

  type GrantTokens = s: seq<GrantToken>
    | 0 <= |s| <= MAX_GRANT_TOKENS

  type GrantToken = s: string
    | 0 < |s| <= 8192
    witness *

  datatype ResponseMetadata = ResponseMetadata(metadata: map<string, string>, requestID: string)

  type HttpStatusCode = int

  datatype GenerateDataKeyRequest = GenerateDataKeyRequest(encryptionContext: EncryptionContext.Map, grantTokens: seq<GrantToken>, keyID: AwsKmsIdentifierString, numberOfBytes: int32) {
    predicate Valid()
      decreases this
    {
      0 <= |grantTokens| <= MAX_GRANT_TOKENS &&
      0 < numberOfBytes <= 1024
    }
  }

  datatype GenerateDataKeyResponse = GenerateDataKeyResponse(ciphertextBlob: seq<uint8>, keyID: string, plaintext: seq<uint8>) {
    predicate method IsWellFormed()
      decreases this
    {
      |keyID| < UINT16_LIMIT &&
      |ciphertextBlob| < UINT16_LIMIT
    }
  }

  datatype EncryptRequest = EncryptRequest(encryptionContext: EncryptionContext.Map, grantTokens: seq<GrantToken>, keyID: AwsKmsIdentifierString, plaintext: seq<uint8>) {
    predicate Valid()
      decreases this
    {
      0 <= |grantTokens| <= MAX_GRANT_TOKENS
    }
  }

  datatype EncryptResponse = EncryptResponse(ciphertextBlob: seq<uint8>, contentLength: int, httpStatusCode: HttpStatusCode, keyID: string, responseMetadata: ResponseMetadata) {
    predicate method IsWellFormed()
      decreases this
    {
      |keyID| < UINT16_LIMIT &&
      |ciphertextBlob| < UINT16_LIMIT
    }
  }

  datatype DecryptRequest = DecryptRequest(keyId: string, ciphertextBlob: seq<uint8>, encryptionContext: EncryptionContext.Map, grantTokens: seq<GrantToken>) {
    predicate Valid()
      decreases this
    {
      0 <= |grantTokens| <= MAX_GRANT_TOKENS
    }
  }

  datatype DecryptResponse = DecryptResponse(contentLength: int, httpStatusCode: HttpStatusCode, keyID: string, plaintext: seq<uint8>, responseMetadata: ResponseMetadata)

  trait {:extern ""DafnyAWSKMSClientSupplier""} DafnyAWSKMSClientSupplier {
    method GetClient(region: Option<string>) returns (res: Result<IAmazonKeyManagementService, string>)
      decreases region
  }

  class BaseClientSupplier extends DafnyAWSKMSClientSupplier {
    constructor ()
    {
    }

    method GetClient(region: Option<string>) returns (res: Result<IAmazonKeyManagementService, string>)
      decreases region
    {
      var resClient := GetDefaultAWSKMSServiceClientExtern(region);
      return resClient;
    }
  }

  const MAX_GRANT_TOKENS := 10

  method {:extern ""KMSUtils.ClientHelper"", ""GetDefaultAWSKMSServiceClientExtern""} GetDefaultAWSKMSServiceClientExtern(region: Option<string>) returns (res: Result<IAmazonKeyManagementService, string>)
    decreases region

  predicate {:opaque} {:fuel 0, 0} GenerateDataKeyCalledWith(client: IAmazonKeyManagementService, request: GenerateDataKeyRequest)
    decreases client, request
  {
    true
  }

  predicate {:opaque} {:fuel 0, 0} GenerateDataKeyResult(ciphertextBlob: seq<uint8>, plaintext: seq<uint8>)
    decreases ciphertextBlob, plaintext
  {
    true
  }

  predicate {:opaque} {:fuel 0, 0} EncryptCalledWith(client: IAmazonKeyManagementService, request: EncryptRequest)
    decreases client, request
  {
    true
  }

  predicate {:opaque} {:fuel 0, 0} EncryptResult(ciphertextBlob: seq<uint8>)
    decreases ciphertextBlob
  {
    true
  }

  predicate {:opaque} {:fuel 0, 0} DecryptCalledWith(client: IAmazonKeyManagementService, request: DecryptRequest)
    decreases client, request
  {
    true
  }

  predicate {:opaque} {:fuel 0, 0} DecryptResult(keyID: string, plaintext: seq<uint8>)
    decreases keyID, plaintext
  {
    true
  }

  method {:extern ""KMSUtils.ClientHelper"", ""GenerateDataKey""} GenerateDataKey(client: IAmazonKeyManagementService, request: GenerateDataKeyRequest) returns (res: Result<GenerateDataKeyResponse, string>)
    requires request.Valid()
    ensures GenerateDataKeyCalledWith(client, request)
    ensures res.Success? ==> var r: GenerateDataKeyResponse := res.value; GenerateDataKeyResult(r.ciphertextBlob, r.plaintext)
    decreases client, request

  method {:extern ""KMSUtils.ClientHelper"", ""Encrypt""} Encrypt(client: IAmazonKeyManagementService, request: EncryptRequest) returns (res: Result<EncryptResponse, string>)
    requires request.Valid()
    ensures EncryptCalledWith(client, request)
    ensures res.Success? ==> EncryptResult(res.value.ciphertextBlob)
    decreases client, request

  method {:extern ""KMSUtils.ClientHelper"", ""Decrypt""} Decrypt(client: IAmazonKeyManagementService, request: DecryptRequest) returns (res: Result<DecryptResponse, string>)
    requires request.Valid()
    ensures DecryptCalledWith(client, request)
    ensures res.Success? ==> var r: DecryptResponse := res.value; DecryptResult(r.keyID, r.plaintext)
    decreases client, request
}

module {:extern ""AlgorithmSuite""} AlgorithmSuite {

  import opened Wrappers = Wrappers

  import opened UInt = StandardLibrary.UInt

  import EncryptionSuites = EncryptionSuites

  import S = Signature

  import KeyDerivationAlgorithms = KeyDerivationAlgorithms
  newtype ID = x: uint16
    | x in VALID_IDS
    witness 20
{
    function method EncryptionSuite(): EncryptionSuites.EncryptionSuite
      ensures EncryptionSuite().Valid()
      decreases this
    {
      Suite[this].algorithm
    }

    function method KeyLength(): nat
      decreases this
    {
      Suite[this].algorithm.keyLen as nat
    }

    predicate method ContainsIdentityKDF()
      decreases this
    {
      Suite[this].hkdf == KeyDerivationAlgorithms.IDENTITY
    }

    function method KDFInputKeyLength(): nat
      ensures ContainsIdentityKDF() ==> KDFInputKeyLength() == KeyLength()
      decreases this
    {
      match Suite[this].hkdf
      case HKDF_WITH_SHA_384() =>
        Suite[this].algorithm.keyLen as nat
      case HKDF_WITH_SHA_256() =>
        Suite[this].algorithm.keyLen as nat
      case IDENTITY() =>
        Suite[this].algorithm.keyLen as nat
    }

    function method IVLength(): nat
      decreases this
    {
      Suite[this].algorithm.ivLen as nat
    }

    function method TagLength(): nat
      decreases this
    {
      Suite[this].algorithm.tagLen as nat
    }

    function method SignatureType(): Option<S.ECDSAParams>
      decreases this
    {
      Suite[this].sign
    }

    predicate method ValidPlaintextDataKey(plaintextDataKey: seq<uint8>)
      decreases this, plaintextDataKey
    {
      |plaintextDataKey| == KDFInputKeyLength()
    }
  }

  datatype AlgSuite = AlgSuite(algorithm: EncryptionSuites.EncryptionSuite, hkdf: KeyDerivationAlgorithms.KeyDerivationAlgorithm, sign: Option<S.ECDSAParams>)

  const VALID_IDS: set<uint16> := {888, 838, 532, 376, 326, 276, 120, 70, 20}
  const AES_256_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384: ID := 888
  const AES_192_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384: ID := 838
  const AES_128_GCM_IV12_TAG16_HKDF_SHA256_ECDSA_P256: ID := 532
  const AES_256_GCM_IV12_TAG16_HKDF_SHA256_NO_SIGNATURE_ALG: ID := 376
  const AES_192_GCM_IV12_TAG16_HKDF_SHA256_NO_SIGNATURE_ALG: ID := 326
  const AES_128_GCM_IV12_TAG16_HKDF_SHA256_NO_SIGNATURE_ALG: ID := 276
  const AES_256_GCM_IV12_TAG16_IDENTITY_NO_SIGNATURE_ALG: ID := 120
  const AES_192_GCM_IV12_TAG16_IDENTITY_NO_SIGNATURE_ALG: ID := 70
  const AES_128_GCM_IV12_TAG16_IDENTITY_NO_SIGNATURE_ALG: ID := 20
  const Suite := map[AES_256_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384 := AlgSuite(EncryptionSuites.AES_GCM_256, KeyDerivationAlgorithms.HKDF_WITH_SHA_384, Some(S.ECDSA_P384)), AES_192_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384 := AlgSuite(EncryptionSuites.AES_GCM_192, KeyDerivationAlgorithms.HKDF_WITH_SHA_384, Some(S.ECDSA_P384)), AES_128_GCM_IV12_TAG16_HKDF_SHA256_ECDSA_P256 := AlgSuite(EncryptionSuites.AES_GCM_128, KeyDerivationAlgorithms.HKDF_WITH_SHA_256, Some(S.ECDSA_P256)), AES_256_GCM_IV12_TAG16_HKDF_SHA256_NO_SIGNATURE_ALG := AlgSuite(EncryptionSuites.AES_GCM_256, KeyDerivationAlgorithms.HKDF_WITH_SHA_256, None), AES_192_GCM_IV12_TAG16_HKDF_SHA256_NO_SIGNATURE_ALG := AlgSuite(EncryptionSuites.AES_GCM_192, KeyDerivationAlgorithms.HKDF_WITH_SHA_256, None), AES_128_GCM_IV12_TAG16_HKDF_SHA256_NO_SIGNATURE_ALG := AlgSuite(EncryptionSuites.AES_GCM_128, KeyDerivationAlgorithms.HKDF_WITH_SHA_256, None), AES_256_GCM_IV12_TAG16_IDENTITY_NO_SIGNATURE_ALG := AlgSuite(EncryptionSuites.AES_GCM_256, KeyDerivationAlgorithms.IDENTITY, None), AES_192_GCM_IV12_TAG16_IDENTITY_NO_SIGNATURE_ALG := AlgSuite(EncryptionSuites.AES_GCM_192, KeyDerivationAlgorithms.IDENTITY, None), AES_128_GCM_IV12_TAG16_IDENTITY_NO_SIGNATURE_ALG := AlgSuite(EncryptionSuites.AES_GCM_128, KeyDerivationAlgorithms.IDENTITY, None)]

  lemma SuiteIsComplete(id: ID)
    ensures id in Suite.Keys
    decreases id
  {
  }

  lemma ValidIDsAreSuiteKeys()
    ensures VALID_IDS == set id: ID {:trigger id in Suite.Keys} | id in Suite.Keys :: id as uint16
  {
    forall x: uint16 | x in VALID_IDS
      ensures exists id: ID :: id in Suite.Keys && id as uint16 == x
    {
      assert x as ID in Suite.Keys;
    }
  }
}

module {:extern ""ESDKClient""} ESDKClient {

  import opened Wrappers = Wrappers

  import opened StandardLibrary = StandardLibrary

  import opened UInt = StandardLibrary.UInt

  import EncryptionContext = EncryptionContext

  import AlgorithmSuite = AlgorithmSuite

  import AESEncryption = AESEncryption

  import CMMDefs = CMMDefs

  import DefaultCMMDef = DefaultCMMDef

  import Deserialize = Deserialize

  import HKDF = HKDF

  import KeyringDefs = KeyringDefs

  import KeyDerivationAlgorithms = KeyDerivationAlgorithms

  import Materials = Materials

  import Msg = MessageHeader

  import MessageBody = MessageBody

  import Random = Random

  import Serialize = Serialize

  import Signature = Signature

  import Streams = Streams
  datatype EncryptRequest = EncryptRequest(plaintext: seq<uint8>, cmm: CMMDefs.CMM?, keyring: KeyringDefs.Keyring?, plaintextLength: nat, encryptionContext: EncryptionContext.Map, algorithmSuiteID: Option<uint16>, frameLength: Option<uint32>) {
    static function method WithCMM(plaintext: seq<uint8>, cmm: CMMDefs.CMM): EncryptRequest
      requires cmm.Valid()
      reads cmm.Repr
      decreases cmm.Repr, plaintext, cmm
    {
      EncryptRequest(plaintext, cmm, null, |plaintext|, map[], None, None)
    }

    static function method WithKeyring(plaintext: seq<uint8>, keyring: KeyringDefs.Keyring): EncryptRequest
      requires keyring.Valid()
      reads keyring.Repr
      decreases keyring.Repr, plaintext, keyring
    {
      EncryptRequest(plaintext, null, keyring, |plaintext|, map[], None, None)
    }

    function method SetEncryptionContext(encryptionContext: EncryptionContext.Map): EncryptRequest
      decreases this, encryptionContext
    {
      this.(encryptionContext := encryptionContext)
    }

    function method SetAlgorithmSuiteID(algorithmSuiteID: uint16): EncryptRequest
      decreases this, algorithmSuiteID
    {
      this.(algorithmSuiteID := Some(algorithmSuiteID))
    }

    function method SetFrameLength(frameLength: uint32): EncryptRequest
      decreases this, frameLength
    {
      this.(frameLength := Some(frameLength))
    }
  }

  datatype DecryptRequest = DecryptRequest(message: seq<uint8>, cmm: CMMDefs.CMM?, keyring: KeyringDefs.Keyring?) {
    static function method WithCMM(message: seq<uint8>, cmm: CMMDefs.CMM): DecryptRequest
      requires cmm.Valid()
      reads cmm.Repr
      decreases cmm.Repr, message, cmm
    {
      DecryptRequest(message, cmm, null)
    }

    static function method WithKeyring(message: seq<uint8>, keyring: KeyringDefs.Keyring): DecryptRequest
      requires keyring.Valid()
      reads keyring.Repr
      decreases keyring.Repr, message, keyring
    {
      DecryptRequest(message, null, keyring)
    }
  }

  datatype DecryptResultWithVerificationInfo = DecryptResultWithVerificationInfo(plaintext: seq<uint8>, ghost header: Msg.Header, ghost hbSeq: seq<uint8>, ghost frames: seq<MessageBody.Frame>, ghost signature: Option<seq<uint8>>)

  const DEFAULT_FRAME_LENGTH: uint32 := 4096

  function SerializeMessageWithSignature(headerBody: Msg.HeaderBody, headerAuthentication: Msg.HeaderAuthentication, frames: seq<MessageBody.Frame>, signature: seq<uint8>): (message: seq<uint8>)
    requires forall frame: MessageBody.Frame | frame in frames :: frame.Valid()
    requires headerBody.Valid()
    requires |signature| < UINT16_LIMIT
    decreases headerBody, headerAuthentication, frames, signature
  {
    ghost var serializedSignature: seq<uint8> := UInt16ToSeq(|signature| as uint16) + signature;
    SerializeMessageWithoutSignature(headerBody, headerAuthentication, frames) + serializedSignature
  }

  function SerializeMessageWithoutSignature(headerBody: Msg.HeaderBody, headerAuthentication: Msg.HeaderAuthentication, frames: seq<MessageBody.Frame>): (message: seq<uint8>)
    requires forall frame: MessageBody.Frame | frame in frames :: frame.Valid()
    requires headerBody.Valid()
    decreases headerBody, headerAuthentication, frames
  {
    ghost var serializedHeaderBody: seq<uint8> := (reveal Msg.HeaderBodyToSeq(); Msg.HeaderBodyToSeq(headerBody));
    ghost var serializedHeaderAuthentication: seq<uint8> := headerAuthentication.iv + headerAuthentication.authenticationTag;
    ghost var serializedFrames: seq<uint8> := MessageBody.FramesToSequence(frames);
    serializedHeaderBody + serializedHeaderAuthentication + serializedFrames
  }

  predicate ValidHeaderBodyForRequest(headerBody: Msg.HeaderBody, request: EncryptRequest)
    decreases headerBody, request
  {
    headerBody.Valid() &&
    headerBody.version == Msg.VERSION_1 &&
    headerBody.typ == Msg.TYPE_CUSTOMER_AED &&
    (exists material: Materials.ValidEncryptionMaterials | CMMDefs.EncryptionMaterialsSignature(material) :: 
      headerBody.algorithmSuiteID == material.algorithmSuiteID &&
      headerBody.aad == material.encryptionContext &&
      headerBody.encryptedDataKeys == Msg.EncryptedDataKeys(material.encryptedDataKeys)) &&
    headerBody.contentType == Msg.ContentType.Framed &&
    headerBody.frameLength == if request.frameLength.Some? then request.frameLength.value else DEFAULT_FRAME_LENGTH
  }

  predicate ValidHeaderAuthenticationForRequest(headerAuthentication: Msg.HeaderAuthentication, headerBody: Msg.HeaderBody)
    requires headerBody.Valid()
    decreases headerAuthentication, headerBody
  {
    ghost var serializedHeaderBody: seq<uint8> := (reveal Msg.HeaderBodyToSeq(); Msg.HeaderBodyToSeq(headerBody));
    headerAuthentication.iv == seq(headerBody.algorithmSuiteID.IVLength(), (_: int) => 0) &&
    Msg.HeaderAuthenticationMatchesHeaderBody(headerAuthentication, headerBody) &&
    exists encryptionOutput: AESEncryption.EncryptionOutput, cipherkey: seq<uint8> | IsDerivedKey(cipherkey) :: 
      AESEncryption.EncryptedWithKey(encryptionOutput.cipherText, cipherkey)
  }

  predicate ValidFramesForRequest(frames: seq<MessageBody.Frame>, request: EncryptRequest, headerBody: Msg.HeaderBody)
    decreases frames, request, headerBody
  {
    (forall frame: MessageBody.Frame | frame in frames :: 
      frame.Valid()) &&
    MessageBody.FramesEncryptPlaintext(frames, request.plaintext) &&
    (forall frame: MessageBody.Frame | frame in frames :: 
      |frame.iv| == headerBody.algorithmSuiteID.IVLength()) &&
    exists cipherkey: seq<uint8> | IsDerivedKey(cipherkey) :: 
      forall frame: MessageBody.Frame | frame in frames :: 
        AESEncryption.EncryptedWithKey(frame.encContent, cipherkey)
  }

  predicate ValidSignatureForRequest(signature: seq<uint8>, headerBody: Msg.HeaderBody, headerAuthentication: Msg.HeaderAuthentication, frames: seq<MessageBody.Frame>)
    requires forall frame: MessageBody.Frame | frame in frames :: frame.Valid()
    requires headerBody.Valid()
    decreases signature, headerBody, headerAuthentication, frames
  {
    ghost var serializedMessage: seq<uint8> := SerializeMessageWithoutSignature(headerBody, headerAuthentication, frames);
    |signature| < UINT16_LIMIT &&
    exists material: Materials.ValidEncryptionMaterials | CMMDefs.EncryptionMaterialsSignature(material) && material.signingKey.Some? :: 
      Signature.IsSigned(material.signingKey.value, serializedMessage, signature)
  }

  method Encrypt(request: EncryptRequest) returns (res: Result<seq<uint8>, string>)
    requires request.cmm != null ==> request.cmm.Valid()
    requires request.keyring != null ==> request.keyring.Valid()
    modifies if request.cmm == null then {} else request.cmm.Repr, if request.keyring == null then {} else request.keyring.Repr
    ensures request.cmm != null ==> request.cmm.Valid()
    ensures request.cmm != null ==> fresh(request.cmm.Repr - old(request.cmm.Repr))
    ensures request.cmm == null && request.keyring == null ==> res.Failure?
    ensures request.cmm != null && request.keyring != null ==> res.Failure?
    ensures request.algorithmSuiteID.Some? && request.algorithmSuiteID.value !in AlgorithmSuite.VALID_IDS ==> res.Failure?
    ensures request.frameLength.Some? && request.frameLength.value == 0 ==> res.Failure?
    ensures match res { case Success(_mcc#0) => (var encryptedSequence := _mcc#0; exists headerBody, headerAuthentication, frames :: ValidHeaderBodyForRequest(headerBody, request) && ValidHeaderAuthenticationForRequest(headerAuthentication, headerBody) && ValidFramesForRequest(frames, request, headerBody) && match headerBody.algorithmSuiteID.SignatureType() { case Some(_v1) => (exists signature | ValidSignatureForRequest(signature, headerBody, headerAuthentication, frames) :: encryptedSequence == SerializeMessageWithSignature(headerBody, headerAuthentication, frames, signature)) case None => encryptedSequence == SerializeMessageWithoutSignature(headerBody, headerAuthentication, frames) }) case Failure(_mcc#1) => var e := _mcc#1; true }
    decreases request
  {
    if request.cmm != null && request.keyring != null {
      return Failure(""EncryptRequest.keyring OR EncryptRequest.cmm must be set (not both)."");
    } else if request.cmm == null && request.keyring == null {
      return Failure(""EncryptRequest.cmm and EncryptRequest.keyring cannot both be null."");
    } else if request.algorithmSuiteID.Some? && request.algorithmSuiteID.value !in AlgorithmSuite.VALID_IDS {
      return Failure(""Invalid algorithmSuiteID."");
    } else if request.frameLength.Some? && request.frameLength.value == 0 {
      return Failure(""Request frameLength must be > 0"");
    }
    var cmm: CMMDefs.CMM;
    if request.keyring == null {
      cmm := request.cmm;
    } else {
      cmm := new DefaultCMMDef.DefaultCMM.OfKeyring(request.keyring);
    }
    var frameLength := if request.frameLength.Some? then request.frameLength.value else DEFAULT_FRAME_LENGTH;
    var algorithmSuiteID := if request.algorithmSuiteID.Some? then Some(request.algorithmSuiteID.value as AlgorithmSuite.ID) else None;
    var encMatRequest := Materials.EncryptionMaterialsRequest(request.encryptionContext, algorithmSuiteID, Some(request.plaintextLength as nat));
    var encMat :- cmm.GetEncryptionMaterials(encMatRequest);
    if UINT16_LIMIT <= |encMat.encryptedDataKeys| {
      return Failure(""Number of EDKs exceeds the allowed maximum."");
    }
    var messageID: Msg.MessageID :- Random.GenerateBytes(Msg.MESSAGE_ID_LEN as int32);
    var derivedDataKey := DeriveKey(encMat.plaintextDataKey.value, encMat.algorithmSuiteID, messageID);
    var headerBody := Msg.HeaderBody(Msg.VERSION_1, Msg.TYPE_CUSTOMER_AED, encMat.algorithmSuiteID, messageID, encMat.encryptionContext, Msg.EncryptedDataKeys(encMat.encryptedDataKeys), Msg.ContentType.Framed, encMat.algorithmSuiteID.IVLength() as uint8, frameLength);
    assert ValidHeaderBodyForRequest(headerBody, request);
    ghost var serializedHeaderBody := (reveal Msg.HeaderBodyToSeq(); Msg.HeaderBodyToSeq(headerBody));
    var wr := new Streams.ByteWriter();
    var _ :- Serialize.SerializeHeaderBody(wr, headerBody);
    var unauthenticatedHeader := wr.GetDataWritten();
    assert unauthenticatedHeader == serializedHeaderBody;
    var iv: seq<uint8> := seq(encMat.algorithmSuiteID.IVLength(), (_: int) => 0);
    var encryptionOutput :- AESEncryption.AESEncryptExtern(encMat.algorithmSuiteID.EncryptionSuite(), iv, derivedDataKey, [], unauthenticatedHeader);
    var headerAuthentication := Msg.HeaderAuthentication(iv, encryptionOutput.authTag);
    assert ValidHeaderAuthenticationForRequest(headerAuthentication, headerBody) by {
      assert headerAuthentication.iv == seq(headerBody.algorithmSuiteID.IVLength(), (_: int) => 0);
      assert Msg.HeaderAuthenticationMatchesHeaderBody(headerAuthentication, headerBody);
      assert IsDerivedKey(derivedDataKey) && AESEncryption.EncryptedWithKey(encryptionOutput.cipherText, derivedDataKey);
    }
    ghost var serializedHeaderAuthentication := headerAuthentication.iv + headerAuthentication.authenticationTag;
    assert request.cmm != null ==> request.cmm.Valid();
    var _ :- Serialize.SerializeHeaderAuthentication(wr, headerAuthentication, encMat.algorithmSuiteID);
    assert wr.GetDataWritten() == serializedHeaderBody + serializedHeaderAuthentication;
    var seqWithGhostFrames :- MessageBody.EncryptMessageBody(request.plaintext, frameLength as int, messageID, derivedDataKey, encMat.algorithmSuiteID);
    var body := seqWithGhostFrames.sequence;
    ghost var frames := seqWithGhostFrames.frames;
    assert ValidFramesForRequest(frames, request, headerBody) && body == MessageBody.FramesToSequence(frames) by {
      assert forall frame: MessageBody.Frame | frame in frames :: frame.Valid();
      assert MessageBody.FramesEncryptPlaintext(frames, request.plaintext);
      assert forall frame: MessageBody.Frame | frame in frames :: |frame.iv| == headerBody.algorithmSuiteID.IVLength();
      assert IsDerivedKey(derivedDataKey);
      assert forall frame: MessageBody.Frame | frame in frames :: AESEncryption.EncryptedWithKey(frame.encContent, derivedDataKey);
    }
    var msg := wr.GetDataWritten() + body;
    if encMat.algorithmSuiteID.SignatureType().Some? {
      var ecdsaParams := encMat.algorithmSuiteID.SignatureType().value;
      var bytes :- Signature.Sign(ecdsaParams, encMat.signingKey.value, msg);
      if |bytes| != ecdsaParams.SignatureLength() as int {
        return Failure(""Malformed response from Sign()."");
      }
      var signature := UInt16ToSeq(|bytes| as uint16) + bytes;
      assert ValidSignatureForRequest(bytes, headerBody, headerAuthentication, frames) by {
        assert |signature| < UINT16_LIMIT;
        assert Signature.IsSigned(encMat.signingKey.value, msg, bytes);
      }
      msg := msg + signature;
      assert headerBody.algorithmSuiteID.SignatureType().Some?;
      assert msg == SerializeMessageWithSignature(headerBody, headerAuthentication, frames, bytes);
      return Success(msg);
    } else {
      assert msg == SerializeMessageWithoutSignature(headerBody, headerAuthentication, frames);
      return Success(msg);
    }
  }

  method DeriveKey(plaintextDataKey: seq<uint8>, algorithmSuiteID: AlgorithmSuite.ID, messageID: Msg.MessageID)
      returns (derivedDataKey: seq<uint8>)
    requires |plaintextDataKey| == algorithmSuiteID.KDFInputKeyLength()
    ensures |derivedDataKey| == algorithmSuiteID.KeyLength()
    ensures IsDerivedKey(derivedDataKey)
    decreases plaintextDataKey, algorithmSuiteID, messageID
  {
    var algorithm := AlgorithmSuite.Suite[algorithmSuiteID].hkdf;
    if algorithm == KeyDerivationAlgorithms.IDENTITY {
      assert IsDerivedKey(plaintextDataKey) by {
        reveal IsDerivedKey();
      }
      return plaintextDataKey;
    }
    var infoSeq := UInt16ToSeq(algorithmSuiteID as uint16) + messageID;
    var len := algorithmSuiteID.KeyLength();
    var derivedKey := HKDF.Hkdf(algorithm, None, plaintextDataKey, infoSeq, len);
    assert IsDerivedKey(derivedKey) by {
      reveal IsDerivedKey();
    }
    return derivedKey;
  }

  predicate {:opaque} {:fuel 0, 0} IsDerivedKey(derivedDataKey: seq<uint8>)
    decreases derivedDataKey
  {
    true
  }

  method Decrypt(request: DecryptRequest) returns (res: Result<seq<uint8>, string>)
    requires request.cmm != null ==> request.cmm.Valid()
    requires request.keyring != null ==> request.keyring.Valid()
    modifies if request.cmm == null then {} else request.cmm.Repr, if request.keyring == null then {} else request.keyring.Repr
    ensures request.cmm != null ==> request.cmm.Valid()
    ensures request.cmm != null ==> fresh(request.cmm.Repr - old(request.cmm.Repr))
    ensures request.cmm == null && request.keyring == null ==> res.Failure?
    ensures request.cmm != null && request.keyring != null ==> res.Failure?
    decreases request
  {
    var decryptWithVerificationInfo :- DecryptWithVerificationInfo(request);
    return Success(decryptWithVerificationInfo.plaintext);
  }

  method DecryptWithVerificationInfo(request: DecryptRequest) returns (res: Result<DecryptResultWithVerificationInfo, string>)
    requires request.cmm != null ==> request.cmm.Valid()
    requires request.keyring != null ==> request.keyring.Valid()
    modifies if request.cmm == null then {} else request.cmm.Repr, if request.keyring == null then {} else request.keyring.Repr
    ensures request.cmm != null ==> request.cmm.Valid()
    ensures request.cmm != null ==> fresh(request.cmm.Repr - old(request.cmm.Repr))
    ensures request.cmm == null && request.keyring == null ==> res.Failure?
    ensures request.cmm != null && request.keyring != null ==> res.Failure?
    ensures match res { case Success(_mcc#0) => (var d := _mcc#0; d.header.body.Valid() && Msg.IsSerializationOfHeaderBody(d.hbSeq, d.header.body) && (d.header.body.contentType.Framed? ==> (forall frame: MessageBody.Frame | frame in d.frames :: frame.Valid()) && MessageBody.FramesEncryptPlaintext(d.frames, d.plaintext) && match d.signature { case Some(_v6) => |d.signature.value| < UINT16_LIMIT && request.message == d.hbSeq + d.header.auth.iv + d.header.auth.authenticationTag + MessageBody.FramesToSequence(d.frames) + UInt16ToSeq(|d.signature.value| as uint16) + d.signature.value case None => request.message == d.hbSeq + d.header.auth.iv + d.header.auth.authenticationTag + MessageBody.FramesToSequence(d.frames) })) case Failure(_mcc#1) => var e := _mcc#1; true }
    decreases request
  {
    if request.cmm != null && request.keyring != null {
      return Failure(""DecryptRequest.keyring OR DecryptRequest.cmm must be set (not both)."");
    } else if request.cmm == null && request.keyring == null {
      return Failure(""DecryptRequest.cmm and DecryptRequest.keyring cannot both be null."");
    }
    var cmm: CMMDefs.CMM;
    if request.keyring == null {
      cmm := request.cmm;
    } else {
      cmm := new DefaultCMMDef.DefaultCMM.OfKeyring(request.keyring);
    }
    var rd := new Streams.ByteReader(request.message);
    var deserializeHeaderResult :- Deserialize.DeserializeHeader(rd);
    var header := deserializeHeaderResult.header;
    if header.body.contentType.Framed? {
      assert HeaderBySequence(header, deserializeHeaderResult.hbSeq, rd.reader.data[..rd.reader.pos]) by {
        reveal HeaderBySequence();
        assert header.body.contentType.Framed?;
        assert header.body.Valid();
        assert Msg.IsSerializationOfHeaderBody(deserializeHeaderResult.hbSeq, header.body);
        assert rd.reader.data[..rd.reader.pos] == deserializeHeaderResult.hbSeq + header.auth.iv + header.auth.authenticationTag;
      }
      assert DataIsFramed(request.message) by {
        assert 0 <= rd.reader.pos <= |request.message|;
        assert rd.reader.data[..rd.reader.pos] == request.message[..rd.reader.pos];
        assert HeaderBySequence(header, deserializeHeaderResult.hbSeq, request.message[..rd.reader.pos]);
      }
    }
    var decMatRequest := Materials.DecryptionMaterialsRequest(header.body.algorithmSuiteID, header.body.encryptedDataKeys.entries, header.body.aad);
    var decMat :- cmm.DecryptMaterials(decMatRequest);
    var decryptionKey := DeriveKey(decMat.plaintextDataKey.value, decMat.algorithmSuiteID, header.body.messageID);
    ghost var endHeaderPos := rd.reader.pos;
    var plaintext;
    match header.body.contentType {
      case {:split false} NonFramed() =>
        plaintext :- MessageBody.DecryptNonFramedMessageBody(rd, decMat.algorithmSuiteID, decryptionKey, header.body.messageID);
      case {:split false} Framed() =>
        plaintext :- MessageBody.DecryptFramedMessageBody(rd, decMat.algorithmSuiteID, decryptionKey, header.body.frameLength as int, header.body.messageID);
    }
    assert header.body.contentType.Framed? ==> exists frames: seq<MessageBody.Frame> | |frames| < UINT32_LIMIT && (forall frame: MessageBody.Frame | frame in frames :: frame.Valid()) && MessageBody.FramesToSequence(frames) == rd.reader.data[endHeaderPos .. rd.reader.pos] :: true && MessageBody.FramesEncryptPlaintext(frames, plaintext);
    ghost var frames: seq<MessageBody.Frame> :| header.body.contentType.Framed? ==> |frames| < UINT32_LIMIT && (forall frame: MessageBody.Frame | frame in frames :: frame.Valid()) && MessageBody.FramesToSequence(frames) == rd.reader.data[endHeaderPos .. rd.reader.pos] && MessageBody.FramesEncryptPlaintext(frames, plaintext);
    if header.body.contentType.Framed? {
      assert FramesBySequence(frames, rd.reader.data[endHeaderPos .. rd.reader.pos]) by {
        reveal FramesBySequence();
        assert |frames| < UINT32_LIMIT;
        assert forall frame: MessageBody.Frame | frame in frames :: frame.Valid();
        assert rd.reader.data[endHeaderPos .. rd.reader.pos] == MessageBody.FramesToSequence(frames);
      }
      assert HeaderBySequence(header, deserializeHeaderResult.hbSeq, rd.reader.data[..endHeaderPos]) by {
        assert endHeaderPos == |deserializeHeaderResult.hbSeq| + |header.auth.iv + header.auth.authenticationTag|;
        assert HeaderBySequence(header, deserializeHeaderResult.hbSeq, rd.reader.data[..endHeaderPos]);
      }
      assert FramesBySequence(frames, rd.reader.data[endHeaderPos .. rd.reader.pos]);
    }
    ghost var signature: Option<seq<uint8>> := None;
    ghost var endFramePos := rd.reader.pos;
    assert header.body.contentType.Framed? ==> 0 <= endHeaderPos <= endFramePos <= |request.message|;
    if decMat.algorithmSuiteID.SignatureType().Some? {
      var verifyResult, locSig := VerifySignature(rd, decMat);
      signature := Some(locSig);
      if verifyResult.Failure? {
        return Failure(verifyResult.error);
      }
      assert SignatureBySequence(signature.value, rd.reader.data[endFramePos .. rd.reader.pos]);
    }
    var isDone := rd.IsDoneReading();
    if !isDone {
      return Failure(""message contains additional bytes at end"");
    }
    if header.body.contentType.Framed? {
      if decMat.algorithmSuiteID.SignatureType().Some? {
        assert signature.Some?;
        assert SignatureBySequence(signature.value, rd.reader.data[endFramePos .. rd.reader.pos]);
        assert HeaderBySequence(header, deserializeHeaderResult.hbSeq, request.message[..endHeaderPos]) && FramesBySequence(frames, request.message[endHeaderPos .. endFramePos]) && SignatureBySequence(signature.value, request.message[endFramePos..]) by {
          assert 0 <= endHeaderPos <= endFramePos <= |request.message|;
          assert SignatureBySequence(signature.value, request.message[endFramePos..]) by {
            assert header.body.contentType.Framed? ==> SignatureBySequence(signature.value, rd.reader.data[endFramePos .. rd.reader.pos]);
            assert rd.reader.data[endFramePos .. rd.reader.pos] == request.message[endFramePos..] by {
              calc {
                rd.reader.data[endFramePos .. rd.reader.pos];
              ==
                {
                  UpperBoundRemv(rd.reader.data, endFramePos);
                  assert rd.reader.pos == |rd.reader.data|;
                }
                rd.reader.data[endFramePos..];
              ==
                {
                  assert rd.reader.data == request.message;
                }
                request.message[endFramePos..];
              }
            }
            assert SignatureBySequence(signature.value, rd.reader.data[endFramePos .. rd.reader.pos]);
          }
        }
        HBandMBwithSigMatchSequence(header, deserializeHeaderResult.hbSeq, frames, signature.value, request.message);
      } else {
        assert signature.None?;
        assert 0 <= endHeaderPos <= |request.message| by {
          assert request.message == rd.reader.data;
        }
        assert HeaderBySequence(header, deserializeHeaderResult.hbSeq, request.message[..endHeaderPos]) && FramesBySequence(frames, request.message[endHeaderPos..]) by {
          assert HeaderBySequence(header, deserializeHeaderResult.hbSeq, rd.reader.data[..endHeaderPos]) && FramesBySequence(frames, rd.reader.data[endHeaderPos .. rd.reader.pos]);
          assert rd.reader.data[endHeaderPos .. rd.reader.pos] == request.message[endHeaderPos..] by {
            calc {
              rd.reader.data[endHeaderPos .. rd.reader.pos];
            ==
              {
                UpperBoundRemv(rd.reader.data, endHeaderPos);
              }
              rd.reader.data[endHeaderPos..];
            ==
              {
                assert rd.reader.data == request.message;
              }
              request.message[endHeaderPos..];
            }
          }
        }
        assert 0 <= endHeaderPos <= |request.message|;
        HBandMBMatchSequence(header, deserializeHeaderResult.hbSeq, frames, request.message);
      }
    }
    var decryptResultWithVerificationInfo := DecryptResultWithVerificationInfo(plaintext, header, deserializeHeaderResult.hbSeq, frames, signature);
    return Success(decryptResultWithVerificationInfo);
  }

  method VerifySignature(rd: Streams.ByteReader, decMat: Materials.ValidDecryptionMaterials)
      returns (res: Result<(), string>, ghost signature: seq<uint8>)
    requires rd.Valid()
    requires decMat.algorithmSuiteID.SignatureType().Some?
    modifies rd.reader`pos
    ensures rd.Valid()
    ensures match res { case Success(_mcc#0) => 2 <= old(rd.reader.pos) + 2 <= rd.reader.pos && SignatureBySequence(signature, rd.reader.data[old(rd.reader.pos) .. rd.reader.pos]) case Failure(_mcc#1) => true }
    decreases rd, decMat
  {
    var ecdsaParams := decMat.algorithmSuiteID.SignatureType().value;
    var usedCapacity := rd.GetSizeRead();
    assert usedCapacity == rd.reader.pos;
    var msg := rd.reader.data[..usedCapacity];
    var signatureLengthResult := rd.ReadUInt16();
    if signatureLengthResult.Failure? {
      return Failure(signatureLengthResult.error), [];
    }
    var sigResult := rd.ReadBytes(signatureLengthResult.value as nat);
    if sigResult.Failure? {
      return Failure(sigResult.error), [];
    }
    var signatureVerifiedResult := Signature.Verify(ecdsaParams, decMat.verificationKey.value, msg, sigResult.value);
    if signatureVerifiedResult.Failure? {
      return Failure(signatureVerifiedResult.error), [];
    }
    if !signatureVerifiedResult.value {
      return Failure(""signature not verified""), [];
    }
    assert SignatureBySequence(sigResult.value, rd.reader.data[old(rd.reader.pos) .. rd.reader.pos]) by {
      reveal SignatureBySequence();
    }
    return Success(()), sigResult.value;
  }

  predicate {:opaque} {:fuel 0, 0} HeaderBySequence(header: Msg.Header, hbSeq: seq<uint8>, sequence: seq<uint8>)
    decreases header, hbSeq, sequence
  {
    header.body.contentType.Framed? &&
    header.body.Valid() &&
    Msg.IsSerializationOfHeaderBody(hbSeq, header.body) &&
    sequence == hbSeq + header.auth.iv + header.auth.authenticationTag
  }

  predicate {:opaque} {:fuel 0, 0} FramesBySequence(frames: seq<MessageBody.Frame>, sequence: seq<uint8>)
    decreases frames, sequence
  {
    |frames| < UINT32_LIMIT &&
    (forall frame: MessageBody.Frame | frame in frames :: 
      frame.Valid()) &&
    sequence == MessageBody.FramesToSequence(frames)
  }

  predicate {:opaque} {:fuel 0, 0} SignatureBySequence(signature: seq<uint8>, sequence: seq<uint8>)
    decreases signature, sequence
  {
    |signature| < UINT16_LIMIT &&
    sequence == UInt16ToSeq(|signature| as uint16) + signature
  }

  lemma /*{:_induction frames}*/ HBandMBMatchSequence(header: Msg.Header, hbSeq: seq<uint8>, frames: seq<MessageBody.Frame>, message: seq<uint8>)
    requires forall frame: MessageBody.Frame | frame in frames :: frame.Valid()
    requires |message| >= |hbSeq| + |header.auth.iv + header.auth.authenticationTag|
    requires exists headerLength: int | 0 <= headerLength <= |message| :: HeaderBySequence(header, hbSeq, message[..headerLength]) && FramesBySequence(frames, message[headerLength..])
    ensures message == hbSeq + header.auth.iv + header.auth.authenticationTag + MessageBody.FramesToSequence(frames)
    decreases header, hbSeq, frames, message
  {
    reveal HeaderBySequence(), FramesBySequence();
  }

  lemma /*{:_induction frames}*/ HBandMBwithSigMatchSequence(header: Msg.Header, hbSeq: seq<uint8>, frames: seq<MessageBody.Frame>, signature: seq<uint8>, message: seq<uint8>)
    requires forall frame: MessageBody.Frame | frame in frames :: frame.Valid()
    requires |message| >= |hbSeq| + |header.auth.iv + header.auth.authenticationTag| + |MessageBody.FramesToSequence(frames)|
    requires exists headerLength: int, frameLength: int | 0 <= headerLength <= frameLength < |message| :: HeaderBySequence(header, hbSeq, message[..headerLength]) && FramesBySequence(frames, message[headerLength .. frameLength]) && SignatureBySequence(signature, message[frameLength..])
    ensures |signature| < UINT16_LIMIT && message == hbSeq + header.auth.iv + header.auth.authenticationTag + MessageBody.FramesToSequence(frames) + UInt16ToSeq(|signature| as uint16) + signature
    decreases header, hbSeq, frames, signature, message
  {
    reveal HeaderBySequence(), FramesBySequence(), SignatureBySequence();
  }

  lemma UpperBoundRemv(sequence: seq<uint8>, lo: int)
    requires 0 <= lo <= |sequence|
    ensures sequence[lo .. |sequence|] == sequence[lo..]
    decreases sequence, lo
  {
  }

  predicate DataIsFramed(sequence: seq<uint8>)
    decreases sequence
  {
    exists i: int, header: Msg.Header, hbSeq: seq<uint8> | 0 <= i <= |sequence| :: 
      HeaderBySequence(header, hbSeq, sequence[..i])
  }
}

module {:extern ""CachingCMMDef""} CachingCMMDef {

  import opened Wrappers = Wrappers

  import opened UInt = StandardLibrary.UInt

  import CMMDefs = CMMDefs

  import AlgorithmSuite = AlgorithmSuite

  import Materials = Materials

  import EncryptionContext = EncryptionContext

  import CryptoDatatypes = CryptoDatatypes

  import Digest = Digest

  import Signature = Signature

  import Streams = Streams

  import Serialize = Serialize

  import MessageHeader = MessageHeader

  import Time = Time

  import Sorting = Sorting
  class CachingCMM extends CMMDefs.CMM {
    const cmm: CMMDefs.CMM
    const cmc: CryptographicMaterialsCache
    const secondsToLiveLimit: nat
    const messageLimit: uint64
    const byteLimit: uint64

    predicate Valid()
      reads this, Repr
      ensures Valid() ==> this in Repr
      decreases Repr + {this}
    {
      this in Repr &&
      cmm in Repr &&
      cmm.Repr <= Repr &&
      this !in cmm.Repr &&
      cmm.Valid() &&
      cmc in Repr &&
      cmc.Repr <= Repr &&
      this !in cmc.Repr &&
      cmc.Valid() &&
      cmm.Repr !! cmc.Repr
    }

    constructor (cmm: CMMDefs.CMM, secondsToLiveLimit: nat)
      requires cmm.Valid() && secondsToLiveLimit != 0
      ensures Valid() && fresh(Repr - old(cmm.Repr))
      ensures this.cmm == cmm
      ensures this.secondsToLiveLimit == secondsToLiveLimit
      decreases cmm, secondsToLiveLimit
    {
      this.secondsToLiveLimit := secondsToLiveLimit;
      this.messageLimit := DEFAULT_MESSAGE_USE_LIMIT_PER_CACHED_KEY;
      this.byteLimit := DEFAULT_BYTE_USE_LIMIT_PER_CACHED_KEY;
      this.cmm := cmm;
      var cmc := new CryptographicMaterialsCache();
      assert cmc in cmc.Repr;
      this.cmc := cmc;
      Repr := {this} + cmm.Repr + cmc.Repr;
    }

    constructor WithMessageLimit(cmm: CMMDefs.CMM, secondsToLiveLimit: nat, messageLimit: uint64)
      requires cmm.Valid() && secondsToLiveLimit != 0
      ensures Valid() && fresh(Repr - old(cmm.Repr))
      ensures this.cmm == cmm
      ensures this.secondsToLiveLimit == secondsToLiveLimit && this.messageLimit == messageLimit
      decreases cmm, secondsToLiveLimit, messageLimit
    {
      this.secondsToLiveLimit := secondsToLiveLimit;
      this.messageLimit := messageLimit;
      this.byteLimit := DEFAULT_BYTE_USE_LIMIT_PER_CACHED_KEY;
      this.cmm := cmm;
      var cmc := new CryptographicMaterialsCache();
      assert cmc in cmc.Repr;
      this.cmc := cmc;
      Repr := {this} + cmm.Repr + cmc.Repr;
    }

    constructor WithLimits(cmm: CMMDefs.CMM, secondsToLiveLimit: nat, messageLimit: uint64, byteLimit: uint64)
      requires cmm.Valid() && secondsToLiveLimit != 0
      ensures Valid() && fresh(Repr - old(cmm.Repr))
      ensures this.cmm == cmm
      ensures this.secondsToLiveLimit == secondsToLiveLimit && this.messageLimit == messageLimit && this.byteLimit == byteLimit
      decreases cmm, secondsToLiveLimit, messageLimit, byteLimit
    {
      this.secondsToLiveLimit := secondsToLiveLimit;
      this.messageLimit := messageLimit;
      this.byteLimit := byteLimit;
      this.cmm := cmm;
      var cmc := new CryptographicMaterialsCache();
      assert cmc in cmc.Repr;
      this.cmc := cmc;
      Repr := {this} + cmm.Repr + cmc.Repr;
    }

    constructor ForTestingOnly_WithZeroTimeToLive(cmm: CMMDefs.CMM)
      requires cmm.Valid()
      ensures Valid() && fresh(Repr - old(cmm.Repr))
      ensures this.cmm == cmm
      ensures this.secondsToLiveLimit == 0
      decreases cmm
    {
      this.secondsToLiveLimit := 0;
      this.messageLimit := DEFAULT_MESSAGE_USE_LIMIT_PER_CACHED_KEY;
      this.byteLimit := DEFAULT_BYTE_USE_LIMIT_PER_CACHED_KEY;
      this.cmm := cmm;
      var cmc := new CryptographicMaterialsCache();
      assert cmc in cmc.Repr;
      this.cmc := cmc;
      Repr := {this} + cmm.Repr + cmc.Repr;
    }

    method GetEncryptionMaterials(materialsRequest: Materials.EncryptionMaterialsRequest) returns (res: Result<Materials.ValidEncryptionMaterials, string>)
      requires Valid()
      modifies Repr
      ensures Valid() && fresh(Repr - old(Repr))
      ensures res.Success? ==> CMMDefs.EncryptionMaterialsSignature(res.value)
      ensures res.Success? ==> res.value.plaintextDataKey.Some? && res.value.Serializable()
      ensures res.Success? ==> res.value.Serializable()
      decreases materialsRequest
    {
      reveal CMMDefs.EncryptionMaterialsSignatureOpaque();
      if materialsRequest.plaintextLength.None? || byteLimit as int < materialsRequest.plaintextLength.value || (materialsRequest.algorithmSuiteID.Some? && materialsRequest.algorithmSuiteID.value.ContainsIdentityKDF()) {
        res := cmm.GetEncryptionMaterials(materialsRequest);
        Repr := Repr + cmm.Repr;
        return;
      }
      var isSerializable := EncryptionContext.CheckSerializable(materialsRequest.encryptionContext);
      if !isSerializable {
        return Failure(""Invalid Encryption Context"");
      }
      var cacheID :- ComputeCacheIDForEncrypt(materialsRequest.algorithmSuiteID, materialsRequest.encryptionContext);
      var entry := cmc.LookupEncrypt(cacheID);
      Repr := Repr + cmc.Repr;
      if entry != null {
        entry.IncrementUse(materialsRequest.plaintextLength.value);
        var currentTime := Time.GetCurrent();
        if entry.expiryTime <= currentTime as nat || messageLimit as nat <= entry.messagesEncrypted || byteLimit as nat < entry.bytesEncrypted {
          cmc.EvictEncrypt(cacheID);
          Repr := Repr + cmc.Repr;
        } else {
          return Success(entry.encMat);
        }
      }
      res := cmm.GetEncryptionMaterials(materialsRequest.(plaintextLength := Some(byteLimit as nat)));
      Repr := Repr + cmm.Repr;
      var encMat :- res;
      entry := cmc.AddEncrypt(cacheID, encMat, secondsToLiveLimit);
      Repr := Repr + cmc.Repr;
      entry.IncrementUse(materialsRequest.plaintextLength.value);
      return Success(encMat);
    }

    method DecryptMaterials(materialsRequest: Materials.ValidDecryptionMaterialsRequest) returns (res: Result<Materials.ValidDecryptionMaterials, string>)
      requires Valid()
      modifies Repr
      ensures Valid() && fresh(Repr - old(Repr))
      ensures res.Success? ==> res.value.plaintextDataKey.Some?
      decreases materialsRequest
    {
      var isSerializable := EncryptionContext.CheckSerializable(materialsRequest.encryptionContext);
      if !isSerializable {
        return Failure(""Invalid Encryption Context"");
      }
      var cacheID :- ComputeCacheIDForDecrypt(materialsRequest);
      var entry := cmc.LookupDecrypt(cacheID);
      Repr := Repr + cmc.Repr;
      if entry != null {
        var currentTime := Time.GetCurrent();
        if entry.expiryTime <= currentTime as nat {
          cmc.EvictDecrypt(cacheID);
          Repr := Repr + cmc.Repr;
        } else {
          return Success(entry.decMat);
        }
      }
      res := cmm.DecryptMaterials(materialsRequest);
      Repr := Repr + cmm.Repr;
      var decMat :- res;
      entry := cmc.AddDecrypt(cacheID, decMat, secondsToLiveLimit);
      Repr := Repr + cmc.Repr;
      return Success(decMat);
    }
  }

  class CryptographicMaterialsCache {
    ghost var Repr: set<object>
    var EncryptMap: map<seq<uint8>, CacheEntryEncrypt>
    var DecryptMap: map<seq<uint8>, CacheEntryDecrypt>

    predicate Valid()
      reads this, Repr
      ensures Valid() ==> this in Repr
      decreases Repr + {this}
    {
      this in Repr &&
      (forall id: seq<uint8> :: 
        id in EncryptMap.Keys ==>
          EncryptMap[id] in Repr &&
          EncryptMap[id].Valid()) &&
      forall id: seq<uint8> :: 
        id in DecryptMap.Keys ==>
          DecryptMap[id] in Repr &&
          DecryptMap[id].Valid()
    }

    constructor ()
      ensures Valid() && fresh(Repr)
    {
      Repr, EncryptMap, DecryptMap := {this}, map[], map[];
    }

    function method LookupEncrypt(cacheID: seq<uint8>): (entry: CacheEntryEncrypt?)
      requires Valid()
      reads Repr
      ensures entry != null ==> entry in Repr && entry.Valid()
      decreases Repr, cacheID
    {
      if cacheID in EncryptMap.Keys then
        EncryptMap[cacheID]
      else
        null
    }

    function method LookupDecrypt(cacheID: seq<uint8>): (entry: CacheEntryDecrypt?)
      requires Valid()
      reads Repr
      ensures entry != null ==> entry in Repr && entry.Valid()
      decreases Repr, cacheID
    {
      if cacheID in DecryptMap.Keys then
        DecryptMap[cacheID]
      else
        null
    }

    method AddEncrypt(cacheID: seq<uint8>, encMat: Materials.ValidEncryptionMaterials, secondsToLiveLimit: nat)
        returns (entry: CacheEntryEncrypt)
      requires Valid()
      requires encMat.Serializable() && encMat.plaintextDataKey.Some?
      modifies Repr
      ensures Valid() && fresh(Repr - old(Repr)) && entry in Repr
      decreases cacheID, encMat, secondsToLiveLimit
    {
      entry := new CacheEntryEncrypt(encMat, secondsToLiveLimit);
      Repr := Repr + {entry};
      EncryptMap := EncryptMap[cacheID := entry];
    }

    method AddDecrypt(cacheID: seq<uint8>, decMat: Materials.ValidDecryptionMaterials, secondsToLiveLimit: nat)
        returns (entry: CacheEntryDecrypt)
      requires Valid()
      requires decMat.plaintextDataKey.Some?
      modifies Repr
      ensures Valid() && fresh(Repr - old(Repr)) && entry in Repr
      decreases cacheID, decMat, secondsToLiveLimit
    {
      entry := new CacheEntryDecrypt(decMat, secondsToLiveLimit);
      Repr := Repr + {entry};
      DecryptMap := DecryptMap[cacheID := entry];
    }

    method EvictEncrypt(cacheID: seq<uint8>)
      requires Valid()
      modifies Repr
      ensures Valid() && fresh(Repr - old(Repr))
      decreases cacheID
    {
      EncryptMap := map id: seq<uint8> {:trigger EncryptMap[id]} {:trigger id in EncryptMap.Keys} | id in EncryptMap.Keys && id != cacheID :: EncryptMap[id];
    }

    method EvictDecrypt(cacheID: seq<uint8>)
      requires Valid()
      modifies Repr
      ensures Valid() && fresh(Repr - old(Repr))
      decreases cacheID
    {
      DecryptMap := map id: seq<uint8> {:trigger DecryptMap[id]} {:trigger id in DecryptMap.Keys} | id in DecryptMap.Keys && id != cacheID :: DecryptMap[id];
    }
  }

  class CacheEntryEncrypt {
    const encMat: Materials.ValidEncryptionMaterials
    const expiryTime: nat
    var messagesEncrypted: nat
    var bytesEncrypted: nat

    predicate Valid()
    {
      encMat.Serializable()
    }

    constructor (encMat: Materials.ValidEncryptionMaterials, secondsToLiveLimit: nat)
      ensures messagesEncrypted == bytesEncrypted == 0
      ensures this.encMat == encMat
      decreases encMat, secondsToLiveLimit
    {
      this.encMat := encMat;
      var currentTime := Time.GetCurrent();
      expiryTime := currentTime as nat + secondsToLiveLimit;
      messagesEncrypted, bytesEncrypted := 0, 0;
    }

    method IncrementUse(byteCount: nat)
      modifies this
      ensures messagesEncrypted == old(messagesEncrypted) + 1
      ensures bytesEncrypted == old(bytesEncrypted) + byteCount
      decreases byteCount
    {
      messagesEncrypted := messagesEncrypted + 1;
      bytesEncrypted := bytesEncrypted + byteCount;
    }
  }

  class CacheEntryDecrypt {
    const decMat: Materials.ValidDecryptionMaterials
    const expiryTime: nat

    predicate Valid()
    {
      decMat.plaintextDataKey.Some?
    }

    constructor (decMat: Materials.ValidDecryptionMaterials, secondsToLiveLimit: nat)
      ensures this.decMat == decMat
      decreases decMat, secondsToLiveLimit
    {
      this.decMat := decMat;
      var currentTime := Time.GetCurrent();
      expiryTime := currentTime as nat + secondsToLiveLimit;
    }
  }

  const DEFAULT_BYTE_USE_LIMIT_PER_CACHED_KEY: uint64 := 9223372036854775807
  const DEFAULT_MESSAGE_USE_LIMIT_PER_CACHED_KEY: uint64 := 4294967296
  const CACHE_ID_HASH_ALGORITHM := CryptoDatatypes.SHA_512

  method ComputeCacheIDForEncrypt(algSuiteID: Option<AlgorithmSuite.ID>, encCtx: EncryptionContext.Map) returns (res: Result<seq<uint8>, string>)
    requires EncryptionContext.Serializable(encCtx)
    decreases algSuiteID, encCtx
  {
    var wr := new Streams.ByteWriter();
    match algSuiteID {
      case {:split false} None() =>
        var _ := wr.WriteByte(0);
      case {:split false} Some(algID) =>
        var _ := wr.WriteByte(1);
        var _ := wr.WriteUInt16(algID as uint16);
    }
    var encCtxWr := new Streams.ByteWriter();
    var _ :- Serialize.SerializeAAD(encCtxWr, encCtx);
    var encCtxEncoding :- Digest.Digest(CACHE_ID_HASH_ALGORITHM, encCtxWr.GetDataWritten());
    var _ := wr.WriteBytes(encCtxEncoding);
    res := Digest.Digest(CACHE_ID_HASH_ALGORITHM, wr.GetDataWritten());
  }

  method ComputeCacheIDForDecrypt(materialsRequest: Materials.ValidDecryptionMaterialsRequest) returns (res: Result<seq<uint8>, string>)
    requires EncryptionContext.Serializable(materialsRequest.encryptionContext)
    decreases materialsRequest
  {
    var i := 0;
    var edkHashes := new seq<uint8>[|materialsRequest.encryptedDataKeys|] ((_: nat) => []);
    while i < |materialsRequest.encryptedDataKeys|
      decreases |materialsRequest.encryptedDataKeys| - i
    {
      var edk := materialsRequest.encryptedDataKeys[i];
      edkHashes[i] :- Digest.Digest(CACHE_ID_HASH_ALGORITHM, MessageHeader.EDKEntryToSeq(edk));
      i := i + 1;
    }
    Sorting.AboutLexicographicByteSeqBelow();
    Sorting.SelectionSort(edkHashes, Sorting.LexicographicByteSeqBelow);
    var wr := new Streams.ByteWriter();
    var _ := wr.WriteUInt16(materialsRequest.algorithmSuiteID as uint16);
    i := 0;
    while i < edkHashes.Length
      invariant wr.Valid()
      decreases edkHashes.Length - i
    {
      var _ := wr.WriteBytes(edkHashes[i]);
      i := i + 1;
    }
    var zeros := seq<uint8>(Digest.Length(CACHE_ID_HASH_ALGORITHM), (_: int) => 0);
    var _ := wr.WriteBytes(zeros);
    var encCtxWr := new Streams.ByteWriter();
    var _ :- Serialize.SerializeAAD(encCtxWr, materialsRequest.encryptionContext);
    var encCtxEncoding :- Digest.Digest(CACHE_ID_HASH_ALGORITHM, encCtxWr.GetDataWritten());
    var _ := wr.WriteBytes(encCtxEncoding);
    res := Digest.Digest(CACHE_ID_HASH_ALGORITHM, wr.GetDataWritten());
  }
}

module {:extern ""DefaultCMMDef""} DefaultCMMDef {

  import opened Wrappers = Wrappers

  import opened UInt = StandardLibrary.UInt

  import Materials = Materials

  import EncryptionContext = EncryptionContext

  import CMMDefs = CMMDefs

  import KeyringDefs = KeyringDefs

  import AlgorithmSuite = AlgorithmSuite

  import Signature = Signature

  import Base64 = Base64

  import MessageHeader = MessageHeader

  import UTF8 = UTF8

  import Deserialize = Deserialize
  class DefaultCMM extends CMMDefs.CMM {
    const keyring: KeyringDefs.Keyring

    predicate Valid()
      reads this, Repr
      ensures Valid() ==> this in Repr
      decreases Repr + {this}
    {
      this in Repr &&
      keyring in Repr &&
      keyring.Repr <= Repr &&
      this !in keyring.Repr &&
      keyring.Valid()
    }

    constructor OfKeyring(k: KeyringDefs.Keyring)
      requires k.Valid()
      ensures keyring == k
      ensures Valid() && fresh(Repr - k.Repr)
      decreases k
    {
      keyring := k;
      Repr := {this} + k.Repr;
    }

    method GetEncryptionMaterials(materialsRequest: Materials.EncryptionMaterialsRequest) returns (res: Result<Materials.ValidEncryptionMaterials, string>)
      requires Valid()
      ensures Valid()
      ensures res.Success? ==> CMMDefs.EncryptionMaterialsSignature(res.value)
      ensures res.Success? ==> res.value.plaintextDataKey.Some? && res.value.Serializable()
      ensures Materials.EC_PUBLIC_KEY_FIELD in materialsRequest.encryptionContext ==> res.Failure?
      ensures res.Success? && (materialsRequest.algorithmSuiteID.None? || materialsRequest.algorithmSuiteID.value.SignatureType().Some?) ==> Materials.EC_PUBLIC_KEY_FIELD in res.value.encryptionContext
      ensures res.Success? ==> res.value.Serializable()
      ensures res.Success? ==> match materialsRequest.algorithmSuiteID { case None => res.value.algorithmSuiteID == 888 case Some(_mcc#0) => var id := _mcc#0; res.value.algorithmSuiteID == id }
      decreases materialsRequest
    {
      reveal CMMDefs.EncryptionMaterialsSignatureOpaque();
      var reservedField := Materials.EC_PUBLIC_KEY_FIELD;
      assert reservedField in Materials.RESERVED_KEY_VALUES;
      if reservedField in materialsRequest.encryptionContext.Keys {
        return Failure(""Reserved Field found in EncryptionContext keys."");
      }
      var id := materialsRequest.algorithmSuiteID.UnwrapOr(AlgorithmSuite.AES_256_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384);
      var enc_sk := None;
      var enc_ctx := materialsRequest.encryptionContext;
      match id.SignatureType() {
        case {:split false} None() =>
        case {:split false} Some(param) =>
          var signatureKeys :- Signature.KeyGen(param);
          enc_sk := Some(signatureKeys.signingKey);
          var enc_vk :- UTF8.Encode(Base64.Encode(signatureKeys.verificationKey));
          enc_ctx := enc_ctx[reservedField := enc_vk];
      }
      var validAAD := EncryptionContext.CheckSerializable(enc_ctx);
      if !validAAD {
        return Failure(""Invalid Encryption Context"");
      }
      assert EncryptionContext.Serializable(enc_ctx);
      var materials := Materials.EncryptionMaterials.WithoutDataKeys(enc_ctx, id, enc_sk);
      assert materials.encryptionContext == enc_ctx;
      materials :- keyring.OnEncrypt(materials);
      if materials.plaintextDataKey.None? || |materials.encryptedDataKeys| == 0 {
        return Failure(""Could not retrieve materials required for encryption"");
      }
      assert materials.Valid();
      return Success(materials);
    }

    method DecryptMaterials(materialsRequest: Materials.ValidDecryptionMaterialsRequest) returns (res: Result<Materials.ValidDecryptionMaterials, string>)
      requires Valid()
      ensures Valid()
      ensures res.Success? ==> res.value.plaintextDataKey.Some?
      decreases materialsRequest
    {
      var vkey := None;
      var algID := materialsRequest.algorithmSuiteID;
      var encCtx := materialsRequest.encryptionContext;
      if algID.SignatureType().Some? {
        var reservedField := Materials.EC_PUBLIC_KEY_FIELD;
        if reservedField !in encCtx {
          return Failure(""Could not get materials required for decryption."");
        }
        var encodedVKey := encCtx[reservedField];
        var utf8Decoded :- UTF8.Decode(encodedVKey);
        var base64Decoded :- Base64.Decode(utf8Decoded);
        vkey := Some(base64Decoded);
      }
      var materials := Materials.DecryptionMaterials.WithoutPlaintextDataKey(encCtx, algID, vkey);
      materials :- keyring.OnDecrypt(materials, materialsRequest.encryptedDataKeys);
      if materials.plaintextDataKey.None? {
        return Failure(""Keyring.OnDecrypt failed to decrypt the plaintext data key."");
      }
      return Success(materials);
    }
  }

  predicate {:opaque} {:fuel 0, 0} DecryptionMaterialsFromDefaultCMM(key: seq<uint8>)
    decreases key
  {
    true
  }
}

module {:extern ""CMMDefs""} CMMDefs {

  import opened Wrappers = Wrappers

  import opened UInt = StandardLibrary.UInt

  import Materials = Materials

  import AlgorithmSuite = AlgorithmSuite

  import Signature = Signature

  import EncryptionContext = EncryptionContext
  trait {:termination false} CMM {
    ghost var Repr: set<object>

    predicate Valid()
      reads this, Repr
      ensures Valid() ==> this in Repr
      decreases Repr + {this}

    method GetEncryptionMaterials(materialsRequest: Materials.EncryptionMaterialsRequest) returns (res: Result<Materials.ValidEncryptionMaterials, string>)
      requires Valid()
      modifies Repr
      ensures Valid()
      ensures res.Success? ==> EncryptionMaterialsSignature(res.value)
      ensures res.Success? ==> res.value.plaintextDataKey.Some? && res.value.Serializable()
      ensures Valid() && fresh(Repr - old(Repr))
      decreases materialsRequest

    static predicate ValidAAD(encryptionContext: EncryptionContext.Map)
      decreases encryptionContext
    {
      EncryptionContext.Serializable(encryptionContext)
    }

    method DecryptMaterials(materialsRequest: Materials.ValidDecryptionMaterialsRequest) returns (res: Result<Materials.ValidDecryptionMaterials, string>)
      requires Valid()
      modifies Repr
      ensures Valid() && fresh(Repr - old(Repr))
      ensures res.Success? ==> res.value.plaintextDataKey.Some?
      decreases materialsRequest
  }

  predicate EncryptionMaterialsSignature(validEncryptionMaterials: Materials.ValidEncryptionMaterials)
    decreases validEncryptionMaterials
  {
    EncryptionMaterialsSignatureOpaque(validEncryptionMaterials)
  }

  predicate {:opaque} {:fuel 0, 0} EncryptionMaterialsSignatureOpaque(validEncryptionMaterials: Materials.ValidEncryptionMaterials)
    decreases validEncryptionMaterials
  {
    true
  }
}

module Deserialize {

  export
    provides DeserializeHeader, Materials, Streams, StandardLibrary, Wrappers, UInt, AlgorithmSuite, Msg, InsertNewEntry, UTF8, EncryptionContext
    reveals DeserializeHeaderResult


  import Msg = MessageHeader

  import AlgorithmSuite = AlgorithmSuite

  import Streams = Streams

  import opened StandardLibrary = StandardLibrary

  import opened Wrappers = Wrappers

  import opened UInt = StandardLibrary.UInt

  import UTF8 = UTF8

  import Materials = Materials

  import EncryptionContext = EncryptionContext
  datatype DeserializeHeaderResult = DeserializeHeaderResult(header: Msg.Header, ghost hbSeq: seq<uint8>)

  method DeserializeHeader(rd: Streams.ByteReader) returns (res: Result<DeserializeHeaderResult, string>)
    requires rd.Valid()
    modifies rd.reader`pos
    ensures rd.Valid()
    ensures match res { case Success(_mcc#0) => (var desres := _mcc#0; desres.header.Valid() && old(rd.reader.pos) <= rd.reader.pos <= |rd.reader.data| && Msg.IsSerializationOfHeaderBody(desres.hbSeq, desres.header.body) && desres.hbSeq + desres.header.auth.iv + desres.header.auth.authenticationTag == rd.reader.data[old(rd.reader.pos) .. rd.reader.pos]) case Failure(_mcc#1) => true }
    decreases rd
  {
    var hb :- DeserializeHeaderBody(rd);
    ghost var hbSeq := rd.reader.data[old(rd.reader.pos) .. rd.reader.pos];
    var auth :- DeserializeHeaderAuthentication(rd, hb.algorithmSuiteID);
    return Success(DeserializeHeaderResult(Msg.Header(hb, auth), hbSeq));
  }

  method DeserializeHeaderBody(rd: Streams.ByteReader) returns (ret: Result<Msg.HeaderBody, string>)
    requires rd.Valid()
    modifies rd.reader`pos
    ensures rd.Valid()
    ensures match ret { case Success(_mcc#0) => (var hb := _mcc#0; hb.Valid() && old(rd.reader.pos) <= rd.reader.pos <= |rd.reader.data| && Msg.IsSerializationOfHeaderBody(rd.reader.data[old(rd.reader.pos) .. rd.reader.pos], hb)) case Failure(_mcc#1) => true }
    decreases rd
  {
    var version :- DeserializeVersion(rd);
    var typ :- DeserializeType(rd);
    var algorithmSuiteID :- DeserializeAlgorithmSuiteID(rd);
    var messageID :- DeserializeMsgID(rd);
    assert [version as uint8] + [typ as uint8] + UInt16ToSeq(algorithmSuiteID as uint16) + messageID == rd.reader.data[old(rd.reader.pos) .. rd.reader.pos];
    ghost var aadStart := rd.reader.pos;
    var aad :- DeserializeAAD(rd);
    ghost var aadEnd := rd.reader.pos;
    var encryptedDataKeys :- DeserializeEncryptedDataKeys(rd);
    var contentType :- DeserializeContentType(rd);
    ghost var reserveStart := rd.reader.pos;
    var _ :- DeserializeReserved(rd);
    ghost var reserveEnd := rd.reader.pos;
    var ivLength :- rd.ReadByte();
    var frameLength :- rd.ReadUInt32();
    if ivLength as nat != algorithmSuiteID.IVLength() {
      return Failure(""Deserialization Error: Incorrect IV length."");
    }
    if contentType.NonFramed? && frameLength != 0 {
      return Failure(""Deserialization Error: Frame length must be 0 when content type is non-framed."");
    } else if contentType.Framed? && frameLength == 0 {
      return Failure(""Deserialization Error: Frame length must be non-0 when content type is framed."");
    }
    reveal Msg.IsSerializationOfHeaderBody();
    var hb := Msg.HeaderBody(version, typ, algorithmSuiteID, messageID, aad, encryptedDataKeys, contentType, ivLength, frameLength);
    assert Msg.IsSerializationOfHeaderBody(rd.reader.data[old(rd.reader.pos) .. rd.reader.pos], hb) by {
      reveal Msg.IsSerializationOfHeaderBody();
      ghost var s := rd.reader.data[old(rd.reader.pos) .. rd.reader.pos];
      ghost var serializedAAD := rd.reader.data[aadStart .. aadEnd];
      assert EncryptionContext.LinearSeqToMap(serializedAAD, aad);
      assert s[0 .. 1] == [hb.version as uint8];
      assert Msg.IsSerializationOfHeaderBodyAux(s, hb, serializedAAD);
    }
    return Success(hb);
  }

  method DeserializeHeaderAuthentication(rd: Streams.ByteReader, algorithmSuiteID: AlgorithmSuite.ID) returns (ret: Result<Msg.HeaderAuthentication, string>)
    requires rd.Valid()
    requires algorithmSuiteID in AlgorithmSuite.Suite.Keys
    modifies rd.reader`pos
    ensures rd.Valid()
    ensures match ret { case Success(_mcc#0) => (var ha := _mcc#0; var bytesRead := algorithmSuiteID.IVLength() + algorithmSuiteID.TagLength(); var serHa := ha.iv + ha.authenticationTag; |ha.iv| == algorithmSuiteID.IVLength() && |ha.authenticationTag| == algorithmSuiteID.TagLength() && old(rd.reader.pos) + bytesRead == rd.reader.pos && serHa == rd.reader.data[old(rd.reader.pos) .. rd.reader.pos]) case Failure(_mcc#1) => true }
    decreases rd, algorithmSuiteID
  {
    var iv :- rd.ReadBytes(algorithmSuiteID.IVLength());
    var authenticationTag :- rd.ReadBytes(algorithmSuiteID.TagLength());
    return Success(Msg.HeaderAuthentication(iv, authenticationTag));
  }

  method DeserializeVersion(rd: Streams.ByteReader) returns (ret: Result<Msg.Version, string>)
    requires rd.Valid()
    modifies rd.reader`pos
    ensures rd.Valid()
    ensures match ret { case Success(_mcc#0) => (var ver := _mcc#0; var bytesRead := 1; var serVer := [ver as uint8]; old(rd.reader.pos) + bytesRead == rd.reader.pos && serVer == rd.reader.data[old(rd.reader.pos) .. rd.reader.pos]) case Failure(_mcc#1) => true }
    decreases rd
  {
    var version :- rd.ReadByte();
    if version == Msg.VERSION_1 {
      return Success(version);
    } else {
      return Failure(""Deserialization Error: Version not supported."");
    }
  }

  method DeserializeType(rd: Streams.ByteReader) returns (ret: Result<Msg.Type, string>)
    requires rd.Valid()
    modifies rd.reader`pos
    ensures rd.Valid()
    ensures match ret { case Success(_mcc#0) => (var typ := _mcc#0; var bytesRead := 1; var serTyp := [typ as uint8]; old(rd.reader.pos) + bytesRead == rd.reader.pos && serTyp == rd.reader.data[old(rd.reader.pos) .. rd.reader.pos]) case Failure(_mcc#1) => true }
    decreases rd
  {
    var typ :- rd.ReadByte();
    if typ == Msg.TYPE_CUSTOMER_AED {
      return Success(typ);
    } else {
      return Failure(""Deserialization Error: Type not supported."");
    }
  }

  method DeserializeAlgorithmSuiteID(rd: Streams.ByteReader) returns (ret: Result<AlgorithmSuite.ID, string>)
    requires rd.Valid()
    modifies rd.reader`pos
    ensures rd.Valid()
    ensures match ret { case Success(_mcc#0) => (var algID := _mcc#0; var bytesRead := 2; var serAlgID := UInt16ToSeq(algID as uint16); old(rd.reader.pos) + bytesRead == rd.reader.pos && serAlgID == rd.reader.data[old(rd.reader.pos) .. rd.reader.pos]) case Failure(_mcc#1) => true }
    decreases rd
  {
    var algorithmSuiteID :- rd.ReadUInt16();
    if algorithmSuiteID in AlgorithmSuite.VALID_IDS {
      return Success(algorithmSuiteID as AlgorithmSuite.ID);
    } else {
      return Failure(""Deserialization Error: Algorithm suite not supported."");
    }
  }

  method DeserializeMsgID(rd: Streams.ByteReader) returns (ret: Result<Msg.MessageID, string>)
    requires rd.Valid()
    modifies rd.reader`pos
    ensures rd.Valid()
    ensures match ret { case Success(_mcc#0) => (var messageID := _mcc#0; var bytesRead := |messageID|; var sermessageID := messageID; old(rd.reader.pos) + bytesRead == rd.reader.pos && sermessageID == rd.reader.data[old(rd.reader.pos) .. rd.reader.pos]) case Failure(_mcc#1) => true }
    decreases rd
  {
    var msgID: seq<uint8> :- rd.ReadBytes(Msg.MESSAGE_ID_LEN);
    return Success(msgID);
  }

  method DeserializeUTF8(rd: Streams.ByteReader, n: nat) returns (ret: Result<UTF8.ValidUTF8Bytes, string>)
    requires rd.Valid()
    modifies rd.reader`pos
    ensures rd.Valid()
    ensures ret.Success? ==> var expectedRes: Option<UTF8.ValidUTF8Bytes> := EncryptionContext.GetUTF8(rd.reader.data[old(rd.reader.pos)..], n); expectedRes.Some? && expectedRes.value == ret.value
    ensures match ret { case Success(_mcc#0) => (var bytes := _mcc#0; UTF8.ValidUTF8Seq(bytes) && old(rd.reader.pos) + n == rd.reader.pos && bytes == rd.reader.data[old(rd.reader.pos) .. rd.reader.pos]) case Failure(_mcc#1) => true }
    decreases rd, n
  {
    var bytes :- rd.ReadBytes(n);
    if UTF8.ValidUTF8Seq(bytes) {
      var utf8: UTF8.ValidUTF8Bytes := bytes;
      assert bytes == rd.reader.data[old(rd.reader.pos)..][..n];
      return Success(utf8);
    } else {
      return Failure(""Deserialization Error: Not a valid UTF8 string."");
    }
  }

  method DeserializeAAD(rd: Streams.ByteReader) returns (ret: Result<EncryptionContext.Map, string>)
    requires rd.Valid()
    modifies rd.reader`pos
    ensures rd.Valid()
    ensures match ret { case Success(_mcc#0) => (var aad := _mcc#0; EncryptionContext.Serializable(aad) && old(rd.reader.pos) <= rd.reader.pos <= |rd.reader.data| && EncryptionContext.LinearSeqToMap(rd.reader.data[old(rd.reader.pos) .. rd.reader.pos], aad)) case Failure(_mcc#1) => true }
    decreases rd
  {
    reveal EncryptionContext.Serializable();
    var kvPairsLength :- rd.ReadUInt16();
    if kvPairsLength == 0 {
      return Success(map[]);
    } else if kvPairsLength < 2 {
      return Failure(""Deserialization Error: The number of bytes in encryption context exceeds the given length."");
    }
    var totalBytesRead := 0;
    var kvPairsCount :- rd.ReadUInt16();
    totalBytesRead := totalBytesRead + 2;
    if kvPairsCount == 0 {
      return Failure(""Deserialization Error: Key value pairs count is 0."");
    }
    var kvPairs: EncryptionContext.Linear := [];
    var i := 0;
    ghost var startKvPos := rd.reader.pos;
    ghost var unsortedKvPairs: EncryptionContext.Linear := [];
    while i < kvPairsCount
      invariant startKvPos <= rd.reader.pos
      invariant rd.Valid()
      invariant |kvPairs| == i as int
      invariant i <= kvPairsCount
      invariant |kvPairs| == |unsortedKvPairs|
      invariant forall kvPair: (UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes) :: kvPair in kvPairs <==> kvPair in unsortedKvPairs
      invariant totalBytesRead == 2 + EncryptionContext.LinearLength(kvPairs, 0, i as nat) <= kvPairsLength as nat
      invariant totalBytesRead == |rd.reader.data[old(rd.reader.pos) .. rd.reader.pos]| - 2
      invariant EncryptionContext.SerializableLinear(kvPairs)
      invariant EncryptionContext.SerializableUnsortedLinear(unsortedKvPairs)
      invariant rd.reader.data[startKvPos .. rd.reader.pos] == EncryptionContext.LinearToUnorderedSeq(unsortedKvPairs, 0, |unsortedKvPairs|)
      decreases kvPairsCount as int - i as int
    {
      ghost var oldPosPair := rd.reader.pos;
      ghost var oldKvPairs := kvPairs;
      ghost var oldunsortedKvPairs := unsortedKvPairs;
      var keyLength :- rd.ReadUInt16();
      totalBytesRead := totalBytesRead + 2;
      var key :- DeserializeUTF8(rd, keyLength as nat);
      totalBytesRead := totalBytesRead + |key|;
      var valueLength :- rd.ReadUInt16();
      totalBytesRead := totalBytesRead + 2;
      if kvPairsLength as nat < totalBytesRead + valueLength as nat {
        return Failure(""Deserialization Error: The number of bytes in encryption context exceeds the given length."");
      }
      var value :- DeserializeUTF8(rd, valueLength as nat);
      totalBytesRead := totalBytesRead + |value|;
      var opt, insertionPoint := InsertNewEntry(kvPairs, key, value);
      match opt {
        case {:split false} Some(kvPairs_) =>
          EncryptionContext.LinearInsert(kvPairs, insertionPoint, key, value);
          kvPairs := kvPairs_;
          unsortedKvPairs := unsortedKvPairs + [(key, value)];
        case {:split false} None() =>
          return Failure(""Deserialization Error: Duplicate key."");
      }
      i := i + 1;
      assert EncryptionContext.KVPairToSeq((key, value)) == rd.reader.data[oldPosPair .. rd.reader.pos] by {
        assert rd.reader.data[oldPosPair .. rd.reader.pos] == rd.reader.data[oldPosPair .. oldPosPair + 4 + |key| + |value|];
        assert UInt16ToSeq(|key| as uint16) == rd.reader.data[oldPosPair .. oldPosPair + 2];
        assert key == rd.reader.data[oldPosPair + 2 .. oldPosPair + 2 + |key|];
        assert UInt16ToSeq(|value| as uint16) == rd.reader.data[oldPosPair + 2 + |key| .. oldPosPair + 2 + |key| + 2];
        assert value == rd.reader.data[oldPosPair + 4 + |key| .. oldPosPair + 4 + |key| + |value|];
      }
      assert forall p: (UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes) :: p in oldKvPairs || p == (key, value) <==> p in kvPairs;
      assert rd.reader.data[startKvPos .. rd.reader.pos] == EncryptionContext.LinearToUnorderedSeq(unsortedKvPairs, 0, |unsortedKvPairs|) by {
        EncryptionContext.LinearToUnorderedSeqInductiveStep(oldunsortedKvPairs, [(key, value)], 0, |oldunsortedKvPairs|);
        assert EncryptionContext.LinearToUnorderedSeq(unsortedKvPairs, 0, |unsortedKvPairs| - 1) == rd.reader.data[startKvPos .. oldPosPair];
        assert EncryptionContext.KVPairToSeq(unsortedKvPairs[|unsortedKvPairs| - 1]) == rd.reader.data[oldPosPair .. rd.reader.pos];
        assert rd.reader.data[startKvPos .. rd.reader.pos] == rd.reader.data[startKvPos .. oldPosPair] + rd.reader.data[oldPosPair .. rd.reader.pos];
      }
    }
    if kvPairsLength as nat != totalBytesRead {
      return Failure(""Deserialization Error: Bytes actually read differs from bytes supposed to be read."");
    }
    var encryptionContext: map<UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes> := EncryptionContext.LinearToMap(kvPairs);
    var isValid := EncryptionContext.CheckSerializable(encryptionContext);
    if !isValid || |kvPairs| != |encryptionContext| {
      return Failure(""Deserialization Error: Failed to parse encryption context."");
    }
    SerializationIsValid(rd.reader.data[old(rd.reader.pos) .. rd.reader.pos], encryptionContext, unsortedKvPairs, kvPairs);
    return Success(encryptionContext);
  }

  lemma /*{:_induction unsortedKvPairs, kvPairs}*/ SerializationIsValid(sequence: seq<uint8>, resultMap: EncryptionContext.Map, unsortedKvPairs: EncryptionContext.Linear, kvPairs: EncryptionContext.Linear)
    requires |resultMap| == 0 ==> |sequence| == 2
    requires |resultMap| != 0 ==> 4 <= |sequence|
    requires EncryptionContext.Serializable(resultMap)
    requires |resultMap| == |kvPairs| == |unsortedKvPairs|
    requires forall kvPair: (UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes) :: kvPair in kvPairs <==> kvPair in unsortedKvPairs
    requires EncryptionContext.SerializableUnsortedLinear(unsortedKvPairs)
    requires EncryptionContext.SerializableLinear(kvPairs)
    requires (reveal EncryptionContext.Serializable(); EncryptionContext.Serializable(resultMap) && EncryptionContext.SerializableLinear(kvPairs) ==> EncryptionContext.MapToSeq(resultMap) == if |resultMap| == 0 then [] else UInt16ToSeq(|kvPairs| as uint16) + EncryptionContext.LinearToSeq(kvPairs, 0, |kvPairs|))
    requires |sequence[2..]| < UINT16_LIMIT && sequence[..2] == UInt16ToSeq(|sequence[2..]| as uint16)
    requires |resultMap| != 0 ==> sequence[2..][..2] == UInt16ToSeq(|resultMap| as uint16)
    requires |resultMap| != 0 ==> sequence[4..] == EncryptionContext.LinearToUnorderedSeq(unsortedKvPairs, 0, |unsortedKvPairs|)
    ensures EncryptionContext.LinearSeqToMap(sequence, resultMap)
    decreases sequence, resultMap, unsortedKvPairs, kvPairs
  {
    reveal EncryptionContext.Serializable();
    if |resultMap| == 0 {
    } else {
      assert EncryptionContext.LinearSeqToMap(sequence, resultMap) by {
        assert EncryptionContext.SeqToMap(sequence[2..], resultMap) by {
          EncryptionContext.InsertionSortPreservesProperties(unsortedKvPairs);
          EncryptionContext.SortedSequenceIsUnqiue(kvPairs, EncryptionContext.InsertionSort(unsortedKvPairs));
          assert EncryptionContext.SeqToLinearToMap(sequence[2..], resultMap, unsortedKvPairs, kvPairs) by {
            assert 2 <= |sequence[2..]|;
            assert EncryptionContext.SerializableUnsortedLinear(unsortedKvPairs);
            assert EncryptionContext.SerializableLinear(kvPairs);
            assert EncryptionContext.SerializableKVPairs(resultMap);
            assert sequence[2..][..2] == UInt16ToSeq(|resultMap| as uint16);
            assert EncryptionContext.LinearToUnorderedSeq(unsortedKvPairs, 0, |unsortedKvPairs|) == sequence[2..][2..];
            assert kvPairs == EncryptionContext.InsertionSort(unsortedKvPairs);
            assert EncryptionContext.MapToSeq(resultMap) == sequence[2..][..2] + EncryptionContext.LinearToSeq(kvPairs, 0, |kvPairs|);
          }
          assert sequence[..2] == UInt16ToSeq(|sequence[2..]| as uint16);
        }
      }
    }
  }

  method InsertNewEntry(kvPairs: EncryptionContext.Linear, key: UTF8.ValidUTF8Bytes, value: UTF8.ValidUTF8Bytes)
      returns (res: Option<EncryptionContext.Linear>, ghost insertionPoint: nat)
    requires EncryptionContext.LinearSorted(kvPairs)
    requires forall i: int, j: int | 0 <= i < j < |kvPairs| :: kvPairs[i].0 != kvPairs[j].0
    ensures (exists l: (UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes) | l in kvPairs :: key == l.0) <==> res.None?
    ensures match res { case None => (exists i :: 0 <= i < |kvPairs| && kvPairs[i].0 == key) case Some(_mcc#0) => var kvPairs' := _mcc#0; insertionPoint <= |kvPairs| && kvPairs' == kvPairs[..insertionPoint] + [(key, value)] + kvPairs[insertionPoint..] && EncryptionContext.LinearSorted(kvPairs') && forall i, j | 0 <= i < j < |kvPairs'| :: kvPairs'[i].0 != kvPairs'[j].0 }
    decreases kvPairs, key, value
  {
    var n := |kvPairs|;
    while 0 < n && LexicographicLessOrEqual(key, kvPairs[n - 1].0, UInt.UInt8Less)
      invariant 0 <= n <= |kvPairs|
      invariant forall i: int :: n <= i < |kvPairs| ==> LexicographicLessOrEqual(key, kvPairs[i].0, UInt.UInt8Less)
      invariant forall i: int | n < i < |kvPairs| :: kvPairs[i].0 != key
      decreases n - 0
    {
      n := n - 1;
    }
    EncryptionContext.LinearSortedImpliesStrongLinearSorted(kvPairs);
    if kvPairs != [] && LexicographicLessOrEqual(key, kvPairs[|kvPairs| - 1].0, UInt.UInt8Less) && kvPairs[n].0 == key {
      return None, n;
    } else {
      var kvPairs' := kvPairs[..n] + [(key, value)] + kvPairs[n..];
      if 0 < n {
        LexIsTotal(kvPairs'[n - 1].0, kvPairs'[n].0, UInt.UInt8Less);
      }
      return Some(kvPairs'), n;
    }
  }

  method DeserializeEncryptedDataKeys(rd: Streams.ByteReader) returns (ret: Result<Msg.EncryptedDataKeys, string>)
    requires rd.Valid()
    modifies rd.reader`pos
    ensures rd.Valid()
    ensures match ret { case Success(_mcc#0) => (var edks := _mcc#0; edks.Valid() && var n := |Msg.EDKsToSeq(edks)|; old(rd.reader.pos) + n == rd.reader.pos && Msg.EDKsToSeq(edks) == rd.reader.data[old(rd.reader.pos) .. rd.reader.pos]) case Failure(_mcc#1) => true }
    decreases rd
  {
    var edkCount :- rd.ReadUInt16();
    if edkCount == 0 {
      return Failure(""Deserialization Error: Encrypted data key count is 0."");
    }
    assert rd.reader.pos == old(rd.reader.pos) + 2;
    var edkEntries: seq<Materials.EncryptedDataKey> := [];
    var i := 0;
    while i < edkCount
      invariant old(rd.reader.pos) + 2 <= rd.reader.pos
      invariant rd.Valid()
      invariant i <= edkCount
      invariant |edkEntries| == i as int
      invariant forall i: int :: 0 <= i < |edkEntries| ==> edkEntries[i].Valid()
      invariant Msg.EDKEntriesToSeq(edkEntries, 0, |edkEntries|) == rd.reader.data[old(rd.reader.pos) + 2 .. rd.reader.pos]
      decreases edkCount as int - i as int
    {
      ghost var invStartPos := rd.reader.pos;
      var keyProviderIDLength :- rd.ReadUInt16();
      var str :- DeserializeUTF8(rd, keyProviderIDLength as nat);
      var keyProviderID := str;
      var keyProviderInfoLength :- rd.ReadUInt16();
      var keyProviderInfo :- rd.ReadBytes(keyProviderInfoLength as nat);
      var edkLength :- rd.ReadUInt16();
      var edk :- rd.ReadBytes(edkLength as nat);
      edkEntries := edkEntries + [Materials.EncryptedDataKey(keyProviderID, keyProviderInfo, edk)];
      i := i + 1;
      assert invStartPos < rd.reader.pos;
      assert Msg.EDKEntriesToSeq(edkEntries, 0, |edkEntries|) == rd.reader.data[old(rd.reader.pos) + 2 .. rd.reader.pos] by {
        assert Msg.EDKEntryToSeq(Materials.EncryptedDataKey(keyProviderID, keyProviderInfo, edk)) == rd.reader.data[invStartPos .. rd.reader.pos];
        Msg.EDKEntriesToSeqInductiveStep(edkEntries[..|edkEntries| - 1], [Materials.EncryptedDataKey(keyProviderID, keyProviderInfo, edk)], 0, |edkEntries[..|edkEntries| - 1]|);
      }
    }
    assert |edkEntries| == edkCount as int;
    var edks := Msg.EncryptedDataKeys(edkEntries);
    return Success(edks);
  }

  method DeserializeContentType(rd: Streams.ByteReader) returns (ret: Result<Msg.ContentType, string>)
    requires rd.Valid()
    modifies rd.reader`pos
    ensures rd.Valid()
    ensures match ret { case Success(_mcc#0) => (var contentType := _mcc#0; old(rd.reader.pos) + 1 == rd.reader.pos && [Msg.ContentTypeToUInt8(contentType)] == rd.reader.data[old(rd.reader.pos) .. rd.reader.pos]) case Failure(_mcc#1) => true }
    decreases rd
  {
    var byte :- rd.ReadByte();
    match Msg.UInt8ToContentType(byte)
    case {:split false} None() =>
      return Failure(""Deserialization Error: Content type not supported."");
    case {:split false} Some(contentType) =>
      return Success(contentType);
  }

  method DeserializeReserved(rd: Streams.ByteReader) returns (ret: Result<seq<uint8>, string>)
    requires rd.Valid()
    modifies rd.reader`pos
    ensures rd.Valid()
    ensures match ret { case Success(_mcc#0) => (var contnetType := _mcc#0; old(rd.reader.pos) + 4 == rd.reader.pos && Msg.Reserved == rd.reader.data[old(rd.reader.pos) .. rd.reader.pos]) case Failure(_mcc#1) => true }
    decreases rd
  {
    var reserved :- rd.ReadBytes(4);
    if reserved == Msg.Reserved {
      return Success(reserved);
    } else {
      return Failure(""Deserialization Error: Reserved fields must be 0."");
    }
  }
}

module {:extern ""EncryptionContext""} EncryptionContext {

  import opened StandardLibrary = StandardLibrary

  import opened Wrappers = Wrappers

  import opened UInt = StandardLibrary.UInt

  import UTF8 = UTF8

  import Sets = Sets
  type Map = map<UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes>

  type Linear = seq<(UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes)>

  predicate {:opaque} {:fuel 0, 0} Serializable(encryptionContext: Map)
    decreases encryptionContext
  {
    SerializableKVPairs(encryptionContext) &&
    Length(encryptionContext) < UINT16_LIMIT
  }

  predicate method SerializableKVPairs(encryptionContext: Map)
    decreases encryptionContext
  {
    |encryptionContext| < UINT16_LIMIT &&
    forall key: UTF8.ValidUTF8Bytes :: 
      key in encryptionContext.Keys ==>
        SerializableKVPair((key, encryptionContext[key]))
  }

  predicate method SerializableKVPair(kvPair: (UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes))
    decreases kvPair
  {
    |kvPair.0| < UINT16_LIMIT &&
    |kvPair.1| < UINT16_LIMIT &&
    UTF8.ValidUTF8Seq(kvPair.0) &&
    UTF8.ValidUTF8Seq(kvPair.1)
  }

  predicate SerializableUnsortedLinear(linear: Linear)
    decreases linear
  {
    |linear| < UINT16_LIMIT &&
    (forall i: int :: 
      0 <= i < |linear| ==>
        SerializableKVPair(linear[i])) &&
    LinearIsUnique(linear)
  }

  predicate SerializableLinear(linear: Linear)
    decreases linear
  {
    LinearSorted(linear) &&
    SerializableUnsortedLinear(linear)
  }

  predicate LinearIsUnique(linear: Linear)
    decreases linear
  {
    forall i: int, j: int | 0 <= i < j < |linear| :: 
      linear[i].0 != linear[j].0
  }

  function Length(encryptionContext: Map): nat
    decreases encryptionContext
  {
    if |encryptionContext| == 0 then
      0
    else
      ghost var keys: seq<UTF8.ValidUTF8Bytes> := SetToOrderedSequence(encryptionContext.Keys, UInt.UInt8Less); ghost var kvPairs: seq<(UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes)> := seq(|keys|, (i: int) requires 0 <= i < |keys| => (keys[i], encryptionContext[keys[i]])); 2 + LinearLength(kvPairs, 0, |kvPairs|)
  }

  function LinearLength(kvPairs: Linear, lo: nat, hi: nat): nat
    requires lo <= hi <= |kvPairs|
    decreases kvPairs, lo, hi
  {
    if lo == hi then
      0
    else
      LinearLength(kvPairs, lo, hi - 1) + 2 + |kvPairs[hi - 1].0| + 2 + |kvPairs[hi - 1].1|
  }

  method {:extern ""LinearToMap""} LinearToMap(kvPairs: Linear) returns (res: Map)
    ensures (reveal Serializable(); Serializable(res) && SerializableLinear(kvPairs) ==> MapToSeq(res) == if |res| == 0 then [] else UInt16ToSeq(|kvPairs| as uint16) + LinearToSeq(kvPairs, 0, |kvPairs|))
    decreases kvPairs

  lemma /*{:_induction kvPairs, lo, mid, hi}*/ LinearSplit(kvPairs: Linear, lo: nat, mid: nat, hi: nat)
    requires lo <= mid <= hi <= |kvPairs|
    ensures LinearLength(kvPairs, lo, hi) == LinearLength(kvPairs, lo, mid) + LinearLength(kvPairs, mid, hi)
    decreases kvPairs, lo, mid, hi
  {
  }

  lemma /*{:_induction kvPairs, more}*/ LinearPrefix(kvPairs: Linear, more: Linear)
    ensures LinearLength(kvPairs + more, 0, |kvPairs|) == LinearLength(kvPairs, 0, |kvPairs|)
    decreases kvPairs, more
  {
    ghost var n := |kvPairs|;
    if n == 0 {
    } else {
      ghost var last := kvPairs[n - 1];
      calc {
        LinearLength(kvPairs + more, 0, n);
      ==
        LinearLength(kvPairs + more, 0, n - 1) + 4 + |last.0| + |last.1|;
      ==
        {
          assert kvPairs + more == kvPairs[..n - 1] + ([last] + more);
        }
        LinearLength(kvPairs[..n - 1] + ([last] + more), 0, n - 1) + 4 + |last.0| + |last.1|;
      ==
        {
          LinearPrefix(kvPairs[..n - 1], [last] + more);
        }
        LinearLength(kvPairs[..n - 1], 0, n - 1) + 4 + |last.0| + |last.1|;
      ==
        {
          LinearPrefix(kvPairs[..n - 1], [last] + more);
        }
        LinearLength(kvPairs[..n - 1] + [last], 0, n - 1) + 4 + |last.0| + |last.1|;
      ==
        {
          assert kvPairs[..n - 1] + [last] == kvPairs;
        }
        LinearLength(kvPairs, 0, n - 1) + 4 + |last.0| + |last.1|;
      ==
        LinearLength(kvPairs, 0, n);
      }
    }
  }

  lemma /*{:_induction kvPairs}*/ LinearExtend(kvPairs: Linear, key: UTF8.ValidUTF8Bytes, value: UTF8.ValidUTF8Bytes)
    ensures LinearLength(kvPairs + [(key, value)], 0, |kvPairs| + 1) == LinearLength(kvPairs, 0, |kvPairs|) + 4 + |key| + |value|
    decreases kvPairs, key, value
  {
    LinearPrefix(kvPairs, [(key, value)]);
  }

  lemma /*{:_induction kvPairs}*/ LinearInsert(kvPairs: Linear, insertionPoint: nat, key: UTF8.ValidUTF8Bytes, value: UTF8.ValidUTF8Bytes)
    requires insertionPoint <= |kvPairs|
    ensures ghost var kvPairs': seq<(UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes)> := kvPairs[..insertionPoint] + [(key, value)] + kvPairs[insertionPoint..]; LinearLength(kvPairs', 0, |kvPairs'|) == LinearLength(kvPairs, 0, |kvPairs|) + 4 + |key| + |value|
    decreases |kvPairs|
  {
    ghost var kvPairs' := kvPairs[..insertionPoint] + [(key, value)] + kvPairs[insertionPoint..];
    if |kvPairs| == insertionPoint {
      assert kvPairs' == kvPairs + [(key, value)];
      LinearExtend(kvPairs, key, value);
    } else {
      ghost var m := |kvPairs| - 1;
      var (d0, d1) := kvPairs[m];

      ghost var a, b, c, d := kvPairs[..insertionPoint], [(key, value)], kvPairs[insertionPoint .. m], [(d0, d1)];
      assert kvPairs == a + c + d;
      assert kvPairs' == a + b + c + d;
      ghost var ac := a + c;
      ghost var abc := a + b + c;
      calc {
        LinearLength(kvPairs', 0, |kvPairs'|);
        LinearLength(abc + [(d0, d1)], 0, |abc| + 1);
      ==
        {
          LinearExtend(abc, d0, d1);
        }
        LinearLength(abc, 0, |abc|) + 4 + |d0| + |d1|;
      ==
        {
          LinearInsert(ac, insertionPoint, key, value);
        }
        LinearLength(ac, 0, |ac|) + 4 + |key| + |value| + 4 + |d0| + |d1|;
      ==
        {
          LinearExtend(ac, d0, d1);
        }
        LinearLength(kvPairs, 0, |kvPairs|) + 4 + |key| + |value|;
      }
    }
  }

  method ComputeLength(encryptionContext: Map) returns (res: nat)
    ensures res as nat == Length(encryptionContext)
    decreases encryptionContext
  {
    reveal Serializable();
    if |encryptionContext| == 0 {
      return 0;
    }
    var keys: seq<UTF8.ValidUTF8Bytes> := Sets.ComputeSetToOrderedSequence(encryptionContext.Keys, UInt.UInt8Less);
    var kvPairs := seq(|keys|, (i: int) requires 0 <= i < |keys| => (keys[i], encryptionContext[keys[i]]));
    var len := 2;
    var i := 0;
    while i < |kvPairs|
      invariant i <= |kvPairs|
      invariant 2 + LinearLength(kvPairs, 0, i as int) == len as int
      decreases |kvPairs| - i
    {
      var kvPair := kvPairs[i];
      len := len + 4 + |kvPair.0| + |kvPair.1|;
      LinearSplit(kvPairs, 0, i + 1, |kvPairs| as int);
      i := i + 1;
    }
    assert len == 2 + LinearLength(kvPairs, 0, |kvPairs|);
    assert len == Length(encryptionContext);
    return len;
  }

  method CheckSerializable(encryptionContext: Map) returns (res: bool)
    ensures res == Serializable(encryptionContext)
    decreases encryptionContext
  {
    reveal Serializable();
    if |encryptionContext| == 0 {
      return true;
    } else if |encryptionContext| >= UINT16_LIMIT {
      return false;
    }
    var keys: seq<UTF8.ValidUTF8Bytes> := Sets.ComputeSetToOrderedSequence<uint8>(encryptionContext.Keys, UInt.UInt8Less);
    var kvPairs := seq(|keys|, (i: int) requires 0 <= i < |keys| => (keys[i], encryptionContext[keys[i]]));
    assert forall i: int :: 0 <= i < |keys| ==> kvPairs[i] == (keys[i], encryptionContext[keys[i]]);
    var kvPairsLen := 2;
    var i := 0;
    while i < |kvPairs|
      invariant i <= |kvPairs|
      invariant forall k: int :: 0 <= k < i ==> SerializableKVPair(kvPairs[k])
      invariant 2 + LinearLength(kvPairs, 0, i as int) == kvPairsLen as int < UINT16_LIMIT
      decreases |kvPairs| - i
    {
      var kvPair := kvPairs[i];
      kvPairsLen := kvPairsLen + 4 + |kvPair.0| + |kvPair.1|;
      LinearSplit(kvPairs, 0, i as int + 1, |kvPairs| as int);
      if !(|kvPair.0| < UINT16_LIMIT && |kvPair.1| < UINT16_LIMIT) {
        assert kvPair.0 in encryptionContext.Keys;
        return false;
      } else if kvPairsLen >= UINT16_LIMIT {
        return false;
      }
      assert forall k: int :: 0 <= k < i ==> SerializableKVPair(kvPairs[k]);
      assert kvPairsLen < UINT16_LIMIT;
      i := i + 1;
    }
    return true;
  }

  predicate LinearSortedUpTo(a: Linear, n: nat)
    requires n <= |a|
    decreases a, n
  {
    forall j: int :: 
      0 < j < n ==>
        LexicographicLessOrEqual(a[j - 1].0, a[j].0, UInt.UInt8Less)
  }

  predicate LinearSorted(kvPairs: Linear)
    decreases kvPairs
  {
    LinearSortedUpTo(kvPairs, |kvPairs|)
  }

  predicate StrongLinearSorted(kvPairs: Linear)
    decreases kvPairs
  {
    forall i: int, j: int | 0 <= i < j < |kvPairs| :: 
      LexicographicLessOrEqual(kvPairs[i].0, kvPairs[j].0, UInt.UInt8Less)
  }

  lemma LinearSortedImpliesStrongLinearSorted(ls: Linear)
    requires LinearSorted(ls)
    ensures StrongLinearSorted(ls)
    decreases ls
  {
    if |ls| <= 1 {
    } else {
      forall i: int, j: int | 0 <= i < j < |ls|
        ensures LexicographicLessOrEqual(ls[i].0, ls[j].0, UInt.UInt8Less)
      {
        LinearSortedImpliesStrongLinearSorted(ls[1..]);
        if i == 0 && 2 <= |ls| {
          LexIsReflexive(ls[1].0, UInt.UInt8Less);
          LexIsTransitive(ls[i].0, ls[1].0, ls[j].0, UInt.UInt8Less);
          assert LexicographicLessOrEqual(ls[i].0, ls[j].0, UInt.UInt8Less);
        } else {
          assert LexicographicLessOrEqual(ls[i].0, ls[j].0, UInt.UInt8Less);
        }
      }
    }
  }

  lemma SortedSequenceIsUnqiue(xs: Linear, ys: Linear)
    requires LinearSorted(xs) && LinearIsUnique(xs)
    requires LinearSorted(ys) && LinearIsUnique(ys)
    requires forall p: (UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes) :: p in xs <==> p in ys
    ensures xs == ys
    decreases xs, ys
  {
    LinearSortedImpliesStrongLinearSorted(xs);
    LinearSortedImpliesStrongLinearSorted(ys);
    if xs != [] && ys != [] {
      assert xs[0] == ys[0] by {
        if xs[0] != ys[0] {
          assert forall p: (UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes) | p in xs[1..] :: LexicographicLessOrEqual(xs[0].0, p.0, UInt.UInt8Less);
          assert xs[0] in ys[1..] by {
            assert xs[0] != ys[0] && !(xs[0] in ys[1..]) ==> xs[0] !in ys;
          }
          assert forall p: (UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes) | p in ys[1..] :: LexicographicLessOrEqual(ys[0].0, p.0, UInt.UInt8Less);
          assert ys[0] in xs[1..] by {
            assert ys[0] != xs[0] && !(ys[0] in xs[1..]) ==> ys[0] !in xs;
          }
          assert LexicographicLessOrEqual(ys[0].0, xs[0].0, UInt.UInt8Less);
          assert LexicographicLessOrEqual(xs[0].0, ys[0].0, UInt.UInt8Less);
          assert false;
        }
      }
      assert forall p: (UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes) :: p in xs[1..] <==> p in ys[1..] by {
        if exists p: (UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes) :: p in xs[1..] && !(p in ys[1..]) {
          ghost var p :| p in xs[1..] && !(p in ys[1..]);
          assert p != ys[0];
          assert p in xs && !(p in ys);
          assert false;
        } else {
          if exists p: (UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes) :: p in ys[1..] && !(p in xs[1..]) {
            ghost var p :| p in ys[1..] && !(p in xs[1..]);
            assert p != xs[0];
            assert p in xs && !(p in ys);
            assert false;
          }
        }
      }
      SortedSequenceIsUnqiue(xs[1..], ys[1..]);
    } else {
      if xs == [] && ys != [] {
        assert ys[0] in xs;
        assert false;
      }
      if ys == [] && xs != [] {
        assert xs[0] in ys;
        assert false;
      }
    }
  }

  predicate LinearSeqToMap(sequence: seq<uint8>, resultMap: Map)
    decreases sequence, resultMap
  {
    if 2 <= |sequence| && |sequence[2..]| < UINT16_LIMIT then
      sequence[..2] == UInt16ToSeq(|sequence[2..]| as uint16) &&
      SeqToMap(sequence[2..], resultMap)
    else
      false
  }

  predicate SeqToMap(sequence: seq<uint8>, resultMap: Map)
    decreases sequence, resultMap
  {
    if 2 <= |sequence| then
      exists unsortedKvPairs: Linear :: 
        SeqToLinearToMap(sequence, resultMap, unsortedKvPairs, InsertionSort(unsortedKvPairs))
    else
      |resultMap| == 0
  }

  predicate SeqToLinearToMap(sequence: seq<uint8>, resultMap: Map, unsortedKvPairs: Linear, sortedKvPairs: Linear)
    decreases sequence, resultMap, unsortedKvPairs, sortedKvPairs
  {
    2 <= |sequence| &&
    SerializableUnsortedLinear(unsortedKvPairs) &&
    SerializableLinear(sortedKvPairs) &&
    SerializableKVPairs(resultMap) &&
    sequence[..2] == UInt16ToSeq(|resultMap| as uint16) &&
    LinearToUnorderedSeq(unsortedKvPairs, 0, |unsortedKvPairs|) == sequence[2..] &&
    sortedKvPairs == InsertionSort(unsortedKvPairs) &&
    MapToSeq(resultMap) == sequence[..2] + LinearToSeq(sortedKvPairs, 0, |sortedKvPairs|)
  }

  lemma MapToLinearIsDualLinearSeqToMap(resultMap: Map)
    requires Serializable(resultMap)
    ensures LinearSeqToMap(MapToLinear(resultMap), resultMap)
    decreases resultMap
  {
    reveal Serializable();
    LengthCorrect(resultMap);
    MapToSeqIsDualSeqToMap(resultMap);
  }

  function LinearToUnorderedSeq(kvPairs: Linear, lo: nat, hi: nat): seq<uint8>
    requires SerializableUnsortedLinear(kvPairs)
    requires lo <= hi <= |kvPairs|
    decreases kvPairs, lo, hi
  {
    if lo == hi then
      []
    else
      LinearToUnorderedSeq(kvPairs, lo, hi - 1) + KVPairToSeq(kvPairs[hi - 1])
  }

  lemma /*{:_induction kvHead, kvTail, lo, hi}*/ LinearToUnorderedSeqInductiveStep(kvHead: Linear, kvTail: Linear, lo: nat, hi: nat)
    requires SerializableUnsortedLinear(kvHead + kvTail)
    requires lo <= hi <= |kvHead|
    ensures SerializableUnsortedLinear(kvHead)
    ensures LinearToUnorderedSeq(kvHead + kvTail, lo, hi) == LinearToUnorderedSeq(kvHead, lo, hi)
    decreases kvHead, kvTail, lo, hi
  {
    assert SerializableUnsortedLinear(kvHead) by {
      assert |kvHead| < UINT16_LIMIT;
      assert forall i: int :: 0 <= i < |kvHead| ==> SerializableKVPair(kvHead[i]) by {
        assert forall pair: (UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes) :: pair in kvHead ==> pair in kvHead + kvTail;
        assert (exists pair: (UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes) :: pair in kvHead && !SerializableKVPair(pair)) ==> exists pair: (UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes) :: pair in kvHead + kvTail && !SerializableKVPair(pair);
      }
      assert LinearIsUnique(kvHead) by {
        ghost var kvPairs := kvHead + kvTail;
        assert forall i: int | 0 <= i < |kvHead| :: kvHead[i] == kvPairs[i];
        assert (exists i: int, j: int | 0 <= i < j < |kvHead| :: kvHead[i] == kvHead[j]) ==> exists i: int, j: int | 0 <= i < j < |kvPairs| :: kvPairs[i] == kvPairs[j];
      }
    }
  }

  lemma MapToSeqIsDualSeqToMap(resultMap: Map)
    requires SerializableKVPairs(resultMap)
    ensures SeqToMap(MapToSeq(resultMap), resultMap)
    decreases resultMap
  {
    ghost var sequenceComplete := MapToSeq(resultMap);
    if sequenceComplete != [] {
      ghost var sequence := sequenceComplete[2..];
      ghost var kvPairs :| (forall i: int :: 0 <= i < |kvPairs| ==> SerializableKVPair(kvPairs[i])) && |kvPairs| < UINT16_LIMIT && LinearSorted(kvPairs) && LinearIsUnique(kvPairs) && LinearToSeq(kvPairs, 0, |kvPairs|) == sequence && sequenceComplete[..2] == UInt16ToSeq(|kvPairs| as uint16);
      InsertionSortPreservesProperties(kvPairs);
      SortedSequenceIsUnqiue(kvPairs, InsertionSort(kvPairs));
      SortedLinearIsFixpointAADDuality(kvPairs);
    } else {
    }
  }

  lemma /*{:_induction linear}*/ SortedLinearIsFixpointAADDuality(linear: Linear)
    requires forall p: (UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes) | p in linear :: SerializableKVPair(p)
    requires |linear| < UINT16_LIMIT
    requires LinearIsUnique(linear)
    requires LinearSorted(linear)
    ensures forall hi: int | 0 <= hi <= |linear| :: LinearToUnorderedSeq(linear, 0, hi) == LinearToSeq(linear, 0, hi)
    decreases linear
  {
    SortedLinearIsFixpointAADDualityAux(linear, |linear|);
  }

  lemma /*{:_induction linear}*/ SortedLinearIsFixpointAADDualityAux(linear: Linear, lim: nat)
    requires forall p: (UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes) | p in linear :: SerializableKVPair(p)
    requires |linear| < UINT16_LIMIT
    requires LinearIsUnique(linear)
    requires LinearSorted(linear)
    requires lim <= |linear|
    ensures forall hi: int | 0 <= hi <= lim :: LinearToUnorderedSeq(linear, 0, hi) == LinearToSeq(linear, 0, hi)
    decreases linear, lim
  {
    if lim == 0 {
      assert LinearToUnorderedSeq(linear, 0, 0) == LinearToSeq(linear, 0, 0);
    } else {
      SortedLinearIsFixpointAADDualityAux(linear, lim - 1);
      assert LinearToUnorderedSeq(linear, 0, lim) == LinearToSeq(linear, 0, lim);
    }
  }

  lemma /*{:_induction ps}*/ InsertionSortPreservesProperties(ps: Linear)
    requires LinearIsUnique(ps)
    requires forall l: (UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes) | l in ps :: SerializableKVPair(l)
    ensures LinearIsUnique(InsertionSort(ps))
    ensures forall l: (UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes) | l in InsertionSort(ps) :: SerializableKVPair(l)
    ensures |InsertionSort(ps)| == |ps|
    decreases ps
  {
    if ps == [] {
    } else {
      ghost var ls := InsertionSort(ps[1..]);
      forall j: int | 0 <= j < |ls|
        ensures ps[0].0 != ls[j].0
      {
        assert ps[0].0 == ls[j].0 ==> ls[j] in ps[1..];
        assert ps[0].0 == ls[j].0 ==> false;
      }
      InsertPairPreservesProperties(ps[0], ls);
    }
  }

  lemma /*{:_induction p, ps}*/ InsertPairPreservesProperties(p: (UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes), ps: Linear)
    requires LinearSorted(ps)
    requires LinearIsUnique(ps)
    requires forall j: int | 0 <= j < |ps| :: p.0 != ps[j].0
    requires forall l: (UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes) | l in ps :: SerializableKVPair(l)
    requires SerializableKVPair(p)
    ensures LinearIsUnique(InsertPair(p, ps))
    ensures forall l: (UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes) | l in InsertPair(p, ps) :: SerializableKVPair(l)
    ensures |InsertPair(p, ps)| == |ps| + 1
    decreases p, ps
  {
    if ps == [] || LexicographicLessOrEqual(p.0, ps[0].0, UInt.UInt8Less) {
    } else {
      assert LinearIsUnique([ps[0]] + InsertPair(p, ps[1..])) by {
        ghost var ls := InsertPair(p, ps[1..]);
        ghost var l := ps[0];
        assert !LinearIsUnique([l] + ls) ==> exists m: (UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes) | m in ls :: m.0 == l.0;
      }
    }
  }

  function MapToSeq(kvPairs: Map): seq<uint8>
    requires SerializableKVPairs(kvPairs)
    decreases kvPairs
  {
    ghost var n: int := |kvPairs|;
    if n == 0 then
      []
    else
      ghost var keys: seq<UTF8.ValidUTF8Bytes> := SetToOrderedSequence<uint8>(kvPairs.Keys, UInt.UInt8Less); ghost var kvPairsSeq: seq<(UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes)> := seq(|keys|, (i: int) requires 0 <= i < |keys| => (keys[i], kvPairs[keys[i]])); UInt16ToSeq(n as uint16) + LinearToSeq(kvPairsSeq, 0, |kvPairsSeq|)
  }

  function LinearToSeq(kvPairs: Linear, lo: nat, hi: nat): seq<uint8>
    requires SerializableLinear(kvPairs)
    requires lo <= hi <= |kvPairs|
    decreases kvPairs, lo, hi
  {
    if lo == hi then
      []
    else
      LinearToSeq(kvPairs, lo, hi - 1) + KVPairToSeq(kvPairs[hi - 1])
  }

  function MapToLinear(kvPairs: Map): seq<uint8>
    requires Serializable(kvPairs)
    decreases kvPairs
  {
    reveal Serializable();
    UInt16ToSeq(Length(kvPairs) as uint16) + MapToSeq(kvPairs)
  }

  function KVPairToSeq(kvPair: (UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes)): seq<uint8>
    requires SerializableKVPair(kvPair)
    decreases kvPair
  {
    UInt16ToSeq(|kvPair.0| as uint16) + kvPair.0 + UInt16ToSeq(|kvPair.1| as uint16) + kvPair.1
  }

  function InsertionSort(linear: Linear): Linear
    ensures ghost var linearSorted: Linear := InsertionSort(linear); (forall p: (UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes) :: p in linear <==> p in linearSorted) && LinearSorted(linearSorted)
    decreases linear
  {
    if linear == [] then
      []
    else
      InsertPair(linear[0], InsertionSort(linear[1..]))
  }

  function InsertPair(p: (UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes), ps: Linear): Linear
    requires LinearSorted(ps)
    ensures ghost var ls: Linear := InsertPair(p, ps); LinearSorted(ls) && forall l: (UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes) :: l in ps || l == p <==> l in ls
    decreases p, ps
  {
    if ps == [] || LexicographicLessOrEqual(p.0, ps[0].0, UInt.UInt8Less) then
      [p] + ps
    else
      LexIsTotal(p.0, ps[0].0, UInt.UInt8Less); [ps[0]] + InsertPair(p, ps[1..])
  }

  function GetUTF8(sequence: seq<uint8>, length: nat): (res: Option<UTF8.ValidUTF8Bytes>)
    ensures |sequence| >= length && UTF8.ValidUTF8Seq(sequence[..length]) <==> res.Some?
    ensures res.Some? ==> sequence[..length] == res.value
    decreases sequence, length
  {
    if |sequence| >= length then
      ghost var utfSeq: seq<uint8> := sequence[..length];
      if UTF8.ValidUTF8Seq(utfSeq) then
        ghost var utf: UTF8.ValidUTF8Bytes := utfSeq;
        Some(utf)
      else
        None
    else
      None
  }

  lemma DualOfUTF8(utf: UTF8.ValidUTF8Bytes, remainder: seq<uint8>)
    requires |utf| < UINT16_LIMIT && UTF8.ValidUTF8Seq(utf)
    ensures ghost var serializedUtf: seq<uint8> := UInt16ToSeq(|utf| as uint16) + utf + remainder; GetUTF8(serializedUtf[2..], |utf|) == Some(utf)
    decreases utf, remainder
  {
    ghost var serializedUtf := UInt16ToSeq(|utf| as uint16) + utf + remainder;
    assert serializedUtf[2..][..|utf|] == utf;
    ghost var serial := serializedUtf[2..];
    ghost var deserializedUTF := GetUTF8(serial, |utf|);
    assert deserializedUTF.Some? by {
      assert serial[..|utf|] == utf;
      assert |serial| >= |utf| && UTF8.ValidUTF8Seq(serial[..|utf|]);
    }
    assert deserializedUTF.value == serial[..|utf|];
  }

  lemma LengthCorrect(encryptionContext: Map)
    requires Serializable(encryptionContext)
    ensures |MapToLinear(encryptionContext)| == 2 + Length(encryptionContext)
    decreases encryptionContext
  {
    reveal Serializable();
    ghost var keys: seq<UTF8.ValidUTF8Bytes> := SetToOrderedSequence(encryptionContext.Keys, UInt.UInt8Less);
    ghost var kvPairs := seq(|keys|, (i: int) requires 0 <= i < |keys| => (keys[i], encryptionContext[keys[i]]));
    LinearLengthCorrect(kvPairs, 0, |kvPairs|);
  }

  lemma /*{:_induction encryptionContext, lo, hi}*/ LinearLengthCorrect(encryptionContext: Linear, lo: nat, hi: nat)
    requires forall i: int :: 0 <= i < |encryptionContext| ==> SerializableKVPair(encryptionContext[i])
    requires lo <= hi <= |encryptionContext|
    requires |encryptionContext| < UINT16_LIMIT
    requires LinearSorted(encryptionContext)
    requires LinearIsUnique(encryptionContext)
    ensures |LinearToSeq(encryptionContext, lo, hi)| == LinearLength(encryptionContext, lo, hi)
    decreases encryptionContext, lo, hi
  {
  }
}

module AwsKmsMrkAreUnique {

  import opened StandardLibrary = StandardLibrary

  import opened Wrappers = Wrappers

  import opened Seq = Seq

  import opened AwsKmsArnParsing = AwsKmsArnParsing
  function method AwsKmsMrkAreUnique(identifiers: seq<AwsKmsIdentifier>): (result: Result<(), string>)
    decreases identifiers
  {
    var mrks: seq<AwsKmsIdentifier> := Seq.Filter(IsMultiRegionAwsKmsIdentifier, identifiers);
    if |mrks| == 0 then
      Success(())
    else
      var mrkKeyIds: seq<string> := Seq.Map(GetKeyId, mrks); var setMrks: set<seq<char>> := ToSet(mrkKeyIds); if |mrkKeyIds| == |setMrks| then Success(()) else var duplicateMrkIds: set<seq<char>> := set x: seq<char> {:trigger multiset(mrkKeyIds)[x]} {:trigger x in mrkKeyIds} | x in mrkKeyIds && multiset(mrkKeyIds)[x] >= 1; var isDuplicate: AwsKmsIdentifier -> bool := (identifier: AwsKmsIdentifier) => GetKeyId(identifier) in duplicateMrkIds; var identifierToString: AwsKmsIdentifier -> string := (i: AwsKmsIdentifier) => i.ToString(); var duplicateIdentifiers: seq<AwsKmsIdentifier> := Seq.Filter(isDuplicate, identifiers); var duplicates: seq<string> := Seq.Map(identifierToString, duplicateIdentifiers); Need(|duplicates| > 0, ""Impossible""); Failure(""Related multi-Region keys: "" + Join(duplicates, "","") + ""are not allowed."")
  }

  function method GetKeyId(identifier: AwsKmsIdentifier): (result: string)
    decreases identifier
  {
    match identifier {
      case AwsKmsArnIdentifier(a) =>
        a.resource.value
      case AwsKmsRawResourceIdentifier(i) =>
        i.value
    }
  }

  lemma /*{:_induction identifiers}*/ AwsKmsMrkAreUniqueCorrect(identifiers: seq<AwsKmsIdentifier>)
    ensures |Seq.Filter(IsMultiRegionAwsKmsIdentifier, identifiers)| == 0 ==> AwsKmsMrkAreUnique(identifiers).Success?
    ensures ghost var mrks: seq<AwsKmsIdentifier> := Seq.Filter(IsMultiRegionAwsKmsIdentifier, identifiers); ghost var ids: seq<string> := Seq.Map(GetKeyId, mrks); |mrks| > 0 && Seq.HasNoDuplicates(ids) ==> AwsKmsMrkAreUnique(identifiers).Success?
    ensures ghost var mrks: seq<AwsKmsIdentifier> := Seq.Filter(IsMultiRegionAwsKmsIdentifier, identifiers); ghost var ids: seq<string> := Seq.Map(GetKeyId, mrks); |mrks| > 0 && !Seq.HasNoDuplicates(ids) ==> AwsKmsMrkAreUnique(identifiers).Failure?
    decreases identifiers
  {
    ghost var mrks := Seq.Filter(IsMultiRegionAwsKmsIdentifier, identifiers);
    ghost var ids := Seq.Map(GetKeyId, mrks);
    if Seq.HasNoDuplicates(ids) {
      LemmaCardinalityOfSetNoDuplicates(ids);
    }
    if |ToSet(ids)| == |ids| {
      LemmaNoDuplicatesCardinalityOfSet(ids);
    }
  }
}

module {:extern ""AwsKmsMrkAwareSymmetricKeyring""} AwsKmsMrkAwareSymmetricKeyring {

  import opened StandardLibrary = StandardLibrary

  import opened Wrappers = Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened AwsKmsArnParsing = AwsKmsArnParsing

  import opened AmazonKeyManagementService = AmazonKeyManagementService

  import opened Seq = Seq

  import opened Actions = Actions

  import opened Constants = Constants

  import opened M = AwsKmsMrkMatchForDecrypt

  import opened KeyringDefs = KeyringDefs

  import Materials = Materials

  import opened KMSUtils = KMSUtils

  import UTF8 = UTF8
  class AwsKmsMrkAwareSymmetricKeyring extends Keyring {
    const client: IAmazonKeyManagementService
    const awsKmsKey: AwsKmsIdentifierString
    const awsKmsArn: AwsKmsIdentifier
    const grantTokens: KMSUtils.GrantTokens

    constructor (client: IAmazonKeyManagementService, awsKmsKey: string, grantTokens: GrantTokens)
      requires ParseAwsKmsIdentifier(awsKmsKey).Success?
      requires UTF8.IsASCIIString(awsKmsKey)
      requires 0 < |awsKmsKey| <= MAX_AWS_KMS_IDENTIFIER_LENGTH
      ensures Valid()
      ensures fresh(Repr - {this})
      ensures this.client == client && this.awsKmsKey == awsKmsKey && this.grantTokens == grantTokens
      decreases client, awsKmsKey, grantTokens
    {
      var parsedAwsKmsId := ParseAwsKmsIdentifier(awsKmsKey);
      this.client := client;
      this.awsKmsKey := awsKmsKey;
      this.awsKmsArn := parsedAwsKmsId.value;
      this.grantTokens := grantTokens;
      Repr := {this};
    }

    predicate Valid()
      reads this, Repr
      ensures Valid() ==> this in Repr
      decreases Repr + {this}
    {
      true &&
      this in Repr
    }

    method OnEncrypt(materials: Materials.ValidEncryptionMaterials) returns (res: Result<Materials.ValidEncryptionMaterials, string>)
      requires Valid()
      ensures Valid()
      ensures OnEncryptPure(materials, res)
      ensures true && materials.plaintextDataKey.None? ==> GenerateDataKeyCalledWith(client, GenerateDataKeyRequest(materials.encryptionContext, grantTokens, awsKmsKey, materials.algorithmSuiteID.KDFInputKeyLength() as int32))
      ensures materials.plaintextDataKey.None? && res.Success? ==> res.value.plaintextDataKey.Some? && |res.value.encryptedDataKeys| == |materials.encryptedDataKeys| + 1 && materials.algorithmSuiteID.ValidPlaintextDataKey(res.value.plaintextDataKey.value) && GenerateDataKeyResult(Last(res.value.encryptedDataKeys).ciphertext, res.value.plaintextDataKey.value)
      ensures true && materials.plaintextDataKey.Some? ==> true && EncryptCalledWith(client, EncryptRequest(materials.encryptionContext, grantTokens, awsKmsKey, materials.plaintextDataKey.value))
      ensures materials.plaintextDataKey.Some? && res.Success? ==> |res.value.encryptedDataKeys| == |materials.encryptedDataKeys| + 1 && EncryptResult(Last(res.value.encryptedDataKeys).ciphertext)
      decreases materials
    {
      if materials.plaintextDataKey.None? {
        var generatorRequest := GenerateDataKeyRequest(materials.encryptionContext, grantTokens, awsKmsKey, materials.algorithmSuiteID.KDFInputKeyLength() as int32);
        var maybeGenerateResponse := GenerateDataKey(client, generatorRequest);
        if maybeGenerateResponse.Failure? {
          return Failure(maybeGenerateResponse.error);
        }
        var generateResponse := maybeGenerateResponse.value;
        :- Need(generateResponse.IsWellFormed(), ""Invalid response from KMS GenerateDataKey"");
        :- Need(ParseAwsKmsIdentifier(generateResponse.keyID).Success?, ""Invalid response from KMS GenerateDataKey:: Invalid Key Id"");
        :- Need(materials.algorithmSuiteID.ValidPlaintextDataKey(generateResponse.plaintext), ""Invalid response from AWS KMS GenerateDataKey: Invalid data key"");
        var providerInfo :- UTF8.Encode(generateResponse.keyID);
        :- Need(|providerInfo| < UINT16_LIMIT, ""AWS KMS Key ID too long."");
        var edk := Materials.EncryptedDataKey(PROVIDER_ID, providerInfo, generateResponse.ciphertextBlob);
        var plaintextDataKey := generateResponse.plaintext;
        var result := materials.WithKeys(Some(plaintextDataKey), [edk]);
        return Success(result);
      } else {
        var encryptRequest := KMSUtils.EncryptRequest(materials.encryptionContext, grantTokens, awsKmsKey, materials.plaintextDataKey.value);
        var maybeEncryptResponse := KMSUtils.Encrypt(client, encryptRequest);
        if maybeEncryptResponse.Failure? {
          return Failure(maybeEncryptResponse.error);
        }
        var encryptResponse := maybeEncryptResponse.value;
        :- Need(encryptResponse.IsWellFormed(), ""Invalid response from KMS Encrypt"");
        :- Need(ParseAwsKmsIdentifier(encryptResponse.keyID).Success?, ""Invalid response from AWS KMS Encrypt:: Invalid Key Id"");
        var providerInfo :- UTF8.Encode(encryptResponse.keyID);
        :- Need(|providerInfo| < UINT16_LIMIT, ""AWS KMS Key ID too long."");
        var edk := Materials.EncryptedDataKey(PROVIDER_ID, providerInfo, encryptResponse.ciphertextBlob);
        var result := materials.WithKeys(materials.plaintextDataKey, [edk]);
        return Success(result);
      }
    }

    method OnDecrypt(materials: Materials.ValidDecryptionMaterials, encryptedDataKeys: seq<Materials.EncryptedDataKey>) returns (res: Result<Materials.ValidDecryptionMaterials, string>)
      requires Valid()
      ensures Valid()
      ensures OnDecryptPure(materials, res)
      ensures materials.plaintextDataKey.Some? ==> res.Success? && res.value == materials
      ensures materials.plaintextDataKey.None? && res.Success? ==> res.value.plaintextDataKey.Some? && exists edk: Materials.EncryptedDataKey | edk in encryptedDataKeys :: edk.providerID == PROVIDER_ID && DecryptCalledWith(client, DecryptRequest(awsKmsKey, edk.ciphertext, materials.encryptionContext, grantTokens)) && DecryptResult(awsKmsKey, res.value.plaintextDataKey.value) && materials.algorithmSuiteID.ValidPlaintextDataKey(res.value.plaintextDataKey.value)
      decreases materials, encryptedDataKeys
    {
      if materials.plaintextDataKey.Some? {
        return Success(materials);
      }
      var filter := new OnDecryptEncryptedDataKeyFilter(awsKmsArn);
      var edksToAttempt :- FilterWithResult(filter, encryptedDataKeys);
      var decryptClosure := new DecryptSingleEncryptedDataKey(materials, client, awsKmsKey, grantTokens);
      var outcome := ReduceToSuccess(decryptClosure, edksToAttempt);
      return match outcome { case Success(_mcc#0) => (var mat := _mcc#0; assert exists edk | edk in edksToAttempt :: edk in encryptedDataKeys && filter.Ensures(edk, Success(true)) && decryptClosure.Ensures(edk, Success(mat)) && DecryptCalledWith(client, DecryptRequest(awsKmsKey, edk.ciphertext, materials.encryptionContext, grantTokens)) && DecryptResult(awsKmsKey, mat.plaintextDataKey.value); Success(mat)) case Failure(_mcc#1) => var errors := _mcc#1; if |errors| == 0 then Failure(""Unable to decrypt data key: No Encrypted Data Keys found to match."") else var concatString := (s, a) => a + ""\n"" + s; var error := Seq.FoldRight(concatString, errors, ""Unable to decrypt data key:\n""); Failure(error) };
    }
  }

  class OnDecryptEncryptedDataKeyFilter extends ActionWithResult<Materials.EncryptedDataKey, bool, string> {
    const awsKmsKey: AwsKmsIdentifier

    constructor (awsKmsKey: AwsKmsIdentifier)
      decreases awsKmsKey
    {
      this.awsKmsKey := awsKmsKey;
    }

    predicate Ensures(edk: Materials.EncryptedDataKey, res: Result<bool, string>)
      decreases edk, res
    {
      true &&
      (res.Success? &&
      res.value ==>
        edk.providerID == PROVIDER_ID)
    }

    method Invoke(edk: Materials.EncryptedDataKey) returns (res: Result<bool, string>)
      ensures Ensures(edk, res)
      decreases edk
    {
      if edk.providerID != PROVIDER_ID {
        return Success(false);
      }
      if !UTF8.ValidUTF8Seq(edk.providerInfo) {
        return Failure(""Invalid AWS KMS encoding, provider info is not UTF8."");
      }
      var keyId :- UTF8.Decode(edk.providerInfo);
      var arn :- ParseAwsKmsArn(keyId);
      return Success(AwsKmsMrkMatchForDecrypt(awsKmsKey, AwsKmsArnIdentifier(arn)));
    }
  }

  class DecryptSingleEncryptedDataKey extends ActionWithResult<Materials.EncryptedDataKey, Materials.CompleteDecryptionMaterials, string> {
    const materials: Materials.PendingDecryptionMaterials
    const client: IAmazonKeyManagementService
    const awsKmsKey: AwsKmsIdentifierString
    const grantTokens: KMSUtils.GrantTokens

    constructor (materials: Materials.PendingDecryptionMaterials, client: IAmazonKeyManagementService, awsKmsKey: AwsKmsIdentifierString, grantTokens: KMSUtils.GrantTokens)
      ensures this.materials == materials && this.client == client && this.awsKmsKey == awsKmsKey && this.grantTokens == grantTokens
      decreases materials, client, awsKmsKey, grantTokens
    {
      this.materials := materials;
      this.client := client;
      this.awsKmsKey := awsKmsKey;
      this.grantTokens := grantTokens;
    }

    predicate Ensures(edk: Materials.EncryptedDataKey, res: Result<Materials.CompleteDecryptionMaterials, string>)
      decreases edk, res
    {
      res.Success? ==>
        res.value.Valid() &&
        OnDecryptPure(materials, res) &&
        DecryptCalledWith(client, DecryptRequest(awsKmsKey, edk.ciphertext, materials.encryptionContext, grantTokens)) &&
        DecryptResult(awsKmsKey, res.value.plaintextDataKey.value)
    }

    method Invoke(edk: Materials.EncryptedDataKey) returns (res: Result<Materials.CompleteDecryptionMaterials, string>)
      ensures Ensures(edk, res)
      decreases edk
    {
      var decryptRequest := KMSUtils.DecryptRequest(awsKmsKey, edk.ciphertext, materials.encryptionContext, grantTokens);
      var decryptResponse :- KMSUtils.Decrypt(client, decryptRequest);
      :- Need(decryptResponse.keyID == awsKmsKey && materials.algorithmSuiteID.ValidPlaintextDataKey(decryptResponse.plaintext), ""Invalid response from KMS Decrypt"");
      var result := materials.WithPlaintextDataKey(decryptResponse.plaintext);
      return Success(result);
    }
  }
}

module AwsKmsMrkMatchForDecrypt {

  import opened StandardLibrary = StandardLibrary

  import opened Wrappers = Wrappers

  import opened Seq = Seq

  import opened AwsKmsArnParsing = AwsKmsArnParsing
  predicate method AwsKmsMrkMatchForDecrypt(configuredAwsKmsIdentifier: AwsKmsIdentifier, messageAwsKmsIdentifer: AwsKmsIdentifier)
    decreases configuredAwsKmsIdentifier, messageAwsKmsIdentifer
  {
    if configuredAwsKmsIdentifier == messageAwsKmsIdentifer then
      true
    else
      match (messageAwsKmsIdentifer, configuredAwsKmsIdentifier) { case _#Make2(_mcc#0, _mcc#1) => match _mcc#0 { case AwsKmsArnIdentifier(_mcc#2) => match _mcc#1 { case AwsKmsArnIdentifier(_mcc#4) => (var messageAwsKmsArn := _mcc#4; var configuredAwsKmsArn := _mcc#2; if !IsMultiRegionAwsKmsArn(configuredAwsKmsArn) || !IsMultiRegionAwsKmsArn(messageAwsKmsArn) then false else messageAwsKmsArn.partition == configuredAwsKmsArn.partition && messageAwsKmsArn.service == configuredAwsKmsArn.service && messageAwsKmsArn.account == configuredAwsKmsArn.account && messageAwsKmsArn.resource == configuredAwsKmsArn.resource) case AwsKmsRawResourceIdentifier(_mcc#6) => false } case AwsKmsRawResourceIdentifier(_mcc#8) => false } }
  }

  lemma AwsKmsMrkMatchForDecryptCorrect(config: string, message: string)
    ensures ghost var c: Result<AwsKmsIdentifier, string> := ParseAwsKmsIdentifier(config); ghost var m: Result<AwsKmsIdentifier, string> := ParseAwsKmsIdentifier(message); config == message && c.Success? && m.Success? ==> AwsKmsMrkMatchForDecrypt(c.value, m.value)
    ensures ghost var c: Result<AwsKmsArn, seq<char>> := ParseAwsKmsArn(config); ghost var m: Result<AwsKmsArn, seq<char>> := ParseAwsKmsArn(message); config != message && c.Success? && m.Success? && IsMultiRegionAwsKmsArn(c.value) != IsMultiRegionAwsKmsArn(m.value) ==> !AwsKmsMrkMatchForDecrypt(AwsKmsArnIdentifier(c.value), AwsKmsArnIdentifier(m.value))
    ensures ghost var c: Result<AwsArn, seq<char>> := ParseAwsKmsArn(config); ghost var m: Result<AwsArn, seq<char>> := ParseAwsKmsArn(message); c.Success? && m.Success? && IsMultiRegionAwsKmsArn(c.value) && IsMultiRegionAwsKmsArn(m.value) ==> AwsKmsMrkMatchForDecrypt(AwsKmsArnIdentifier(c.value), AwsKmsArnIdentifier(m.value)) == (m.value.partition == c.value.partition && m.value.service == c.value.service && m.value.account == c.value.account && m.value.resource == c.value.resource)
    decreases config, message
  {
  }
}

module Constants {

  import UTF8 = UTF8
  const PROVIDER_ID: UTF8.ValidUTF8Bytes := var s: seq<uint8> := [97, 119, 115, 45, 107, 109, 115]; assert UTF8.ValidUTF8Range(s, 0, 7); s
}

module {:extern ""KeyringDefs""} KeyringDefs {

  import opened Wrappers = Wrappers

  import opened UInt = StandardLibrary.UInt

  import Materials = Materials

  import AlgorithmSuite = AlgorithmSuite
  trait {:termination false} Keyring {
    ghost var Repr: set<object>

    predicate Valid()
      reads this, Repr
      ensures Valid() ==> this in Repr
      decreases Repr + {this}

    method OnEncrypt(materials: Materials.ValidEncryptionMaterials) returns (res: Result<Materials.ValidEncryptionMaterials, string>)
      requires Valid()
      ensures Valid()
      ensures OnEncryptPure(materials, res)
      decreases materials

    method OnDecrypt(materials: Materials.ValidDecryptionMaterials, encryptedDataKeys: seq<Materials.EncryptedDataKey>) returns (res: Result<Materials.ValidDecryptionMaterials, string>)
      requires Valid()
      ensures Valid()
      ensures OnDecryptPure(materials, res)
      decreases materials, encryptedDataKeys
  }

  predicate OnEncryptPure(materials: Materials.ValidEncryptionMaterials, res: Result<Materials.ValidEncryptionMaterials, string>)
    decreases materials, res
  {
    res.Success? ==>
      materials.encryptionContext == res.value.encryptionContext &&
      materials.algorithmSuiteID == res.value.algorithmSuiteID &&
      materials.encryptedDataKeys <= res.value.encryptedDataKeys &&
      materials.signingKey == res.value.signingKey &&
      (materials.plaintextDataKey.Some? ==>
        res.value.plaintextDataKey == materials.plaintextDataKey)
  }

  predicate OnDecryptPure(materials: Materials.ValidDecryptionMaterials, res: Result<Materials.ValidDecryptionMaterials, string>)
    decreases materials, res
  {
    (res.Success? &&
    materials.plaintextDataKey.Some? ==>
      true &&
      materials == res.value) &&
    (res.Success? &&
    materials.plaintextDataKey.None? ==>
      materials.encryptionContext == res.value.encryptionContext &&
      materials.algorithmSuiteID == res.value.algorithmSuiteID &&
      materials.verificationKey == res.value.verificationKey &&
      res.value.plaintextDataKey.Some?)
  }
}

module {:extern ""MultiKeyringDef""} MultiKeyringDef {

  import opened KeyringDefs = KeyringDefs

  import opened Wrappers = Wrappers

  import opened UInt = StandardLibrary.UInt

  import AlgorithmSuite = AlgorithmSuite

  import Mat = Materials
  class MultiKeyring extends Keyring {
    const generator: Keyring?
    const children: seq<Keyring>

    constructor (g: Keyring?, c: seq<Keyring>)
      requires g != null ==> g.Valid()
      requires forall i: int :: 0 <= i < |c| ==> c[i].Valid()
      ensures generator == g
      ensures children == c
      ensures Valid() && fresh(Repr - (if g != null then g.Repr else {}) - childrenRepr(c))
      ensures generator == g && children == c
      decreases g, c
    {
      generator := g;
      children := c;
      Repr := {this} + (if g != null then g.Repr else {}) + childrenRepr(c);
    }

    predicate Valid()
      reads this, Repr
      ensures Valid() ==> this in Repr
      decreases Repr + {this}
    {
      this in Repr &&
      (generator != null ==>
        generator in Repr &&
        generator.Repr <= Repr &&
        generator.Valid()) &&
      forall j: int :: 
        0 <= j < |children| ==>
          children[j] in Repr &&
          children[j].Repr <= Repr &&
          children[j].Valid()
    }

    method OnEncrypt(materials: Materials.ValidEncryptionMaterials) returns (res: Result<Materials.ValidEncryptionMaterials, string>)
      requires Valid()
      ensures Valid()
      ensures OnEncryptPure(materials, res)
      decreases materials
    {
      var resultMaterials := materials;
      if generator != null {
        resultMaterials :- generator.OnEncrypt(resultMaterials);
      }
      if resultMaterials.plaintextDataKey.None? {
        return Failure(""Bad state: data key not found"");
      }
      var i := 0;
      while i < |children|
        invariant resultMaterials.plaintextDataKey.Some?
        invariant materials.encryptionContext == resultMaterials.encryptionContext
        invariant materials.algorithmSuiteID == resultMaterials.algorithmSuiteID
        invariant materials.plaintextDataKey.Some? ==> resultMaterials.plaintextDataKey == materials.plaintextDataKey
        invariant materials.encryptedDataKeys <= resultMaterials.encryptedDataKeys
        invariant materials.signingKey == resultMaterials.signingKey
        decreases |children| - i
      {
        resultMaterials :- children[i].OnEncrypt(resultMaterials);
        i := i + 1;
      }
      res := Success(resultMaterials);
    }

    method OnDecrypt(materials: Materials.ValidDecryptionMaterials, edks: seq<Materials.EncryptedDataKey>) returns (res: Result<Materials.ValidDecryptionMaterials, string>)
      requires Valid()
      ensures Valid()
      ensures OnDecryptPure(materials, res)
      decreases materials, edks
    {
      if materials.plaintextDataKey.Some? {
        return Success(materials);
      }
      if generator != null {
        var onDecryptResult := generator.OnDecrypt(materials, edks);
        if onDecryptResult.Success? {
          return onDecryptResult;
        }
      }
      var i := 0;
      res := Success(materials);
      while i < |children|
        invariant res.Success? ==> materials.encryptionContext == res.value.encryptionContext && materials.algorithmSuiteID == res.value.algorithmSuiteID && (materials.plaintextDataKey.Some? ==> res.value.plaintextDataKey == materials.plaintextDataKey) && materials.verificationKey == res.value.verificationKey
        decreases |children| - i
      {
        var onDecryptResult := children[i].OnDecrypt(materials, edks);
        if onDecryptResult.Success? {
          return onDecryptResult;
        }
        i := i + 1;
      }
      return Failure(""Unable to decrypt."");
    }
  }

  function childrenRepr(xs: seq<Keyring>): (res: set<object>)
    reads set i: int {:trigger xs[i]} | 0 <= i < |xs| :: xs[i]
    ensures forall i: Keyring :: i in xs ==> i in res && i.Repr <= res
    decreases |xs|
  {
    if xs == [] then
      {}
    else
      childrenRepr(xs[1..]) + {xs[0]} + xs[0].Repr
  }
}

module {:extern ""RawAESKeyringDef""} RawAESKeyringDef {

  import opened StandardLibrary = StandardLibrary

  import opened Wrappers = Wrappers

  import opened UInt = StandardLibrary.UInt

  import EncryptionSuites = EncryptionSuites

  import AlgorithmSuite = AlgorithmSuite

  import Random = Random

  import KeyringDefs = KeyringDefs

  import AESEncryption = AESEncryption

  import Mat = Materials

  import MessageHeader = MessageHeader

  import UTF8 = UTF8

  import EncryptionContext = EncryptionContext

  import Serialize = Serialize

  import Streams = Streams
  class RawAESKeyring extends KeyringDefs.Keyring {
    const keyNamespace: UTF8.ValidUTF8Bytes
    const keyName: UTF8.ValidUTF8Bytes
    const wrappingKey: seq<uint8>
    const wrappingAlgorithm: EncryptionSuites.EncryptionSuite

    predicate Valid()
      reads this, Repr
      ensures Valid() ==> this in Repr
      decreases Repr + {this}
    {
      this in Repr &&
      |wrappingKey| == wrappingAlgorithm.keyLen as int &&
      wrappingAlgorithm in VALID_ALGORITHMS &&
      wrappingAlgorithm.Valid() &&
      |keyNamespace| < UINT16_LIMIT
    }

    constructor (namespace: UTF8.ValidUTF8Bytes, name: UTF8.ValidUTF8Bytes, key: seq<uint8>, wrappingAlg: EncryptionSuites.EncryptionSuite)
      requires |namespace| < UINT16_LIMIT
      requires wrappingAlg in VALID_ALGORITHMS
      requires wrappingAlg.Valid()
      requires |key| == wrappingAlg.keyLen as int
      ensures keyNamespace == namespace
      ensures keyName == name
      ensures wrappingKey == key
      ensures wrappingAlgorithm == wrappingAlg
      ensures Valid() && fresh(Repr)
      decreases namespace, name, key, wrappingAlg
    {
      keyNamespace := namespace;
      keyName := name;
      wrappingKey := key;
      wrappingAlgorithm := wrappingAlg;
      Repr := {this};
    }

    function method SerializeProviderInfo(iv: seq<uint8>): seq<uint8>
      requires Valid()
      requires |iv| == wrappingAlgorithm.ivLen as int
      reads Repr
      decreases Repr, iv
    {
      keyName + [0, 0, 0, wrappingAlgorithm.tagLen * 8] + [0, 0, 0, wrappingAlgorithm.ivLen] + iv
    }

    method OnEncrypt(materials: Mat.ValidEncryptionMaterials) returns (res: Result<Mat.ValidEncryptionMaterials, string>)
      requires Valid()
      ensures KeyringDefs.OnEncryptPure(materials, res)
      ensures res.Success? ==> true && var encCtxSerializable: bool := (reveal EncryptionContext.Serializable(); EncryptionContext.Serializable(materials.encryptionContext)); |res.value.encryptedDataKeys| == |materials.encryptedDataKeys| + 1 && encCtxSerializable && wrappingAlgorithm.tagLen as nat <= |res.value.encryptedDataKeys[|materials.encryptedDataKeys|].ciphertext| && var encOutput: AESEncryption.EncryptionOutput := DeserializeEDKCiphertext(res.value.encryptedDataKeys[|materials.encryptedDataKeys|].ciphertext, wrappingAlgorithm.tagLen as nat); true && AESEncryption.EncryptionOutputEncryptedWithAAD(encOutput, EncryptionContext.MapToSeq(materials.encryptionContext))
      ensures res.Success? ==> |res.value.encryptedDataKeys| == |materials.encryptedDataKeys| + 1 && res.value.encryptedDataKeys[|materials.encryptedDataKeys|].providerID == keyNamespace && ValidProviderInfo(res.value.encryptedDataKeys[|materials.encryptedDataKeys|].providerInfo)
      ensures !EncryptionContext.Serializable(materials.encryptionContext) ==> res.Failure?
      decreases materials
    {
      reveal EncryptionContext.Serializable();
      var valid := EncryptionContext.CheckSerializable(materials.encryptionContext);
      if !valid {
        return Failure(""Unable to serialize encryption context"");
      }
      var materialsWithDataKey := materials;
      if materialsWithDataKey.plaintextDataKey.None? {
        var k :- Random.GenerateBytes(materials.algorithmSuiteID.KeyLength() as int32);
        materialsWithDataKey := materialsWithDataKey.WithKeys(Some(k), []);
      }
      var iv :- Random.GenerateBytes(wrappingAlgorithm.ivLen as int32);
      var providerInfo := SerializeProviderInfo(iv);
      var wr := new Streams.ByteWriter();
      var _ :- Serialize.SerializeKVPairs(wr, materials.encryptionContext);
      var aad := wr.GetDataWritten();
      assert aad == EncryptionContext.MapToSeq(materials.encryptionContext);
      var encryptResult :- AESEncryption.AESEncrypt(wrappingAlgorithm, iv, wrappingKey, materialsWithDataKey.plaintextDataKey.value, aad);
      var encryptedKey := SerializeEDKCiphertext(encryptResult);
      if UINT16_LIMIT <= |providerInfo| {
        return Failure(""Serialized provider info too long."");
      }
      if UINT16_LIMIT <= |encryptedKey| {
        return Failure(""Encrypted data key too long."");
      }
      var edk := Mat.EncryptedDataKey(keyNamespace, providerInfo, encryptedKey);
      res := Success(materialsWithDataKey.WithKeys(materialsWithDataKey.plaintextDataKey, [edk]));
    }

    method OnDecrypt(materials: Mat.ValidDecryptionMaterials, edks: seq<Mat.EncryptedDataKey>) returns (res: Result<Mat.ValidDecryptionMaterials, string>)
      requires Valid()
      ensures Valid()
      ensures KeyringDefs.OnDecryptPure(materials, res)
      ensures res.Success? && materials.plaintextDataKey.None? && res.value.plaintextDataKey.Some? ==> var encCtxSerializable: bool := (reveal EncryptionContext.Serializable(); EncryptionContext.Serializable(materials.encryptionContext)); encCtxSerializable && AESEncryption.PlaintextDecryptedWithAAD(res.value.plaintextDataKey.value, EncryptionContext.MapToSeq(materials.encryptionContext))
      ensures materials.plaintextDataKey.None? && !EncryptionContext.Serializable(materials.encryptionContext) && (exists i: int :: 0 <= i < |edks| && ShouldDecryptEDK(edks[i])) ==> res.Failure?
      decreases materials, edks
    {
      if materials.plaintextDataKey.Some? {
        return Success(materials);
      }
      var i := 0;
      while i < |edks|
        invariant forall prevIndex: int :: 0 <= prevIndex < i ==> prevIndex < |edks| && !ShouldDecryptEDK(edks[prevIndex])
        decreases |edks| - i
      {
        if ShouldDecryptEDK(edks[i]) {
          reveal EncryptionContext.Serializable();
          var valid := EncryptionContext.CheckSerializable(materials.encryptionContext);
          if !valid {
            return Failure(""Unable to serialize encryption context"");
          }
          var wr := new Streams.ByteWriter();
          var _ :- Serialize.SerializeKVPairs(wr, materials.encryptionContext);
          var aad := wr.GetDataWritten();
          assert aad == EncryptionContext.MapToSeq(materials.encryptionContext);
          var iv := GetIvFromProvInfo(edks[i].providerInfo);
          var encryptionOutput := DeserializeEDKCiphertext(edks[i].ciphertext, wrappingAlgorithm.tagLen as nat);
          var ptKey :- AESEncryption.AESDecrypt(wrappingAlgorithm, wrappingKey, encryptionOutput.cipherText, encryptionOutput.authTag, iv, aad);
          if materials.algorithmSuiteID.ValidPlaintextDataKey(ptKey) {
            return Success(materials.WithPlaintextDataKey(ptKey));
          } else {
            return Failure(""Decryption failed: bad datakey length."");
          }
        }
        i := i + 1;
      }
      return Failure(""Unable to decrypt."");
    }

    predicate method ShouldDecryptEDK(edk: Mat.EncryptedDataKey)
      decreases edk
    {
      edk.providerID == keyNamespace &&
      ValidProviderInfo(edk.providerInfo) &&
      wrappingAlgorithm.tagLen as int <= |edk.ciphertext|
    }

    predicate method ValidProviderInfo(info: seq<uint8>)
      decreases info
    {
      |info| == |keyName| + AUTH_TAG_LEN_LEN + IV_LEN_LEN + wrappingAlgorithm.ivLen as int &&
      info[0 .. |keyName|] == keyName &&
      SeqToUInt32(info[|keyName| .. |keyName| + AUTH_TAG_LEN_LEN]) == wrappingAlgorithm.tagLen as uint32 * 8 &&
      SeqToUInt32(info[|keyName| + AUTH_TAG_LEN_LEN .. |keyName| + AUTH_TAG_LEN_LEN + IV_LEN_LEN]) == wrappingAlgorithm.ivLen as uint32
    }

    function method GetIvFromProvInfo(info: seq<uint8>): seq<uint8>
      requires ValidProviderInfo(info)
      decreases info
    {
      info[|keyName| + AUTH_TAG_LEN_LEN + IV_LEN_LEN..]
    }
  }

  const AUTH_TAG_LEN_LEN := 4
  const IV_LEN_LEN := 4
  const VALID_ALGORITHMS := {EncryptionSuites.AES_GCM_128, EncryptionSuites.AES_GCM_192, EncryptionSuites.AES_GCM_256}

  function method DeserializeEDKCiphertext(ciphertext: seq<uint8>, tagLen: nat): (encOutput: AESEncryption.EncryptionOutput)
    requires tagLen <= |ciphertext|
    ensures |encOutput.authTag| == tagLen
    decreases ciphertext, tagLen
  {
    var encryptedKeyLength: int := |ciphertext| - tagLen as int;
    AESEncryption.EncryptionOutput(ciphertext[..encryptedKeyLength], ciphertext[encryptedKeyLength..])
  }

  function method SerializeEDKCiphertext(encOutput: AESEncryption.EncryptionOutput): (ciphertext: seq<uint8>)
    decreases encOutput
  {
    encOutput.cipherText + encOutput.authTag
  }

  lemma EDKSerializeDeserialize(encOutput: AESEncryption.EncryptionOutput)
    ensures DeserializeEDKCiphertext(SerializeEDKCiphertext(encOutput), |encOutput.authTag|) == encOutput
    decreases encOutput
  {
  }

  lemma EDKDeserializeSerialze(ciphertext: seq<uint8>, tagLen: nat)
    requires tagLen <= |ciphertext|
    ensures SerializeEDKCiphertext(DeserializeEDKCiphertext(ciphertext, tagLen)) == ciphertext
    decreases ciphertext, tagLen
  {
  }
}

module {:extern ""RawRSAKeyringDef""} RawRSAKeyringDef {

  import opened StandardLibrary = StandardLibrary

  import opened Wrappers = Wrappers

  import opened UInt = StandardLibrary.UInt

  import AlgorithmSuite = AlgorithmSuite

  import KeyringDefs = KeyringDefs

  import Materials = Materials

  import Random = Random

  import RSA = RSAEncryption

  import UTF8 = UTF8
  class RawRSAKeyring extends KeyringDefs.Keyring {
    const keyNamespace: UTF8.ValidUTF8Bytes
    const keyName: UTF8.ValidUTF8Bytes
    const paddingMode: RSA.PaddingMode
    const publicKey: Option<RSA.PublicKey>
    const privateKey: Option<RSA.PrivateKey>

    predicate Valid()
      reads this, Repr
      ensures Valid() ==> this in Repr
      decreases Repr + {this}
    {
      this in Repr &&
      (publicKey.Some? || privateKey.Some?) &&
      (publicKey.Some? ==>
        publicKey.value in Repr &&
        publicKey.value.Repr <= Repr &&
        this !in publicKey.value.Repr &&
        publicKey.value.Valid()) &&
      (publicKey.Some? ==>
        publicKey.value.padding == paddingMode) &&
      (privateKey.Some? ==>
        privateKey.value in Repr &&
        privateKey.value.Repr <= Repr &&
        this !in privateKey.value.Repr &&
        privateKey.value.Valid()) &&
      (privateKey.Some? ==>
        privateKey.value.padding == paddingMode) &&
      |keyNamespace| < UINT16_LIMIT &&
      |keyName| < UINT16_LIMIT
    }

    constructor (namespace: UTF8.ValidUTF8Bytes, name: UTF8.ValidUTF8Bytes, padding: RSA.PaddingMode, publicKey: Option<RSA.PublicKey>, privateKey: Option<RSA.PrivateKey>)
      requires publicKey.Some? || privateKey.Some?
      requires publicKey.Some? ==> publicKey.value.Valid()
      requires publicKey.Some? ==> publicKey.value.padding == padding
      requires privateKey.Some? ==> privateKey.value.Valid()
      requires privateKey.Some? ==> privateKey.value.padding == padding
      requires |namespace| < UINT16_LIMIT
      requires |name| < UINT16_LIMIT
      ensures keyNamespace == namespace
      ensures keyName == name
      ensures paddingMode == padding
      ensures this.publicKey == publicKey
      ensures this.privateKey == privateKey
      ensures Valid() && fresh(Repr - KeyRepr(publicKey) - KeyRepr(privateKey))
      decreases namespace, name, padding, publicKey, privateKey
    {
      keyNamespace := namespace;
      keyName := name;
      paddingMode := padding;
      this.publicKey := publicKey;
      this.privateKey := privateKey;
      Repr := {this} + KeyRepr(publicKey) + KeyRepr(privateKey);
    }

    static function KeyRepr(key: Option<RSA.Key>): set<object>
      reads if key.Some? then {key.value} else {}
      decreases if key.Some? then {key.value} else {}, key
    {
      if key.Some? then
        key.value.Repr
      else
        {}
    }

    method OnEncrypt(materials: Materials.ValidEncryptionMaterials) returns (res: Result<Materials.ValidEncryptionMaterials, string>)
      requires Valid()
      ensures publicKey.None? ==> res.Failure?
      ensures KeyringDefs.OnEncryptPure(materials, res)
      ensures res.Success? ==> forall i: int :: |materials.encryptedDataKeys| <= i < |res.value.encryptedDataKeys| ==> res.value.encryptedDataKeys[i].providerID == keyNamespace && res.value.encryptedDataKeys[i].providerInfo == keyName
      decreases materials
    {
      if publicKey.None? {
        return Failure(""Encryption key undefined"");
      }
      var materialsWithDataKey := materials;
      if materials.plaintextDataKey.None? {
        var k :- Random.GenerateBytes(materialsWithDataKey.algorithmSuiteID.KDFInputKeyLength() as int32);
        materialsWithDataKey := materials.WithKeys(Some(k), []);
      }
      var encryptedCiphertext :- RSA.Encrypt(paddingMode, publicKey.value, materialsWithDataKey.plaintextDataKey.value);
      if UINT16_LIMIT <= |encryptedCiphertext| {
        return Failure(""Encrypted data key too long."");
      }
      var encryptedDataKey := Materials.EncryptedDataKey(keyNamespace, keyName, encryptedCiphertext);
      var materials := materialsWithDataKey.WithKeys(materialsWithDataKey.plaintextDataKey, [encryptedDataKey]);
      assert materials.Valid();
      return Success(materials);
    }

    method OnDecrypt(materials: Materials.ValidDecryptionMaterials, encryptedDataKeys: seq<Materials.EncryptedDataKey>) returns (res: Result<Materials.ValidDecryptionMaterials, string>)
      requires Valid()
      ensures Valid()
      ensures KeyringDefs.OnDecryptPure(materials, res)
      ensures privateKey.None? && materials.plaintextDataKey.None? && |encryptedDataKeys| > 0 ==> res.Failure?
      decreases materials, encryptedDataKeys
    {
      if materials.plaintextDataKey.Some? {
        return Success(materials);
      } else if privateKey.None? {
        return Failure(""Decryption key undefined"");
      }
      var i := 0;
      while i < |encryptedDataKeys|
        invariant 0 <= i <= |encryptedDataKeys|
        decreases |encryptedDataKeys| - i
      {
        var encryptedDataKey := encryptedDataKeys[i];
        if encryptedDataKey.providerID == keyNamespace && encryptedDataKey.providerInfo == keyName && 0 < |encryptedDataKey.ciphertext| {
          var potentialPlaintextDataKey := RSA.Decrypt(paddingMode, privateKey.value, encryptedDataKey.ciphertext);
          match potentialPlaintextDataKey
          case {:split false} Failure(_v0) =>
          case {:split false} Success(plaintextDataKey) =>
            if materials.algorithmSuiteID.ValidPlaintextDataKey(plaintextDataKey) {
              return Success(materials.WithPlaintextDataKey(plaintextDataKey));
            } else {
              return Failure(""Bad key length!"");
            }
        }
        i := i + 1;
      }
      return Failure(""Unable to decrypt."");
    }
  }
}

module {:extern ""Materials""} Materials {

  import opened StandardLibrary = StandardLibrary

  import opened Wrappers = Wrappers

  import opened UInt = StandardLibrary.UInt

  import UTF8 = UTF8

  import AlgorithmSuite = AlgorithmSuite

  import EncryptionContext = EncryptionContext
  datatype EncryptedDataKey = EncryptedDataKey(providerID: UTF8.ValidUTF8Bytes, providerInfo: seq<uint8>, ciphertext: seq<uint8>) {
    predicate Valid()
      decreases this
    {
      |providerID| < UINT16_LIMIT &&
      |providerInfo| < UINT16_LIMIT &&
      |ciphertext| < UINT16_LIMIT
    }

    static function method ValidWitness(): EncryptedDataKey
    {
      EncryptedDataKey([], [], [])
    }
  }

  type ValidEncryptedDataKey = i: EncryptedDataKey
    | i.Valid()
    witness EncryptedDataKey.ValidWitness()

  datatype EncryptionMaterials = EncryptionMaterials(encryptionContext: EncryptionContext.Map, algorithmSuiteID: AlgorithmSuite.ID, plaintextDataKey: Option<seq<uint8>>, encryptedDataKeys: seq<ValidEncryptedDataKey>, signingKey: Option<seq<uint8>>) {
    predicate Valid()
      decreases this
    {
      (algorithmSuiteID.SignatureType().Some? ==>
        signingKey.Some?) &&
      (plaintextDataKey.Some? ==>
        algorithmSuiteID.ValidPlaintextDataKey(plaintextDataKey.value)) &&
      (plaintextDataKey.None? ==>
        |encryptedDataKeys| == 0)
    }

    predicate Empty()
      decreases this
    {
      plaintextDataKey.None? &&
      |encryptedDataKeys| == 0 &&
      (algorithmSuiteID.SignatureType().Some? ==>
        signingKey.Some?)
    }

    predicate Useable()
      decreases this
    {
      plaintextDataKey.Some? &&
      algorithmSuiteID.ValidPlaintextDataKey(plaintextDataKey.value) &&
      |encryptedDataKeys| > 0 &&
      (algorithmSuiteID.SignatureType().Some? ==>
        signingKey.Some?)
    }

    predicate Serializable()
      decreases this
    {
      |encryptedDataKeys| > 0 &&
      EncryptionContext.Serializable(encryptionContext)
    }

    static function method ValidWitness(): EncryptionMaterials
    {
      EncryptionMaterials(map[], AlgorithmSuite.AES_256_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384, None, [], Some(seq(32, (i: int) => 0)))
    }

    static function method WithoutDataKeys(encryptionContext: EncryptionContext.Map, algorithmSuiteID: AlgorithmSuite.ID, signingKey: Option<seq<uint8>>): ValidEncryptionMaterials
      requires algorithmSuiteID.SignatureType().Some? ==> signingKey.Some?
      decreases encryptionContext, algorithmSuiteID, signingKey
    {
      var m: EncryptionMaterials := EncryptionMaterials(encryptionContext, algorithmSuiteID, None, [], signingKey);
      assert m.Valid();
      m
    }

    function method WithKeys(newPlaintextDataKey: Option<seq<uint8>>, newEncryptedDataKeys: seq<ValidEncryptedDataKey>): (res: ValidEncryptionMaterials)
      requires Valid()
      requires this.plaintextDataKey.Some? ==> newPlaintextDataKey == this.plaintextDataKey
      requires newPlaintextDataKey.Some? ==> this.algorithmSuiteID.ValidPlaintextDataKey(newPlaintextDataKey.value)
      requires newPlaintextDataKey.None? ==> |newEncryptedDataKeys| == 0
      ensures this.encryptionContext == res.encryptionContext
      ensures this.algorithmSuiteID == res.algorithmSuiteID
      ensures newPlaintextDataKey == res.plaintextDataKey
      ensures this.encryptedDataKeys + newEncryptedDataKeys == res.encryptedDataKeys
      ensures this.signingKey == res.signingKey
      decreases this, newPlaintextDataKey, newEncryptedDataKeys
    {
      var r: EncryptionMaterials := this.(plaintextDataKey := newPlaintextDataKey, encryptedDataKeys := encryptedDataKeys + newEncryptedDataKeys);
      assert r.Valid();
      r
    }
  }

  type ValidEncryptionMaterials = i: EncryptionMaterials
    | i.Valid()
    witness EncryptionMaterials.ValidWitness()

  type EmptyEncryptionMaterials = i: EncryptionMaterials
    | i.Empty()
    witness *

  type UseableEncryptionMaterials = i: EncryptionMaterials
    | i.Useable()
    witness *

  datatype DecryptionMaterials = DecryptionMaterials(algorithmSuiteID: AlgorithmSuite.ID, encryptionContext: EncryptionContext.Map, plaintextDataKey: Option<seq<uint8>>, verificationKey: Option<seq<uint8>>) {
    predicate Valid()
      decreases this
    {
      (plaintextDataKey.Some? ==>
        algorithmSuiteID.ValidPlaintextDataKey(plaintextDataKey.value)) &&
      (algorithmSuiteID.SignatureType().Some? ==>
        verificationKey.Some?)
    }

    predicate Pending()
      decreases this
    {
      plaintextDataKey.None? &&
      (algorithmSuiteID.SignatureType().Some? ==>
        verificationKey.Some?)
    }

    predicate Complete()
      decreases this
    {
      plaintextDataKey.Some? &&
      algorithmSuiteID.ValidPlaintextDataKey(plaintextDataKey.value) &&
      (algorithmSuiteID.SignatureType().Some? ==>
        verificationKey.Some?)
    }

    static function method ValidWitness(): DecryptionMaterials
    {
      DecryptionMaterials(AlgorithmSuite.AES_256_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384, map[], Some(seq(32, (i: int) => 0)), Some(seq(32, (i: int) => 0)))
    }

    static function method WithoutPlaintextDataKey(encryptionContext: EncryptionContext.Map, algorithmSuiteID: AlgorithmSuite.ID, verificationKey: Option<seq<uint8>>): ValidDecryptionMaterials
      requires algorithmSuiteID.SignatureType().Some? ==> verificationKey.Some?
      decreases encryptionContext, algorithmSuiteID, verificationKey
    {
      var m: DecryptionMaterials := DecryptionMaterials(algorithmSuiteID, encryptionContext, None, verificationKey);
      assert m.Valid();
      m
    }

    function method WithPlaintextDataKey(plaintextDataKey: seq<uint8>): (res: ValidDecryptionMaterials)
      requires Valid()
      requires this.plaintextDataKey.None?
      requires algorithmSuiteID.ValidPlaintextDataKey(plaintextDataKey)
      ensures this.encryptionContext == res.encryptionContext
      ensures this.algorithmSuiteID == res.algorithmSuiteID
      ensures res.plaintextDataKey.Some?
      ensures this.verificationKey == res.verificationKey
      decreases this, plaintextDataKey
    {
      var m: DecryptionMaterials := this.(plaintextDataKey := Some(plaintextDataKey));
      assert m.Valid();
      m
    }
  }

  type PendingDecryptionMaterials = i: DecryptionMaterials
    | i.Pending()
    witness *

  type CompleteDecryptionMaterials = i: DecryptionMaterials
    | i.Complete()
    witness *

  type ValidDecryptionMaterials = i: DecryptionMaterials
    | i.Valid()
    witness DecryptionMaterials.ValidWitness()

  datatype EncryptionMaterialsRequest = EncryptionMaterialsRequest(encryptionContext: EncryptionContext.Map, algorithmSuiteID: Option<AlgorithmSuite.ID>, plaintextLength: Option<nat>)

  datatype DecryptionMaterialsRequest = DecryptionMaterialsRequest(algorithmSuiteID: AlgorithmSuite.ID, encryptedDataKeys: seq<ValidEncryptedDataKey>, encryptionContext: EncryptionContext.Map) {
    predicate Valid()
      decreases this
    {
      |encryptedDataKeys| > 0
    }

    static function method ValidWitness(): DecryptionMaterialsRequest
    {
      DecryptionMaterialsRequest(AlgorithmSuite.AES_256_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384, [EncryptedDataKey.ValidWitness()], map[])
    }
  }

  type ValidDecryptionMaterialsRequest = i: DecryptionMaterialsRequest
    | i.Valid()
    witness DecryptionMaterialsRequest.ValidWitness()

  const EC_PUBLIC_KEY_FIELD: UTF8.ValidUTF8Bytes := var s: seq<uint8> := [97, 119, 115, 45, 99, 114, 121, 112, 116, 111, 45, 112, 117, 98, 108, 105, 99, 45, 107, 101, 121]; assert UTF8.ValidUTF8Range(s, 0, 21); s
  const RESERVED_KEY_VALUES := {EC_PUBLIC_KEY_FIELD}
}

module MessageBody {

  export
    provides EncryptMessageBody, DecryptFramedMessageBody, DecryptNonFramedMessageBody, Wrappers, UInt, Msg, AlgorithmSuite, Materials, Streams, FramesToSequence, FrameToSequence, ValidFrames, FramesEncryptPlaintext, AESEncryption, DecryptedWithKey
    reveals Frame, Frame.Valid, SeqWithGhostFrames


  import opened Wrappers = Wrappers

  import opened UInt = StandardLibrary.UInt

  import AlgorithmSuite = AlgorithmSuite

  import Msg = MessageHeader

  import AESEncryption = AESEncryption

  import Materials = Materials

  import Streams = Streams

  import EncryptionSuites = EncryptionSuites

  import UTF8 = UTF8
  datatype BodyAADContent = AADRegularFrame | AADFinalFrame | AADSingleBlock

  datatype Frame = RegularFrame(seqNum: uint32, iv: seq<uint8>, encContent: seq<uint8>, authTag: seq<uint8>) | FinalFrame(seqNum: uint32, iv: seq<uint8>, encContent: seq<uint8>, authTag: seq<uint8>) {
    predicate Valid()
      decreases this
    {
      |encContent| < UINT32_LIMIT
    }
  }

  datatype SeqWithGhostFrames = SeqWithGhostFrames(sequence: seq<uint8>, ghost frames: seq<Frame>)

  datatype FrameWithGhostSeq = FrameWithGhostSeq(frame: Frame, ghost sequence: seq<uint8>)

  predicate ValidFrames(frames: seq<Frame>)
    decreases frames
  {
    0 < |frames| < UINT32_LIMIT &&
    forall i: int | 0 <= i < |frames| :: 
      ghost var frame: Frame := frames[i]; frame.Valid() && (if i == |frames| - 1 then frame.FinalFrame? else frame.RegularFrame?) && frame.seqNum as int == i + START_SEQUENCE_NUMBER as int && forall j: int | i < j < |frames| :: frame.iv != frames[j].iv
  }

  const BODY_AAD_CONTENT_REGULAR_FRAME: string := ""AWSKMSEncryptionClient Frame""
  const BODY_AAD_CONTENT_FINAL_FRAME: string := ""AWSKMSEncryptionClient Final Frame""
  const BODY_AAD_CONTENT_SINGLE_BLOCK: string := ""AWSKMSEncryptionClient Single Block""

  function method BodyAADContentTypeString(bc: BodyAADContent): string
    decreases bc
  {
    match bc
    case AADRegularFrame() =>
      BODY_AAD_CONTENT_REGULAR_FRAME
    case AADFinalFrame() =>
      BODY_AAD_CONTENT_FINAL_FRAME
    case AADSingleBlock() =>
      BODY_AAD_CONTENT_SINGLE_BLOCK
  }

  const START_SEQUENCE_NUMBER: uint32 := 1
  const ENDFRAME_SEQUENCE_NUMBER: uint32 := 4294967295
  const NONFRAMED_SEQUENCE_NUMBER: uint32 := 1

  function method IVSeq(algorithmSuiteID: AlgorithmSuite.ID, sequenceNumber: uint32): seq<uint8>
    decreases algorithmSuiteID, sequenceNumber
  {
    seq(algorithmSuiteID.IVLength() - 4, (_: int) => 0) + UInt32ToSeq(sequenceNumber)
  }

  lemma IVSeqDistinct(algorithmSuiteID: AlgorithmSuite.ID, m: uint32, n: uint32)
    requires m != n
    ensures IVSeq(algorithmSuiteID, m) != IVSeq(algorithmSuiteID, n)
    decreases algorithmSuiteID, m, n
  {
    ghost var paddingLength := algorithmSuiteID.IVLength() - 4;
    assert IVSeq(algorithmSuiteID, m)[paddingLength..] == UInt32ToSeq(m);
    assert IVSeq(algorithmSuiteID, n)[paddingLength..] == UInt32ToSeq(n);
    UInt32SeqSerializeDeserialize(m);
    UInt32SeqSerializeDeserialize(n);
  }

  function FramesToSequence(frames: seq<Frame>): seq<uint8>
    requires forall frame: Frame | frame in frames :: frame.Valid()
    decreases frames
  {
    if frames == [] then
      []
    else
      FramesToSequence(frames[..|frames| - 1]) + FrameToSequence(frames[|frames| - 1])
  }

  lemma /*{:_induction frames}*/ ExtendFramesToSequence(frames: seq<Frame>, frame: Frame)
    requires |frames| < UINT32_LIMIT - 1
    requires forall frame: Frame | frame in frames :: frame.Valid()
    requires frame.Valid()
    ensures FramesToSequence(frames + [frame]) == FramesToSequence(frames) + FrameToSequence(frame)
    decreases frames, frame
  {
  }

  function FrameToSequence(frame: Frame): (res: seq<uint8>)
    requires frame.Valid()
    ensures match frame { case RegularFrame(_mcc#0, _mcc#1, _mcc#2, _mcc#3) => (var authTag: seq<uint8> := _mcc#3; var encContent: seq<uint8> := _mcc#2; var iv: seq<uint8> := _mcc#1; 4 + |iv| + |encContent| + |authTag| == |res|) case FinalFrame(_mcc#4, _mcc#5, _mcc#6, _mcc#7) => var authTag: seq<uint8> := _mcc#7; var encContent: seq<uint8> := _mcc#6; var iv: seq<uint8> := _mcc#5; var seqNum: uint32 := _mcc#4; 4 + 4 + |iv| + 4 + |encContent| + |authTag| == |res| }
    decreases frame
  {
    match frame
    case RegularFrame(seqNum, iv, encContent, authTag) =>
      var seqNumSeq := UInt32ToSeq(seqNum);
      seqNumSeq + iv + encContent + authTag
    case FinalFrame(seqNum, iv, encContent, authTag) =>
      var seqNumEndSeq := UInt32ToSeq(ENDFRAME_SEQUENCE_NUMBER);
      var seqNumSeq := UInt32ToSeq(seqNum);
      var encContentLengthSeq := UInt32ToSeq(|encContent| as uint32);
      seqNumEndSeq + seqNumSeq + iv + encContentLengthSeq + encContent + authTag
  }

  predicate FramesEncryptPlaintext(frames: seq<Frame>, plaintext: seq<uint8>)
    decreases frames, plaintext
  {
    exists plaintextSeg: seq<seq<uint8>> :: 
      FramesEncryptPlaintextSegments(frames, plaintextSeg) &&
      SumPlaintextSegments(plaintextSeg) == plaintext
  }

  predicate FramesEncryptPlaintextSegments(frames: seq<Frame>, plaintextSeg: seq<seq<uint8>>)
    decreases frames, plaintextSeg
  {
    if |frames| != |plaintextSeg| then
      false
    else if frames == [] then
      true
    else
      FramesEncryptPlaintextSegments(frames[..|frames| - 1], plaintextSeg[..|frames| - 1]) && AESEncryption.CiphertextGeneratedWithPlaintext(frames[|frames| - 1].encContent, plaintextSeg[|frames| - 1])
  }

  lemma /*{:_induction frames, plaintextSeg}*/ ExtendFramesEncryptPlaintextSegments(frames: seq<Frame>, plaintextSeg: seq<seq<uint8>>, frame: Frame, plaintextFrame: seq<uint8>)
    requires FramesEncryptPlaintextSegments(frames, plaintextSeg)
    requires AESEncryption.CiphertextGeneratedWithPlaintext(frame.encContent, plaintextFrame)
    ensures FramesEncryptPlaintextSegments(frames + [frame], plaintextSeg + [plaintextFrame])
    decreases frames, plaintextSeg, frame, plaintextFrame
  {
  }

  function SumPlaintextSegments(plaintextSeg: seq<seq<uint8>>): seq<uint8>
    decreases plaintextSeg
  {
    if plaintextSeg == [] then
      []
    else
      SumPlaintextSegments(plaintextSeg[..|plaintextSeg| - 1]) + plaintextSeg[|plaintextSeg| - 1]
  }

  lemma /*{:_induction plaintextSeg}*/ ExtendSumPlaintextSegments(plaintextSeg: seq<seq<uint8>>, plaintextFrame: seq<uint8>)
    ensures SumPlaintextSegments(plaintextSeg + [plaintextFrame]) == SumPlaintextSegments(plaintextSeg) + plaintextFrame
    decreases plaintextSeg, plaintextFrame
  {
  }

  method EncryptMessageBody(plaintext: seq<uint8>, frameLength: int, messageID: Msg.MessageID, key: seq<uint8>, algorithmSuiteID: AlgorithmSuite.ID)
      returns (result: Result<SeqWithGhostFrames, string>)
    requires |key| == algorithmSuiteID.KeyLength()
    requires 0 < frameLength < UINT32_LIMIT
    ensures match result { case Success(_mcc#0) => (var seqWithGhostFrames := _mcc#0; var frames := seqWithGhostFrames.frames; ValidFrames(frames) && (forall frame | frame in frames :: frame.Valid()) && (forall frame: Frame | frame in frames :: |frame.iv| == algorithmSuiteID.IVLength()) && FramesToSequence(frames) == seqWithGhostFrames.sequence && FramesEncryptPlaintext(frames, plaintext) && forall frame: Frame | frame in frames :: AESEncryption.EncryptedWithKey(frame.encContent, key)) case Failure(_mcc#1) => var e := _mcc#1; true }
    decreases plaintext, frameLength, messageID, key, algorithmSuiteID
  {
    var body := [];
    var n: int, sequenceNumber := 0, START_SEQUENCE_NUMBER;
    ghost var frames: seq<Frame> := [];
    ghost var plaintextSeg := [];
    while n + frameLength < |plaintext|
      invariant |plaintext| != 0 ==> 0 <= n < |plaintext|
      invariant |plaintext| == 0 ==> 0 == n
      invariant START_SEQUENCE_NUMBER <= sequenceNumber <= ENDFRAME_SEQUENCE_NUMBER
      invariant |frames| == (sequenceNumber - START_SEQUENCE_NUMBER) as int
      invariant forall i: int | 0 <= i < |frames| :: var frame: Frame := frames[i]; frame.Valid() && frame.RegularFrame? && frame.seqNum as int == i + START_SEQUENCE_NUMBER as int
      invariant forall i: int | 0 <= i < |frames| :: frames[i].iv == IVSeq(algorithmSuiteID, frames[i].seqNum)
      invariant FramesToSequence(frames) == body
      invariant FramesEncryptPlaintextSegments(frames, plaintextSeg)
      invariant SumPlaintextSegments(plaintextSeg) == plaintext[..n]
      invariant forall frame: Frame | frame in frames :: AESEncryption.EncryptedWithKey(frame.encContent, key)
      decreases |plaintext| - (n + frameLength)
    {
      if sequenceNumber == ENDFRAME_SEQUENCE_NUMBER {
        return Failure(""too many frames"");
      }
      var plaintextFrame := plaintext[n .. n + frameLength];
      var regularFrame, frame := EncryptRegularFrame(algorithmSuiteID, key, frameLength, messageID, plaintextFrame, sequenceNumber);
      if regularFrame.IsFailure() {
        return regularFrame.PropagateFailure();
      }
      assert frame.iv == IVSeq(algorithmSuiteID, sequenceNumber);
      ExtendFramesToSequence(frames, frame);
      ExtendFramesEncryptPlaintextSegments(frames, plaintextSeg, frame, plaintextFrame);
      ExtendSumPlaintextSegments(plaintextSeg, plaintextFrame);
      frames := frames + [frame];
      body := body + regularFrame.Extract();
      plaintextSeg := plaintextSeg + [plaintextFrame];
      n, sequenceNumber := n + frameLength, sequenceNumber + 1;
      assert SumPlaintextSegments(plaintextSeg) == plaintext[..n];
    }
    var finalFrameResult, finalFrame := EncryptFinalFrame(algorithmSuiteID, key, frameLength, messageID, plaintext[n..], sequenceNumber);
    if finalFrameResult.IsFailure() {
      return finalFrameResult.PropagateFailure();
    }
    var finalFrameSequence := finalFrameResult.Extract();
    assert finalFrame.iv == IVSeq(algorithmSuiteID, sequenceNumber);
    ExtendFramesToSequence(frames, finalFrame);
    ExtendFramesEncryptPlaintextSegments(frames, plaintextSeg, finalFrame, plaintext[n..]);
    ExtendSumPlaintextSegments(plaintextSeg, plaintext[n..]);
    frames := frames + [finalFrame];
    body := body + finalFrameSequence;
    plaintextSeg := plaintextSeg + [plaintext[n..]];
    assert ValidFrames(frames) by {
      forall i: int, j: int | 0 <= i < j < |frames|
        ensures frames[i].iv != frames[j].iv
      {
        assert frames[i].seqNum as int == i + START_SEQUENCE_NUMBER as int;
        assert frames[j].seqNum as int == j + START_SEQUENCE_NUMBER as int;
        assert frames[i].iv == IVSeq(algorithmSuiteID, frames[i].seqNum);
        assert frames[j].iv == IVSeq(algorithmSuiteID, frames[j].seqNum);
        IVSeqDistinct(algorithmSuiteID, frames[i].seqNum, frames[j].seqNum);
      }
    }
    result := Success(SeqWithGhostFrames(body, frames));
  }

  method EncryptRegularFrame(algorithmSuiteID: AlgorithmSuite.ID, key: seq<uint8>, ghost frameLength: int, messageID: Msg.MessageID, plaintext: seq<uint8>, sequenceNumber: uint32)
      returns (res: Result<seq<uint8>, string>, ghost regFrame: Frame)
    requires |key| == algorithmSuiteID.KeyLength()
    requires 0 < frameLength < UINT32_LIMIT && START_SEQUENCE_NUMBER <= sequenceNumber <= ENDFRAME_SEQUENCE_NUMBER
    requires |plaintext| < UINT32_LIMIT
    requires |plaintext| == frameLength && sequenceNumber != ENDFRAME_SEQUENCE_NUMBER
    requires 4 <= algorithmSuiteID.IVLength()
    ensures match res { case Success(_mcc#0) => (var resultSuccess := _mcc#0; 4 + algorithmSuiteID.IVLength() + algorithmSuiteID.TagLength() + frameLength == |resultSuccess| && var iv := IVSeq(algorithmSuiteID, sequenceNumber); var encContent := resultSuccess[4 + algorithmSuiteID.IVLength() .. 4 + algorithmSuiteID.IVLength() + frameLength]; var authTag := resultSuccess[4 + algorithmSuiteID.IVLength() + frameLength..]; var frame := RegularFrame(sequenceNumber, iv, encContent, authTag); frame == regFrame && FrameToSequence(regFrame) == resultSuccess && AESEncryption.CiphertextGeneratedWithPlaintext(frame.encContent, plaintext) && AESEncryption.EncryptedWithKey(frame.encContent, key)) case Failure(_mcc#1) => var e := _mcc#1; true }
    decreases algorithmSuiteID, key, frameLength, messageID, plaintext, sequenceNumber
  {
    var seqNumSeq := UInt32ToSeq(sequenceNumber);
    var unauthenticatedFrame := seqNumSeq;
    var iv := IVSeq(algorithmSuiteID, sequenceNumber);
    var aad := BodyAAD(messageID, AADRegularFrame, sequenceNumber, |plaintext| as uint64);
    var encryptionOutputResult := AESEncryption.AESEncrypt(algorithmSuiteID.EncryptionSuite(), iv, key, plaintext, aad);
    if encryptionOutputResult.IsFailure() {
      res := encryptionOutputResult.PropagateFailure();
      regFrame := RegularFrame(0, [], [], []);
      return;
    }
    var encryptionOutput := encryptionOutputResult.Extract();
    ghost var frame := RegularFrame(sequenceNumber, iv, encryptionOutput.cipherText, encryptionOutput.authTag);
    SeqWithUInt32Suffix(iv, sequenceNumber as nat);
    unauthenticatedFrame := unauthenticatedFrame + iv;
    unauthenticatedFrame := unauthenticatedFrame + encryptionOutput.cipherText + encryptionOutput.authTag;
    return Success(unauthenticatedFrame), frame;
  }

  method EncryptFinalFrame(algorithmSuiteID: AlgorithmSuite.ID, key: seq<uint8>, frameLength: int, messageID: Msg.MessageID, plaintext: seq<uint8>, sequenceNumber: uint32)
      returns (res: Result<seq<uint8>, string>, ghost finalFrame: Frame)
    requires |key| == algorithmSuiteID.KeyLength()
    requires START_SEQUENCE_NUMBER <= sequenceNumber <= ENDFRAME_SEQUENCE_NUMBER
    requires 0 <= |plaintext| < UINT32_LIMIT
    requires 0 < frameLength < UINT32_LIMIT
    requires |plaintext| <= frameLength
    requires 4 <= algorithmSuiteID.IVLength()
    ensures match res { case Success(_mcc#0) => (var resultSuccess := _mcc#0; 4 + 4 + algorithmSuiteID.IVLength() + 4 + algorithmSuiteID.TagLength() <= |resultSuccess| <= 4 + 4 + algorithmSuiteID.IVLength() + 4 + algorithmSuiteID.TagLength() + frameLength && var contentLength: uint32 := SeqToUInt32(resultSuccess[4 + 4 + algorithmSuiteID.IVLength() .. 4 + 4 + algorithmSuiteID.IVLength() + 4]); |resultSuccess| == 4 + 4 + algorithmSuiteID.IVLength() + 4 + contentLength as int + algorithmSuiteID.TagLength() && resultSuccess[..4] == UInt32ToSeq(ENDFRAME_SEQUENCE_NUMBER) && |plaintext| == SeqToUInt32(resultSuccess[4 + 4 + algorithmSuiteID.IVLength() .. 4 + 4 + algorithmSuiteID.IVLength() + 4]) as int && var iv := IVSeq(algorithmSuiteID, sequenceNumber); var encContent := resultSuccess[4 + 4 + algorithmSuiteID.IVLength() + 4..][..|plaintext|]; var authTag := resultSuccess[4 + 4 + algorithmSuiteID.IVLength() + 4 + |plaintext|..]; var frame := FinalFrame(sequenceNumber, iv, encContent, authTag); FrameToSequence(frame) == resultSuccess && finalFrame == frame && AESEncryption.CiphertextGeneratedWithPlaintext(frame.encContent, plaintext) && AESEncryption.EncryptedWithKey(frame.encContent, key)) case Failure(_mcc#1) => var e := _mcc#1; true }
    decreases algorithmSuiteID, key, frameLength, messageID, plaintext, sequenceNumber
  {
    var unauthenticatedFrame := UInt32ToSeq(ENDFRAME_SEQUENCE_NUMBER);
    var seqNumSeq := UInt32ToSeq(sequenceNumber);
    unauthenticatedFrame := unauthenticatedFrame + seqNumSeq;
    var iv := IVSeq(algorithmSuiteID, sequenceNumber);
    SeqWithUInt32Suffix(iv, sequenceNumber as nat);
    unauthenticatedFrame := unauthenticatedFrame + iv;
    unauthenticatedFrame := unauthenticatedFrame + UInt32ToSeq(|plaintext| as uint32);
    var aad := BodyAAD(messageID, AADFinalFrame, sequenceNumber, |plaintext| as uint64);
    var encryptionOutputResult := AESEncryption.AESEncrypt(algorithmSuiteID.EncryptionSuite(), iv, key, plaintext, aad);
    if encryptionOutputResult.IsFailure() {
      res := encryptionOutputResult.PropagateFailure();
      finalFrame := RegularFrame(0, [], [], []);
      return;
    }
    var encryptionOutput := encryptionOutputResult.Extract();
    unauthenticatedFrame := unauthenticatedFrame + encryptionOutput.cipherText + encryptionOutput.authTag;
    assert |plaintext| == |encryptionOutput.cipherText|;
    ghost var frame := FinalFrame(sequenceNumber, iv, encryptionOutput.cipherText, encryptionOutput.authTag);
    finalFrame := frame;
    assert FrameToSequence(frame) == unauthenticatedFrame;
    assert |plaintext| == SeqToUInt32(unauthenticatedFrame[4 + 4 + algorithmSuiteID.IVLength() .. 4 + 4 + algorithmSuiteID.IVLength() + 4]) as int;
    assert |unauthenticatedFrame| == 4 + 4 + algorithmSuiteID.IVLength() + 4 + |plaintext| + algorithmSuiteID.TagLength();
    assert unauthenticatedFrame[4 + 4 + algorithmSuiteID.IVLength() + 4..][..|plaintext|] == encryptionOutput.cipherText;
    return Success(unauthenticatedFrame), finalFrame;
  }

  method DecryptFramedMessageBody(rd: Streams.ByteReader, algorithmSuiteID: AlgorithmSuite.ID, key: seq<uint8>, frameLength: int, messageID: Msg.MessageID)
      returns (res: Result<seq<uint8>, string>)
    requires rd.Valid()
    requires |key| == algorithmSuiteID.KeyLength()
    requires 0 < frameLength < UINT32_LIMIT
    modifies rd.reader`pos
    ensures rd.Valid()
    ensures res.Success? ==> DecryptedWithKey(key, res.value)
    ensures match res { case Success(_mcc#0) => (var plaintext := _mcc#0; old(rd.reader.pos) <= rd.reader.pos <= |rd.reader.data| && exists frames: seq<Frame> | |frames| < UINT32_LIMIT && (forall frame | frame in frames :: frame.Valid()) && FramesToSequence(frames) == rd.reader.data[old(rd.reader.pos) .. rd.reader.pos] :: true && FramesEncryptPlaintext(frames, plaintext)) case Failure(_mcc#1) => true }
    decreases rd, algorithmSuiteID, key, frameLength, messageID
  {
    var plaintext := [];
    var n: uint32 := 1;
    ghost var frames: seq<Frame> := [];
    ghost var plaintextSeg: seq<seq<uint8>> := [];
    while true
      invariant rd.Valid()
      invariant n as int - 1 == |frames|
      invariant n <= ENDFRAME_SEQUENCE_NUMBER
      invariant forall frame: Frame | frame in frames :: frame.Valid()
      invariant old(rd.reader.pos) <= rd.reader.pos <= |rd.reader.data|
      invariant FramesToSequence(frames) == rd.reader.data[old(rd.reader.pos) .. rd.reader.pos]
      invariant rd.Valid()
      invariant FramesEncryptPlaintextSegments(frames, plaintextSeg)
      invariant SumPlaintextSegments(plaintextSeg) == plaintext
      invariant DecryptedSegmentsWithKey(key, plaintextSeg)
      invariant plaintext == SumPlaintextSegments(plaintextSeg)
      decreases ENDFRAME_SEQUENCE_NUMBER - n
    {
      var frameWithGhostSeq :- DecryptFrame(rd, algorithmSuiteID, key, frameLength, messageID, n);
      assert |frameWithGhostSeq.sequence| < UINT32_LIMIT;
      var decryptedFrame := frameWithGhostSeq.frame;
      ghost var ciphertext := frameWithGhostSeq.sequence;
      assert |ciphertext| < UINT32_LIMIT;
      ghost var encryptedFrame := if decryptedFrame.FinalFrame? then FinalFrame(decryptedFrame.seqNum, decryptedFrame.iv, ciphertext, decryptedFrame.authTag) else RegularFrame(decryptedFrame.seqNum, decryptedFrame.iv, ciphertext, decryptedFrame.authTag);
      assert encryptedFrame.Valid();
      frames := frames + [encryptedFrame];
      var (decryptedFramePlaintext, final) := (decryptedFrame.encContent, decryptedFrame.FinalFrame?);

      plaintext := plaintext + decryptedFramePlaintext;
      plaintextSeg := plaintextSeg + [decryptedFramePlaintext];
      if final {
        assert FramesEncryptPlaintextSegments(frames, plaintextSeg);
        assert SumPlaintextSegments(plaintextSeg) == plaintext;
        break;
      }
      n := n + 1;
    }
    assert |frames| < UINT32_LIMIT;
    assert forall frame: Frame | frame in frames :: frame.Valid();
    assert FramesToSequence(frames) == rd.reader.data[old(rd.reader.pos) .. rd.reader.pos];
    return Success(plaintext);
  }

  method DecryptFrame(rd: Streams.ByteReader, algorithmSuiteID: AlgorithmSuite.ID, key: seq<uint8>, frameLength: int, messageID: Msg.MessageID, expectedSequenceNumber: uint32)
      returns (res: Result<FrameWithGhostSeq, string>)
    requires rd.Valid()
    requires |key| == algorithmSuiteID.KeyLength()
    requires 0 < frameLength < UINT32_LIMIT
    modifies rd.reader`pos
    ensures rd.Valid()
    ensures match res { case Success(_mcc#0) => (var frameWithGhostSeq := _mcc#0; expectedSequenceNumber == ENDFRAME_SEQUENCE_NUMBER ==> frameWithGhostSeq.frame.FinalFrame?) case Failure(_mcc#1) => true }
    ensures res.Success? ==> |res.value.sequence| < UINT32_LIMIT
    ensures match res { case Success(_mcc#2) => (var frameWithGhostSeq := _mcc#2; true && var decryptedFrame := frameWithGhostSeq.frame; var ciphertext := frameWithGhostSeq.sequence; var final := decryptedFrame.FinalFrame?; decryptedFrame.Valid() && old(rd.reader.pos) < rd.reader.pos <= |rd.reader.data| && AESEncryption.CiphertextGeneratedWithPlaintext(ciphertext, decryptedFrame.encContent) && AESEncryption.DecryptedWithKey(key, decryptedFrame.encContent) && var encryptedFrame := if decryptedFrame.FinalFrame? then FinalFrame(decryptedFrame.seqNum, decryptedFrame.iv, ciphertext, decryptedFrame.authTag) else RegularFrame(decryptedFrame.seqNum, decryptedFrame.iv, ciphertext, decryptedFrame.authTag); rd.reader.data[old(rd.reader.pos) .. rd.reader.pos] == FrameToSequence(encryptedFrame) && AESEncryption.CiphertextGeneratedWithPlaintext(encryptedFrame.encContent, decryptedFrame.encContent)) case Failure(_mcc#3) => true }
    decreases rd, algorithmSuiteID, key, frameLength, messageID, expectedSequenceNumber
  {
    var final := false;
    var sequenceNumber :- rd.ReadUInt32();
    ghost var frameSerialization := UInt32ToSeq(sequenceNumber);
    assert rd.reader.data[old(rd.reader.pos) .. rd.reader.pos] == frameSerialization;
    if sequenceNumber == ENDFRAME_SEQUENCE_NUMBER {
      final := true;
      sequenceNumber :- rd.ReadUInt32();
      frameSerialization := frameSerialization + UInt32ToSeq(sequenceNumber);
      assert rd.reader.data[old(rd.reader.pos) .. rd.reader.pos] == frameSerialization;
    }
    if sequenceNumber != expectedSequenceNumber {
      return Failure(""unexpected frame sequence number"");
    }
    var iv :- rd.ReadBytes(algorithmSuiteID.IVLength());
    frameSerialization := frameSerialization + iv;
    assert rd.reader.data[old(rd.reader.pos) .. rd.reader.pos] == frameSerialization;
    var len := frameLength as uint32;
    if final {
      len :- rd.ReadUInt32();
      if len > frameLength as uint32 {
        return Failure(""Final frame too long"");
      }
      frameSerialization := frameSerialization + UInt32ToSeq(len);
    }
    var aad := BodyAAD(messageID, if final then AADFinalFrame else AADRegularFrame, sequenceNumber, len as uint64);
    var ciphertext :- rd.ReadBytes(len as nat);
    frameSerialization := frameSerialization + ciphertext;
    assert rd.reader.data[old(rd.reader.pos) .. rd.reader.pos] == frameSerialization;
    var authTag :- rd.ReadBytes(algorithmSuiteID.TagLength());
    frameSerialization := frameSerialization + authTag;
    assert rd.reader.data[old(rd.reader.pos) .. rd.reader.pos] == frameSerialization;
    var plaintext :- Decrypt(ciphertext, authTag, algorithmSuiteID, iv, key, aad);
    assert AESEncryption.CiphertextGeneratedWithPlaintext(ciphertext, plaintext);
    assert rd.reader.data[old(rd.reader.pos) .. rd.reader.pos] == frameSerialization;
    var frame := if final then FinalFrame(sequenceNumber, iv, plaintext, authTag) else RegularFrame(sequenceNumber, iv, plaintext, authTag);
    ghost var encryptedFrame := if final then FinalFrame(sequenceNumber, iv, ciphertext, authTag) else RegularFrame(sequenceNumber, iv, ciphertext, authTag);
    assert frameSerialization == FrameToSequence(encryptedFrame);
    assert !final ==> frameSerialization[..4] == rd.reader.data[old(rd.reader.pos)..][..4];
    assert !final ==> frameSerialization[4..][..algorithmSuiteID.IVLength()] == rd.reader.data[old(rd.reader.pos)..][4..][..algorithmSuiteID.IVLength()];
    assert !final ==> frameSerialization[4 + algorithmSuiteID.IVLength()..][..frameLength] == rd.reader.data[old(rd.reader.pos)..][4 + algorithmSuiteID.IVLength()..][..frameLength];
    assert !final ==> frameSerialization[4 + frameLength + algorithmSuiteID.IVLength()..] == rd.reader.data[old(rd.reader.pos)..][4 + frameLength + algorithmSuiteID.IVLength()..][..algorithmSuiteID.TagLength()];
    assert rd.reader.data[old(rd.reader.pos) .. rd.reader.pos] == frameSerialization;
    assert old(rd.reader.pos) < rd.reader.pos <= |rd.reader.data|;
    return Success(FrameWithGhostSeq(frame, ciphertext));
  }

  method BodyAAD(messageID: seq<uint8>, bc: BodyAADContent, sequenceNumber: uint32, length: uint64)
      returns (aad: seq<uint8>)
    decreases messageID, bc, sequenceNumber, length
  {
    var contentAAD := UTF8.Encode(BodyAADContentTypeString(bc));
    aad := messageID + contentAAD.value + UInt32ToSeq(sequenceNumber) + UInt64ToSeq(length);
  }

  method Decrypt(ciphertext: seq<uint8>, authTag: seq<uint8>, algorithmSuiteID: AlgorithmSuite.ID, iv: seq<uint8>, key: seq<uint8>, aad: seq<uint8>)
      returns (res: Result<seq<uint8>, string>)
    requires |iv| == algorithmSuiteID.IVLength()
    requires |key| == algorithmSuiteID.KeyLength()
    requires |authTag| == algorithmSuiteID.TagLength()
    ensures res.Success? ==> AESEncryption.CiphertextGeneratedWithPlaintext(ciphertext, res.value)
    ensures res.Success? ==> |ciphertext| == |res.value|
    ensures res.Success? ==> AESEncryption.DecryptedWithKey(key, res.value)
    decreases ciphertext, authTag, algorithmSuiteID, iv, key, aad
  {
    var encAlg := algorithmSuiteID.EncryptionSuite();
    res := AESEncryption.AESDecrypt(encAlg, key, ciphertext, authTag, iv, aad);
    assert res.Success? ==> AESEncryption.DecryptedWithKey(key, res.value);
  }

  predicate DecryptedWithKey(key: seq<uint8>, plaintext: seq<uint8>)
    decreases key, plaintext
  {
    if AESEncryption.DecryptedWithKey(key, plaintext) then
      true
    else
      exists plaintextSeg: seq<seq<uint8>> | SumPlaintextSegments(plaintextSeg) == plaintext :: DecryptedSegmentsWithKey(key, plaintextSeg)
  }

  predicate DecryptedSegmentsWithKey(key: seq<uint8>, plaintextSeg: seq<seq<uint8>>)
    decreases key, plaintextSeg
  {
    if plaintextSeg == [] then
      true
    else
      DecryptedSegmentsWithKey(key, plaintextSeg[..|plaintextSeg| - 1]) && AESEncryption.DecryptedWithKey(key, plaintextSeg[|plaintextSeg| - 1])
  }

  method DecryptNonFramedMessageBody(rd: Streams.ByteReader, algorithmSuiteID: AlgorithmSuite.ID, key: seq<uint8>, messageID: Msg.MessageID)
      returns (res: Result<seq<uint8>, string>)
    requires rd.Valid()
    requires |key| == algorithmSuiteID.KeyLength()
    modifies rd.reader`pos
    ensures rd.Valid()
    decreases rd, algorithmSuiteID, key, messageID
  {
    var iv :- rd.ReadBytes(algorithmSuiteID.IVLength());
    var contentLength :- rd.ReadUInt64();
    var ciphertext :- rd.ReadBytes(contentLength as nat);
    var authTag :- rd.ReadBytes(algorithmSuiteID.TagLength());
    var aad := BodyAAD(messageID, AADSingleBlock, NONFRAMED_SEQUENCE_NUMBER, contentLength);
    var plaintext :- Decrypt(ciphertext, authTag, algorithmSuiteID, iv, key, aad);
    return Success(plaintext);
  }
}

module {:extern ""MessageHeader""} MessageHeader {

  import AlgorithmSuite = AlgorithmSuite

  import Sets = Sets

  import opened Wrappers = Wrappers

  import opened UInt = StandardLibrary.UInt

  import EncryptionContext = EncryptionContext

  import Materials = Materials

  import UTF8 = UTF8

  import AESEncryption = AESEncryption
  datatype Header = Header(body: HeaderBody, auth: HeaderAuthentication) {
    predicate Valid()
      decreases this
    {
      body.Valid() &&
      |auth.iv| == body.algorithmSuiteID.IVLength() &&
      |auth.authenticationTag| == body.algorithmSuiteID.TagLength()
    }
  }

  type Version = x: uint8
    | x == VERSION_1
    witness VERSION_1

  type Type = x: uint8
    | x == TYPE_CUSTOMER_AED
    witness TYPE_CUSTOMER_AED

  type MessageID = x: seq<uint8>
    | |x| == MESSAGE_ID_LEN
    witness [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]

  datatype ContentType = NonFramed | Framed

  datatype EncryptedDataKeys = EncryptedDataKeys(entries: seq<Materials.EncryptedDataKey>) {
    predicate Valid()
      decreases this
    {
      0 < |entries| < UINT16_LIMIT &&
      forall i: int :: 
        0 <= i < |entries| ==>
          entries[i].Valid()
    }
  }

  datatype HeaderBody = HeaderBody(version: Version, typ: Type, algorithmSuiteID: AlgorithmSuite.ID, messageID: MessageID, aad: EncryptionContext.Map, encryptedDataKeys: EncryptedDataKeys, contentType: ContentType, ivLength: uint8, frameLength: uint32) {
    predicate Valid()
      decreases this
    {
      EncryptionContext.Serializable(aad) &&
      encryptedDataKeys.Valid() &&
      algorithmSuiteID.IVLength() == ivLength as nat &&
      ValidFrameLength(frameLength, contentType)
    }
  }

  datatype HeaderAuthentication = HeaderAuthentication(iv: seq<uint8>, authenticationTag: seq<uint8>)

  const VERSION_1: uint8 := 1
  const TYPE_CUSTOMER_AED: uint8 := 128
  const MESSAGE_ID_LEN := 16
  const Reserved: seq<uint8> := [0, 0, 0, 0]

  function method ContentTypeToUInt8(contentType: ContentType): uint8
    decreases contentType
  {
    match contentType
    case NonFramed() =>
      1
    case Framed() =>
      2
  }

  function method UInt8ToContentType(x: uint8): Option<ContentType>
    decreases x
  {
    if x == 1 then
      Some(NonFramed)
    else if x == 2 then
      Some(Framed)
    else
      None
  }

  lemma ContentTypeConversionsCorrect(contentType: ContentType, x: uint8)
    ensures UInt8ToContentType(ContentTypeToUInt8(contentType)) == Some(contentType)
    ensures ghost var opt: Option<ContentType> := UInt8ToContentType(x); opt == None || ContentTypeToUInt8(opt.value) == x
    decreases contentType, x
  {
  }

  predicate HeaderAuthenticationMatchesHeaderBody(headerAuthentication: HeaderAuthentication, headerBody: HeaderBody)
    requires headerBody.Valid()
    decreases headerAuthentication, headerBody
  {
    ghost var serializedHeaderBody: seq<uint8> := (reveal HeaderBodyToSeq(); HeaderBodyToSeq(headerBody));
    headerAuthentication.iv == seq(headerBody.algorithmSuiteID.IVLength(), (_: int) => 0) &&
    exists encryptionOutput: EncryptionOutput | AESEncryption.EncryptionOutputEncryptedWithAAD(encryptionOutput, serializedHeaderBody) && AESEncryption.CiphertextGeneratedWithPlaintext(encryptionOutput.cipherText, []) :: 
      encryptionOutput.authTag == headerAuthentication.authenticationTag
  }

  predicate ValidFrameLength(frameLength: uint32, contentType: ContentType)
    decreases frameLength, contentType
  {
    match contentType
    case NonFramed() =>
      frameLength == 0
    case Framed() =>
      frameLength != 0
  }

  function {:opaque} {:fuel 0, 0} HeaderBodyToSeq(hb: HeaderBody): seq<uint8>
    requires hb.Valid()
    decreases hb
  {
    [hb.version as uint8] + [hb.typ as uint8] + UInt16ToSeq(hb.algorithmSuiteID as uint16) + hb.messageID + EncryptionContext.MapToLinear(hb.aad) + EDKsToSeq(hb.encryptedDataKeys) + [ContentTypeToUInt8(hb.contentType)] + Reserved + [hb.ivLength] + UInt32ToSeq(hb.frameLength)
  }

  function EDKsToSeq(encryptedDataKeys: EncryptedDataKeys): seq<uint8>
    requires encryptedDataKeys.Valid()
    decreases encryptedDataKeys
  {
    ghost var n: int := |encryptedDataKeys.entries|;
    UInt16ToSeq(n as uint16) + EDKEntriesToSeq(encryptedDataKeys.entries, 0, n)
  }

  function EDKEntriesToSeq(entries: seq<Materials.EncryptedDataKey>, lo: nat, hi: nat): seq<uint8>
    requires forall i: int :: 0 <= i < |entries| ==> entries[i].Valid()
    requires lo <= hi <= |entries|
    decreases entries, lo, hi
  {
    if lo == hi then
      []
    else
      EDKEntriesToSeq(entries, lo, hi - 1) + EDKEntryToSeq(entries[hi - 1])
  }

  lemma /*{:_induction entriesHead, entriesTail, lo, hi}*/ EDKEntriesToSeqInductiveStep(entriesHead: seq<Materials.EncryptedDataKey>, entriesTail: seq<Materials.EncryptedDataKey>, lo: nat, hi: nat)
    requires ghost var entries: seq<Materials.EncryptedDataKey> := entriesHead + entriesTail; forall i: int :: 0 <= i < |entries| ==> entries[i].Valid()
    requires lo <= hi <= |entriesHead|
    ensures forall i: int :: 0 <= i < |entriesHead| ==> entriesHead[i].Valid()
    ensures ghost var entries: seq<Materials.EncryptedDataKey> := entriesHead + entriesTail; EDKEntriesToSeq(entriesHead + entriesTail, lo, hi) == EDKEntriesToSeq(entriesHead, lo, hi)
    decreases entriesHead, entriesTail, lo, hi
  {
    assert forall i: int :: 0 <= i < |entriesHead| ==> entriesHead[i].Valid() by {
      if !forall i: int :: 0 <= i < |entriesHead| ==> entriesHead[i].Valid() {
        ghost var entry :| entry in entriesHead && !entry.Valid();
        assert entry in entriesHead + entriesTail;
        assert false;
      }
    }
  }

  function method EDKEntryToSeq(edk: Materials.EncryptedDataKey): seq<uint8>
    requires edk.Valid()
    decreases edk
  {
    UInt16ToSeq(|edk.providerID| as uint16) + edk.providerID + UInt16ToSeq(|edk.providerInfo| as uint16) + edk.providerInfo + UInt16ToSeq(|edk.ciphertext| as uint16) + edk.ciphertext
  }

  predicate {:opaque} {:fuel 0, 0} IsSerializationOfHeaderBody(sequence: seq<uint8>, hb: HeaderBody)
    requires hb.Valid()
    decreases sequence, hb
  {
    exists serializedAAD: seq<uint8> | EncryptionContext.LinearSeqToMap(serializedAAD, hb.aad) :: 
      IsSerializationOfHeaderBodyAux(sequence, hb, serializedAAD)
  }

  predicate IsSerializationOfHeaderBodyAux(sequence: seq<uint8>, hb: HeaderBody, serializedAAD: seq<uint8>)
    requires hb.Valid() && EncryptionContext.LinearSeqToMap(serializedAAD, hb.aad)
    decreases sequence, hb, serializedAAD
  {
    sequence == [hb.version as uint8] + [hb.typ as uint8] + UInt16ToSeq(hb.algorithmSuiteID as uint16) + hb.messageID + serializedAAD + EDKsToSeq(hb.encryptedDataKeys) + [ContentTypeToUInt8(hb.contentType)] + Reserved + [hb.ivLength] + UInt32ToSeq(hb.frameLength)
  }

  lemma IsSerializationOfHeaderBodyDuality(hb: HeaderBody)
    requires hb.Valid()
    ensures IsSerializationOfHeaderBody(HeaderBodyToSeq(hb), hb)
    decreases hb
  {
    reveal HeaderBodyToSeq(), IsSerializationOfHeaderBody();
    EncryptionContext.MapToLinearIsDualLinearSeqToMap(hb.aad);
  }
}

module Serialize {

  import Msg = MessageHeader

  import EncryptionContext = EncryptionContext

  import AlgorithmSuite = AlgorithmSuite

  import Streams = Streams

  import opened StandardLibrary = StandardLibrary

  import opened Wrappers = Wrappers

  import opened UInt = StandardLibrary.UInt

  import UTF8 = UTF8

  import Sets = Sets
  method SerializeHeaderBody(wr: Streams.ByteWriter, hb: Msg.HeaderBody) returns (ret: Result<nat, string>)
    requires wr.Valid() && hb.Valid()
    modifies wr.writer`data
    ensures wr.Valid()
    ensures match ret { case Success(_mcc#0) => (var totalWritten := _mcc#0; var serHb := (reveal Msg.HeaderBodyToSeq(); Msg.HeaderBodyToSeq(hb)); var initLen := old(wr.GetSizeWritten()); totalWritten == |serHb| && initLen + totalWritten == wr.GetSizeWritten() && serHb == wr.GetDataWritten()[initLen .. initLen + totalWritten]) case Failure(_mcc#1) => var e := _mcc#1; true }
    decreases wr, hb
  {
    var totalWritten := 0;
    var len := wr.WriteByte(hb.version as uint8);
    totalWritten := totalWritten + len;
    len := wr.WriteByte(hb.typ as uint8);
    totalWritten := totalWritten + len;
    len := wr.WriteUInt16(hb.algorithmSuiteID as uint16);
    totalWritten := totalWritten + len;
    len := wr.WriteBytes(hb.messageID);
    totalWritten := totalWritten + len;
    len :- SerializeAAD(wr, hb.aad);
    totalWritten := totalWritten + len;
    len := SerializeEDKs(wr, hb.encryptedDataKeys);
    totalWritten := totalWritten + len;
    var contentType := Msg.ContentTypeToUInt8(hb.contentType);
    len := wr.WriteByte(contentType);
    totalWritten := totalWritten + len;
    len := wr.WriteBytes(Msg.Reserved);
    totalWritten := totalWritten + len;
    len := wr.WriteByte(hb.ivLength);
    totalWritten := totalWritten + len;
    len := wr.WriteUInt32(hb.frameLength);
    totalWritten := totalWritten + len;
    reveal Msg.HeaderBodyToSeq();
    return Success(totalWritten);
  }

  method SerializeHeaderAuthentication(wr: Streams.ByteWriter, ha: Msg.HeaderAuthentication, ghost algorithmSuiteID: AlgorithmSuite.ID)
      returns (ret: Result<nat, string>)
    requires wr.Valid()
    modifies wr.writer`data
    ensures wr.Valid()
    ensures match ret { case Success(_mcc#0) => (var totalWritten := _mcc#0; var serHa := ha.iv + ha.authenticationTag; var initLen := old(wr.GetSizeWritten()); initLen + totalWritten == wr.GetSizeWritten() && serHa == wr.GetDataWritten()[initLen .. initLen + totalWritten] && totalWritten == |serHa| && old(wr.GetDataWritten()) + serHa == wr.GetDataWritten()) case Failure(_mcc#1) => var e := _mcc#1; true }
    decreases wr, ha, algorithmSuiteID
  {
    var m := wr.WriteBytes(ha.iv);
    var n := wr.WriteBytes(ha.authenticationTag);
    return Success(m + n);
  }

  method SerializeAAD(wr: Streams.ByteWriter, kvPairs: EncryptionContext.Map) returns (ret: Result<nat, string>)
    requires wr.Valid() && EncryptionContext.Serializable(kvPairs)
    modifies wr.writer`data
    ensures wr.Valid() && EncryptionContext.Serializable(kvPairs)
    ensures match ret { case Success(_mcc#0) => (var totalWritten := _mcc#0; var serAAD := EncryptionContext.MapToLinear(kvPairs); var initLen := old(wr.GetSizeWritten()); totalWritten == |serAAD| && initLen + totalWritten == wr.GetSizeWritten() && wr.GetDataWritten() == old(wr.GetDataWritten()) + serAAD) case Failure(_mcc#1) => var e := _mcc#1; true }
    decreases wr, kvPairs
  {
    reveal EncryptionContext.Serializable();
    var totalWritten := 0;
    var kvPairsLength := EncryptionContext.ComputeLength(kvPairs);
    var len := wr.WriteUInt16(kvPairsLength as uint16);
    totalWritten := totalWritten + len;
    len :- SerializeKVPairs(wr, kvPairs);
    totalWritten := totalWritten + len;
    return Success(totalWritten);
  }

  method SerializeKVPairs(wr: Streams.ByteWriter, encryptionContext: EncryptionContext.Map) returns (ret: Result<nat, string>)
    requires wr.Valid() && EncryptionContext.SerializableKVPairs(encryptionContext)
    modifies wr.writer`data
    ensures wr.Valid() && EncryptionContext.SerializableKVPairs(encryptionContext)
    ensures match ret { case Success(_mcc#0) => (var newlyWritten := _mcc#0; var serAAD := EncryptionContext.MapToSeq(encryptionContext); newlyWritten == |serAAD| && wr.GetSizeWritten() == old(wr.GetSizeWritten()) + newlyWritten && wr.GetDataWritten() == old(wr.GetDataWritten()) + serAAD) case Failure(_mcc#1) => var e := _mcc#1; true }
    decreases wr, encryptionContext
  {
    var newlyWritten := 0;
    if |encryptionContext| == 0 {
      return Success(newlyWritten);
    }
    var len := wr.WriteUInt16(|encryptionContext| as uint16);
    newlyWritten := newlyWritten + len;
    var keys: seq<UTF8.ValidUTF8Bytes> := Sets.ComputeSetToOrderedSequence(encryptionContext.Keys, UInt.UInt8Less);
    ghost var kvPairs := seq(|keys|, (i: int) requires 0 <= i < |keys| => (keys[i], encryptionContext[keys[i]]));
    ghost var n := |keys|;
    ghost var writtenBeforeLoop := wr.GetDataWritten();
    assert writtenBeforeLoop == old(wr.GetDataWritten()) + UInt16ToSeq(n as uint16);
    var j := 0;
    while j < |keys|
      invariant j <= n == |keys|
      invariant wr.GetDataWritten() == writtenBeforeLoop + EncryptionContext.LinearToSeq(kvPairs, 0, j)
      invariant wr.GetSizeWritten() == old(wr.GetSizeWritten()) + newlyWritten
      decreases |keys| - j
    {
      len :- SerializeKVPair(wr, keys[j], encryptionContext[keys[j]]);
      newlyWritten := newlyWritten + len;
      assert wr.GetSizeWritten() == old(wr.GetSizeWritten()) + newlyWritten;
      calc {
        wr.GetDataWritten();
      ==
        writtenBeforeLoop + EncryptionContext.LinearToSeq(kvPairs, 0, j) + EncryptionContext.KVPairToSeq(kvPairs[j]);
      ==
        writtenBeforeLoop + (EncryptionContext.LinearToSeq(kvPairs, 0, j) + EncryptionContext.KVPairToSeq(kvPairs[j]));
      ==
        {
          assert EncryptionContext.LinearToSeq(kvPairs, 0, j) + EncryptionContext.KVPairToSeq(kvPairs[j]) == EncryptionContext.LinearToSeq(kvPairs, 0, j + 1);
        }
        writtenBeforeLoop + EncryptionContext.LinearToSeq(kvPairs, 0, j + 1);
      }
      j := j + 1;
    }
    return Success(newlyWritten);
  }

  method SerializeKVPair(wr: Streams.ByteWriter, k: UTF8.ValidUTF8Bytes, v: UTF8.ValidUTF8Bytes)
      returns (ret: Result<nat, string>)
    requires wr.Valid() && EncryptionContext.SerializableKVPair((k, v))
    modifies wr.writer`data
    ensures wr.Valid()
    ensures match ret { case Success(_mcc#0) => (var newlyWritten := _mcc#0; var serKV := EncryptionContext.KVPairToSeq((k, v)); newlyWritten == |serKV| && wr.GetSizeWritten() == old(wr.GetSizeWritten()) + newlyWritten && wr.GetDataWritten() == old(wr.GetDataWritten()) + serKV) case Failure(_mcc#1) => var e := _mcc#1; true }
    decreases wr, k, v
  {
    ghost var previouslyWritten := wr.GetDataWritten();
    var newlyWritten := 0;
    var len := wr.WriteUInt16(|k| as uint16);
    newlyWritten := newlyWritten + len;
    len := wr.WriteBytes(k);
    newlyWritten := newlyWritten + len;
    len := wr.WriteUInt16(|v| as uint16);
    newlyWritten := newlyWritten + len;
    len := wr.WriteBytes(v);
    newlyWritten := newlyWritten + len;
    calc {
      wr.GetDataWritten();
    ==
      previouslyWritten + UInt16ToSeq(|k| as uint16) + k + UInt16ToSeq(|v| as uint16) + v;
    ==
      previouslyWritten + (UInt16ToSeq(|k| as uint16) + k + UInt16ToSeq(|v| as uint16) + v);
    ==
      previouslyWritten + EncryptionContext.KVPairToSeq((k, v));
    }
    return Success(newlyWritten);
  }

  method SerializeEDKs(wr: Streams.ByteWriter, encryptedDataKeys: Msg.EncryptedDataKeys) returns (ret: nat)
    requires wr.Valid() && encryptedDataKeys.Valid()
    modifies wr.writer`data
    ensures wr.Valid() && encryptedDataKeys.Valid()
    ensures ret == |Msg.EDKsToSeq(encryptedDataKeys)|
    ensures old(wr.GetSizeWritten()) + ret == wr.GetSizeWritten()
    ensures wr.GetDataWritten() == old(wr.GetDataWritten()) + Msg.EDKsToSeq(encryptedDataKeys)
    decreases wr, encryptedDataKeys
  {
    var totalWritten := 0;
    var len := wr.WriteUInt16(|encryptedDataKeys.entries| as uint16);
    totalWritten := totalWritten + len;
    var j := 0;
    ghost var n := |encryptedDataKeys.entries|;
    while j < |encryptedDataKeys.entries|
      invariant j <= n == |encryptedDataKeys.entries|
      invariant wr.GetDataWritten() == old(wr.GetDataWritten()) + UInt16ToSeq(n as uint16) + Msg.EDKEntriesToSeq(encryptedDataKeys.entries, 0, j)
      invariant totalWritten == 2 + |Msg.EDKEntriesToSeq(encryptedDataKeys.entries, 0, j)|
      decreases |encryptedDataKeys.entries| - j
    {
      var entry := encryptedDataKeys.entries[j];
      len := wr.WriteUInt16(|entry.providerID| as uint16);
      totalWritten := totalWritten + len;
      len := wr.WriteBytes(entry.providerID);
      totalWritten := totalWritten + len;
      len := wr.WriteUInt16(|entry.providerInfo| as uint16);
      totalWritten := totalWritten + len;
      len := wr.WriteBytes(entry.providerInfo);
      totalWritten := totalWritten + len;
      len := wr.WriteUInt16(|entry.ciphertext| as uint16);
      totalWritten := totalWritten + len;
      len := wr.WriteBytes(entry.ciphertext);
      totalWritten := totalWritten + len;
      j := j + 1;
    }
    return totalWritten;
  }
}

module Actions {

  import opened Wrappers = Wrappers
  trait {:termination false} Action<A, R> {
    method Invoke(a: A) returns (r: R)
      ensures Ensures(a, r)

    predicate Ensures(a: A, r: R)
  }

  trait {:termination false} ActionWithResult<A, R, E> extends Action<A, Result<R, E>> {
    method Invoke(a: A) returns (res: Result<R, E>)
      ensures Ensures(a, res)
  }

  method Map<A, R>(action: Action<A, R>, s: seq<A>) returns (res: seq<R>)
    ensures |s| == |res|
    ensures forall i: int :: true && 0 <= i < |s| ==> action.Ensures(s[i], res[i])
    decreases action, s
  {
    var rs := [];
    for i: int := 0 to |s|
      invariant |s[..i]| == |rs|
      invariant forall j: int :: true && 0 <= j < i ==> action.Ensures(s[j], rs[j])
    {
      var r := action.Invoke(s[i]);
      rs := rs + [r];
    }
    return rs;
  }

  method MapWithResult<A, R, E>(action: ActionWithResult<A, R, E>, s: seq<A>) returns (res: Result<seq<R>, E>)
    ensures res.Success? ==> |s| == |res.value|
    ensures res.Success? ==> forall i: int :: true && 0 <= i < |s| ==> action.Ensures(s[i], Success(res.value[i]))
    decreases action, s
  {
    var rs := [];
    for i: int := 0 to |s|
      invariant |s[..i]| == |rs|
      invariant forall j: int :: true && 0 <= j < i ==> action.Ensures(s[j], Success(rs[j]))
    {
      var r :- action.Invoke(s[i]);
      rs := rs + [r];
    }
    return Success(rs);
  }

  method Filter<A>(action: Action<A, bool>, s: seq<A>) returns (res: seq<A>)
    ensures |s| >= |res|
    ensures forall j: A :: j in res ==> j in s && action.Ensures(j, true)
    decreases action, s
  {
    var rs := [];
    for i: int := 0 to |s|
      invariant |s[..i]| >= |rs|
      invariant forall j: A :: j in rs ==> j in s && action.Ensures(j, true)
    {
      var r := action.Invoke(s[i]);
      if r {
        rs := rs + [s[i]];
      }
    }
    return rs;
  }

  method FilterWithResult<A, E>(action: ActionWithResult<A, bool, E>, s: seq<A>) returns (res: Result<seq<A>, E>)
    ensures res.Success? ==> |s| >= |res.value| && forall j: A :: j in res.value ==> j in s && action.Ensures(j, Success(true))
    decreases action, s
  {
    var rs := [];
    for i: int := 0 to |s|
      invariant |s[..i]| >= |rs|
      invariant forall j: A :: j in rs ==> j in s && action.Ensures(j, Success(true))
    {
      var r :- action.Invoke(s[i]);
      if r {
        rs := rs + [s[i]];
      }
    }
    return Success(rs);
  }

  method ReduceToSuccess<A, B, E>(action: ActionWithResult<A, B, E>, s: seq<A>) returns (res: Result<B, seq<E>>)
    ensures res.Success? ==> exists a: A | a in s :: action.Ensures(a, Success(res.value))
    decreases action, s
  {
    var errors := [];
    for i: int := 0 to |s| {
      var attempt := action.Invoke(s[i]);
      if attempt.Success? {
        return Success(attempt.value);
      } else {
        errors := errors + [attempt.error];
      }
    }
    return Failure(errors);
  }
}

module Base64 {

  import opened Wrappers = Wrappers

  import opened UInt = StandardLibrary.UInt
  newtype index = x: int
    | 0 <= x < 64

  newtype uint24 = x: int
    | 0 <= x < 16777216

  predicate method IsBase64Char(c: char)
    decreases c
  {
    c == '+' || c == '/' || '0' <= c <= '9' || 'A' <= c <= 'Z' || 'a' <= c <= 'z'
  }

  predicate method IsUnpaddedBase64String(s: string)
    decreases s
  {
    |s| % 4 == 0 &&
    forall k: char :: 
      k in s ==>
        IsBase64Char(k)
  }

  function method IndexToChar(i: index): (c: char)
    ensures IsBase64Char(c)
    decreases i
  {
    if i == 63 then
      '/'
    else if i == 62 then
      '+'
    else if 52 <= i <= 61 then
      (i - 4) as char
    else if 26 <= i <= 51 then
      i as char + 71 as char
    else
      i as char + 65 as char
  }

  function method CharToIndex(c: char): (i: index)
    requires IsBase64Char(c)
    ensures IndexToChar(i) == c
    decreases c
  {
    if c == '/' then
      63
    else if c == '+' then
      62
    else if '0' <= c <= '9' then
      (c + 4 as char) as index
    else if 'a' <= c <= 'z' then
      (c - 71 as char) as index
    else
      (c - 65 as char) as index
  }

  lemma CharToIndexToChar(x: char)
    requires IsBase64Char(x)
    ensures IndexToChar(CharToIndex(x)) == x
    decreases x
  {
  }

  lemma IndexToCharToIndex(x: index)
    ensures CharToIndex(IndexToChar(x)) == x
    decreases x
  {
  }

  function method UInt24ToSeq(x: uint24): (ret: seq<uint8>)
    ensures |ret| == 3
    ensures ret[0] as uint24 * 65536 + ret[1] as uint24 * 256 + ret[2] as uint24 == x
    decreases x
  {
    var b0: uint8 := (x / 65536) as uint8;
    var x0: uint24 := x - b0 as uint24 * 65536;
    var b1: uint8 := (x0 / 256) as uint8;
    var b2: uint8 := (x0 % 256) as uint8;
    [b0, b1, b2]
  }

  function method SeqToUInt24(s: seq<uint8>): (x: uint24)
    requires |s| == 3
    ensures UInt24ToSeq(x) == s
    decreases s
  {
    s[0] as uint24 * 65536 + s[1] as uint24 * 256 + s[2] as uint24
  }

  lemma UInt24ToSeqToUInt24(x: uint24)
    ensures SeqToUInt24(UInt24ToSeq(x)) == x
    decreases x
  {
  }

  lemma SeqToUInt24ToSeq(s: seq<uint8>)
    requires |s| == 3
    ensures UInt24ToSeq(SeqToUInt24(s)) == s
    decreases s
  {
  }

  function method UInt24ToIndexSeq(x: uint24): (ret: seq<index>)
    ensures |ret| == 4
    ensures ret[0] as uint24 * 262144 + ret[1] as uint24 * 4096 + ret[2] as uint24 * 64 + ret[3] as uint24 == x
    decreases x
  {
    var b0: index := (x / 262144) as index;
    var x0: uint24 := x - b0 as uint24 * 262144;
    var b1: index := (x0 / 4096) as index;
    var x1: uint24 := x0 - b1 as uint24 * 4096;
    var b2: index := (x1 / 64) as index;
    var b3: index := (x1 % 64) as index;
    [b0, b1, b2, b3]
  }

  function method IndexSeqToUInt24(s: seq<index>): (x: uint24)
    requires |s| == 4
    ensures UInt24ToIndexSeq(x) == s
    decreases s
  {
    s[0] as uint24 * 262144 + s[1] as uint24 * 4096 + s[2] as uint24 * 64 + s[3] as uint24
  }

  lemma UInt24ToIndexSeqToUInt24(x: uint24)
    ensures IndexSeqToUInt24(UInt24ToIndexSeq(x)) == x
    decreases x
  {
  }

  lemma IndexSeqToUInt24ToIndexSeq(s: seq<index>)
    requires |s| == 4
    ensures UInt24ToIndexSeq(IndexSeqToUInt24(s)) == s
    decreases s
  {
  }

  function method DecodeBlock(s: seq<index>): (ret: seq<uint8>)
    requires |s| == 4
    ensures |ret| == 3
    ensures UInt24ToIndexSeq(SeqToUInt24(ret)) == s
    decreases s
  {
    UInt24ToSeq(IndexSeqToUInt24(s))
  }

  function method EncodeBlock(s: seq<uint8>): (ret: seq<index>)
    requires |s| == 3
    ensures |ret| == 4
    ensures UInt24ToSeq(IndexSeqToUInt24(ret)) == s
    ensures DecodeBlock(ret) == s
    decreases s
  {
    UInt24ToIndexSeq(SeqToUInt24(s))
  }

  lemma EncodeDecodeBlock(s: seq<uint8>)
    requires |s| == 3
    ensures DecodeBlock(EncodeBlock(s)) == s
    decreases s
  {
  }

  lemma DecodeEncodeBlock(s: seq<index>)
    requires |s| == 4
    ensures EncodeBlock(DecodeBlock(s)) == s
    decreases s
  {
  }

  function method DecodeRecursively(s: seq<index>): (b: seq<uint8>)
    requires |s| % 4 == 0
    ensures |b| == |s| / 4 * 3
    ensures |b| % 3 == 0
    ensures |b| == 0 ==> |s| == 0
    ensures |b| != 0 ==> EncodeBlock(b[..3]) == s[..4]
    decreases |s|
  {
    if |s| == 0 then
      []
    else
      DecodeBlock(s[..4]) + DecodeRecursively(s[4..])
  }

  function method EncodeRecursively(b: seq<uint8>): (s: seq<index>)
    requires |b| % 3 == 0
    ensures |s| == |b| / 3 * 4
    ensures |s| % 4 == 0
    ensures DecodeRecursively(s) == b
    decreases b
  {
    if |b| == 0 then
      []
    else
      EncodeBlock(b[..3]) + EncodeRecursively(b[3..])
  }

  lemma /*{:_induction s}*/ DecodeEncodeRecursively(s: seq<index>)
    requires |s| % 4 == 0
    ensures EncodeRecursively(DecodeRecursively(s)) == s
    decreases s
  {
  }

  lemma /*{:_induction b}*/ EncodeDecodeRecursively(b: seq<uint8>)
    requires |b| % 3 == 0
    ensures DecodeRecursively(EncodeRecursively(b)) == b
    decreases b
  {
  }

  function method FromCharsToIndices(s: seq<char>): (b: seq<index>)
    requires forall k: char :: k in s ==> IsBase64Char(k)
    ensures |b| == |s|
    ensures forall k: int :: 0 <= k < |b| ==> IndexToChar(b[k]) == s[k]
    decreases s
  {
    seq(|s|, (i: int) requires 0 <= i < |s| => CharToIndex(s[i]))
  }

  function method FromIndicesToChars(b: seq<index>): (s: seq<char>)
    ensures forall k: char :: k in s ==> IsBase64Char(k)
    ensures |s| == |b|
    ensures forall k: int :: 0 <= k < |s| ==> CharToIndex(s[k]) == b[k]
    ensures FromCharsToIndices(s) == b
    decreases b
  {
    seq(|b|, (i: int) requires 0 <= i < |b| => IndexToChar(b[i]))
  }

  lemma FromCharsToIndicesToChars(s: seq<char>)
    requires forall k: char :: k in s ==> IsBase64Char(k)
    ensures FromIndicesToChars(FromCharsToIndices(s)) == s
    decreases s
  {
  }

  lemma FromIndicesToCharsToIndices(b: seq<index>)
    ensures FromCharsToIndices(FromIndicesToChars(b)) == b
    decreases b
  {
  }

  function method DecodeUnpadded(s: seq<char>): (b: seq<uint8>)
    requires IsUnpaddedBase64String(s)
    ensures |b| == |s| / 4 * 3
    ensures |b| % 3 == 0
    decreases s
  {
    DecodeRecursively(FromCharsToIndices(s))
  }

  function method EncodeUnpadded(b: seq<uint8>): (s: seq<char>)
    requires |b| % 3 == 0
    ensures IsUnpaddedBase64String(s)
    ensures |s| == |b| / 3 * 4
    ensures DecodeUnpadded(s) == b
    decreases b
  {
    FromIndicesToChars(EncodeRecursively(b))
  }

  lemma EncodeDecodeUnpadded(b: seq<uint8>)
    requires |b| % 3 == 0
    ensures DecodeUnpadded(EncodeUnpadded(b)) == b
    decreases b
  {
  }

  lemma DecodeEncodeUnpadded(s: seq<char>)
    requires |s| % 4 == 0
    requires IsUnpaddedBase64String(s)
    ensures EncodeUnpadded(DecodeUnpadded(s)) == s
    decreases s
  {
    ghost var fromCharsToIndicesS := FromCharsToIndices(s);
    calc {
      EncodeUnpadded(DecodeUnpadded(s));
    ==
      EncodeUnpadded(DecodeRecursively(FromCharsToIndices(s)));
    ==
      EncodeUnpadded(DecodeRecursively(fromCharsToIndicesS));
    ==
      assert |fromCharsToIndicesS| % 4 == 0; assert |DecodeRecursively(fromCharsToIndicesS)| % 3 == 0; FromIndicesToChars(EncodeRecursively(DecodeRecursively(fromCharsToIndicesS)));
    ==
      {
        DecodeEncodeRecursively(fromCharsToIndicesS);
      }
      FromIndicesToChars(fromCharsToIndicesS);
    ==
      FromIndicesToChars(FromCharsToIndices(s));
    ==
      {
        FromCharsToIndicesToChars(s);
      }
      s;
    }
  }

  predicate method Is1Padding(s: seq<char>)
    decreases s
  {
    |s| == 4 &&
    IsBase64Char(s[0]) &&
    IsBase64Char(s[1]) &&
    IsBase64Char(s[2]) &&
    CharToIndex(s[2]) % 4 == 0 &&
    s[3] == '='
  }

  function method Decode1Padding(s: seq<char>): (b: seq<uint8>)
    requires Is1Padding(s)
    ensures |b| == 2
    decreases s
  {
    var d: seq<uint8> := DecodeBlock([CharToIndex(s[0]), CharToIndex(s[1]), CharToIndex(s[2]), 0]);
    [d[0], d[1]]
  }

  function method Encode1Padding(b: seq<uint8>): (s: seq<char>)
    requires |b| == 2
    ensures Is1Padding(s)
    ensures Decode1Padding(s) == b
    decreases b
  {
    var e: seq<index> := EncodeBlock([b[0], b[1], 0]);
    [IndexToChar(e[0]), IndexToChar(e[1]), IndexToChar(e[2]), '=']
  }

  lemma DecodeEncode1Padding(s: seq<char>)
    requires Is1Padding(s)
    ensures Encode1Padding(Decode1Padding(s)) == s
    decreases s
  {
  }

  lemma EncodeDecode1Padding(b: seq<uint8>)
    requires |b| == 2
    ensures Decode1Padding(Encode1Padding(b)) == b
    decreases b
  {
  }

  predicate method Is2Padding(s: seq<char>)
    decreases s
  {
    |s| == 4 &&
    IsBase64Char(s[0]) &&
    IsBase64Char(s[1]) &&
    CharToIndex(s[1]) % 16 == 0 &&
    s[2] == '=' &&
    s[3] == '='
  }

  function method Decode2Padding(s: seq<char>): (b: seq<uint8>)
    requires Is2Padding(s)
    ensures |b| == 1
    decreases s
  {
    var d: seq<uint8> := DecodeBlock([CharToIndex(s[0]), CharToIndex(s[1]), 0, 0]);
    [d[0]]
  }

  function method Encode2Padding(b: seq<uint8>): (s: seq<char>)
    requires |b| == 1
    ensures Is2Padding(s)
    ensures Decode2Padding(s) == b
    decreases b
  {
    var e: seq<index> := EncodeBlock([b[0], 0, 0]);
    [IndexToChar(e[0]), IndexToChar(e[1]), '=', '=']
  }

  lemma DecodeEncode2Padding(s: seq<char>)
    requires Is2Padding(s)
    ensures Encode2Padding(Decode2Padding(s)) == s
    decreases s
  {
  }

  lemma EncodeDecode2Padding(b: seq<uint8>)
    requires |b| == 1
    ensures Decode2Padding(Encode2Padding(b)) == b
    decreases b
  {
  }

  predicate method IsBase64String(s: string)
    decreases s
  {
    var finalBlockStart: int := |s| - 4;
    |s| % 4 == 0 &&
    (IsUnpaddedBase64String(s) || (IsUnpaddedBase64String(s[..finalBlockStart]) && (Is1Padding(s[finalBlockStart..]) || Is2Padding(s[finalBlockStart..]))))
  }

  function method DecodeValid(s: seq<char>): (b: seq<uint8>)
    requires IsBase64String(s)
    decreases s
  {
    if s == [] then
      []
    else
      var finalBlockStart: int := |s| - 4; var prefix: seq<char>, suffix: seq<char> := s[..finalBlockStart], s[finalBlockStart..]; if Is1Padding(suffix) then DecodeUnpadded(prefix) + Decode1Padding(suffix) else if Is2Padding(suffix) then DecodeUnpadded(prefix) + Decode2Padding(suffix) else DecodeUnpadded(s)
  }

  lemma AboutDecodeValid(s: seq<char>, b: seq<uint8>)
    requires IsBase64String(s) && b == DecodeValid(s)
    ensures 4 <= |s| ==> ghost var finalBlockStart: int := |s| - 4; ghost var prefix: seq<char>, suffix: seq<char> := s[..finalBlockStart], s[finalBlockStart..]; (Is1Padding(suffix) ==> |b| % 3 == 2) && (Is2Padding(suffix) ==> |b| % 3 == 1) && (!Is1Padding(suffix) && !Is2Padding(suffix) ==> |b| % 3 == 0)
    decreases s, b
  {
    if 4 <= |s| {
      ghost var finalBlockStart := |s| - 4;
      ghost var prefix, suffix := s[..finalBlockStart], s[finalBlockStart..];
      if s == [] {
      } else if Is1Padding(suffix) {
        assert !Is2Padding(suffix);
        ghost var x, y := DecodeUnpadded(prefix), Decode1Padding(suffix);
        assert b == x + y;
        assert |x| == |x| / 3 * 3 && |y| == 2;
        Mod3(|x| / 3, |y|, |b|);
      } else if Is2Padding(suffix) {
        ghost var x, y := DecodeUnpadded(prefix), Decode2Padding(suffix);
        assert b == x + y;
        assert |x| == |x| / 3 * 3 && |y| == 1;
        Mod3(|x| / 3, |y|, |b|);
      } else {
        assert b == DecodeUnpadded(s);
      }
    }
  }

  lemma Mod3(x: nat, k: nat, n: nat)
    requires 0 <= k < 3 && n == 3 * x + k
    ensures n % 3 == k
    decreases x, k, n
  {
  }

  function method Decode(s: seq<char>): (b: Result<seq<uint8>, string>)
    ensures IsBase64String(s) ==> b.Success?
    ensures !IsBase64String(s) ==> b.Failure?
    decreases s
  {
    if IsBase64String(s) then
      Success(DecodeValid(s))
    else
      Failure(""The encoding is malformed"")
  }

  predicate StringIs7Bit(s: string)
    decreases s
  {
    forall i: int :: 
      0 <= i < |s| ==>
        s[i] < 128 as char
  }

  function method Encode(b: seq<uint8>): (s: seq<char>)
    ensures StringIs7Bit(s)
    ensures |s| % 4 == 0
    ensures IsBase64String(s)
    decreases b
  {
    if |b| % 3 == 0 then
      EncodeUnpadded(b)
    else if |b| % 3 == 1 then
      EncodeUnpadded(b[..|b| - 1]) + Encode2Padding(b[|b| - 1..])
    else
      EncodeUnpadded(b[..|b| - 2]) + Encode1Padding(b[|b| - 2..])
  }

  lemma EncodeLengthExact(b: seq<uint8>)
    ensures ghost var s: seq<char> := Encode(b); (|b| % 3 == 0 ==> |s| == |b| / 3 * 4) && (|b| % 3 != 0 ==> |s| == |b| / 3 * 4 + 4)
    decreases b
  {
    ghost var s := Encode(b);
    if |b| % 3 == 0 {
      assert s == EncodeUnpadded(b);
      assert |s| == |b| / 3 * 4;
    } else if |b| % 3 == 1 {
      assert s == EncodeUnpadded(b[..|b| - 1]) + Encode2Padding(b[|b| - 1..]);
      calc {
        |s|;
      ==
        |EncodeUnpadded(b[..|b| - 1])| + |Encode2Padding(b[|b| - 1..])|;
      ==
        {
          assert |Encode2Padding(b[|b| - 1..])| == 4;
        }
        |EncodeUnpadded(b[..|b| - 1])| + 4;
      ==
        {
          assert |EncodeUnpadded(b[..|b| - 1])| == |b[..|b| - 1]| / 3 * 4;
        }
        |b[..|b| - 1]| / 3 * 4 + 4;
      ==
        {
          assert |b[..|b| - 1]| == |b| - 1;
        }
        (|b| - 1) / 3 * 4 + 4;
      ==
        {
          assert (|b| - 1) / 3 == |b| / 3;
        }
        |b| / 3 * 4 + 4;
      }
    } else {
      assert s == EncodeUnpadded(b[..|b| - 2]) + Encode1Padding(b[|b| - 2..]);
      calc {
        |s|;
      ==
        |EncodeUnpadded(b[..|b| - 2])| + |Encode1Padding(b[|b| - 2..])|;
      ==
        {
          assert |Encode1Padding(b[|b| - 2..])| == 4;
        }
        |EncodeUnpadded(b[..|b| - 2])| + 4;
      ==
        {
          assert |EncodeUnpadded(b[..|b| - 2])| == |b[..|b| - 2]| / 3 * 4;
        }
        |b[..|b| - 2]| / 3 * 4 + 4;
      ==
        {
          assert |b[..|b| - 2]| == |b| - 2;
        }
        (|b| - 2) / 3 * 4 + 4;
      ==
        {
          assert (|b| - 2) / 3 == |b| / 3;
        }
        |b| / 3 * 4 + 4;
      }
      assert ghost var s: seq<char> := Encode(b); (|b| % 3 == 0 ==> |s| == |b| / 3 * 4) && (|b| % 3 != 0 ==> |s| == |b| / 3 * 4 + 4);
    }
  }

  lemma EncodeLengthBound(b: seq<uint8>)
    ensures ghost var s: seq<char> := Encode(b); |s| <= |b| / 3 * 4 + 4
    decreases b
  {
    EncodeLengthExact(b);
  }
}

module Base64Lemmas {

  import opened StandardLibrary = StandardLibrary

  import opened Wrappers = Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened Base64 = Base64
  lemma DecodeValidEncodeEmpty(s: seq<char>)
    requires s == []
    ensures Encode(DecodeValid(s)) == s
    decreases s
  {
  }

  lemma DecodeValidEncodeUnpadded(s: seq<char>)
    requires IsBase64String(s)
    requires |s| >= 4
    requires !Is1Padding(s[|s| - 4..])
    requires !Is2Padding(s[|s| - 4..])
    ensures Encode(DecodeValid(s)) == s
    decreases s
  {
    calc {
      Encode(DecodeValid(s));
    ==
      Encode(DecodeUnpadded(s));
    ==
      EncodeUnpadded(DecodeUnpadded(s));
    ==
      {
        DecodeEncodeUnpadded(s);
      }
      s;
    }
  }

  lemma DecodeValidUnpaddedPartialFrom1PaddedSeq(s: seq<char>)
    requires IsBase64String(s)
    requires |s| >= 4
    requires Is1Padding(s[|s| - 4..])
    ensures DecodeValid(s)[..|DecodeValid(s)| - 2] == DecodeUnpadded(s[..|s| - 4])
    decreases s
  {
  }

  lemma DecodeValid1PaddedPartialFrom1PaddedSeq(s: seq<char>)
    requires IsBase64String(s)
    requires |s| >= 4
    requires Is1Padding(s[|s| - 4..])
    ensures DecodeValid(s)[|DecodeValid(s)| - 2..] == Decode1Padding(s[|s| - 4..])
    decreases s
  {
  }

  lemma DecodeValidEncode1Padding(s: seq<char>)
    requires IsBase64String(s)
    requires |s| >= 4
    requires Is1Padding(s[|s| - 4..])
    ensures Encode(DecodeValid(s)) == s
    decreases s
  {
    calc {
      Encode(DecodeValid(s));
    ==
      assert |DecodeValid(s)| % 3 == 2; EncodeUnpadded(DecodeValid(s)[..|DecodeValid(s)| - 2]) + Encode1Padding(DecodeValid(s)[|DecodeValid(s)| - 2..]);
    ==
      {
        DecodeValidUnpaddedPartialFrom1PaddedSeq(s);
      }
      EncodeUnpadded(DecodeUnpadded(s[..|s| - 4])) + Encode1Padding(DecodeValid(s)[|DecodeValid(s)| - 2..]);
    ==
      {
        DecodeEncodeUnpadded(s[..|s| - 4]);
      }
      s[..|s| - 4] + Encode1Padding(DecodeValid(s)[|DecodeValid(s)| - 2..]);
    ==
      {
        DecodeValid1PaddedPartialFrom1PaddedSeq(s);
      }
      s[..|s| - 4] + Encode1Padding(Decode1Padding(s[|s| - 4..]));
    ==
      {
        DecodeEncode1Padding(s[|s| - 4..]);
      }
      s[..|s| - 4] + s[|s| - 4..];
    ==
      {
        SeqPartsMakeWhole(s, |s| - 4);
      }
      s;
    }
  }

  lemma DecodeValidUnpaddedPartialFrom2PaddedSeq(s: seq<char>)
    requires IsBase64String(s)
    requires |s| >= 4
    requires Is2Padding(s[|s| - 4..])
    ensures DecodeValid(s)[..|DecodeValid(s)| - 1] == DecodeUnpadded(s[..|s| - 4])
    decreases s
  {
  }

  lemma DecodeValid2PaddedPartialFrom2PaddedSeq(s: seq<char>)
    requires IsBase64String(s)
    requires |s| >= 4
    requires Is2Padding(s[|s| - 4..])
    ensures DecodeValid(s)[|DecodeValid(s)| - 1..] == Decode2Padding(s[|s| - 4..])
    decreases s
  {
  }

  lemma DecodeValidEncode2Padding(s: seq<char>)
    requires IsBase64String(s)
    requires |s| >= 4
    requires Is2Padding(s[|s| - 4..])
    ensures Encode(DecodeValid(s)) == s
    decreases s
  {
    calc {
      Encode(DecodeValid(s));
    ==
      assert |DecodeValid(s)| % 3 == 1; EncodeUnpadded(DecodeValid(s)[..|DecodeValid(s)| - 1]) + Encode2Padding(DecodeValid(s)[|DecodeValid(s)| - 1..]);
    ==
      {
        DecodeValidUnpaddedPartialFrom2PaddedSeq(s);
      }
      EncodeUnpadded(DecodeUnpadded(s[..|s| - 4])) + Encode2Padding(DecodeValid(s)[|DecodeValid(s)| - 1..]);
    ==
      {
        DecodeEncodeUnpadded(s[..|s| - 4]);
      }
      s[..|s| - 4] + Encode2Padding(DecodeValid(s)[|DecodeValid(s)| - 1..]);
    ==
      {
        DecodeValid2PaddedPartialFrom2PaddedSeq(s);
      }
      s[..|s| - 4] + Encode2Padding(Decode2Padding(s[|s| - 4..]));
    ==
      {
        DecodeEncode2Padding(s[|s| - 4..]);
      }
      s[..|s| - 4] + s[|s| - 4..];
    ==
      {
        SeqPartsMakeWhole(s, |s| - 4);
      }
      s;
    }
  }

  lemma DecodeValidEncode(s: seq<char>)
    requires IsBase64String(s)
    ensures Encode(DecodeValid(s)) == s
    decreases s
  {
    if s == [] {
      calc {
        Encode(DecodeValid(s));
      ==
        {
          DecodeValidEncodeEmpty(s);
        }
        s;
      }
    } else if |s| >= 4 && Is1Padding(s[|s| - 4..]) {
      calc {
        Encode(DecodeValid(s));
      ==
        {
          DecodeValidEncode1Padding(s);
        }
        s;
      }
    } else if |s| >= 4 && Is2Padding(s[|s| - 4..]) {
      calc {
        Encode(DecodeValid(s));
      ==
        {
          DecodeValidEncode2Padding(s);
        }
        s;
      }
    } else {
      calc {
        Encode(DecodeValid(s));
      ==
        {
          DecodeValidEncodeUnpadded(s);
        }
        s;
      }
    }
  }

  lemma EncodeDecodeValid(b: seq<uint8>)
    ensures DecodeValid(Encode(b)) == b
    decreases b
  {
  }

  lemma DecodeEncode(s: seq<char>)
    requires IsBase64String(s)
    ensures Encode(Decode(s).value) == s
    decreases s
  {
    calc {
      Encode(Decode(s).value);
    ==
      {
        DecodeValidEncode(s);
      }
      s;
    }
  }

  lemma EncodeDecode(b: seq<uint8>)
    ensures Decode(Encode(b)) == Success(b)
    decreases b
  {
    calc {
      Decode(Encode(b));
    ==
      {
        assert IsBase64String(Encode(b));
      }
      Success(DecodeValid(Encode(b)));
    ==
      {
        EncodeDecodeValid(b);
      }
      Success(b);
    }
  }
}

module StandardLibrary {

  import opened Wrappers = Wrappers

  import opened U = UInt
  function method {:tailrecursion} Join<T>(ss: seq<seq<T>>, joiner: seq<T>): (s: seq<T>)
    requires 0 < |ss|
    decreases ss, joiner
  {
    if |ss| == 1 then
      ss[0]
    else
      ss[0] + joiner + Join(ss[1..], joiner)
  }

  function method {:tailrecursion} Split<T(==)>(s: seq<T>, delim: T): (res: seq<seq<T>>)
    ensures delim !in s ==> res == [s]
    ensures s == [] ==> res == [[]]
    ensures 0 < |res|
    ensures forall i: int :: 0 <= i < |res| ==> delim !in res[i]
    ensures Join(res, [delim]) == s
    decreases |s|
  {
    var i: Option<nat> := FindIndexMatching(s, delim, 0);
    if i.Some? then
      [s[..i.value]] + Split(s[i.value + 1..], delim)
    else
      [s]
  }

  lemma /*{:_induction s}*/ WillSplitOnDelim<T>(s: seq<T>, delim: T, prefix: seq<T>)
    requires |prefix| < |s|
    requires forall i: int :: 0 <= i < |prefix| ==> prefix[i] == s[i]
    requires delim !in prefix && s[|prefix|] == delim
    ensures Split(s, delim) == [prefix] + Split(s[|prefix| + 1..], delim)
    decreases s, prefix
  {
    calc {
      Split(s, delim);
    ==
      ghost var i: Option<nat> := FindIndexMatching(s, delim, 0); if i.Some? then [s[..i.value]] + Split(s[i.value + 1..], delim) else [s];
    ==
      {
        FindIndexMatchingLocatesElem(s, delim, 0, |prefix|);
        assert FindIndexMatching(s, delim, 0).Some?;
      }
      [s[..|prefix|]] + Split(s[|prefix| + 1..], delim);
    ==
      {
        assert s[..|prefix|] == prefix;
      }
      [prefix] + Split(s[|prefix| + 1..], delim);
    }
  }

  lemma /*{:_induction s}*/ WillNotSplitWithOutDelim<T>(s: seq<T>, delim: T)
    requires delim !in s
    ensures Split(s, delim) == [s]
    decreases s
  {
    calc {
      Split(s, delim);
    ==
      ghost var i: Option<nat> := FindIndexMatching(s, delim, 0); if i.Some? then [s[..i.value]] + Split(s[i.value + 1..], delim) else [s];
    ==
      {
        FindIndexMatchingLocatesElem(s, delim, 0, |s|);
      }
      [s];
    }
  }

  lemma FindIndexMatchingLocatesElem<T>(s: seq<T>, c: T, start: nat, elemIndex: nat)
    requires start <= elemIndex <= |s|
    requires forall i: int :: start <= i < elemIndex ==> s[i] != c
    requires elemIndex == |s| || s[elemIndex] == c
    ensures FindIndexMatching(s, c, start) == if elemIndex == |s| then None else Some(elemIndex)
    decreases elemIndex - start
  {
  }

  function method FindIndexMatching<T(==)>(s: seq<T>, c: T, i: nat): (index: Option<nat>)
    requires i <= |s|
    ensures index.Some? ==> i <= index.value < |s| && s[index.value] == c && c !in s[i .. index.value]
    ensures index.None? ==> c !in s[i..]
    decreases |s| - i
  {
    FindIndex(s, (x: T) => x == c, i)
  }

  function method {:tailrecursion} FindIndex<T>(s: seq<T>, f: T -> bool, i: nat): (index: Option<nat>)
    requires i <= |s|
    ensures index.Some? ==> i <= index.value < |s| && f(s[index.value]) && forall j: int :: i <= j < index.value ==> !f(s[j])
    ensures index.None? ==> forall j: int :: i <= j < |s| ==> !f(s[j])
    decreases |s| - i
  {
    if i == |s| then
      None
    else if f(s[i]) then
      Some(i)
    else
      FindIndex(s, f, i + 1)
  }

  function method {:tailrecursion} Filter<T>(s: seq<T>, f: T -> bool): (res: seq<T>)
    ensures forall i: int :: 0 <= i < |s| && f(s[i]) ==> s[i] in res
    ensures forall i: int :: 0 <= i < |res| ==> res[i] in s && f(res[i])
    ensures |res| <= |s|
    decreases s
  {
    if |s| == 0 then
      []
    else if f(s[0]) then
      [s[0]] + Filter(s[1..], f)
    else
      Filter(s[1..], f)
  }

  lemma /*{:_induction s, s', f}*/ FilterIsDistributive<T>(s: seq<T>, s': seq<T>, f: T -> bool)
    ensures Filter(s + s', f) == Filter(s, f) + Filter(s', f)
    decreases s, s'
  {
    if s == [] {
      assert s + s' == s';
    } else {
      ghost var S := s + s';
      ghost var s1 := s[1..];
      calc {
        Filter(S, f);
      ==
        if f(S[0]) then [S[0]] + Filter(S[1..], f) else Filter(S[1..], f);
      ==
        {
          assert S[0] == s[0] && S[1..] == s1 + s';
        }
        if f(s[0]) then [s[0]] + Filter(s1 + s', f) else Filter(s1 + s', f);
      ==
        {
          FilterIsDistributive(s1, s', f);
        }
        if f(s[0]) then [s[0]] + (Filter(s1, f) + Filter(s', f)) else Filter(s1, f) + Filter(s', f);
      ==
        if f(s[0]) then [s[0]] + Filter(s1, f) + Filter(s', f) else Filter(s1, f) + Filter(s', f);
      ==
        (if f(s[0]) then [s[0]] + Filter(s1, f) else Filter(s1, f)) + Filter(s', f);
      ==
        Filter(s, f) + Filter(s', f);
      }
    }
  }

  function method Min(a: int, b: int): int
    decreases a, b
  {
    if a < b then
      a
    else
      b
  }

  function method Fill<T>(value: T, n: nat): seq<T>
    ensures |Fill(value, n)| == n
    ensures forall i: int :: 0 <= i < n ==> Fill(value, n)[i] == value
    decreases n
  {
    seq(n, (_: int) => value)
  }

  method SeqToArray<T>(s: seq<T>) returns (a: array<T>)
    ensures fresh(a)
    ensures a.Length == |s|
    ensures forall i: int :: 0 <= i < |s| ==> a[i] == s[i]
    decreases s
  {
    a := new T[|s|] ((i: int) requires 0 <= i < |s| => s[i]);
  }

  lemma SeqPartsMakeWhole<T>(s: seq<T>, i: nat)
    requires 0 <= i <= |s|
    ensures s[..i] + s[i..] == s
    decreases s, i
  {
  }

  predicate method LexicographicLessOrEqual<T(==)>(a: seq<T>, b: seq<T>, less: (T, T) -> bool)
    decreases a, b
  {
    exists k: int :: 
      0 <= k <= |a| &&
      LexicographicLessOrEqualAux(a, b, less, k)
  }

  predicate method LexicographicLessOrEqualAux<T(==)>(a: seq<T>, b: seq<T>, less: (T, T) -> bool, lengthOfCommonPrefix: nat)
    requires 0 <= lengthOfCommonPrefix <= |a|
    decreases a, b, lengthOfCommonPrefix
  {
    lengthOfCommonPrefix <= |b| &&
    (forall i: int :: 
      0 <= i < lengthOfCommonPrefix ==>
        a[i] == b[i]) &&
    (lengthOfCommonPrefix == |a| || (lengthOfCommonPrefix < |b| && less(a[lengthOfCommonPrefix], b[lengthOfCommonPrefix])))
  }

  predicate Trichotomous<T(!new)>(less: (T, T) -> bool)
  {
    (forall x: T, y: T :: 
      less(x, y) || x == y || less(y, x)) &&
    (forall x: T, y: T :: 
      less(x, y) &&
      less(y, x) ==>
        false) &&
    forall x: T, y: T :: 
      less(x, y) ==>
        x != y
  }

  predicate Transitive<T(!new)>(R: (T, T) -> bool)
  {
    forall x: T, y: T, z: T :: 
      R(x, y) &&
      R(y, z) ==>
        R(x, z)
  }

  lemma UInt8LessIsTrichotomousTransitive()
    ensures Trichotomous(UInt8Less)
    ensures Transitive(UInt8Less)
  {
  }

  lemma LexIsReflexive<T>(a: seq<T>, less: (T, T) -> bool)
    ensures LexicographicLessOrEqual(a, a, less)
    decreases a
  {
    assert LexicographicLessOrEqualAux(a, a, less, |a|);
  }

  lemma LexIsAntisymmetric<T>(a: seq<T>, b: seq<T>, less: (T, T) -> bool)
    requires Trich: Trichotomous(less)
    requires LexicographicLessOrEqual(a, b, less)
    requires LexicographicLessOrEqual(b, a, less)
    ensures a == b
    decreases a, b
  {
    assert LessIrreflexive: forall x: T, y: T :: less(x, y) ==> x != y by {
      reveal Trich;
    }
    assert ASymmetric: forall x: T, y: T :: less(x, y) && less(y, x) ==> false by {
      reveal Trich;
    }
    ghost var k0 :| 0 <= k0 <= |a| && LexicographicLessOrEqualAux(a, b, less, k0);
    ghost var k1 :| 0 <= k1 <= |b| && LexicographicLessOrEqualAux(b, a, less, k1);
    ghost var max := if k0 < k1 then k1 else k0;
    assert max <= |a| && max <= |b|;
    assert SameUntilMax: forall i: int :: 0 <= i < max ==> a[i] == b[i];
    assert AA: k0 == |a| || (k0 < |b| && less(a[k0], b[k0]));
    assert BB: k1 == |b| || (k1 < |a| && less(b[k1], a[k1]));
    calc {
      true;
    ==>
      {
        reveal AA, BB;
      }
      (k0 == |a| || (k0 < |b| && less(a[k0], b[k0]))) &&
      (k1 == |b| || (k1 < |a| && less(b[k1], a[k1])));
    ==
      (k0 == |a| && k1 == |b|) || (k0 == |a| && k1 < |a| && less(b[k1], a[k1])) || (k0 < |b| && less(a[k0], b[k0]) && k1 == |b|) || (k0 < |b| && less(a[k0], b[k0]) && k1 < |a| && less(b[k1], a[k1]));
    ==
      {
        reveal LessIrreflexive, SameUntilMax;
      }
      (k0 == |a| && k1 == |b|) || (k0 < |b| && less(a[k0], b[k0]) && k1 < |a| && less(b[k1], a[k1]));
    ==>
      {
        reveal LessIrreflexive, SameUntilMax;
        assert max <= k0 && max <= k1;
      }
      (k0 == |a| && k1 == |b|) || (k0 < |b| && less(a[k0], b[k0]) && k1 < |a| && less(b[k1], a[k1]) && k0 == k1 == max);
    ==
      {
        reveal ASymmetric;
      }
      k0 == |a| &&
      k1 == |b|;
    ==>
      {
        assert |a| == k0 <= max && |b| == k1 <= max ==> k0 == k1;
      }
      max == |a| == |b|;
    ==>
      {
        reveal SameUntilMax;
      }
      a == b;
    }
  }

  lemma LexIsTransitive<T>(a: seq<T>, b: seq<T>, c: seq<T>, less: (T, T) -> bool)
    requires Transitive(less)
    requires LexicographicLessOrEqual(a, b, less)
    requires LexicographicLessOrEqual(b, c, less)
    ensures LexicographicLessOrEqual(a, c, less)
    decreases a, b, c
  {
    ghost var k0 :| 0 <= k0 <= |a| && LexicographicLessOrEqualAux(a, b, less, k0);
    ghost var k1 :| 0 <= k1 <= |b| && LexicographicLessOrEqualAux(b, c, less, k1);
    ghost var k := if k0 < k1 then k0 else k1;
    assert LexicographicLessOrEqualAux(a, c, less, k);
  }

  lemma LexIsTotal<T>(a: seq<T>, b: seq<T>, less: (T, T) -> bool)
    requires Trich: Trichotomous(less)
    ensures LexicographicLessOrEqual(a, b, less) || LexicographicLessOrEqual(b, a, less)
    decreases a, b
  {
    ghost var m := 0;
    while m < |a| && m < |b| && a[m] == b[m]
      invariant m <= |a| && m <= |b|
      invariant forall i: int :: 0 <= i < m ==> a[i] == b[i]
      decreases |a| - m, if m < |a| then |b| - m else 0 - 1
    {
      m := m + 1;
    }
    if m == |a| == |b| {
      assert a == b;
      LexIsReflexive(a, less);
    } else if m == |a| < |b| {
      assert LexicographicLessOrEqualAux(a, b, less, m);
    } else if m == |b| < |a| {
      assert LexicographicLessOrEqualAux(b, a, less, m);
    } else {
      assert m < |a| && m < |b|;
      reveal Trich;
      if
      case less(a[m], b[m]) =>
        assert LexicographicLessOrEqualAux(a, b, less, m);
      case less(b[m], a[m]) =>
        assert LexicographicLessOrEqualAux(b, a, less, m);
    }
  }

  function method {:tailrecursion} SetToOrderedSequence<T(==,!new)>(s: set<seq<T>>, less: (T, T) -> bool): (q: seq<seq<T>>)
    requires Trichotomous(less) && Transitive(less)
    ensures |s| == |q|
    ensures forall i: int :: 0 <= i < |q| ==> q[i] in s
    ensures forall k: seq<T> :: k in s ==> k in q
    ensures forall i: int :: 0 < i < |q| ==> LexicographicLessOrEqual(q[i - 1], q[i], less)
    ensures forall i: int, j: int | 0 <= i < j < |q| :: q[i] != q[j]
    decreases s
  {
    if s == {} then
      []
    else
      ThereIsAMinimum(s, less); assert forall a: seq<T>, b: seq<T> :: IsMinimum(a, s, less) && IsMinimum(b, s, less) ==> a == b by {
    forall a: seq<T>, b: seq<T> | IsMinimum(a, s, less) && IsMinimum(b, s, less) {
      MinimumIsUnique(a, b, s, less);
    }
  } var a: seq<T> :| a in s && IsMinimum(a, s, less); [a] + SetToOrderedSequence(s - {a}, less)
  }

  predicate method IsMinimum<T(==)>(a: seq<T>, s: set<seq<T>>, less: (T, T) -> bool)
    decreases a, s
  {
    a in s &&
    forall z: seq<T> :: 
      z in s ==>
        LexicographicLessOrEqual(a, z, less)
  }

  lemma ThereIsAMinimum<T>(s: set<seq<T>>, less: (T, T) -> bool)
    requires s != {}
    requires Trichotomous(less) && Transitive(less)
    ensures exists a: seq<T> :: IsMinimum(a, s, less)
    decreases s
  {
    ghost var a := FindMinimum(s, less);
  }

  lemma MinimumIsUnique<T>(a: seq<T>, b: seq<T>, s: set<seq<T>>, less: (T, T) -> bool)
    requires IsMinimum(a, s, less) && IsMinimum(b, s, less)
    requires Trichotomous(less)
    ensures a == b
    decreases a, b, s
  {
    LexIsAntisymmetric(a, b, less);
  }

  lemma FindMinimum<T>(s: set<seq<T>>, less: (T, T) -> bool) returns (a: seq<T>)
    requires s != {}
    requires Trichotomous(less) && Transitive(less)
    ensures IsMinimum(a, s, less)
    decreases s
  {
    a :| a in s;
    if s == {a} {
      LexIsReflexive(a, less);
    } else {
      ghost var s' := s - {a};
      assert forall x: seq<T> :: x in s <==> x == a || x in s';
      ghost var a' := FindMinimum(s', less);
      if LexicographicLessOrEqual(a', a, less) {
        a := a';
      } else {
        assert LexicographicLessOrEqual(a, a', less) by {
          LexIsTotal(a, a', less);
        }
        forall z: seq<T> | z in s
          ensures LexicographicLessOrEqual(a, z, less)
        {
          if z == a {
            LexIsReflexive(a, less);
          } else {
            calc {
              true;
            ==
              z in s';
            ==>
              LexicographicLessOrEqual(a', z, less);
            ==>
              {
                LexIsTransitive(a, a', z, less);
              }
              LexicographicLessOrEqual(a, z, less);
            }
          }
        }
      }
    }
  }

  module UInt {
    newtype uint8 = x: int
      | 0 <= x < 256

    newtype uint16 = x: int
      | 0 <= x < 65536

    newtype uint32 = x: int
      | 0 <= x < 4294967296

    newtype uint64 = x: int
      | 0 <= x < 18446744073709551616

    newtype int32 = x: int
      | -2147483648 <= x < 2147483648

    const UINT16_LIMIT := 65536
    const UINT32_LIMIT := 4294967296
    const INT32_MAX_LIMIT := 2147483648

    predicate method UInt8Less(a: uint8, b: uint8)
      decreases a, b
    {
      a < b
    }

    function method UInt16ToSeq(x: uint16): (ret: seq<uint8>)
      ensures |ret| == 2
      ensures 256 * ret[0] as uint16 + ret[1] as uint16 == x
      decreases x
    {
      var b0: uint8 := (x / 256) as uint8;
      var b1: uint8 := (x % 256) as uint8;
      [b0, b1]
    }

    function method SeqToUInt16(s: seq<uint8>): (x: uint16)
      requires |s| == 2
      ensures UInt16ToSeq(x) == s
      decreases s
    {
      var x0: uint16 := s[0] as uint16 * 256;
      x0 + s[1] as uint16
    }

    lemma UInt16SeqSerializeDeserialize(x: uint16)
      ensures SeqToUInt16(UInt16ToSeq(x)) == x
      decreases x
    {
    }

    lemma UInt16SeqDeserializeSerialize(s: seq<uint8>)
      requires |s| == 2
      ensures UInt16ToSeq(SeqToUInt16(s)) == s
      decreases s
    {
    }

    function method UInt32ToSeq(x: uint32): (ret: seq<uint8>)
      ensures |ret| == 4
      ensures 16777216 * ret[0] as uint32 + 65536 * ret[1] as uint32 + 256 * ret[2] as uint32 + ret[3] as uint32 == x
      decreases x
    {
      var b0: uint8 := (x / 16777216) as uint8;
      var x0: uint32 := x - b0 as uint32 * 16777216;
      var b1: uint8 := (x0 / 65536) as uint8;
      var x1: uint32 := x0 - b1 as uint32 * 65536;
      var b2: uint8 := (x1 / 256) as uint8;
      var b3: uint8 := (x1 % 256) as uint8;
      [b0, b1, b2, b3]
    }

    function method SeqToUInt32(s: seq<uint8>): (x: uint32)
      requires |s| == 4
      ensures UInt32ToSeq(x) == s
      decreases s
    {
      var x0: uint32 := s[0] as uint32 * 16777216;
      var x1: uint32 := x0 + s[1] as uint32 * 65536;
      var x2: uint32 := x1 + s[2] as uint32 * 256;
      x2 + s[3] as uint32
    }

    lemma UInt32SeqSerializeDeserialize(x: uint32)
      ensures SeqToUInt32(UInt32ToSeq(x)) == x
      decreases x
    {
    }

    lemma UInt32SeqDeserializeSerialize(s: seq<uint8>)
      requires |s| == 4
      ensures UInt32ToSeq(SeqToUInt32(s)) == s
      decreases s
    {
    }

    function method UInt64ToSeq(x: uint64): (ret: seq<uint8>)
      ensures |ret| == 8
      ensures 72057594037927936 * ret[0] as uint64 + 281474976710656 * ret[1] as uint64 + 1099511627776 * ret[2] as uint64 + 4294967296 * ret[3] as uint64 + 16777216 * ret[4] as uint64 + 65536 * ret[5] as uint64 + 256 * ret[6] as uint64 + ret[7] as uint64 == x
      decreases x
    {
      var b0: uint8 := (x / 72057594037927936) as uint8;
      var x0: uint64 := x - b0 as uint64 * 72057594037927936;
      var b1: uint8 := (x0 / 281474976710656) as uint8;
      var x1: uint64 := x0 - b1 as uint64 * 281474976710656;
      var b2: uint8 := (x1 / 1099511627776) as uint8;
      var x2: uint64 := x1 - b2 as uint64 * 1099511627776;
      var b3: uint8 := (x2 / 4294967296) as uint8;
      var x3: uint64 := x2 - b3 as uint64 * 4294967296;
      var b4: uint8 := (x3 / 16777216) as uint8;
      var x4: uint64 := x3 - b4 as uint64 * 16777216;
      var b5: uint8 := (x4 / 65536) as uint8;
      var x5: uint64 := x4 - b5 as uint64 * 65536;
      var b6: uint8 := (x5 / 256) as uint8;
      var b7: uint8 := (x5 % 256) as uint8;
      [b0, b1, b2, b3, b4, b5, b6, b7]
    }

    function method SeqToUInt64(s: seq<uint8>): (x: uint64)
      requires |s| == 8
      ensures UInt64ToSeq(x) == s
      decreases s
    {
      var x0: uint64 := s[0] as uint64 * 72057594037927936;
      var x1: uint64 := x0 + s[1] as uint64 * 281474976710656;
      var x2: uint64 := x1 + s[2] as uint64 * 1099511627776;
      var x3: uint64 := x2 + s[3] as uint64 * 4294967296;
      var x4: uint64 := x3 + s[4] as uint64 * 16777216;
      var x5: uint64 := x4 + s[5] as uint64 * 65536;
      var x6: uint64 := x5 + s[6] as uint64 * 256;
      var x: uint64 := x6 + s[7] as uint64;
      UInt64SeqSerialize(x, s);
      x
    }

    lemma UInt64SeqSerialize(x: uint64, s: seq<uint8>)
      requires |s| == 8
      requires 72057594037927936 * s[0] as uint64 + 281474976710656 * s[1] as uint64 + 1099511627776 * s[2] as uint64 + 4294967296 * s[3] as uint64 + 16777216 * s[4] as uint64 + 65536 * s[5] as uint64 + 256 * s[6] as uint64 + s[7] as uint64 == x
      ensures UInt64ToSeq(x) == s
      decreases x, s
    {
      calc {
        UInt64ToSeq(x);
      ==
        UInt64ToSeq(s[0] as uint64 * 72057594037927936 + s[1] as uint64 * 281474976710656 + s[2] as uint64 * 1099511627776 + s[3] as uint64 * 4294967296 + s[4] as uint64 * 16777216 + s[5] as uint64 * 65536 + s[6] as uint64 * 256 + s[7] as uint64);
      ==
        ghost var b0: uint8 := ((s[0] as uint64 * 72057594037927936 + s[1] as uint64 * 281474976710656 + s[2] as uint64 * 1099511627776 + s[3] as uint64 * 4294967296 + s[4] as uint64 * 16777216 + s[5] as uint64 * 65536 + s[6] as uint64 * 256 + s[7] as uint64) / 72057594037927936) as uint8; assert b0 == s[0]; ghost var x0: uint64 := s[0] as uint64 * 72057594037927936 + s[1] as uint64 * 281474976710656 + s[2] as uint64 * 1099511627776 + s[3] as uint64 * 4294967296 + s[4] as uint64 * 16777216 + s[5] as uint64 * 65536 + s[6] as uint64 * 256 + s[7] as uint64 - b0 as uint64 * 72057594037927936; assert x0 == s[1] as uint64 * 281474976710656 + s[2] as uint64 * 1099511627776 + s[3] as uint64 * 4294967296 + s[4] as uint64 * 16777216 + s[5] as uint64 * 65536 + s[6] as uint64 * 256 + s[7] as uint64; ghost var b1: uint8 := (x0 / 281474976710656) as uint8; assert b1 == s[1]; ghost var x1: uint64 := x0 - b1 as uint64 * 281474976710656; assert x1 == s[2] as uint64 * 1099511627776 + s[3] as uint64 * 4294967296 + s[4] as uint64 * 16777216 + s[5] as uint64 * 65536 + s[6] as uint64 * 256 + s[7] as uint64; ghost var b2: uint8 := (x1 / 1099511627776) as uint8; assert b2 == s[2]; ghost var x2: uint64 := x1 - b2 as uint64 * 1099511627776; assert x2 == s[3] as uint64 * 4294967296 + s[4] as uint64 * 16777216 + s[5] as uint64 * 65536 + s[6] as uint64 * 256 + s[7] as uint64; ghost var b3: uint8 := (x2 / 4294967296) as uint8; assert b3 == s[3]; ghost var x3: uint64 := x2 - b3 as uint64 * 4294967296; assert x3 == s[4] as uint64 * 16777216 + s[5] as uint64 * 65536 + s[6] as uint64 * 256 + s[7] as uint64; ghost var b4: uint8 := (x3 / 16777216) as uint8; assert b4 == s[4]; ghost var x4: uint64 := x3 - b4 as uint64 * 16777216; assert x4 == s[5] as uint64 * 65536 + s[6] as uint64 * 256 + s[7] as uint64; ghost var b5: uint8 := (x4 / 65536) as uint8; assert b5 == s[5]; ghost var x5: uint64 := x4 - b5 as uint64 * 65536; assert x5 == s[6] as uint64 * 256 + s[7] as uint64; ghost var b6: uint8 := (x5 / 256) as uint8; assert b6 == s[6]; ghost var b7: uint8 := (x5 % 256) as uint8; assert b7 == s[7]; [b0, b1, b2, b3, b4, b5, b6, b7];
      ==
        [s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7]];
      ==
        s;
      }
    }

    lemma UInt64SeqSerializeDeserialize(x: uint64)
      ensures SeqToUInt64(UInt64ToSeq(x)) == x
      decreases x
    {
    }

    lemma UInt64SeqDeserializeSerialize(s: seq<uint8>)
      requires |s| == 8
      ensures UInt64ToSeq(SeqToUInt64(s)) == s
      decreases s
    {
    }

    function SeqToNat(s: seq<uint8>): nat
      decreases s
    {
      if s == [] then
        0
      else
        ghost var finalIndex: int := |s| - 1; SeqToNat(s[..finalIndex]) * 256 + s[finalIndex] as nat
    }

    lemma /*{:_induction s}*/ SeqToNatZeroPrefix(s: seq<uint8>)
      ensures SeqToNat(s) == SeqToNat([0] + s)
      decreases s
    {
      if s == [] {
      } else {
        ghost var s' := [0] + s;
        ghost var sLength := |s|;
        ghost var sFinalIndex := sLength - 1;
        calc {
          SeqToNat(s);
        ==
          SeqToNat(s[..sFinalIndex]) * 256 + s[sFinalIndex] as nat;
        ==
          SeqToNat([0] + s[..sFinalIndex]) * 256 + s[sFinalIndex] as nat;
        ==
          {
            assert s'[..sLength] == [0] + s[..sFinalIndex] && s'[sLength] == s[sFinalIndex];
          }
          SeqToNat(s'[..sLength]) * 256 + s'[sLength] as nat;
        ==
          SeqToNat(s');
        ==
          SeqToNat([0] + s);
        }
      }
    }

    lemma /*{:_induction s}*/ SeqWithUInt32Suffix(s: seq<uint8>, n: nat)
      requires n < UINT32_LIMIT
      requires 4 <= |s|
      requires ghost var suffixStartIndex: int := |s| - 4; s[suffixStartIndex..] == UInt32ToSeq(n as uint32) && forall i: int :: 0 <= i < suffixStartIndex ==> s[i] == 0
      ensures SeqToNat(s) == n
      decreases s, n
    {
      if |s| == 4 {
        calc {
          SeqToNat(s);
        ==
          SeqToNat(s[..3]) * 256 + s[3] as nat;
        ==
          {
            assert s[..3][..2] == s[..2] && s[..3][2] == s[2];
          }
          (SeqToNat(s[..2]) * 256 + s[2] as nat) * 256 + s[3] as nat;
        ==
          {
            assert s[..2][..1] == s[..1] && s[..2][1] == s[1];
          }
          ((SeqToNat(s[..1]) * 256 + s[1] as nat) * 256 + s[2] as nat) * 256 + s[3] as nat;
        ==
          {
            assert s[..1][..0] == s[..0] && s[..1][0] == s[0];
          }
          (((SeqToNat(s[..0]) * 256 + s[0] as nat) * 256 + s[1] as nat) * 256 + s[2] as nat) * 256 + s[3] as nat;
        ==
          n;
        }
      } else {
        assert s == [0] + s[1..];
        SeqToNatZeroPrefix(s[1..]);
        SeqWithUInt32Suffix(s[1..], n);
      }
    }
  }
}

module {:extern ""Sets""} Sets {

  import opened StandardLibrary = StandardLibrary
  method {:extern ""SetToOrderedSequence""} ComputeSetToOrderedSequence<T(==)>(s: set<seq<T>>, less: (T, T) -> bool) returns (res: seq<seq<T>>)
    requires Trichotomous(less) && Transitive(less)
    ensures res == SetToOrderedSequence(s, less)
    decreases s
}

module Sorting {

  export
    reveals Reflexive, AntiSymmetric, Connected, TotalOrdering, LexicographicByteSeqBelow, LexicographicByteSeqBelowAux
    provides AboutLexicographicByteSeqBelow, SelectionSort, StandardLibrary, UInt


  import StandardLibrary = StandardLibrary

  import opened UInt = StandardLibrary.UInt
  predicate Reflexive<T(!new)>(R: (T, T) -> bool)
  {
    forall x: T :: 
      R(x, x)
  }

  predicate AntiSymmetric<T(!new)>(R: (T, T) -> bool)
  {
    forall x: T, y: T :: 
      R(x, y) &&
      R(y, x) ==>
        x == y
  }

  predicate Connected<T(!new)>(R: (T, T) -> bool)
  {
    forall x: T, y: T :: 
      R(x, y) || R(y, x)
  }

  predicate TotalOrdering<T(!new)>(R: (T, T) -> bool)
  {
    Reflexive(R) &&
    AntiSymmetric(R) &&
    StandardLibrary.Transitive(R) &&
    Connected(R)
  }

  predicate method LexicographicByteSeqBelow(x: seq<uint8>, y: seq<uint8>)
    decreases x, y
  {
    LexicographicByteSeqBelowAux(x, y, 0)
  }

  predicate method LexicographicByteSeqBelowAux(x: seq<uint8>, y: seq<uint8>, n: nat)
    requires n <= |x| && n <= |y|
    decreases |x| - n
  {
    n == |x| || (n != |y| && x[n] < y[n]) || (n != |y| && x[n] == y[n] && LexicographicByteSeqBelowAux(x, y, n + 1))
  }

  lemma AboutLexicographicByteSeqBelow()
    ensures TotalOrdering(LexicographicByteSeqBelow)
  {
    assert Reflexive(LexicographicByteSeqBelow) by {
      forall x: seq<uint8>, n: int | 0 <= n <= |x| {
        AboutLexicographicByteSeqBelowAux_Reflexive(x, n);
      }
    }
    assert AntiSymmetric(LexicographicByteSeqBelow) by {
      forall x: seq<uint8>, y: seq<uint8>, n: nat | n <= |x| && n <= |y| && x[..n] == y[..n] && LexicographicByteSeqBelowAux(x, y, n) && LexicographicByteSeqBelowAux(y, x, n) {
        AboutLexicographicByteSeqBelowAux_AntiSymmetric(x, y, n);
      }
    }
    assert StandardLibrary.Transitive(LexicographicByteSeqBelow) by {
      forall x: seq<uint8>, y: seq<uint8>, z: seq<uint8>, n: nat | n <= |x| && n <= |y| && n <= |z| && LexicographicByteSeqBelowAux(x, y, n) && LexicographicByteSeqBelowAux(y, z, n) {
        AboutLexicographicByteSeqBelowAux_Transitive(x, y, z, n);
      }
    }
    assert Connected(LexicographicByteSeqBelow) by {
      forall x: seq<uint8>, y: seq<uint8>, n: nat | n <= |x| && n <= |y| {
        AboutLexicographicByteSeqBelowAux_Connected(x, y, n);
      }
    }
  }

  lemma /*{:_induction x, n}*/ AboutLexicographicByteSeqBelowAux_Reflexive(x: seq<uint8>, n: nat)
    requires n <= |x|
    ensures LexicographicByteSeqBelowAux(x, x, n)
    decreases |x| - n
  {
  }

  lemma /*{:_induction x, y, n}*/ AboutLexicographicByteSeqBelowAux_AntiSymmetric(x: seq<uint8>, y: seq<uint8>, n: nat)
    requires n <= |x| && n <= |y|
    requires x[..n] == y[..n]
    requires LexicographicByteSeqBelowAux(x, y, n) && LexicographicByteSeqBelowAux(y, x, n)
    ensures x == y
    decreases |x| - n
  {
  }

  lemma /*{:_induction x, y, z, n}*/ AboutLexicographicByteSeqBelowAux_Transitive(x: seq<uint8>, y: seq<uint8>, z: seq<uint8>, n: nat)
    requires n <= |x| && n <= |y| && n <= |z|
    requires LexicographicByteSeqBelowAux(x, y, n) && LexicographicByteSeqBelowAux(y, z, n)
    ensures LexicographicByteSeqBelowAux(x, z, n)
    decreases |x| - n
  {
  }

  lemma /*{:_induction x, y, n}*/ AboutLexicographicByteSeqBelowAux_Connected(x: seq<uint8>, y: seq<uint8>, n: nat)
    requires n <= |x| && n <= |y|
    ensures LexicographicByteSeqBelowAux(x, y, n) || LexicographicByteSeqBelowAux(y, x, n)
    decreases |x| - n
  {
  }

  method SelectionSort<Data>(a: array<Data>, below: (Data, Data) -> bool)
    requires StandardLibrary.Transitive(below)
    requires Connected(below)
    modifies a
    ensures multiset(a[..]) == old(multiset(a[..]))
    ensures forall i: int, j: int :: 0 <= i < j < a.Length ==> below(a[i], a[j])
    decreases a
  {
    var m := 0;
    while m < a.Length
      invariant 0 <= m <= a.Length
      invariant multiset(a[..]) == old(multiset(a[..]))
      invariant forall i: int, j: int :: 0 <= i < j < m ==> below(a[i], a[j])
      invariant forall i: int, j: int :: 0 <= i < m <= j < a.Length ==> below(a[i], a[j])
      decreases a.Length - m
    {
      var mindex, n := m, m + 1;
      while n < a.Length
        invariant m <= mindex < n <= a.Length
        invariant forall i: int :: m <= i < n ==> below(a[mindex], a[i])
        decreases a.Length - n
      {
        if !below(a[mindex], a[n]) {
          mindex := n;
        }
        n := n + 1;
      }
      a[m], a[mindex] := a[mindex], a[m];
      m := m + 1;
    }
  }
}

module Streams {

  import opened Wrappers = Wrappers

  import opened UInt = StandardLibrary.UInt
  class SeqReader<T> {
    ghost var Repr: set<object>
    const data: seq<T>
    var pos: nat

    predicate Valid()
      reads this, Repr
      ensures Valid() ==> this in Repr
      decreases Repr + {this}
    {
      this in Repr &&
      pos <= |data|
    }

    constructor (s: seq<T>)
      ensures pos == 0
      ensures data[..] == s
      ensures Valid() && fresh(Repr)
      decreases s
    {
      data := s;
      pos := 0;
      Repr := {this};
    }

    method ReadElements(n: nat) returns (elems: seq<T>)
      requires Valid()
      requires n + pos <= |data|
      modifies `pos
      ensures n == 0 ==> elems == []
      ensures n > 0 ==> elems == data[old(pos)..][..n]
      ensures pos == old(pos) + n
      ensures data == old(data)
      ensures Valid()
      decreases n
    {
      elems := data[pos..][..n];
      pos := pos + n;
      return elems;
    }

    method ReadExact(n: nat) returns (res: Result<seq<T>, string>)
      requires Valid()
      modifies `pos
      ensures n + old(pos) <= |data| <==> res.Success?
      ensures res.Success? ==> |res.value| == n
      ensures res.Success? ==> pos == old(pos) + n
      ensures res.Success? ==> res.value == data[old(pos) .. old(pos) + n]
      ensures res.Failure? ==> n > |data| - pos
      ensures res.Failure? ==> pos == old(pos)
      ensures data == old(data)
      ensures Valid()
      decreases n
    {
      if n > |data| - pos {
        return Failure(""IO Error: Not enough elements left on stream."");
      } else {
        var elements := ReadElements(n);
        return Success(elements);
      }
    }
  }

  class ByteReader {
    ghost var Repr: set<object>
    const reader: SeqReader<uint8>

    predicate Valid()
      reads this, Repr
      ensures Valid() ==> this in Repr
      decreases Repr + {this}
    {
      this in Repr &&
      reader in Repr &&
      reader.Repr <= Repr &&
      this !in reader.Repr &&
      reader.Valid()
    }

    constructor (s: seq<uint8>)
      ensures reader.data == s
      ensures reader.pos == 0
      ensures Valid() && fresh(Repr)
      decreases s
    {
      var mr := new SeqReader<uint8>(s);
      reader := mr;
      Repr := {this} + mr.Repr;
    }

    method ReadByte() returns (res: Result<uint8, string>)
      requires Valid()
      modifies reader`pos
      ensures res.Failure? ==> |reader.data| - reader.pos < 1
      ensures res.Failure? ==> unchanged(reader)
      ensures res.Success? ==> reader.pos == old(reader.pos) + 1
      ensures old(reader.pos) + 1 <= |old(reader.data)| <==> res.Success?
      ensures res.Success? ==> res.value == reader.data[old(reader.pos)]
      ensures reader.data == old(reader.data)
      ensures Valid()
    {
      var bytes :- reader.ReadExact(1);
      assert |bytes| == 1;
      return Success(bytes[0]);
    }

    method ReadBytes(n: nat) returns (res: Result<seq<uint8>, string>)
      requires Valid()
      modifies reader`pos
      ensures res.Failure? ==> |reader.data| - reader.pos < n
      ensures res.Failure? ==> unchanged(reader)
      ensures res.Success? ==> |res.value| == n
      ensures res.Success? && |res.value| == 0 ==> unchanged(reader)
      ensures res.Success? ==> reader.pos == old(reader.pos) + n
      ensures old(reader.pos) + n <= |old(reader.data)| <==> res.Success?
      ensures res.Success? ==> res.value == reader.data[old(reader.pos) .. old(reader.pos) + n]
      ensures reader.data == old(reader.data)
      ensures Valid()
      decreases n
    {
      var bytes :- reader.ReadExact(n);
      assert |bytes| == n;
      return Success(bytes);
    }

    method ReadUInt16() returns (res: Result<uint16, string>)
      requires Valid()
      modifies reader`pos
      ensures res.Failure? ==> |reader.data| - reader.pos < 2
      ensures res.Failure? ==> unchanged(reader)
      ensures res.Success? ==> reader.pos == old(reader.pos) + 2
      ensures old(reader.pos) + 2 <= |old(reader.data)| <==> res.Success?
      ensures res.Success? ==> res.value == SeqToUInt16(reader.data[old(reader.pos) .. old(reader.pos) + 2])
      ensures reader.data == old(reader.data)
      ensures Valid()
    {
      var bytes :- reader.ReadExact(2);
      assert |bytes| == 2;
      var n := SeqToUInt16(bytes);
      return Success(n);
    }

    method ReadUInt32() returns (res: Result<uint32, string>)
      requires Valid()
      modifies reader`pos
      ensures res.Failure? ==> unchanged(reader)
      ensures res.Success? ==> reader.pos == old(reader.pos) + 4
      ensures old(reader.pos) + 4 <= |old(reader.data)| <==> res.Success?
      ensures res.Success? ==> res.value == SeqToUInt32(reader.data[old(reader.pos) .. old(reader.pos) + 4])
      ensures reader.data == old(reader.data)
      ensures Valid()
    {
      var bytes :- reader.ReadExact(4);
      assert |bytes| == 4;
      var n := SeqToUInt32(bytes);
      return Success(n);
    }

    method ReadUInt64() returns (res: Result<uint64, string>)
      requires Valid()
      modifies reader`pos
      ensures res.Failure? ==> |reader.data| - reader.pos < 8
      ensures res.Failure? ==> unchanged(reader)
      ensures res.Success? ==> reader.pos == old(reader.pos) + 8
      ensures old(reader.pos) + 8 <= |old(reader.data)| <==> res.Success?
      ensures res.Success? ==> res.value == SeqToUInt64(reader.data[old(reader.pos) .. old(reader.pos) + 8])
      ensures reader.data == old(reader.data)
      ensures Valid()
    {
      var bytes :- reader.ReadExact(8);
      assert |bytes| == 8;
      var n := SeqToUInt64(bytes);
      return Success(n);
    }

    method IsDoneReading() returns (b: bool)
      requires Valid()
      ensures (b && |reader.data| - reader.pos == 0) || (!b && |reader.data| - reader.pos > 0)
      ensures Valid()
    {
      return |reader.data| == reader.pos;
    }

    method GetSizeRead() returns (n: nat)
      requires Valid()
      ensures n == reader.pos
      ensures Valid()
    {
      return reader.pos;
    }
  }

  class SeqWriter<T> {
    ghost var Repr: set<object>
    var data: seq<T>

    predicate Valid()
      reads this, Repr
      ensures Valid() ==> this in Repr
      decreases Repr + {this}
    {
      this in Repr
    }

    constructor ()
      ensures data == []
      ensures Valid() && fresh(Repr)
    {
      data := [];
      Repr := {this};
    }

    method WriteElements(elems: seq<T>) returns (n: nat)
      requires Valid()
      modifies `data
      ensures n == |data| - |old(data)| == |elems|
      ensures |elems| == 0 ==> data == old(data)
      ensures |elems| > 0 ==> data == old(data) + elems
      ensures elems == data[|data| - |elems|..]
      ensures Valid()
      decreases elems
    {
      data := data + elems;
      return |elems|;
    }
  }

  class ByteWriter {
    ghost var Repr: set<object>
    const writer: SeqWriter<uint8>

    predicate Valid()
      reads this, Repr
      ensures Valid() ==> this in Repr
      decreases Repr + {this}
    {
      this in Repr &&
      writer in Repr &&
      writer.Repr <= Repr &&
      this !in writer.Repr &&
      writer.Valid()
    }

    constructor ()
      ensures writer.data == []
      ensures Valid() && fresh(Repr)
    {
      var mw := new SeqWriter<uint8>();
      writer := mw;
      Repr := {this} + mw.Repr;
    }

    method WriteByte(n: uint8) returns (r: nat)
      requires Valid()
      modifies writer`data
      ensures !unchanged(writer`data)
      ensures writer.data == old(writer.data) + [n]
      ensures r == 1
      ensures Valid()
      decreases n
    {
      r := writer.WriteElements([n]);
    }

    method WriteBytes(s: seq<uint8>) returns (r: nat)
      requires Valid()
      modifies writer`data
      ensures |s| == 0 ==> unchanged(writer)
      ensures |s| > 0 ==> !unchanged(writer`data)
      ensures writer.data == old(writer.data) + s
      ensures r == |s|
      ensures Valid()
      decreases s
    {
      r := writer.WriteElements(s);
    }

    method WriteUInt16(n: uint16) returns (r: nat)
      requires Valid()
      modifies writer`data
      ensures !unchanged(writer`data)
      ensures writer.data == old(writer.data) + UInt16ToSeq(n)
      ensures r == 2
      ensures Valid()
      decreases n
    {
      r := writer.WriteElements(UInt16ToSeq(n));
    }

    method WriteUInt32(n: uint32) returns (r: nat)
      requires Valid()
      modifies writer`data
      ensures !unchanged(writer`data)
      ensures writer.data == old(writer.data) + UInt32ToSeq(n)
      ensures r == 4
      ensures Valid()
      decreases n
    {
      r := writer.WriteElements(UInt32ToSeq(n));
    }

    function method GetDataWritten(): (s: seq<uint8>)
      requires Valid()
      reads Repr
      ensures s == writer.data
      ensures Valid()
      decreases Repr
    {
      writer.data
    }

    function method GetSizeWritten(): (n: nat)
      requires Valid()
      reads Repr
      ensures n == |writer.data|
      ensures Valid()
      decreases Repr
    {
      |writer.data|
    }
  }
}

module Time {

  import opened StandardLibrary = StandardLibrary

  import opened UInt = StandardLibrary.UInt
  method {:extern ""TimeUtil.Time"", ""CurrentRelativeTime""} GetCurrent() returns (seconds: uint64)
}

module {:extern ""UTF8""} UTF8 {

  import opened Wrappers = Wrappers

  import opened UInt = StandardLibrary.UInt
  type ValidUTF8Bytes = i: seq<uint8>
    | ValidUTF8Seq(i)
    witness []

  method {:extern ""Encode""} Encode(s: string) returns (res: Result<ValidUTF8Bytes, string>)
    ensures IsASCIIString(s) ==> res.Success? && |res.value| == |s|
    decreases s

  method {:extern ""Decode""} Decode(b: ValidUTF8Bytes) returns (res: Result<string, string>)
    decreases b

  predicate method IsASCIIString(s: string)
    decreases s
  {
    forall i: int :: 
      0 <= i < |s| ==>
        s[i] as int < 128
  }

  predicate method Uses1Byte(s: seq<uint8>)
    requires |s| >= 1
    decreases s
  {
    0 <= s[0] <= 127
  }

  predicate method Uses2Bytes(s: seq<uint8>)
    requires |s| >= 2
    decreases s
  {
    194 <= s[0] <= 223 &&
    128 <= s[1] <= 191
  }

  predicate method Uses3Bytes(s: seq<uint8>)
    requires |s| >= 3
    decreases s
  {
    (s[0] == 224 && 160 <= s[1] <= 191 && 128 <= s[2] <= 191) || (225 <= s[0] <= 236 && 128 <= s[1] <= 191 && 128 <= s[2] <= 191) || (s[0] == 237 && 128 <= s[1] <= 159 && 128 <= s[2] <= 191) || (238 <= s[0] <= 239 && 128 <= s[1] <= 191 && 128 <= s[2] <= 191)
  }

  predicate method Uses4Bytes(s: seq<uint8>)
    requires |s| >= 4
    decreases s
  {
    (s[0] == 240 && 144 <= s[1] <= 191 && 128 <= s[2] <= 191 && 128 <= s[3] <= 191) || (241 <= s[0] <= 243 && 128 <= s[1] <= 191 && 128 <= s[2] <= 191 && 128 <= s[3] <= 191) || (s[0] == 244 && 128 <= s[1] <= 143 && 128 <= s[2] <= 191 && 128 <= s[3] <= 191)
  }

  predicate method ValidUTF8Range(a: seq<uint8>, lo: nat, hi: nat)
    requires lo <= hi <= |a|
    decreases hi - lo
  {
    if lo == hi then
      true
    else
      var r: seq<uint8> := a[lo .. hi]; if Uses1Byte(r) then ValidUTF8Range(a, lo + 1, hi) else if 2 <= |r| && Uses2Bytes(r) then ValidUTF8Range(a, lo + 2, hi) else if 3 <= |r| && Uses3Bytes(r) then ValidUTF8Range(a, lo + 3, hi) else 4 <= |r| && Uses4Bytes(r) && ValidUTF8Range(a, lo + 4, hi)
  }

  lemma /*{:_induction a, b, c, lo, hi}*/ ValidUTF8Embed(a: seq<uint8>, b: seq<uint8>, c: seq<uint8>, lo: nat, hi: nat)
    requires lo <= hi <= |b|
    ensures ValidUTF8Range(b, lo, hi) == ValidUTF8Range(a + b + c, |a| + lo, |a| + hi)
    decreases hi - lo
  {
    if lo == hi {
    } else {
      ghost var r := b[lo .. hi];
      ghost var r' := (a + b + c)[|a| + lo .. |a| + hi];
      assert r == r';
      if Uses1Byte(r) {
        ValidUTF8Embed(a, b, c, lo + 1, hi);
      } else if 2 <= |r| && Uses2Bytes(r) {
        ValidUTF8Embed(a, b, c, lo + 2, hi);
      } else if 3 <= |r| && Uses3Bytes(r) {
        ValidUTF8Embed(a, b, c, lo + 3, hi);
      } else if 4 <= |r| && Uses4Bytes(r) {
        ValidUTF8Embed(a, b, c, lo + 4, hi);
      }
    }
  }

  predicate method ValidUTF8Seq(s: seq<uint8>)
    decreases s
  {
    ValidUTF8Range(s, 0, |s|)
  }

  lemma ValidUTF8Concat(s: seq<uint8>, t: seq<uint8>)
    requires ValidUTF8Seq(s) && ValidUTF8Seq(t)
    ensures ValidUTF8Seq(s + t)
    decreases s, t
  {
    ghost var lo := 0;
    while lo < |s|
      invariant lo <= |s|
      invariant ValidUTF8Range(s, lo, |s|)
      invariant ValidUTF8Range(s + t, 0, |s + t|) == ValidUTF8Range(s + t, lo, |s + t|)
      decreases |s| - lo
    {
      ghost var r := (s + t)[lo..];
      if Uses1Byte(r) {
        lo := lo + 1;
      } else if 2 <= |r| && Uses2Bytes(r) {
        lo := lo + 2;
      } else if 3 <= |r| && Uses3Bytes(r) {
        lo := lo + 3;
      } else if 4 <= |r| && Uses4Bytes(r) {
        lo := lo + 4;
      } else {
        assert false;
      }
    }
    calc {
      ValidUTF8Seq(s + t);
    ==
      ValidUTF8Range(s + t, 0, |s + t|);
    ==
      ValidUTF8Range(s + t, lo, |s + t|);
    ==
      {
        assert s + t == s + t + [] && lo == |s| && |s + t| == |s| + |t|;
      }
      ValidUTF8Range(s + t + [], |s|, |s| + |t|);
    ==
      {
        ValidUTF8Embed(s, t, [], 0, |t|);
      }
      ValidUTF8Range(t, 0, |t|);
    ==
      ValidUTF8Seq(t);
    ==
      true;
    }
  }
}

module TestDigest {

  import CryptoDatatypes = CryptoDatatypes

  import Digest = Digest

  module Helpers {

    import CryptoDatatypes = CryptoDatatypes

    import Digest = Digest

    import opened StandardLibrary = StandardLibrary

    import opened UInt = StandardLibrary.UInt
    method ToInt(bytes: seq<uint8>) returns (n: nat)
      decreases bytes
    {
      n := 0;
      var i := 0;
      while i < |bytes|
        decreases |bytes| - i
      {
        n := 256 * n + bytes[i] as int;
        i := i + 1;
      }
    }

    method TestDigest(s: string, alg: CryptoDatatypes.DigestAlgorithm, expected: nat)
      decreases s, alg, expected
    {
      expect forall i: int :: 0 <= i < |s| ==> 'a' <= s[i] <= 'z', ""expectation violation""
      var msg := seq(|s|, (i: int) requires 0 <= i < |s| && 'a' <= s[i] <= 'z' => s[i] as uint8);
      var digest :- Digest.Digest(alg, msg);
      expect |digest| == Digest.Length(alg), ""expectation violation""
      var actual := ToInt(digest);
      expect actual == expected, ""expectation violation""
    }
  }
  method {:test} DigestTestVectors()
  {
    var s := ""abc"";
    Helpers.TestDigest(s, CryptoDatatypes.SHA_512, 11610554759577678887058616627522426787358414133166247019097754655123425531747192578669846860198531688061507751898313498051436198428987376028989280584770719);
    s := """";
    Helpers.TestDigest(s, CryptoDatatypes.SHA_512, 10868450558671247443152026947160338505683745266658651051718065983487878962987857602829315249215796444208488632888003673539585986066311769564391053988452926);
    s := ""abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu"";
    Helpers.TestDigest(s, CryptoDatatypes.SHA_512, 7467751150072304710748607053756525574443640673541183129594735496433453152253989885323496399866777464427478124519714519652484878749913622135027995536779529);
  }
}

module TestSignature {

  import Signature = Signature

  module Helpers {

    import Signature = Signature

    import UTF8 = UTF8

    import opened Wrappers = Wrappers

    import opened UInt = StandardLibrary.UInt
    method RequireGoodKeyLengths(s: Signature.ECDSAParams, sigKeyPair: Signature.SignatureKeyPair)
      decreases s, sigKeyPair
    {
      expect |sigKeyPair.verificationKey| == s.FieldSize(), ""expectation violation""
    }

    method YCompression(s: Signature.ECDSAParams, fieldSize: nat)
      decreases s, fieldSize
    {
      var res :- Signature.KeyGen(s);
      RequireGoodKeyLengths(s, res);
      var public, secret := res.verificationKey, res.signingKey;
      expect 0 < |secret|, ""expectation violation""
      expect |public| == 1 + (fieldSize + 7) / 8, ""expectation violation""
      expect public[0] == 2 || public[0] == 3, ""expectation violation""
    }

    method VerifyMessage(params: Signature.ECDSAParams)
      decreases params
    {
      var message :- UTF8.Encode(""Hello, World!"");
      var keys :- Signature.KeyGen(params);
      RequireGoodKeyLengths(params, keys);
      var signature :- Signature.Sign(params, keys.signingKey, message);
      var shouldBeTrue :- Signature.Verify(params, keys.verificationKey, message, signature);
      expect shouldBeTrue, ""expectation violation""
      var shouldBeFalse :- Signature.Verify(params, keys.verificationKey, message + [1], signature);
      expect !shouldBeFalse, ""expectation violation""
    }
  }
  method {:test} YCompression384()
  {
    Helpers.YCompression(Signature.ECDSA_P384, 384);
  }

  method {:test} YCompression256()
  {
    Helpers.YCompression(Signature.ECDSA_P256, 256);
  }

  method {:test} VerifyMessage384()
  {
    Helpers.VerifyMessage(Signature.ECDSA_P384);
  }

  method {:test} VerifyMessage256()
  {
    Helpers.VerifyMessage(Signature.ECDSA_P256);
  }
}

module {:extern ""TestHKDF""} TestHKDF {

  import opened Wrappers = Wrappers

  import opened HKDF = HKDF

  import opened KeyDerivationAlgorithms = KeyDerivationAlgorithms
  method {:test} Test0()
  {
    var tv_ikm := new [] [11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11];
    var tv_salt := new [] [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];
    var tv_info := new [] [240, 241, 242, 243, 244, 245, 246, 247, 248, 249];
    var tv_okm_desired := new [] [60, 178, 95, 37, 250, 172, 213, 122, 144, 67, 79, 100, 208, 54, 47, 42, 45, 45, 10, 144, 207, 26, 90, 76, 93, 176, 45, 86, 236, 196, 197, 191, 52, 0, 114, 8, 213, 184, 135, 24, 88, 101];
    var okm := Hkdf(HKDF_WITH_SHA_256, Some(tv_salt[..]), tv_ikm[..], tv_info[..], 42);
    expect tv_okm_desired[..] == okm, ""expectation violation""
  }

  method {:test} Test1()
  {
    var tv_ikm := new [] [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79];
    var tv_salt := new [] [96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 130, 86, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175];
    var tv_info := new [] [176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255];
    var tv_okm_desired := new [] [86, 160, 84, 52, 29, 13, 71, 250, 11, 73, 208, 29, 1, 53, 45, 194, 17, 12, 253, 117, 16, 251, 6, 124, 155, 90, 233, 105, 148, 86, 41, 99, 67, 199, 253, 213, 169, 254, 226, 104, 215, 158, 234, 250, 134, 60, 241, 23, 88, 218, 24, 176, 71, 136, 160, 210, 197, 159, 59, 3, 66, 163, 130, 46, 215, 166, 223, 241, 108, 59, 97, 59, 88, 158, 207, 15, 113, 11, 223, 43, 21, 57];
    var okm := Hkdf(HKDF_WITH_SHA_256, Some(tv_salt[..]), tv_ikm[..], tv_info[..], 82);
    expect tv_okm_desired[..] == okm, ""expectation violation""
  }

  method {:test} Test2()
  {
    var tv_salt := None;
    var tv_ikm := new [] [11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11];
    var tv_info := [];
    var tv_okm_desired := new [] [141, 164, 231, 117, 165, 99, 193, 143, 113, 95, 128, 42, 6, 60, 90, 49, 184, 161, 31, 92, 94, 225, 135, 158, 195, 69, 78, 95, 60, 115, 141, 45, 157, 32, 19, 149, 250, 164, 182, 26, 150, 200];
    var okm := Hkdf(HKDF_WITH_SHA_256, tv_salt, tv_ikm[..], tv_info[..], 42);
    expect tv_okm_desired[..] == okm, ""expectation violation""
  }

  method {:test} Test3()
  {
    var tv_salt := new [] [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];
    var tv_ikm := new [] [11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11];
    var tv_info := new [] [240, 241, 242, 243, 244, 245, 246, 247, 248, 249];
    var tv_okm_desired := new [] [155, 80, 151, 168, 96, 56, 184, 5, 48, 144, 118, 164, 75, 58, 159, 56, 6, 62, 37, 181, 22, 220, 191, 54, 159, 57, 76, 250, 180, 54, 133, 247, 72, 182, 69, 119, 99, 228, 240, 32, 79, 197];
    var okm := Hkdf(HKDF_WITH_SHA_384, Some(tv_salt[..]), tv_ikm[..], tv_info[..], 42);
    expect tv_okm_desired[..] == okm, ""expectation violation""
  }

  method {:test} Test4()
  {
    var tv_salt := new [] [96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175];
    var tv_ikm := new [] [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79];
    var tv_info := new [] [176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255];
    var tv_okm_desired := new [] [72, 76, 160, 82, 184, 204, 114, 79, 209, 196, 236, 100, 213, 123, 78, 129, 140, 126, 37, 168, 224, 244, 86, 158, 215, 42, 106, 5, 254, 6, 73, 238, 191, 105, 248, 213, 200, 50, 133, 107, 244, 228, 251, 193, 121, 103, 213, 73, 117, 50, 74, 148, 152, 127, 127, 65, 131, 88, 23, 216, 153, 79, 219, 214, 244, 192, 156, 85, 0, 220, 162, 74, 86, 34, 47, 234, 83, 216, 150, 122, 139, 46];
    var okm := Hkdf(HKDF_WITH_SHA_384, Some(tv_salt[..]), tv_ikm[..], tv_info[..], 82);
    expect tv_okm_desired[..] == okm, ""expectation violation""
  }

  method {:test} Test5()
  {
    var tv_salt := None;
    var tv_ikm := new [] [11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11];
    var tv_info := [];
    var tv_okm_desired := new [] [200, 201, 110, 113, 15, 137, 176, 215, 153, 11, 202, 104, 188, 222, 200, 207, 133, 64, 98, 229, 76, 115, 167, 171, 199, 67, 250, 222, 155, 36, 45, 170, 204, 28, 234, 86, 112, 65, 91, 82, 132, 156];
    var okm := Hkdf(HKDF_WITH_SHA_384, tv_salt, tv_ikm[..], tv_info[..], 42);
    expect tv_okm_desired[..] == okm, ""expectation violation""
  }

  method {:test} Test7()
  {
    var tv_ikm := new [] [11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11];
    var tv_salt := new [] [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];
    var tv_info := new [] [240, 241, 242, 243, 244, 245, 246, 247, 248, 249];
    var tv_okm_desired := new [] [60, 178, 95, 37, 250, 172, 213, 122, 144, 67, 79, 100, 208, 54, 47, 42, 45, 45, 10, 144, 207, 26, 90, 76, 93, 176, 45, 86, 236, 196, 197, 191, 52, 0, 114, 8, 213, 184, 135, 24, 88, 101, 180, 176, 168, 90, 153, 59, 137, 185, 182, 86, 131, 214, 15, 1, 6, 210, 143, 255, 3, 157, 11, 111, 52, 8, 144, 12, 15, 42, 157, 68, 99, 222, 131, 98, 32, 86, 190, 80, 168, 129, 190, 191, 43, 152, 58, 180, 62, 6, 153, 18, 240, 165, 117, 130, 252, 177, 140, 167, 167, 254, 64, 163, 60, 118, 108, 130, 152, 18, 175, 50, 124, 50, 225, 38, 88, 157, 60, 100, 244, 25, 221, 255, 249, 216, 199, 135, 246, 149, 207, 234, 118, 150, 129, 103, 37, 227, 146, 198, 59, 83, 126, 102, 90, 107, 21, 225, 228, 90, 45, 248, 14, 98, 84, 167, 163, 237, 200, 67, 222, 25, 229, 176, 216, 151, 232, 4, 130, 158, 243, 237, 237, 162, 11, 188, 218, 124, 241, 49, 98, 22, 42, 29, 168, 134, 149, 243, 227, 161, 181, 245, 36, 229, 187, 152, 95, 115, 198, 109, 102, 223, 146, 112, 87, 79, 144, 183, 52, 142, 201, 101, 253, 81, 69, 117, 40, 253, 114, 172, 71, 88, 190, 87, 60, 109, 141, 2, 148, 225, 123, 201, 242, 103, 191, 159, 28, 170, 141, 56, 72, 103, 124, 185, 176, 250, 237, 138, 81, 242, 65, 80, 253, 200, 96, 58, 250, 130, 232, 213, 213, 130, 74, 113, 110, 63, 185, 91, 10, 204, 233, 167, 86, 6, 208, 111, 227, 88, 137, 239, 170, 109, 78, 12, 75, 61, 210, 223, 222, 0, 237, 155, 18, 211, 225, 243, 64, 167, 174, 78, 73, 81, 189, 103, 255, 251, 45, 179, 147, 160, 62, 62, 249, 44, 144, 191, 223, 222, 179, 16, 183, 82, 187, 134, 56, 26, 217, 2, 30, 238, 21, 21, 94, 187, 62, 191, 84, 102, 68, 46, 103, 223, 180, 126, 241, 243, 184, 47, 89, 14, 194, 202, 153, 104, 194, 211, 90, 50, 95, 39, 183, 97, 114, 86, 3, 247, 64, 201, 205, 16, 150, 21, 136, 241, 136, 156, 210, 108, 166, 202, 172, 112, 51, 87, 249, 137, 188, 79, 91, 72, 59, 83, 142, 174, 82, 191, 136, 136, 220, 225, 196, 19, 181, 156, 36, 162, 139, 193, 252, 133, 57, 121, 219, 84, 221, 138, 192, 207, 174, 114, 157, 155, 211, 168, 233, 161, 192, 111, 7, 246, 241, 194, 185, 215, 122, 109, 15, 33, 43, 36, 164, 60, 200, 16, 153, 192, 192, 101, 143, 158, 36, 103, 167, 14, 70, 61, 158, 247, 108, 239, 14, 107, 242, 202, 227, 215, 132, 113, 84, 115, 219, 65, 39, 98, 209, 9, 135, 36, 133, 249, 155, 44, 144, 20, 97, 14, 214, 18, 230, 95, 15, 21, 99, 94, 0, 11, 62, 21, 61, 136, 0, 186, 9, 39, 49, 155, 149, 71, 61, 46, 223, 150, 199, 57, 58, 97, 162, 166, 183, 124, 217, 53, 28, 111, 128, 77, 137, 141, 232, 98, 251, 94, 155, 48, 31, 243, 99, 245, 161, 143, 142, 162, 234, 35, 31, 244, 132, 119, 49, 20, 215, 56, 202, 171, 183, 125, 230, 11, 56, 34, 188, 136, 185, 143, 49, 223, 164, 229, 203, 154, 177, 235, 9, 180, 209, 212, 250, 238, 99, 63, 187, 87, 77, 58, 178, 253, 184, 161, 161, 91, 1, 55, 115, 181, 3, 199, 250, 153, 157, 237, 115, 129, 140, 114, 180, 103, 51, 189, 163, 117, 157, 213, 184, 112, 209, 197, 219, 110, 115, 209, 18, 232, 84, 137, 206, 135, 107, 179, 163, 225, 20, 167, 204, 7, 249, 212, 154, 181, 227, 51, 32, 181, 170, 69, 137, 160, 191, 95, 116, 50, 2, 37, 144, 160, 38, 25, 206, 172, 238, 151, 85, 102, 121, 250, 211, 201, 252, 220, 201, 151, 68, 221, 11, 182, 130, 43, 191, 131, 124, 182, 138, 11, 227, 47, 66, 7, 189, 240, 151, 101, 22, 218, 70, 88, 39, 63, 115, 194, 93, 61, 66, 14, 126, 114, 142, 142, 164, 133, 22, 2, 128, 230, 81, 1, 228, 21, 18, 76, 249, 211, 133, 47, 158, 108, 34, 166, 218, 138, 91, 48, 251, 193, 222, 98, 90, 162, 82, 198, 180, 7, 135, 9, 102, 154, 20, 118, 246, 85, 1, 172, 216, 97, 255, 186, 108, 208, 195, 158, 6, 77, 233, 221, 203, 242, 82, 156, 176, 66, 129, 211, 34, 218, 220, 166, 181, 122, 101, 191, 169, 212, 62, 127, 126, 132, 111, 111, 226, 3, 147, 235, 216, 61, 152, 119, 255, 34, 116, 176, 247, 117, 49, 19, 33, 92, 245, 180, 74, 230, 170, 150, 31, 148, 25, 108, 77, 125, 68, 107, 25, 146, 49, 207, 109, 159, 163, 168, 29, 39, 220, 213, 59, 23, 1, 123, 249, 79, 187, 190, 180, 179, 53, 60, 142, 251, 103, 92, 57, 48, 110, 221, 143, 205, 126, 2, 192, 163, 210, 79, 121, 82, 175, 187, 63, 56, 6, 201, 42, 240, 26, 194, 163, 183, 133, 88, 38, 151, 246, 100, 194, 212, 222, 18, 7, 168, 1, 155, 73, 59, 155, 255, 10, 211, 102, 116, 200, 89, 247, 127, 230, 59, 202, 238, 243, 179, 135, 230, 245, 66, 8, 136, 200, 53, 3, 249, 103, 7, 212, 65, 95, 171, 118, 51, 81, 90, 231, 91, 189, 60, 55, 113, 119, 6, 159, 59, 142, 108, 227, 192, 208, 122, 251, 73, 199, 107, 194, 202, 17, 94, 84, 155, 20, 13, 223, 43, 163, 75, 193, 247, 4, 109, 171, 46, 170, 86, 1, 166, 211, 203, 22, 158, 33, 170, 161, 171, 69, 149, 149, 145, 154, 9, 38, 31, 132, 171, 211, 170, 105, 153, 209, 96, 135, 243, 54, 18, 145, 127, 73, 102, 230, 74, 53, 187, 227, 65, 149, 81, 31, 110, 43, 74, 73, 97, 22, 231, 119, 212, 154, 64, 247, 221, 255, 219, 208, 65, 79, 188, 120, 186, 8, 43, 82, 232, 103, 117, 11, 163, 137, 174, 172, 124, 188, 38, 104, 166, 171, 146, 129, 107, 212, 237, 11, 113, 190, 12, 66, 223, 234, 97, 98, 17, 32, 106, 6, 228, 86, 25, 164, 82, 82, 67, 151, 149, 65, 172, 26, 144, 69, 142, 214, 240, 84, 144, 163, 171, 234, 192, 90, 248, 20, 196, 139, 108, 68, 246, 126, 186, 88, 55, 138, 248, 10, 38, 73, 84, 230, 144, 169, 243, 106, 220, 201, 67, 147, 156, 252, 140, 111, 127, 185, 107, 9, 30, 254, 186, 199, 233, 202, 65, 19, 187, 103, 157, 118, 224, 147, 206, 221, 216, 129, 102, 199, 50, 156, 28, 196, 49, 89, 129, 160, 199, 97, 30, 93, 100, 230, 20, 129, 215, 66, 136, 58, 192, 17, 199, 168, 169, 154, 217, 63, 33, 65, 220, 43, 69, 10, 246, 162, 183, 182, 5, 82, 97, 123, 134, 208, 8, 115, 104, 109, 24, 217, 242, 129, 125, 18, 8, 116, 77, 45, 154, 245, 201, 77, 71, 181, 72, 79, 20, 77, 178, 134, 186, 159, 167, 237, 32, 50, 124, 205, 236, 112, 92, 244, 164, 239, 31, 109, 33, 223, 93, 22, 222, 166, 62, 30, 214, 132, 206, 151, 53, 178, 250, 208, 52, 66, 153, 248, 63, 2, 12, 178, 117, 241, 24, 113, 47, 34, 235, 149, 40, 66, 229, 127, 204, 29, 163, 90, 35, 151, 244, 28, 249, 70, 91, 74, 205, 46, 235, 100, 194, 188, 97, 51, 164, 241, 35, 176, 8, 91, 67, 204, 51, 133, 157, 28, 237, 234, 135, 140, 68, 248, 195, 168, 48, 152, 86, 41, 176, 53, 39, 199, 99, 122, 86, 70, 225, 87, 225, 139, 57, 93, 93, 161, 228, 186, 192, 84, 229, 185, 3, 73, 196, 133, 137, 215, 192, 41, 30, 84, 160, 75, 206, 4, 245, 53, 52, 32, 182, 141, 66, 50, 238, 90, 81, 50, 55, 132, 3, 238, 68, 207, 144, 15, 12, 127, 195, 85, 18, 67, 55, 4, 249, 232, 170, 189, 205, 197, 169, 128, 156, 103, 221, 172, 213, 46, 143, 218, 107, 253, 77, 76, 190, 63, 151, 44, 57, 37, 225, 135, 125, 21, 217, 0, 62, 83, 50, 51, 2, 176, 160, 161, 82, 112, 198, 128, 235, 40, 101, 151, 189, 86, 46, 206, 202, 90, 229, 188, 108, 235, 245, 52, 22, 48, 189, 88, 192, 95, 153, 109, 92, 74, 146, 135, 44, 130, 221, 91, 17, 46, 49, 24, 97, 221, 22, 174, 32, 12, 189, 52, 252, 204, 133, 19, 122, 242, 26, 106, 233, 218, 176, 88, 71, 169, 76, 77, 71, 32, 235, 0, 204, 37, 71, 18, 175, 99, 202, 141, 95, 73, 81, 102, 224, 83, 97, 121, 41, 56, 4, 168, 25, 161, 181, 109, 109, 32, 119, 50, 239, 157, 76, 87, 131, 49, 194, 143, 60, 252, 204, 151, 84, 138, 227, 161, 25, 224, 185, 11, 244, 243, 71, 100, 58, 187, 100, 10, 114, 9, 150, 49, 55, 88, 50, 236, 54, 134, 117, 225, 138, 112, 54, 231, 10, 172, 222, 40, 134, 247, 223, 22, 127, 174, 217, 89, 228, 121, 213, 171, 117, 38, 115, 184, 151, 65, 116, 80, 180, 6, 44, 68, 100, 103, 62, 45, 161, 105, 91, 205, 163, 170, 194, 69, 7, 110, 85, 9, 1, 75, 138, 93, 63, 223, 224, 35, 41, 87, 86, 162, 251, 222, 96, 116, 144, 226, 203, 220, 53, 58, 173, 189, 251, 66, 48, 70, 179, 124, 43, 199, 97, 140, 17, 72, 95, 156, 86, 49, 121, 101, 171, 191, 239, 131, 88, 82, 87, 5, 137, 132, 94, 50, 170, 154, 151, 92, 140, 85, 46, 61, 153, 222, 231, 189, 141, 109, 1, 214, 204, 195, 222, 189, 125, 161, 123, 134, 161, 81, 225, 165, 244, 58, 102, 39, 171, 183, 233, 66, 194, 210, 8, 90, 115, 202, 198, 68, 59, 247, 136, 21, 62, 34, 166, 149, 125, 2, 212, 34, 115, 239, 145, 25, 222, 220, 251, 117, 200, 88, 153, 4, 20, 110, 231, 168, 237, 102, 7, 133, 51, 6, 252, 181, 67, 83, 9, 243, 79, 230, 204, 58, 25, 37, 34, 165, 145, 76, 56, 220, 68, 180, 28, 60, 57, 110, 148, 225, 37, 201, 201, 186, 93, 224, 191, 197, 48, 172, 144, 118, 103, 206, 71, 103, 245, 203, 38, 98, 67, 253, 80, 48, 241, 24, 231, 26, 198, 150, 104, 188, 33, 85, 73, 225, 23, 44, 218, 131, 130, 222, 148, 35, 181, 67, 134, 111, 17, 108, 57, 109, 17, 44, 54, 234, 175, 230, 8, 84, 2, 106, 19, 71, 72, 22, 234, 118, 91, 128, 235, 146, 29, 244, 202, 237, 109, 230, 223, 43, 43, 187, 38, 137, 179, 227, 187, 104, 153, 77, 132, 126, 162, 151, 245, 248, 148, 8, 231, 198, 191, 131, 96, 157, 29, 218, 183, 37, 69, 61, 57, 227, 83, 237, 142, 46, 42, 198, 142, 158, 216, 217, 53, 186, 250, 53, 123, 64, 11, 106, 130, 156, 194, 217, 209, 56, 208, 80, 182, 162, 138, 236, 151, 145, 17, 125, 140, 251, 244, 172, 223, 226, 175, 26, 116, 251, 58, 194, 248, 228, 122, 80, 247, 17, 37, 168, 248, 153, 56, 148, 12, 114, 220, 234, 74, 80, 5, 208, 238, 164, 208, 108, 198, 92, 55, 46, 20, 111, 58, 32, 17, 11, 43, 217, 241, 119, 90, 87, 225, 136, 59, 127, 102, 158, 69, 0, 149, 226, 106, 89, 223, 134, 165, 34, 41, 16, 59, 218, 188, 24, 149, 145, 2, 121, 66, 128, 186, 252, 168, 233, 102, 248, 102, 126, 49, 90, 212, 102, 202, 116, 97, 147, 94, 39, 245, 233, 34, 77, 7, 113, 237, 89, 14, 246, 156, 61, 30, 173, 163, 83, 164, 13, 11, 190, 52, 11, 165, 35, 70, 217, 19, 151, 112, 64, 190, 214, 142, 132, 48, 20, 51, 15, 242, 35, 27, 175, 106, 222, 165, 153, 231, 119, 71, 155, 75, 75, 124, 106, 225, 142, 247, 7, 22, 245, 213, 102, 86, 62, 162, 223, 102, 172, 215, 22, 202, 185, 35, 163, 84, 154, 188, 46, 203, 230, 172, 136, 130, 95, 86, 70, 128, 232, 26, 105, 20, 108, 34, 129, 36, 74, 39, 184, 87, 110, 204, 209, 205, 193, 229, 25, 142, 160, 255, 34, 217, 95, 228, 140, 121, 126, 22, 121, 117, 115, 233, 35, 77, 206, 92, 119, 242, 229, 204, 34, 155, 38, 212, 50, 48, 249, 191, 145, 50, 191, 150, 190, 93, 91, 29, 163, 122, 85, 254, 93, 14, 213, 129, 24, 158, 133, 185, 177, 110, 220, 109, 33, 45, 243, 25, 224, 131, 27, 110, 64, 151, 128, 18, 7, 103, 45, 245, 182, 171, 225, 236, 21, 98, 255, 137, 44, 40, 68, 124, 12, 21, 160, 230, 85, 83, 20, 2, 161, 219, 132, 150, 31, 140, 244, 103, 76, 144, 182, 70, 76, 191, 16, 242, 254, 9, 39, 46, 4, 156, 243, 6, 40, 119, 9, 202, 174, 55, 159, 225, 132, 78, 160, 53, 189, 77, 170, 185, 96, 169, 247, 122, 159, 195, 226, 255, 191, 142, 25, 168, 162, 79, 139, 164, 167, 11, 64, 133, 55, 227, 180, 192, 11, 166, 255, 65, 141, 110, 38, 94, 1, 43, 177, 25, 253, 199, 175, 247, 5, 35, 109, 177, 137, 162, 10, 177, 199, 202, 112, 131, 103, 248, 221, 232, 14, 189, 148, 150, 61, 107, 133, 4, 151, 175, 120, 56, 136, 135, 201, 94, 141, 42, 103, 150, 67, 72, 200, 81, 61, 7, 104, 248, 65, 99, 179, 57, 176, 246, 171, 165, 199, 2, 255, 244, 156, 85, 80, 59, 74, 109, 136, 118, 172, 254, 165, 231, 115, 245, 57, 227, 144, 3, 181, 247, 89, 6, 190, 10, 244, 123, 116, 144, 6, 33, 254, 139, 30, 115, 118, 72, 225, 150, 36, 203, 49, 219, 25, 254, 246, 59, 78, 71, 222, 157, 170, 63, 175, 170, 129, 236, 70, 155, 242, 111, 40, 134, 139, 148, 198, 49, 132, 69, 132, 145, 135, 119, 77, 109, 198, 208, 36, 226, 180, 36, 232, 208, 8, 94, 21, 155, 179, 174, 42, 133, 208, 251, 147, 26, 7, 220, 148, 61, 141, 228, 180, 232, 56, 28, 169, 35, 158, 79, 192, 26, 17, 90, 146, 187, 253, 120, 134, 86, 67, 144, 108, 70, 54, 48, 138, 13, 50, 179, 1, 146, 123, 235, 240, 248, 109, 173, 143, 34, 182, 81, 46, 48, 242, 60, 182, 230, 78, 169, 98, 38, 11, 53, 26, 81, 168, 66, 233, 95, 90, 161, 127, 186, 104, 159, 161, 182, 178, 237, 12, 230, 169, 179, 46, 214, 91, 154, 96, 212, 20, 212, 227, 161, 187, 181, 41, 201, 18, 149, 212, 216, 11, 152, 9, 217, 134, 223, 229, 195, 83, 4, 141, 188, 220, 177, 112, 161, 64, 127, 223, 173, 204, 116, 96, 26, 182, 204, 128, 146, 241, 212, 9, 234, 101, 42, 233, 85, 220, 185, 126, 25, 175, 72, 165, 239, 241, 124, 74, 10, 152, 218, 1, 36, 161, 251, 98, 148, 42, 38, 77, 103, 235, 150, 200, 182, 207, 150, 18, 207, 208, 199, 177, 172, 204, 9, 93, 93, 102, 20, 193, 235, 247, 8, 76, 84, 177, 199, 146, 136, 109, 238, 140, 180, 216, 71, 65, 76, 63, 80, 193, 162, 187, 92, 36, 37, 210, 177, 212, 228, 21, 204, 204, 239, 225, 64, 200, 118, 175, 166, 184, 43, 247, 177, 219, 99, 88, 69, 220, 143, 126, 144, 34, 245, 237, 46, 202, 146, 211, 146, 160, 232, 171, 18, 175, 150, 236, 169, 42, 71, 154, 151, 101, 148, 101, 102, 224, 197, 45, 223, 243, 97, 205, 29, 107, 72, 0, 94, 141, 145, 241, 30, 166, 97, 61, 222, 49, 2, 105, 129, 43, 43, 48, 46, 158, 176, 208, 71, 14, 83, 234, 3, 87, 193, 148, 98, 61, 206, 100, 3, 32, 147, 85, 47, 209, 201, 251, 150, 199, 57, 97, 220, 18, 135, 190, 30, 203, 234, 187, 135, 48, 61, 53, 20, 172, 63, 100, 138, 207, 205, 141, 233, 185, 191, 191, 199, 112, 208, 224, 111, 138, 91, 201, 199, 90, 206, 139, 48, 161, 245, 160, 253, 75, 36, 12, 243, 182, 252, 254, 185, 223, 187, 254, 33, 99, 185, 111, 233, 101, 15, 140, 62, 172, 45, 38, 204, 200, 104, 111, 50, 64, 145, 51, 27, 203, 240, 122, 17, 70, 120, 1, 192, 161, 246, 120, 221, 56, 102, 226, 243, 151, 47, 252, 221, 122, 216, 38, 84, 189, 181, 163, 148, 228, 8, 94, 101, 198, 88, 98, 83, 203, 70, 154, 54, 209, 246, 67, 249, 57, 16, 201, 51, 124, 26, 49, 145, 66, 223, 248, 72, 175, 165, 134, 74, 92, 72, 48, 98, 114, 35, 85, 105, 148, 156, 103, 97, 169, 153, 235, 239, 191, 231, 225, 126, 36, 98, 56, 168, 134, 215, 58, 160, 149, 35, 130, 124, 240, 92, 107, 167, 144, 47, 129, 4, 82, 170, 34, 226, 171, 7, 123, 34, 128, 236, 162, 117, 108, 83, 100, 180, 226, 40, 251, 227, 173, 171, 196, 81, 82, 242, 148, 193, 10, 183, 51, 142, 82, 76, 112, 80, 206, 9, 237, 227, 10, 115, 182, 76, 89, 224, 184, 94, 13, 210, 219, 136, 116, 221, 59, 195, 76, 144, 46, 149, 59, 55, 243, 129, 199, 46, 180, 164, 21, 0, 48, 56, 201, 67, 30, 190, 145, 161, 130, 124, 248, 29, 103, 111, 14, 113, 16, 54, 246, 60, 1, 202, 143, 67, 253, 183, 141, 247, 82, 84, 33, 155, 177, 95, 64, 132, 187, 210, 167, 26, 211, 170, 238, 182, 239, 64, 191, 31, 71, 61, 186, 145, 168, 133, 42, 19, 20, 242, 220, 132, 159, 235, 202, 151, 230, 219, 62, 57, 20, 230, 153, 229, 128, 20, 32, 228, 11, 179, 50, 90, 158, 105, 167, 76, 140, 183, 31, 159, 183, 44, 130, 32, 146, 240, 13, 57, 151, 65, 60, 180, 161, 96, 103, 8, 68, 204, 156, 202, 11, 68, 182, 177, 53, 73, 204, 167, 175, 193, 20, 1, 170, 111, 249, 29, 142, 198, 30, 147, 25, 241, 3, 22, 147, 72, 123, 245, 109, 181, 67, 162, 164, 154, 71, 28, 48, 11, 204, 2, 143, 150, 6, 72, 9, 108, 187, 16, 209, 184, 1, 183, 131, 219, 118, 1, 61, 12, 60, 187, 47, 30, 1, 154, 234, 127, 23, 194, 199, 194, 204, 226, 124, 222, 166, 249, 88, 54, 191, 118, 221, 27, 238, 61, 134, 23, 175, 218, 197, 42, 210, 43, 179, 250, 0, 245, 102, 222, 196, 95, 250, 62, 152, 49, 131, 181, 121, 77, 23, 50, 244, 106, 205, 227, 163, 221, 250, 232, 106, 230, 62, 134, 235, 121, 225, 253, 210, 123, 204, 57, 218, 6, 228, 128, 9, 13, 245, 98, 218, 158, 229, 137, 238, 231, 13, 197, 185, 214, 136, 249, 173, 108, 236, 122, 0, 70, 154, 216, 73, 195, 64, 195, 75, 204, 33, 188, 49, 244, 238, 203, 100, 137, 9, 102, 65, 109, 56, 211, 159, 204, 80, 109, 237, 106, 203, 41, 114, 50, 80, 65, 189, 52, 143, 97, 126, 61, 211, 99, 207, 82, 150, 91, 10, 35, 248, 10, 26, 191, 154, 177, 166, 156, 25, 127, 135, 193, 233, 15, 173, 208, 73, 11, 150, 25, 26, 29, 73, 141, 142, 147, 165, 109, 30, 58, 226, 226, 114, 128, 146, 59, 168, 6, 166, 94, 173, 53, 182, 178, 217, 238, 237, 0, 181, 161, 226, 15, 6, 225, 231, 180, 45, 62, 41, 186, 174, 29, 58, 89, 93, 239, 235, 210, 184, 20, 172, 82, 28, 90, 189, 232, 136, 72, 199, 222, 73, 202, 226, 11, 54, 127, 180, 169, 171, 70, 241, 127, 54, 10, 188, 18, 52, 179, 174, 41, 240, 214, 15, 3, 202, 144, 47, 170, 8, 230, 76, 202, 220, 151, 200, 155, 194, 211, 78, 4, 79, 107, 135, 10, 114, 195, 97, 80, 158, 160, 39, 159, 191, 12, 203, 8, 144, 0, 65, 65, 199, 187, 239, 153, 142, 22, 189, 24, 29, 14, 64, 129, 12, 145, 145, 129, 49, 40, 240, 223, 128, 201, 26, 182, 61, 174, 225, 1, 223, 171, 59, 159, 201, 74, 11, 204, 192, 93, 175, 109, 89, 186, 74, 148, 19, 207, 215, 60, 94, 188, 184, 87, 31, 170, 170, 200, 43, 193, 231, 116, 166, 2, 84, 77, 136, 177, 196, 19, 231, 169, 37, 139, 234, 103, 196, 47, 201, 140, 19, 80, 217, 202, 212, 19, 113, 208, 250, 49, 155, 47, 62, 119, 86, 36, 206, 139, 99, 18, 225, 41, 11, 37, 231, 220, 3, 189, 248, 198, 187, 123, 46, 7, 26, 160, 122, 227, 11, 71, 169, 210, 82, 62, 40, 133, 2, 58, 88, 177, 245, 84, 74, 33, 70, 146, 209, 67, 170, 38, 248, 134, 133, 137, 111, 82, 189, 205, 119, 37, 138, 173, 97, 220, 110, 131, 39, 51, 179, 80, 238, 111, 41, 47, 100, 82, 102, 226, 191, 244, 106, 26, 21, 81, 203, 54, 182, 88, 112, 153, 195, 82, 29, 182, 181, 56, 102, 230, 255, 245, 37, 145, 199, 62, 84, 201, 155, 19, 186, 75, 218, 57, 210, 210, 91, 163, 20, 133, 8, 120, 150, 20, 142, 4, 125, 233, 42, 248, 116, 117, 94, 133, 70, 7, 63, 114, 197, 67, 39, 222, 122, 234, 104, 125, 232, 122, 143, 195, 45, 157, 114, 176, 82, 229, 54, 250, 135, 1, 52, 55, 18, 138, 116, 134, 31, 74, 64, 43, 209, 254, 34, 111, 92, 200, 10, 140, 49, 67, 18, 114, 100, 189, 107, 231, 23, 114, 227, 253, 127, 246, 129, 118, 169, 67, 221, 82, 93, 188, 59, 247, 160, 148, 206, 214, 192, 220, 177, 160, 222, 130, 229, 165, 39, 49, 3, 173, 100, 148, 119, 124, 211, 223, 138, 142, 149, 32, 217, 135, 173, 39, 68, 196, 97, 178, 50, 65, 11, 167, 48, 40, 212, 93, 228, 219, 210, 173, 188, 45, 108, 29, 214, 177, 249, 194, 57, 145, 85, 2, 236, 155, 96, 186, 7, 219, 63, 26, 70, 109, 2, 247, 216, 110, 31, 122, 88, 160, 38, 240, 95, 241, 76, 18, 197, 108, 241, 133, 56, 119, 156, 84, 109, 141, 45, 39, 98, 12, 117, 130, 239, 179, 253, 24, 145, 104, 239, 225, 168, 105, 146, 191, 20, 196, 9, 44, 136, 238, 81, 135, 251, 183, 129, 43, 76, 105, 222, 136, 12, 183, 190, 46, 194, 166, 177, 230, 218, 209, 62, 79, 179, 85, 208, 187, 169, 227, 98, 251, 72, 179, 94, 109, 10, 209, 215, 78, 137, 1, 223, 211, 125, 57, 59, 2, 255, 121, 5, 101, 138, 223, 200, 141, 75, 17, 105, 48, 168, 138, 118, 26, 202, 244, 164, 246, 191, 83, 26, 187, 5, 250, 160, 180, 26, 133, 62, 89, 253, 243, 175, 121, 219, 19, 203, 32, 149, 134, 7, 222, 183, 3, 111, 219, 197, 99, 154, 127, 227, 197, 13, 137, 9, 176, 58, 91, 131, 55, 16, 102, 241, 177, 17, 253, 213, 21, 18, 136, 131, 52, 241, 186, 219, 201, 215, 42, 218, 127, 110, 109, 197, 230, 4, 32, 35, 136, 65, 239, 13, 186, 11, 193, 127, 98, 211, 233, 145, 159, 194, 26, 188, 122, 211, 138, 234, 174, 253, 62, 113, 219, 160, 127, 45, 121, 238, 131, 105, 205, 180, 51, 15, 131, 208, 167, 135, 118, 90, 156, 228, 206, 230, 236, 251, 129, 58, 169, 49, 140, 64, 224, 32, 108, 1, 3, 41, 5, 225, 33, 103, 205, 63, 0, 165, 54, 34, 51, 116, 125, 237, 157, 201, 250, 226, 218, 22, 34, 92, 168, 68, 166, 106, 75, 121, 66, 183, 214, 29, 39, 19, 226, 125, 46, 91, 48, 157, 10, 26, 205, 55, 139, 76, 129, 196, 33, 49, 32, 201, 219, 177, 237, 144, 73, 125, 228, 101, 245, 103, 17, 125, 19, 93, 161, 178, 243, 110, 40, 136, 2, 94, 244, 220, 80, 8, 14, 217, 238, 20, 126, 147, 142, 106, 68, 92, 207, 77, 229, 198, 225, 241, 195, 152, 46, 50, 76, 24, 175, 74, 28, 55, 44, 110, 108, 142, 207, 159, 207, 229, 8, 245, 66, 165, 28, 144, 50, 32, 225, 177, 229, 96, 50, 217, 83, 215, 17, 190, 176, 51, 128, 39, 122, 135, 71, 89, 17, 85, 80, 240, 165, 6, 131, 250, 6, 133, 153, 0, 14, 114, 44, 43, 20, 170, 254, 77, 226, 90, 23, 34, 219, 244, 84, 10, 127, 174, 211, 58, 225, 185, 217, 113, 187, 28, 82, 137, 172, 54, 229, 205, 65, 54, 255, 107, 230, 210, 163, 132, 139, 188, 177, 139, 72, 163, 88, 169, 144, 95, 234, 211, 49, 45, 154, 67, 190, 161, 120, 63, 212, 81, 252, 59, 210, 166, 195, 139, 232, 58, 141, 36, 153, 132, 109, 51, 60, 195, 210, 175, 25, 183, 205, 35, 92, 85, 40, 47, 6, 9, 74, 242, 27, 192, 148, 129, 130, 238, 140, 48, 158, 138, 138, 99, 20, 228, 114, 119, 149, 129, 85, 157, 54, 103, 187, 238, 213, 119, 147, 46, 205, 101, 24, 154, 28, 11, 76, 237, 44, 87, 118, 8, 84, 57, 28, 213, 237, 95, 243, 150, 200, 68, 41, 168, 116, 38, 184, 152, 140, 83, 191, 155, 202, 39, 220, 183, 179, 229, 227, 111, 94, 22, 232, 113, 113, 21, 213, 109, 129, 20, 111, 83, 163, 210, 195, 15, 75, 170, 197, 28, 128, 201, 196, 84, 60, 128, 253, 132, 22, 211, 100, 190, 129, 137, 174, 176, 221, 28, 126, 166, 48, 152, 114, 233, 102, 110, 89, 118, 59, 43, 31, 195, 56, 131, 187, 86, 113, 127, 219, 125, 251, 25, 162, 108, 190, 254, 20, 160, 18, 52, 81, 84, 252, 43, 69, 101, 115, 255, 197, 81, 100, 42, 242, 158, 5, 48, 4, 19, 241, 1, 37, 4, 211, 28, 9, 232, 200, 149, 64, 28, 218, 77, 134, 111, 201, 139, 171, 54, 190, 64, 246, 89, 26, 246, 140, 193, 133, 177, 77, 85, 125, 200, 119, 47, 38, 144, 38, 214, 98, 150, 90, 204, 205, 103, 114, 6, 213, 118, 36, 145, 109, 191, 139, 154, 179, 12, 210, 230, 21, 138, 204, 252, 192, 137, 97, 144, 250, 248, 193, 75, 156, 56, 114, 218, 127, 118, 36, 110, 103, 85, 191, 229, 197, 41, 250, 28, 220, 177, 227, 156, 50, 100, 219, 46, 126, 80, 107, 17, 157, 0, 140, 173, 46, 147, 36, 251, 155, 255, 123, 51, 136, 27, 120, 242, 39, 117, 241, 26, 161, 67, 213, 3, 101, 192, 129, 137, 165, 160, 124, 94, 214, 4, 215, 112, 187, 75, 189, 158, 88, 116, 170, 135, 129, 164, 191, 65, 71, 238, 201, 87, 207, 148, 246, 134, 175, 203, 122, 51, 193, 35, 50, 69, 203, 214, 44, 145, 121, 80, 25, 14, 249, 41, 246, 89, 245, 101, 46, 98, 93, 106, 193, 240, 42, 164, 112, 233, 198, 2, 162, 138, 207, 16, 86, 191, 83, 73, 32, 229, 77, 181, 69, 100, 158, 207, 26, 9, 190, 139, 223, 195, 17, 115, 22, 54, 150, 220, 28, 141, 110, 123, 80, 202, 130, 108, 86, 205, 60, 48, 75, 206, 38, 113, 44, 237, 245, 69, 21, 255, 85, 162, 137, 197, 107, 196, 103, 164, 68, 248, 46, 9, 178, 183, 231, 147, 97, 84, 56, 245, 75, 63, 24, 153, 169, 81, 103, 167, 74, 239, 19, 25, 151, 7, 17, 141, 185, 180, 251, 132, 211, 154, 156, 37, 3, 61, 109, 155, 12, 37, 132, 156, 195, 97, 150, 139, 175, 189, 199, 106, 74, 38, 212, 79, 64, 235, 192, 78, 135, 213, 217, 176, 172, 73, 182, 61, 86, 153, 227, 190, 174, 212, 239, 76, 71, 109, 177, 141, 193, 156, 161, 73, 182, 150, 29, 223, 86, 59, 170, 241, 209, 21, 188, 84, 23, 237, 233, 180, 92, 69, 72, 23, 253, 175, 180, 141, 120, 1, 148, 213, 168, 148, 62, 238, 243, 60, 113, 110, 244, 102, 62, 35, 122, 136, 179, 207, 240, 188, 67, 137, 28, 91, 74, 201, 240, 202, 178, 95, 224, 230, 232, 221, 14, 209, 174, 221, 111, 119, 122, 253, 237, 131, 104, 78, 200, 147, 247, 161, 197, 96, 16, 26, 249, 0, 125, 205, 247, 252, 159, 174, 189, 129, 176, 66, 212, 187, 13, 17, 174, 207, 237, 207, 28, 164, 168, 234, 52, 200, 253, 153, 237, 117, 111, 145, 66, 50, 245, 59, 90, 73, 234, 18, 188, 81, 212, 190, 26, 31, 107, 98, 37, 39, 98, 244, 191, 191, 178, 199, 16, 214, 85, 15, 5, 211, 23, 229, 144, 98, 90, 209, 59, 198, 215, 54, 195, 39, 124, 177, 48, 60, 123, 143, 37, 190, 176, 105, 13, 19, 97, 65, 31, 0, 156, 27, 234, 36, 239, 68, 223, 209, 211, 244, 244, 69, 220, 190, 117, 107, 48, 88, 22, 153, 255, 70, 16, 13, 74, 128, 216, 241, 230, 43, 166, 53, 69, 48, 105, 11, 46, 192, 108, 184, 117, 49, 138, 5, 96, 150, 51, 105, 26, 167, 29, 189, 95, 119, 52, 247, 0, 246, 227, 168, 236, 226, 115, 170, 196, 114, 62, 50, 249, 224, 247, 45, 238, 98, 163, 192, 230, 244, 222, 174, 188, 252, 89, 15, 83, 126, 225, 134, 227, 89, 253, 210, 104, 171, 153, 92, 102, 247, 22, 209, 236, 203, 7, 238, 65, 19, 8, 189, 186, 28, 120, 191, 108, 245, 119, 163, 189, 85, 175, 38, 146, 162, 60, 144, 0, 207, 153, 96, 129, 196, 207, 209, 186, 159, 98, 183, 139, 20, 73, 79, 167, 108, 60, 200, 153, 172, 106, 105, 54, 94, 49, 108, 88, 195, 191, 72, 71, 206, 91, 26, 11, 181, 11, 240, 17, 103, 133, 27, 16, 51, 69, 57, 193, 65, 239, 166, 164, 21, 3, 182, 236, 9, 61, 95, 34, 169, 112, 131, 161, 115, 230, 235, 251, 163, 146, 245, 33, 189, 3, 25, 21, 177, 115, 194, 230, 68, 185, 48, 14, 57, 206, 231, 7, 73, 123, 109, 123, 2, 116, 167, 189, 56, 53, 179, 89, 58, 16, 107, 244, 242, 186, 212, 181, 191, 225, 30, 0, 237, 51, 47, 199, 243, 69, 70, 175, 185, 242, 226, 7, 74, 241, 206, 166, 135, 47, 235, 88, 51, 194, 83, 178, 210, 94, 93, 133, 149, 166, 204, 78, 57, 99, 102, 164, 178, 123, 190, 129, 133, 225, 175, 176, 98, 159, 113, 225, 122, 209, 167, 185, 180, 140, 16, 175, 104, 214, 177, 201, 131, 10, 206, 117, 115, 183, 24, 25, 145, 228, 43, 81, 45, 123, 162, 111, 251, 6, 102, 198, 175, 156, 187, 122, 201, 49, 9, 236, 11, 44, 87, 83, 236, 215, 131, 104, 177, 211, 58, 87, 255, 228, 87, 3, 161, 227, 85, 10, 226, 12, 185, 121, 134, 123, 246, 248, 130, 13, 184, 68, 182, 75, 61, 30, 43, 164, 168, 191, 232, 69, 196, 221, 203, 238, 0, 250, 43, 167, 226, 215, 167, 239, 126, 144, 128, 127, 89, 42, 153, 253, 81, 225, 237, 4, 164, 254, 61, 39, 150, 233, 180, 237, 239, 112, 35, 96, 94, 67, 44, 126, 177, 251, 165, 31, 93, 48, 210, 106, 71, 22, 17, 56, 7, 60, 1, 12, 94, 16, 19, 149, 85, 133, 234, 20, 248, 218, 144, 17, 180, 42, 99, 137, 9, 19, 28, 144, 77, 34, 57, 128, 223, 168, 205, 149, 115, 145, 175, 97, 177, 193, 203, 103, 15, 222, 211, 184, 255, 119, 20, 10, 45, 179, 95, 141, 198, 68, 147, 79, 134, 87, 108, 162, 165, 5, 61, 3, 210, 79, 133, 68, 79, 81, 85, 37, 253, 184, 105, 28, 114, 153, 13, 180, 37, 66, 217, 19, 12, 86, 80, 141, 111, 126, 202, 168, 32, 209, 241, 159, 187, 194, 19, 250, 43, 70, 1, 243, 231, 42, 37, 96, 246, 178, 181, 156, 130, 64, 194, 220, 60, 84, 56, 122, 126, 165, 61, 209, 245, 101, 124, 62, 146, 24, 164, 231, 43, 120, 148, 165, 31, 73, 97, 82, 67, 228, 34, 46, 129, 167, 29, 37, 140, 240, 191, 236, 240, 160, 163, 112, 215, 146, 47, 177, 101, 117, 228, 25, 37, 185, 56, 222, 194, 100, 100, 57, 68, 147, 192, 139, 99, 162, 215, 107, 78, 117, 247, 141, 63, 168, 71, 58, 189, 40, 200, 243, 132, 96, 169, 208, 117, 6, 62, 173, 52, 86, 202, 223, 140, 24, 45, 111, 198, 165, 139, 152, 10, 87, 126, 28, 114, 185, 254, 193, 100, 21, 144, 142, 8, 233, 193, 87, 110, 79, 60, 170, 160, 92, 212, 10, 163, 135, 34, 247, 128, 232, 212, 235, 142, 46, 14, 247, 15, 86, 69, 88, 7, 28, 88, 188, 200, 216, 209, 227, 65, 234, 39, 241, 83, 235, 154, 212, 118, 223, 13, 112, 217, 18, 240, 179, 97, 206, 249, 0, 228, 36, 30, 124, 211, 155, 228, 165, 229, 240, 93, 2, 91, 82, 223, 216, 18, 189, 236, 217, 103, 148, 182, 101, 49, 58, 190, 243, 186, 133, 198, 141, 90, 0, 62, 231, 227, 145, 96, 3, 248, 232, 120, 142, 33, 252, 94, 60, 86, 137, 214, 39, 122, 185, 185, 160, 41, 123, 147, 121, 22, 141, 227, 142, 143, 40, 177, 16, 218, 52, 185, 201, 205, 142, 102, 87, 101, 119, 45, 68, 22, 131, 160, 116, 87, 37, 96, 56, 58, 241, 159, 137, 43, 209, 22, 212, 2, 162, 117, 154, 78, 228, 76, 169, 53, 86, 235, 164, 244, 163, 44, 13, 165, 236, 88, 69, 229, 152, 187, 29, 245, 155, 166, 106, 42, 158, 21, 213, 9, 158, 86, 252, 174, 12, 77, 176, 158, 4, 28, 183, 210, 61, 232, 141, 233, 71, 3, 18, 35, 217, 171, 81, 240, 66, 202, 35, 25, 133, 192, 52, 215, 232, 11, 245, 45, 228, 205, 219, 109, 138, 103, 127, 205, 174, 88, 72, 85, 239, 53, 182, 192, 47, 92, 195, 235, 211, 174, 243, 56, 55, 71, 12, 164, 16, 178, 196, 128, 171, 147, 108, 10, 112, 172, 9, 223, 52, 199, 120, 133, 51, 174, 242, 137, 161, 243, 234, 213, 128, 80, 140, 121, 224, 146, 217, 70, 20, 203, 90, 13, 212, 219, 139, 167, 71, 3, 182, 140, 209, 145, 224, 215, 63, 115, 169, 1, 162, 225, 108, 134, 225, 197, 245, 153, 116, 153, 135, 72, 208, 235, 154, 230, 68, 212, 88, 111, 181, 43, 167, 91, 170, 203, 222, 195, 9, 184, 246, 82, 174, 247, 84, 196, 6, 46, 120, 238, 223, 148, 133, 167, 80, 7, 102, 233, 22, 133, 107, 221, 149, 195, 208, 94, 188, 185, 62, 199, 71, 41, 250, 57, 178, 203, 73, 221, 183, 203, 119, 180, 34, 207, 60, 141, 142, 28, 107, 114, 195, 161, 8, 156, 69, 123, 97, 205, 97, 95, 196, 196, 201, 249, 65, 153, 30, 84, 93, 164, 206, 83, 62, 56, 14, 167, 255, 12, 73, 123, 141, 72, 38, 186, 71, 205, 97, 240, 91, 255, 79, 119, 115, 248, 145, 163, 40, 58, 108, 185, 187, 206, 143, 46, 3, 255, 16, 4, 58, 142, 77, 212, 134, 52, 234, 142, 84, 191, 129, 226, 210, 101, 116, 155, 57, 1, 131, 208, 206, 64, 11, 149, 16, 174, 194, 107, 187, 61, 184, 206, 29, 222, 189, 120, 237, 56, 217, 207, 55, 116, 246, 122, 241, 54, 235, 214, 118, 72, 195, 157, 13, 77, 231, 92, 29, 41, 105, 93, 223, 170, 165, 51, 17, 92, 39, 179, 65, 248, 20, 136, 93, 16, 61, 118, 158, 157, 49, 131, 41, 142, 252, 87, 216, 66, 109, 186, 40, 137, 235, 248, 120, 213, 224, 20, 96, 236, 150, 29, 37, 52, 140, 168, 156, 197, 56, 227, 168, 222, 128, 43, 149, 153, 26, 95, 153, 16, 182, 23, 103, 156, 93, 30, 75, 145, 26, 116, 46, 115, 63, 213, 124, 193, 42, 175, 180, 160, 24, 220, 189, 70, 23, 141, 250, 104, 84, 41, 39, 167, 242, 63, 70, 205, 115, 64, 238, 185, 229, 193, 26, 178, 203, 213, 229, 145, 83, 40, 234, 75, 217, 115, 84, 110, 228, 114, 150, 251, 116, 69, 196, 252, 99, 18, 247, 156, 22, 104, 149, 57, 133, 255, 190, 251, 59, 32, 108, 12, 32, 211, 97, 250, 119, 90, 13, 80, 56, 164, 44, 140, 49, 239, 97, 59, 137, 66, 238, 192, 227, 173, 153, 216, 221, 172, 150, 9, 221, 30, 54, 8, 118, 96, 131, 244, 163, 56, 233, 74, 157, 10, 64, 47, 241, 182, 28, 123, 108, 203, 240, 186, 121, 82, 200, 45, 227, 62, 161, 130, 147, 3, 211, 8, 86, 2, 141, 29, 254, 136, 39, 205, 77, 51, 74, 89, 183, 137, 237, 215, 138, 157, 105, 184, 248, 146, 242, 50, 98, 46, 8, 89, 40, 62, 255, 158, 42, 253, 146, 164, 126, 98, 23, 238, 162, 163, 76, 148, 239, 98, 40, 61, 48, 164, 207, 19, 39, 238, 76, 199, 11, 114, 66, 80, 198, 110, 67, 10, 246, 159, 46, 61, 111, 185, 38, 178, 86, 153, 196, 117, 51, 96, 24, 247, 121, 71, 6, 220, 98, 226, 225, 69, 217, 166, 175, 98, 62, 50, 254, 248, 193, 177, 30, 183, 238, 95, 226, 82, 214, 128, 54, 147, 122, 120, 99, 9, 219, 113, 30, 104, 133, 12, 237, 135, 99, 31, 121, 91, 106, 0, 161, 97, 167, 238, 86, 117, 235, 87, 175, 27, 18, 174, 36, 220, 167, 135, 198, 157, 82, 63, 108, 147, 149, 197, 97, 89, 76, 26, 103, 16, 35, 188, 90, 145, 254, 230, 56, 233, 230, 74, 96, 238, 255, 26, 148, 20, 211, 50, 48, 22, 190, 79, 55, 202, 51, 220, 12, 3, 222, 91, 1, 86, 97, 216, 90, 3, 209, 88, 40, 68, 209, 71, 233, 239, 54, 21, 171, 11, 95, 2, 180, 95, 74, 13, 133, 134, 32, 227, 39, 247, 113, 46, 247, 177, 89, 46, 3, 166, 227, 23, 123, 155, 57, 44, 142, 37, 80, 3, 247, 30, 196, 127, 158, 21, 73, 177, 90, 241, 204, 1, 224, 84, 225, 193, 213, 249, 167, 238, 48, 108, 189, 248, 123, 96, 115, 232, 237, 103, 78, 167, 222, 77, 96, 10, 56, 31, 214, 159, 236, 51, 134, 53, 185, 175, 139, 177, 40, 145, 15, 196, 38, 205, 222, 242, 198, 23, 113, 62, 116, 102, 71, 166, 92, 173, 50, 64, 167, 58, 255, 39, 5, 146, 91, 58, 15, 195, 244, 51, 251, 4, 176, 10, 222, 6, 130, 1, 255, 46, 130, 4, 224, 200, 134, 227, 175, 73, 152, 80, 115, 138, 139, 152, 255, 13, 16, 34, 20, 236, 123, 180, 197, 221, 133, 52, 132, 25, 80, 251, 127, 132, 199, 146, 66, 148, 47, 24, 67, 62, 165, 186, 212, 187, 224, 62, 1, 187, 118, 229, 214, 69, 222, 223, 67, 81, 238, 143, 4, 246, 60, 65, 67, 43, 90, 184, 110, 73, 231, 255, 93, 115, 131, 87, 15, 159, 130, 220, 3, 34, 51, 101, 154, 219, 3, 250, 81, 105, 192, 10, 32, 16, 200, 208, 196, 97, 72, 189, 135, 191, 42, 25, 52, 119, 69, 15, 230, 197, 143, 51, 243, 100, 130, 171, 176, 97, 192, 125, 168, 35, 127, 180, 223, 208, 51, 127, 69, 142, 93, 188, 205, 223, 172, 96, 178, 236, 23, 59, 207, 119, 109, 162, 253, 5, 226, 152, 239, 228, 109, 146, 168, 147, 56, 7, 166, 118, 131, 130, 207, 115, 24, 206, 215, 104, 244, 109, 230, 132, 79, 188, 89, 210, 91, 210, 28, 204, 96, 173, 104, 121, 112, 116, 89, 6, 191, 172, 67, 153, 98, 236, 118, 151, 17, 154, 133, 212, 237, 246, 32, 46, 60, 146, 93, 98, 34, 68, 189, 178, 59, 100, 130, 99, 225, 57, 198, 105, 11, 100, 201, 112, 203, 2, 137, 229, 109, 177, 45, 81, 45, 221, 228, 73, 82, 189, 156, 165, 236, 162, 164, 114, 57, 142, 226, 191, 188, 71, 190, 143, 134, 138, 173, 224, 70, 87, 183, 128, 173, 142, 68, 50, 2, 127, 128, 112, 221, 254, 113, 212, 39, 62, 135, 70, 32, 68, 97, 192, 81, 25, 84, 185, 96, 86, 48, 227, 250, 3, 56, 212, 7, 195, 34, 243, 88, 142, 29, 33, 218, 79, 152, 245, 121, 227, 215, 69, 72, 17, 139, 52, 206, 204, 234, 252, 36, 251, 17, 244, 245, 250, 5, 36, 199, 93, 126, 58, 101, 69, 250, 144, 231, 190, 2, 149, 191, 204, 225, 217, 135, 66, 255, 80, 135, 95, 112, 20, 206, 190, 183, 119, 251, 195, 196, 137, 75, 218, 59, 117, 55, 182, 148, 20, 215, 31, 228, 177, 192, 69, 176, 207, 121, 47, 35, 125, 129, 249, 79, 54, 224, 70, 240, 78, 251, 250, 149, 56, 254, 247, 207, 63, 146, 192, 175, 86, 20, 49, 226, 42, 113, 98, 142, 52, 198, 8, 15, 164, 58, 3, 26, 253, 66, 168, 185, 81, 230, 143, 53, 8, 38, 61, 245, 99, 242, 24, 56, 169, 33, 108, 240, 57, 34, 141, 62, 169, 212, 135, 102, 246, 183, 114, 111, 171, 200, 10, 42, 108, 121, 91, 2, 138, 44, 181, 54, 119, 9, 183, 97, 202, 137, 88, 200, 189, 162, 33, 43, 254, 22, 12, 36, 109, 225, 112, 120, 106, 213, 98, 122, 254, 95, 99, 85, 223, 212, 209, 50, 70, 131, 156, 218, 180, 106, 113, 184, 198, 230, 206, 0, 189, 26, 0, 119, 138, 60, 88, 203, 23, 145, 233, 8, 72, 17, 94, 227, 42, 247, 251, 135, 217, 142, 232, 240, 12, 19, 219, 22, 180, 107, 174, 178, 236, 40, 94, 121, 140, 140, 191, 59, 224, 117, 156, 167, 113, 131, 70, 216, 255, 45, 36, 16, 184, 138, 30, 149, 58, 240, 220, 227, 248, 12, 167, 131, 65, 237, 78, 227, 245, 62, 7, 179, 189, 138, 219, 115, 65, 243, 180, 245, 251, 24, 67, 119, 128, 48, 11, 81, 11, 226, 241, 13, 16, 72, 171, 125, 54, 15, 152, 162, 66, 239, 206, 12, 141, 232, 167, 251, 56, 180, 132, 109, 65, 254, 177, 138, 144, 241, 72, 248, 72, 70, 154, 85, 55, 236, 61, 234, 118, 67, 175, 34, 191, 91, 43, 123, 26, 125, 206, 255, 137, 247, 188, 111, 134, 77, 174, 108, 21, 91, 3, 213, 252, 156, 133, 11, 208, 40, 180, 252, 60, 192, 150, 175, 77, 179, 124, 234, 167, 114, 84, 115, 66, 65, 170, 108, 36, 31, 192, 13, 236, 169, 176, 62, 156, 89, 59, 89, 150, 155, 133, 5, 108, 175, 254, 164, 56, 45, 201, 173, 101, 129, 73, 64, 233, 208, 64, 15, 21, 203, 104, 204, 136, 143, 175, 107, 48, 43, 41, 55, 207, 196, 78, 66, 251, 178, 97, 145, 110, 195, 43, 213, 109, 141, 126, 120, 63, 129, 212, 175, 137, 175, 47, 230, 122, 49, 73, 153, 229, 126, 76, 26, 14, 162, 26, 62, 202, 236, 77, 247, 100, 212, 69, 228, 47, 213, 244, 225, 41, 231, 116, 93, 84, 183, 62, 51, 39, 121, 235, 158, 147, 224, 126, 254, 156, 132, 191, 155, 106, 252, 164, 221, 99, 132, 234, 153, 63, 23, 216, 176, 246, 219, 22, 50, 87, 240, 125, 204, 3, 210, 7, 225, 96, 1, 241, 234, 225, 216, 10, 185, 18, 180, 220, 245, 128, 11, 137, 118, 93, 131, 209, 203, 232, 156, 213, 243, 30, 92, 126, 60, 176, 210, 227, 73, 185, 20, 165, 49, 182, 20, 104, 223, 117, 116, 158, 211, 73, 198, 46, 69, 150, 182, 174, 219, 54, 39, 223, 187, 78, 63, 20, 209, 14, 37, 209, 107, 7, 147, 195, 195, 247, 231, 122, 108, 89, 219, 205, 230, 186, 1, 8, 196, 194, 244, 206, 176, 73, 55, 163, 213, 78, 255, 232, 81, 148, 106, 50, 141, 160, 134, 27, 223, 15, 87, 66, 100, 210, 215, 43, 113, 3, 218, 182, 232, 203, 192, 225, 139, 163, 213, 49, 55, 114, 105, 236, 215, 165, 251, 150, 171, 17, 124, 143, 158, 206, 109, 150, 43, 229, 236, 35, 170, 14, 81, 10, 27, 249, 220, 134, 128, 255, 71, 12, 35, 250, 41, 72, 143, 34, 203, 0, 21, 169, 42, 210, 31, 23, 86, 48, 125, 164, 248, 77, 236, 25, 248, 233, 72, 196, 64, 20, 104, 97, 249, 75, 168, 68, 148, 102, 55, 217, 242, 63, 219, 102, 45, 90, 112, 55, 96, 230, 155, 9, 64, 96, 17, 20, 64, 129, 183, 46, 41, 2, 171, 141, 78, 91, 190, 85, 26, 254, 111, 221, 180, 11, 152, 212, 65, 166, 176, 80, 107, 58, 89, 180, 207, 123, 20, 38, 30, 14, 83, 215, 75, 41, 129, 55, 104, 187, 157, 72, 142, 167, 246, 127, 38, 153, 58, 147, 190, 59, 95, 183, 188, 246, 34, 34, 12, 5, 219, 110, 9, 14, 125, 75, 140, 46, 255, 205, 77, 91, 253, 238, 106, 198, 55, 234, 247, 192, 139, 89, 237, 193, 164, 90, 127, 195, 129, 41, 73, 123, 248, 53, 4, 84, 17, 59, 25, 24, 118, 127, 206, 6, 194, 149, 224, 46, 166, 228, 194, 87, 252, 151, 111, 182, 135, 207, 144, 37, 239, 184, 31, 198, 220, 141, 205, 33, 51, 167, 126, 163, 154, 67, 16, 56, 197, 144, 40, 214, 62, 122, 20, 206, 94, 2, 210, 127, 230, 19, 47, 251, 50, 140, 209, 236, 235, 217, 3, 34, 49, 140, 166, 204, 195, 18, 135, 18, 36, 107, 115, 121, 21, 199, 147, 4, 213, 80, 55, 139, 169, 223, 204, 33, 180, 186, 202, 209, 222, 134, 78, 29, 32, 238, 162, 27, 90, 197, 42, 124, 99, 210, 218, 186, 227, 167, 213, 55, 91, 239, 115, 200, 24, 13, 23, 239, 83, 188, 205, 50, 253, 193, 188, 167, 214, 168, 220, 184, 152, 168, 247, 110, 86, 134, 45, 38, 66, 70, 37, 22, 67, 54, 191, 252, 120, 220, 123, 53, 201, 226, 72, 53, 216, 82, 201, 117, 236, 79, 172, 147, 185, 29, 108, 222, 161, 33, 218, 15, 60, 73, 120, 128, 236, 161, 163, 65, 34, 231, 138, 206, 187, 182, 239, 98, 130, 217, 150, 102, 225, 111, 160, 7, 192, 28, 97, 212, 83, 35, 9, 212, 52, 190, 58, 169, 95, 82, 162, 125, 189, 194, 203, 113, 170, 166, 202, 26, 158, 116, 244, 132, 2, 252, 15, 176, 79, 157, 60, 53, 130, 4, 224, 136, 36, 147, 41, 150, 122, 184, 183, 233, 236, 135, 190, 117, 97, 86, 128, 221, 84, 128, 222, 64, 226, 99, 98, 75, 90, 99, 7, 119, 186, 11, 144, 119, 168, 198, 36, 141, 208, 130, 205, 236, 17, 248, 186, 214, 108, 241, 26, 144, 167, 253, 255, 97, 205, 72, 147, 131, 236, 46, 82, 63, 203, 10, 6, 254, 70, 95, 229, 136, 187, 199, 39, 22, 239, 146, 180, 30, 102, 103, 66, 225, 211, 21, 241, 88, 141, 142, 66, 219, 53, 234, 205, 64, 89, 58, 179, 154, 201, 30, 79, 89, 32, 3, 223, 237, 62, 215, 187, 15, 11, 187, 240, 162, 159, 173, 142, 100, 28, 68, 159, 19, 30, 167, 211, 140, 122, 214, 253, 159, 162, 240, 97, 254, 41, 216, 132, 86, 150, 218, 169, 130, 21, 246, 121, 248, 230, 213, 220, 224, 253, 119, 75, 26, 60, 126, 97, 62, 31, 243, 5, 252, 172, 52, 43, 240, 149, 71, 49, 99, 233, 159, 75, 157, 194, 68, 212, 195, 187, 101, 195, 159, 207, 62, 227, 153, 137, 51, 97, 70, 220, 183, 186, 118];
    var okm := Hkdf(HKDF_WITH_SHA_256, Some(tv_salt[..]), tv_ikm[..], tv_info[..], 8129);
    expect tv_okm_desired[..] == okm, ""expectation violation""
  }
}

module {:extern ""TestClient""} TestClient {

  import opened Wrappers = Wrappers

  import opened UInt = StandardLibrary.UInt

  import CMMDefs = CMMDefs

  import DefaultCMMDef = DefaultCMMDef

  import RSA = RSAEncryption

  import RawRSAKeyringDef = RawRSAKeyringDef

  import Materials = Materials

  import Client = ESDKClient

  import Base64 = Base64

  import UTF8 = UTF8

  import TestUtils = TestUtils

  module Helpers {

    import opened StandardLibrary = StandardLibrary

    import opened UInt = StandardLibrary.UInt

    import CMMDefs = CMMDefs

    import DefaultCMMDef = DefaultCMMDef

    import EncryptionContext = EncryptionContext

    import UTF8 = UTF8

    import Client = ESDKClient

    import TestUtils = TestUtils
    method EncryptDecryptTest(cmm: CMMDefs.CMM)
      requires cmm.Valid()
      modifies cmm.Repr
      ensures cmm.Valid() && fresh(cmm.Repr - old(cmm.Repr))
      decreases cmm
    {
      var msg :- UTF8.Encode(""hello"");
      var encryptionContext := TestUtils.SmallEncryptionContext(TestUtils.SmallEncryptionContextVariation.A);
      var encryptRequest := Client.EncryptRequest.WithCMM(msg, cmm).SetEncryptionContext(encryptionContext);
      var e :- Client.Encrypt(encryptRequest);
      var decryptRequest := Client.DecryptRequest.WithCMM(e, cmm);
      var d :- Client.Decrypt(decryptRequest);
      expect msg == d, ""expectation violation""
    }
  }
  method {:test} HappyPath()
  {
    var namespace, name := TestUtils.NamespaceAndName(0);
    var ek, dk := RSA.GenerateKeyPair(2048, RSA.PKCS1);
    var keyring := new RawRSAKeyringDef.RawRSAKeyring(namespace, name, RSA.PaddingMode.PKCS1, Some(ek), Some(dk));
    var cmm := new DefaultCMMDef.DefaultCMM.OfKeyring(keyring);
    Helpers.EncryptDecryptTest(cmm);
  }

  method {:test} EncryptCMMKeyringOverload()
  {
    var kr :- TestUtils.MakeRSAKeyring();
    var cmm := new DefaultCMMDef.DefaultCMM.OfKeyring(kr);
    var badRequest := Client.EncryptRequest.WithCMM([0], cmm).(keyring := kr);
    var result := Client.Encrypt(badRequest);
    expect result.Failure?, ""expectation violation""
    expect result.error == ""EncryptRequest.keyring OR EncryptRequest.cmm must be set (not both)."", ""expectation violation""
  }

  method {:test} EncryptInvalidAlgID()
  {
    var kr :- TestUtils.MakeRSAKeyring();
    var badRequest := Client.EncryptRequest.WithKeyring([0], kr).SetAlgorithmSuiteID(0);
    var result := Client.Encrypt(badRequest);
    expect result.Failure?, ""expectation violation""
    expect result.error == ""Invalid algorithmSuiteID."", ""expectation violation""
  }

  method {:test} EncryptFrameLengthZero()
  {
    var kr :- TestUtils.MakeRSAKeyring();
    var badRequest := Client.EncryptRequest.WithKeyring([0], kr).SetFrameLength(0);
    var result := Client.Encrypt(badRequest);
    expect result.Failure?, ""expectation violation""
    expect result.error == ""Request frameLength must be > 0"", ""expectation violation""
  }

  method {:test} DecryptCMMKeyringOverload()
  {
    var kr :- TestUtils.MakeRSAKeyring();
    var cmm := new DefaultCMMDef.DefaultCMM.OfKeyring(kr);
    var badRequest := Client.DecryptRequest.WithCMM([0], cmm).(keyring := kr);
    var result := Client.Decrypt(badRequest);
    expect result.Failure?, ""expectation violation""
    expect result.error == ""DecryptRequest.keyring OR DecryptRequest.cmm must be set (not both)."", ""expectation violation""
  }
}

module TestCachingCMM {

  import opened Wrappers = Wrappers

  import opened UInt = StandardLibrary.UInt

  import CMMDefs = CMMDefs

  import CachingCMMDef = CachingCMMDef

  import Materials = Materials

  import AlgorithmSuite = AlgorithmSuite

  import EncryptionContext = EncryptionContext

  import TestUtils = TestUtils

  module Helpers {

    import opened StandardLibrary = StandardLibrary

    import opened Wrappers = Wrappers

    import opened UInt = StandardLibrary.UInt

    import CMMDefs = CMMDefs

    import CachingCMMDef = CachingCMMDef

    import Materials = Materials

    import EncryptionContext = EncryptionContext

    import AlgorithmSuite = AlgorithmSuite

    import UTF8 = UTF8

    import TestUtils = TestUtils
    class TestCMM extends CMMDefs.CMM {
      var eCalls: nat
      var dCalls: nat

      predicate Valid()
        reads this, Repr
        ensures Valid() ==> this in Repr
        decreases Repr + {this}
      {
        this in Repr
      }

      constructor ()
        ensures Valid() && fresh(Repr)
        ensures eCalls == dCalls == 0
      {
        eCalls, dCalls := 0, 0;
        Repr := {this};
      }

      method GetEncryptionMaterials(materialsRequest: Materials.EncryptionMaterialsRequest) returns (res: Result<Materials.ValidEncryptionMaterials, string>)
        requires Valid()
        modifies Repr
        ensures Valid() && fresh(Repr - old(Repr))
        ensures res.Success? ==> res.value.plaintextDataKey.Some? && res.value.Serializable()
        ensures res.Success? ==> CMMDefs.EncryptionMaterialsSignature(res.value)
        decreases materialsRequest
      {
        reveal CMMDefs.EncryptionMaterialsSignatureOpaque();
        TestUtils.ExpectSerializableEncryptionContext(materialsRequest.encryptionContext);
        var algSuiteID := if materialsRequest.algorithmSuiteID == None then AlgorithmSuite.AES_256_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384 else materialsRequest.algorithmSuiteID.value;
        var edk: Materials.ValidEncryptedDataKey := Materials.EncryptedDataKey([], [], []);
        var em := Materials.EncryptionMaterials(materialsRequest.encryptionContext, algSuiteID, Some(seq(algSuiteID.KDFInputKeyLength(), (x: int) => 70 + (x % 20) as uint8)), [edk], if algSuiteID.SignatureType() == None then None else Some([52, 53, 54]));
        assert em.Valid();
        eCalls := eCalls + 1;
        return Success(em);
      }

      method DecryptMaterials(materialsRequest: Materials.ValidDecryptionMaterialsRequest) returns (res: Result<Materials.ValidDecryptionMaterials, string>)
        requires Valid()
        modifies Repr
        ensures Valid() && fresh(Repr - old(Repr))
        ensures res.Success? ==> res.value.plaintextDataKey.Some?
        decreases materialsRequest
      {
        var dm := Materials.DecryptionMaterials(materialsRequest.algorithmSuiteID, materialsRequest.encryptionContext, Some(seq(materialsRequest.algorithmSuiteID.KDFInputKeyLength(), (x: int) => 70 + (x % 20) as uint8)), Some([49, 48, 47]));
        assert dm.Valid();
        dCalls := dCalls + 1;
        return Success(dm);
      }
    }

    method CallGetEM(ccmm: CachingCMMDef.CachingCMM, tcmm: TestCMM, request: Materials.EncryptionMaterialsRequest, expectCacheHit: bool)
      requires ccmm.Valid() && ccmm.cmm == tcmm
      requires EncryptionContext.Serializable(request.encryptionContext)
      requires request.encryptionContext.Keys !! Materials.RESERVED_KEY_VALUES
      modifies ccmm.Repr
      ensures ccmm.Valid() && fresh(ccmm.Repr - old(ccmm.Repr))
      decreases ccmm, tcmm, request, expectCacheHit
    {
      var previousECalls := tcmm.eCalls;
      var em :- ccmm.GetEncryptionMaterials(request);
      expect tcmm.eCalls == previousECalls || tcmm.eCalls == previousECalls + 1, ""expectation violation""
      expect expectCacheHit <==> tcmm.eCalls == previousECalls, ""expectation violation""
    }

    method CallDM(ccmm: CachingCMMDef.CachingCMM, tcmm: TestCMM, request: Materials.ValidDecryptionMaterialsRequest, expectCacheHit: bool)
      requires ccmm.Valid() && ccmm.cmm == tcmm
      modifies ccmm.Repr
      ensures ccmm.Valid() && fresh(ccmm.Repr - old(ccmm.Repr))
      decreases ccmm, tcmm, request, expectCacheHit
    {
      var previousDCalls := tcmm.dCalls;
      var dm :- ccmm.DecryptMaterials(request);
      expect tcmm.dCalls == previousDCalls || tcmm.dCalls == previousDCalls + 1, ""expectation violation""
      expect expectCacheHit <==> tcmm.dCalls == previousDCalls, ""expectation violation""
    }
  }
  const SECONDS_TO_LIVE_LIMIT: nat := 3600

  method {:test} TestGetEMMessagesLimit()
  {
    var tcmm := new Helpers.TestCMM();
    var messageLimit := 4;
    var byteLimit := 100;
    var ccmm := new CachingCMMDef.CachingCMM.WithLimits(tcmm, SECONDS_TO_LIVE_LIMIT, messageLimit, byteLimit);
    var encryptionContext := TestUtils.SmallEncryptionContext(TestUtils.SmallEncryptionContextVariation.AB);
    var eRequest := Materials.EncryptionMaterialsRequest(encryptionContext, Some(AlgorithmSuite.AES_128_GCM_IV12_TAG16_HKDF_SHA256_ECDSA_P256), Some(5));
    Helpers.CallGetEM(ccmm, tcmm, eRequest, false);
    Helpers.CallGetEM(ccmm, tcmm, eRequest, true);
    Helpers.CallGetEM(ccmm, tcmm, eRequest, true);
    Helpers.CallGetEM(ccmm, tcmm, eRequest, false);
  }

  method {:test} TestGetEMBytesLimit()
  {
    var tcmm := new Helpers.TestCMM();
    var messageLimit := 1000000;
    var byteLimit := 100;
    var ccmm := new CachingCMMDef.CachingCMM.WithLimits(tcmm, SECONDS_TO_LIVE_LIMIT, messageLimit, byteLimit);
    var encryptionContext := TestUtils.SmallEncryptionContext(TestUtils.SmallEncryptionContextVariation.AB);
    var eRequest := Materials.EncryptionMaterialsRequest(encryptionContext, Some(AlgorithmSuite.AES_128_GCM_IV12_TAG16_HKDF_SHA256_ECDSA_P256), Some(29));
    Helpers.CallGetEM(ccmm, tcmm, eRequest, false);
    Helpers.CallGetEM(ccmm, tcmm, eRequest, true);
    Helpers.CallGetEM(ccmm, tcmm, eRequest, true);
    Helpers.CallGetEM(ccmm, tcmm, eRequest, false);
  }

  method {:test} TestGetEMTimeLimit()
  {
    var tcmm := new Helpers.TestCMM();
    var ccmm := new CachingCMMDef.CachingCMM.ForTestingOnly_WithZeroTimeToLive(tcmm);
    var encryptionContext := TestUtils.SmallEncryptionContext(TestUtils.SmallEncryptionContextVariation.AB);
    var eRequest := Materials.EncryptionMaterialsRequest(encryptionContext, Some(AlgorithmSuite.AES_128_GCM_IV12_TAG16_HKDF_SHA256_ECDSA_P256), Some(29));
    var n := 0;
    while n < 12
      invariant ccmm.Valid() && fresh(ccmm.Repr)
      decreases 12 - n
    {
      Helpers.CallGetEM(ccmm, tcmm, eRequest, false);
      n := n + 1;
    }
  }

  method {:test} TestGetEMVariationsInParameters()
  {
    var tcmm := new Helpers.TestCMM();
    var ccmm := new CachingCMMDef.CachingCMM(tcmm, SECONDS_TO_LIVE_LIMIT);
    var encryptionContext := TestUtils.SmallEncryptionContext(TestUtils.SmallEncryptionContextVariation.AB);
    var eRequest := Materials.EncryptionMaterialsRequest(encryptionContext, Some(AlgorithmSuite.AES_128_GCM_IV12_TAG16_HKDF_SHA256_ECDSA_P256), Some(5));
    Helpers.CallGetEM(ccmm, tcmm, eRequest, false);
    encryptionContext := TestUtils.SmallEncryptionContext(TestUtils.SmallEncryptionContextVariation.BA);
    eRequest := Materials.EncryptionMaterialsRequest(encryptionContext, Some(AlgorithmSuite.AES_128_GCM_IV12_TAG16_HKDF_SHA256_ECDSA_P256), Some(5));
    Helpers.CallGetEM(ccmm, tcmm, eRequest, true);
    var emptyEncryptionContext := TestUtils.SmallEncryptionContext(TestUtils.SmallEncryptionContextVariation.Empty);
    eRequest := Materials.EncryptionMaterialsRequest(emptyEncryptionContext, Some(AlgorithmSuite.AES_128_GCM_IV12_TAG16_HKDF_SHA256_ECDSA_P256), Some(5));
    Helpers.CallGetEM(ccmm, tcmm, eRequest, false);
    eRequest := Materials.EncryptionMaterialsRequest(encryptionContext, Some(AlgorithmSuite.AES_128_GCM_IV12_TAG16_HKDF_SHA256_ECDSA_P256), Some(5));
    Helpers.CallGetEM(ccmm, tcmm, eRequest, true);
    eRequest := Materials.EncryptionMaterialsRequest(encryptionContext, Some(AlgorithmSuite.AES_128_GCM_IV12_TAG16_HKDF_SHA256_ECDSA_P256), Some(99));
    Helpers.CallGetEM(ccmm, tcmm, eRequest, true);
    eRequest := Materials.EncryptionMaterialsRequest(encryptionContext, Some(AlgorithmSuite.AES_256_GCM_IV12_TAG16_IDENTITY_NO_SIGNATURE_ALG), Some(99));
    Helpers.CallGetEM(ccmm, tcmm, eRequest, false);
  }

  method {:test} TestDMFlowLimit()
  {
    var tcmm := new Helpers.TestCMM();
    var messageLimit := 2;
    var byteLimit := 100;
    var ccmm := new CachingCMMDef.CachingCMM.WithLimits(tcmm, SECONDS_TO_LIVE_LIMIT, messageLimit, byteLimit);
    var encryptionContext := TestUtils.SmallEncryptionContext(TestUtils.SmallEncryptionContextVariation.Empty);
    var edk: Materials.ValidEncryptedDataKey := Materials.EncryptedDataKey([], [], []);
    var dRequest := Materials.DecryptionMaterialsRequest(AlgorithmSuite.AES_128_GCM_IV12_TAG16_HKDF_SHA256_ECDSA_P256, [edk], encryptionContext);
    assert dRequest.Valid();
    var n := 0;
    while n < 12
      invariant ccmm.Valid() && fresh(ccmm.Repr)
      decreases 12 - n
    {
      Helpers.CallDM(ccmm, tcmm, dRequest, n != 0);
      n := n + 1;
    }
  }

  method {:test} TestDMTimeLimit()
  {
    var tcmm := new Helpers.TestCMM();
    var timeToLiveLimit := 1;
    var ccmm := new CachingCMMDef.CachingCMM.ForTestingOnly_WithZeroTimeToLive(tcmm);
    var encryptionContext := TestUtils.SmallEncryptionContext(TestUtils.SmallEncryptionContextVariation.AB);
    var edk: Materials.ValidEncryptedDataKey := Materials.EncryptedDataKey([], [], []);
    var dRequest := Materials.DecryptionMaterialsRequest(AlgorithmSuite.AES_128_GCM_IV12_TAG16_HKDF_SHA256_ECDSA_P256, [edk], encryptionContext);
    var n := 0;
    while n < 12
      invariant ccmm.Valid() && fresh(ccmm.Repr)
      decreases 12 - n
    {
      Helpers.CallDM(ccmm, tcmm, dRequest, false);
      n := n + 1;
    }
  }

  method {:test} TestDMVariationsInParameters()
  {
    var tcmm := new Helpers.TestCMM();
    var ccmm := new CachingCMMDef.CachingCMM(tcmm, SECONDS_TO_LIVE_LIMIT);
    var encryptionContext := TestUtils.SmallEncryptionContext(TestUtils.SmallEncryptionContextVariation.AB);
    var edk: Materials.ValidEncryptedDataKey := Materials.EncryptedDataKey([], [], []);
    var dRequest := Materials.DecryptionMaterialsRequest(AlgorithmSuite.AES_128_GCM_IV12_TAG16_HKDF_SHA256_ECDSA_P256, [edk], encryptionContext);
    Helpers.CallDM(ccmm, tcmm, dRequest, false);
    encryptionContext := TestUtils.SmallEncryptionContext(TestUtils.SmallEncryptionContextVariation.BA);
    dRequest := Materials.DecryptionMaterialsRequest(AlgorithmSuite.AES_128_GCM_IV12_TAG16_HKDF_SHA256_ECDSA_P256, [edk], encryptionContext);
    Helpers.CallDM(ccmm, tcmm, dRequest, true);
    var emptyEncryptionContext := TestUtils.SmallEncryptionContext(TestUtils.SmallEncryptionContextVariation.Empty);
    dRequest := Materials.DecryptionMaterialsRequest(AlgorithmSuite.AES_128_GCM_IV12_TAG16_HKDF_SHA256_ECDSA_P256, [edk], emptyEncryptionContext);
    Helpers.CallDM(ccmm, tcmm, dRequest, false);
    var edk' := Materials.EncryptedDataKey([], [82, 83], [84, 85]);
    dRequest := Materials.DecryptionMaterialsRequest(AlgorithmSuite.AES_128_GCM_IV12_TAG16_HKDF_SHA256_ECDSA_P256, [edk'], encryptionContext);
    Helpers.CallDM(ccmm, tcmm, dRequest, false);
    dRequest := Materials.DecryptionMaterialsRequest(AlgorithmSuite.AES_128_GCM_IV12_TAG16_HKDF_SHA256_ECDSA_P256, [edk], encryptionContext);
    Helpers.CallDM(ccmm, tcmm, dRequest, true);
  }
}

module {:extern ""DefaultCMMTests""} DefaultCMMTests {

  import opened Wrappers = Wrappers

  import opened UInt = StandardLibrary.UInt

  import AlgorithmSuite = AlgorithmSuite

  import DefaultCMMDef = DefaultCMMDef

  import Materials = Materials

  import EncryptionContext = EncryptionContext

  import UTF8 = UTF8

  import TestUtils = TestUtils
  method {:test} TestDefaultCMMNoAlg() returns (res: Result<(), string>)
  {
    var keyring :- TestUtils.MakeRSAKeyring();
    var cmm := new DefaultCMMDef.DefaultCMM.OfKeyring(keyring);
    var encCtx: EncryptionContext.Map := map[];
    var getEncMatOutput :- cmm.GetEncryptionMaterials(Materials.EncryptionMaterialsRequest(encCtx, None, None));
    expect getEncMatOutput.algorithmSuiteID == 888, ""GetEncryptionMaterials returned unexpected algorithm id""
    expect |getEncMatOutput.encryptedDataKeys| > 0, ""GetEncryptionMaterials didn't return any EDKs""
    expect getEncMatOutput.algorithmSuiteID.SignatureType().Some?, ""GetEncryptionMaterials didn't return a signature algorithm""
    expect getEncMatOutput.signingKey.Some?, ""GetEncryptionMaterials didn't return a signing key""
    var decMatRequest := Materials.DecryptionMaterialsRequest(getEncMatOutput.algorithmSuiteID, getEncMatOutput.encryptedDataKeys, getEncMatOutput.encryptionContext);
    var decMatOutput :- cmm.DecryptMaterials(decMatRequest);
    expect decMatOutput.plaintextDataKey.Some?, ""DecryptMaterials did not return a plaintext datakey""
    expect decMatOutput.algorithmSuiteID.ValidPlaintextDataKey(decMatOutput.plaintextDataKey.value), ""DecryptMaterials returned invalid plaintext datakey""
    expect decMatOutput.verificationKey.Some?, ""DecryptMaterials did not return a verification key""
    return Success(());
  }

  method {:test} TestDefaultCMMWithAlg() returns (res: Result<(), string>)
  {
    var keyring :- TestUtils.MakeRSAKeyring();
    var cmm := new DefaultCMMDef.DefaultCMM.OfKeyring(keyring);
    var encCtx: EncryptionContext.Map := map[];
    var getEncMatOutput :- cmm.GetEncryptionMaterials(Materials.EncryptionMaterialsRequest(encCtx, Some(AlgorithmSuite.AES_256_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384), None));
    expect getEncMatOutput.algorithmSuiteID == AlgorithmSuite.AES_256_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384, ""GetEncryptionMaterials returned the incorrect algorithm id""
    expect |getEncMatOutput.encryptedDataKeys| > 0, ""GetEncryptionMaterials didn't return any EDKs""
    expect getEncMatOutput.algorithmSuiteID.SignatureType().Some?, ""GetEncryptionMaterials didn't return a signature algorithm""
    expect getEncMatOutput.signingKey.Some?, ""GetEncryptionMaterials didn't return a signing key""
    var decMatRequest := Materials.DecryptionMaterialsRequest(getEncMatOutput.algorithmSuiteID, getEncMatOutput.encryptedDataKeys, getEncMatOutput.encryptionContext);
    var decMatOutput :- cmm.DecryptMaterials(decMatRequest);
    expect decMatOutput.plaintextDataKey.Some?, ""DecryptMaterials did not return a plaintext datakey""
    expect decMatOutput.algorithmSuiteID.ValidPlaintextDataKey(decMatOutput.plaintextDataKey.value), ""DecryptMaterials returned invalid plaintext datakey""
    expect decMatOutput.verificationKey.Some?, ""DecryptMaterials did not return a verification key""
    return Success(());
  }

  method {:test} TestDefaultCMMWithAlgNoSig() returns (res: Result<(), string>)
  {
    var keyring :- TestUtils.MakeRSAKeyring();
    var cmm := new DefaultCMMDef.DefaultCMM.OfKeyring(keyring);
    var encCtx: EncryptionContext.Map := map[];
    var getEncMatOutput :- cmm.GetEncryptionMaterials(Materials.EncryptionMaterialsRequest(encCtx, Some(AlgorithmSuite.AES_256_GCM_IV12_TAG16_HKDF_SHA256_NO_SIGNATURE_ALG), None));
    expect getEncMatOutput.algorithmSuiteID == AlgorithmSuite.AES_256_GCM_IV12_TAG16_HKDF_SHA256_NO_SIGNATURE_ALG, ""GetEncryptionMaterials returned the incorrect algorithm id""
    expect |getEncMatOutput.encryptedDataKeys| > 0, ""GetEncryptionMaterials didn't return any EDKs""
    expect getEncMatOutput.algorithmSuiteID.SignatureType().None?, ""GetEncryptionMaterials returned a signature algorithm when it shouldn't have""
    expect getEncMatOutput.signingKey.None?, ""GetEncryptionMaterials returned a signing key when it shouldn't have""
    var decMatRequest := Materials.DecryptionMaterialsRequest(getEncMatOutput.algorithmSuiteID, getEncMatOutput.encryptedDataKeys, getEncMatOutput.encryptionContext);
    var decMatOutput :- cmm.DecryptMaterials(decMatRequest);
    expect decMatOutput.plaintextDataKey.Some?, ""DecryptMaterials did not return a plaintext datakey""
    expect decMatOutput.algorithmSuiteID.ValidPlaintextDataKey(decMatOutput.plaintextDataKey.value), ""DecryptMaterials returned invalid plaintext datakey""
    expect decMatOutput.verificationKey.None?, ""DecryptMaterials erroneously returned a verification key""
    return Success(());
  }

  method {:test} TestDefaultCMMRejectsBadEncCtxReservedValue() returns (res: Result<(), string>)
  {
    var keyring :- TestUtils.MakeRSAKeyring();
    var cmm := new DefaultCMMDef.DefaultCMM.OfKeyring(keyring);
    var encCtx: EncryptionContext.Map := map[];
    encCtx := encCtx[Materials.EC_PUBLIC_KEY_FIELD := [0]];
    var shouldBeFail := cmm.GetEncryptionMaterials(Materials.EncryptionMaterialsRequest(encCtx, None, None));
    expect shouldBeFail.Failure?, ""GetEncryptionMaterials returned Success with bad input""
    return Success(());
  }

  method {:test} TestDefaultCMMRejectsBadEncCtxTooBig()
  {
    var keyring :- TestUtils.MakeRSAKeyring();
    var cmm := new DefaultCMMDef.DefaultCMM.OfKeyring(keyring);
    var encryptionContext := TestUtils.GenerateInvalidEncryptionContext();
    var shouldBeFail := cmm.GetEncryptionMaterials(Materials.EncryptionMaterialsRequest(encryptionContext, None, None));
    expect shouldBeFail.Failure?, ""GetEncryptionMaterials returned Success with bad input""
  }
}

module TestMultiKeying {

  import opened Wrappers = Wrappers

  import opened UInt = StandardLibrary.UInt

  import RawAESKeyringDef = RawAESKeyringDef

  import EncryptionContext = EncryptionContext

  import EncryptionSuites = EncryptionSuites

  import MultiKeyringDef = MultiKeyringDef

  import TestKeyrings = TestKeyrings

  import AlgorithmSuite = AlgorithmSuite

  import Materials = Materials

  import TestUtils = TestUtils

  import UTF8 = UTF8
  method {:test} TestOnEncryptOnDecryptWithGenerator()
  {
    var encryptionContext := TestUtils.SmallEncryptionContext(TestUtils.SmallEncryptionContextVariation.A);
    var child1Namespace, child1Name := TestUtils.NamespaceAndName(1);
    var child2namespace, child2Name := TestUtils.NamespaceAndName(2);
    var child1Keyring := new RawAESKeyringDef.RawAESKeyring(child1Namespace, child1Name, seq(32, (i: int) => 0), EncryptionSuites.AES_GCM_256);
    var child2Keyring := new RawAESKeyringDef.RawAESKeyring(child2namespace, child2Name, seq(32, (i: int) => 0), EncryptionSuites.AES_GCM_256);
    var multiKeyring := new MultiKeyringDef.MultiKeyring(child1Keyring, [child2Keyring]);
    var algorithmSuiteID := AlgorithmSuite.AES_256_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384;
    var signingKey := seq(32, (i: int) => 0);
    var encryptionMaterialsIn := Materials.EncryptionMaterials.WithoutDataKeys(encryptionContext, algorithmSuiteID, Some(signingKey));
    var encryptionMaterialsOut :- multiKeyring.OnEncrypt(encryptionMaterialsIn);
    expect |encryptionMaterialsOut.encryptedDataKeys| == 2, ""expectation violation""
    var pdk := encryptionMaterialsOut.plaintextDataKey;
    var edk1 := encryptionMaterialsOut.encryptedDataKeys[0];
    var edk2 := encryptionMaterialsOut.encryptedDataKeys[1];
    var verificationKey := seq(32, (i: int) => 0);
    var decryptionMaterialsIn := Materials.DecryptionMaterials.WithoutPlaintextDataKey(encryptionContext, algorithmSuiteID, Some(verificationKey));
    var decryptionMaterialsOut :- multiKeyring.OnDecrypt(decryptionMaterialsIn, [edk1]);
    expect decryptionMaterialsOut.plaintextDataKey == pdk, ""expectation violation""
    decryptionMaterialsOut :- multiKeyring.OnDecrypt(decryptionMaterialsIn, [edk2]);
    expect decryptionMaterialsOut.plaintextDataKey == pdk, ""expectation violation""
  }

  method {:test} TestOnEncryptOnDecryptWithoutGenerator()
  {
    var encryptionContext := TestUtils.SmallEncryptionContext(TestUtils.SmallEncryptionContextVariation.A);
    var child1Namespace, child1Name := TestUtils.NamespaceAndName(1);
    var child2namespace, child2Name := TestUtils.NamespaceAndName(2);
    var child1Keyring := new RawAESKeyringDef.RawAESKeyring(child1Namespace, child1Name, seq(32, (i: int) => 0), EncryptionSuites.AES_GCM_256);
    var child2Keyring := new RawAESKeyringDef.RawAESKeyring(child2namespace, child2Name, seq(32, (i: int) => 0), EncryptionSuites.AES_GCM_256);
    var algorithmSuiteID := AlgorithmSuite.AES_256_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384;
    var signingKey := seq(32, (i: int) => 0);
    var multiKeyring := new MultiKeyringDef.MultiKeyring(null, [child1Keyring, child2Keyring]);
    var pdk := seq(32, (i: int) => 0);
    var encryptionMaterialsIn := Materials.EncryptionMaterials.WithoutDataKeys(encryptionContext, algorithmSuiteID, Some(signingKey)).WithKeys(Some(pdk), []);
    var encryptionMaterialsOut :- multiKeyring.OnEncrypt(encryptionMaterialsIn);
    expect encryptionMaterialsOut.plaintextDataKey == Some(pdk), ""expectation violation""
    expect |encryptionMaterialsOut.encryptedDataKeys| == 2, ""expectation violation""
    var edk1 := encryptionMaterialsOut.encryptedDataKeys[0];
    var edk2 := encryptionMaterialsOut.encryptedDataKeys[1];
    var verificationKey := seq(32, (i: int) => 0);
    var materialsIn := Materials.DecryptionMaterials.WithoutPlaintextDataKey(encryptionContext, algorithmSuiteID, Some(verificationKey));
    var materialsOut :- multiKeyring.OnDecrypt(materialsIn, [edk1]);
    expect materialsOut.plaintextDataKey == Some(pdk), ""expectation violation""
    materialsIn := Materials.DecryptionMaterials.WithoutPlaintextDataKey(encryptionContext, algorithmSuiteID, Some(verificationKey));
    materialsOut :- multiKeyring.OnDecrypt(materialsIn, [edk2]);
    expect materialsOut.plaintextDataKey == Some(pdk), ""expectation violation""
  }

  method {:test} TestOnEncryptChildKeyringFailure()
  {
    var encryptionContext := TestUtils.SmallEncryptionContext(TestUtils.SmallEncryptionContextVariation.A);
    var child1Namespace, child1Name := TestUtils.NamespaceAndName(1);
    var child1Keyring := new RawAESKeyringDef.RawAESKeyring(child1Namespace, child1Name, seq(32, (i: int) => 0), EncryptionSuites.AES_GCM_256);
    var child2Keyring := new TestKeyrings.AlwaysFailingKeyring();
    var multiKeyring := new MultiKeyringDef.MultiKeyring(child1Keyring, [child2Keyring]);
    var algorithmSuiteID := AlgorithmSuite.AES_256_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384;
    var signingKey := seq(32, (i: int) => 0);
    var encryptionMaterialsIn := Materials.EncryptionMaterials.WithoutDataKeys(encryptionContext, algorithmSuiteID, Some(signingKey));
    var encryptionMaterialsOut := multiKeyring.OnEncrypt(encryptionMaterialsIn);
    expect encryptionMaterialsOut.Failure?, ""expectation violation""
  }

  method {:test} TestOnDecryptNoChildDecryptsAndAtLeastOneFails()
  {
    var encryptionContext := map[];
    var algorithmSuiteID := AlgorithmSuite.AES_256_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384;
    var edk := Materials.EncryptedDataKey.ValidWitness();
    var verificationKey := seq(32, (i: int) => 0);
    var childKeyring1 := new TestKeyrings.AlwaysFailingKeyring();
    var childKeyring2 := new TestKeyrings.NoOpKeyring();
    var multiKeyring := new MultiKeyringDef.MultiKeyring(childKeyring2, [childKeyring1, childKeyring2]);
    var decryptionMaterialsIn := Materials.DecryptionMaterials.WithoutPlaintextDataKey(encryptionContext, algorithmSuiteID, Some(verificationKey));
    var decryptionMaterialsOut := multiKeyring.OnDecrypt(decryptionMaterialsIn, [edk]);
    expect decryptionMaterialsOut.Failure?, ""expectation violation""
  }

  method {:test} TestOnDecryptAllChildKeyringsDontDecrypt()
  {
    var encryptionContext := map[];
    var algorithmSuiteID := AlgorithmSuite.AES_256_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384;
    var edk := Materials.EncryptedDataKey.ValidWitness();
    var verificationKey := seq(32, (i: int) => 0);
    var childKeyring := new TestKeyrings.NoOpKeyring();
    var multiKeyring := new MultiKeyringDef.MultiKeyring(null, [childKeyring, childKeyring]);
    var decryptionMaterialsIn := Materials.DecryptionMaterials.WithoutPlaintextDataKey(encryptionContext, algorithmSuiteID, Some(verificationKey));
    var decryptionMaterialsOut :- multiKeyring.OnDecrypt(decryptionMaterialsIn, [edk]);
    expect decryptionMaterialsOut.plaintextDataKey.None?, ""expectation violation""
  }
}

module TestAESKeyring {

  import opened Wrappers = Wrappers

  import opened UInt = StandardLibrary.UInt

  import AESEncryption = AESEncryption

  import RawAESKeyringDef = RawAESKeyringDef

  import MessageHeader = MessageHeader

  import Materials = Materials

  import EncryptionContext = EncryptionContext

  import EncryptionSuites = EncryptionSuites

  import AlgorithmSuite = AlgorithmSuite

  import UTF8 = UTF8

  import opened TestUtils = TestUtils
  method {:test} TestOnEncryptOnDecryptGenerateDataKey()
  {
    var namespace, name := TestUtils.NamespaceAndName(0);
    var rawAESKeyring := new RawAESKeyringDef.RawAESKeyring(namespace, name, seq(32, (i: int) => 0), EncryptionSuites.AES_GCM_256);
    var encryptionContext := TestUtils.SmallEncryptionContext(TestUtils.SmallEncryptionContextVariation.A);
    ExpectSerializableEncryptionContext(encryptionContext);
    var wrappingAlgorithmID := AlgorithmSuite.AES_256_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384;
    var signingKey := seq(32, (i: int) => 0);
    var encryptionMaterialsIn := Materials.EncryptionMaterials.WithoutDataKeys(encryptionContext, wrappingAlgorithmID, Some(signingKey));
    var encryptionMaterialsOut :- rawAESKeyring.OnEncrypt(encryptionMaterialsIn);
    expect |encryptionMaterialsOut.encryptedDataKeys| == 1, ""expectation violation""
    var pdk := encryptionMaterialsOut.plaintextDataKey;
    var edk := encryptionMaterialsOut.encryptedDataKeys[0];
    var verificationKey := seq(32, (i: int) => 0);
    var decryptionMaterialsIn := Materials.DecryptionMaterials.WithoutPlaintextDataKey(encryptionContext, wrappingAlgorithmID, Some(verificationKey));
    var decryptionMaterialsOut :- rawAESKeyring.OnDecrypt(decryptionMaterialsIn, [edk]);
    expect encryptionMaterialsOut.plaintextDataKey == pdk, ""expectation violation""
  }

  method {:test} TestOnEncryptOnDecryptSuppliedDataKey()
  {
    var namespace, name := TestUtils.NamespaceAndName(0);
    var rawAESKeyring := new RawAESKeyringDef.RawAESKeyring(namespace, name, seq(32, (i: int) => 0), EncryptionSuites.AES_GCM_256);
    var encryptionContext := TestUtils.SmallEncryptionContext(TestUtils.SmallEncryptionContextVariation.A);
    ExpectSerializableEncryptionContext(encryptionContext);
    var pdk := seq(32, (i: int) => 0);
    var wrappingAlgorithmID := AlgorithmSuite.AES_256_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384;
    var signingKey := seq(32, (i: int) => 0);
    var encryptionMaterialsIn := Materials.EncryptionMaterials.WithoutDataKeys(encryptionContext, wrappingAlgorithmID, Some(signingKey)).WithKeys(Some(pdk), []);
    var encryptionMaterialsOut :- rawAESKeyring.OnEncrypt(encryptionMaterialsIn);
    expect |encryptionMaterialsOut.encryptedDataKeys| == 1, ""expectation violation""
    var edk := encryptionMaterialsOut.encryptedDataKeys[0];
    var verificationKey := seq(32, (i: int) => 0);
    var decryptionMaterialsIn := Materials.DecryptionMaterials.WithoutPlaintextDataKey(encryptionContext, wrappingAlgorithmID, Some(verificationKey));
    var decryptionMaterialsOut :- rawAESKeyring.OnDecrypt(decryptionMaterialsIn, [edk]);
    expect decryptionMaterialsOut.plaintextDataKey == Some(pdk), ""expectation violation""
  }

  method {:test} TestOnDecryptNoEDKs()
  {
    var namespace, name := TestUtils.NamespaceAndName(0);
    var rawAESKeyring := new RawAESKeyringDef.RawAESKeyring(namespace, name, seq(32, (i: int) => 0), EncryptionSuites.AES_GCM_256);
    var wrappingAlgorithmID := AlgorithmSuite.AES_256_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384;
    var encryptionContext := TestUtils.SmallEncryptionContext(TestUtils.SmallEncryptionContextVariation.A);
    var verificationKey := seq(32, (i: int) => 0);
    var decryptionMaterialsIn := Materials.DecryptionMaterials.WithoutPlaintextDataKey(encryptionContext, wrappingAlgorithmID, Some(verificationKey));
    var decryptionMaterialsOut :- rawAESKeyring.OnDecrypt(decryptionMaterialsIn, []);
    expect decryptionMaterialsOut.plaintextDataKey.None?, ""expectation violation""
  }

  method {:test} TestOnEncryptUnserializableEC()
  {
    var namespace, name := TestUtils.NamespaceAndName(0);
    var rawAESKeyring := new RawAESKeyringDef.RawAESKeyring(namespace, name, seq(32, (i: int) => 0), EncryptionSuites.AES_GCM_256);
    var unserializableEncryptionContext := generateUnserializableEncryptionContext();
    ExpectNonSerializableEncryptionContext(unserializableEncryptionContext);
    var wrappingAlgorithmID := AlgorithmSuite.AES_256_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384;
    var signingKey := seq(32, (i: int) => 0);
    var encryptionMaterialsIn := Materials.EncryptionMaterials.WithoutDataKeys(unserializableEncryptionContext, wrappingAlgorithmID, Some(signingKey));
    var encryptionMaterialsOut := rawAESKeyring.OnEncrypt(encryptionMaterialsIn);
    expect encryptionMaterialsOut.Failure?, ""expectation violation""
  }

  method {:test} TestOnDecryptUnserializableEC()
  {
    var encryptionContext := TestUtils.SmallEncryptionContext(TestUtils.SmallEncryptionContextVariation.A);
    var namespace, name := TestUtils.NamespaceAndName(0);
    var rawAESKeyring := new RawAESKeyringDef.RawAESKeyring(namespace, name, seq(32, (i: int) => 0), EncryptionSuites.AES_GCM_256);
    var wrappingAlgorithmID := AlgorithmSuite.AES_256_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384;
    var signingKey := seq(32, (i: int) => 0);
    var encryptionMaterialsIn := Materials.EncryptionMaterials.WithoutDataKeys(encryptionContext, wrappingAlgorithmID, Some(signingKey));
    var encryptionMaterialsOut :- rawAESKeyring.OnEncrypt(encryptionMaterialsIn);
    expect encryptionMaterialsOut.plaintextDataKey.Some?, ""expectation violation""
    expect |encryptionMaterialsOut.encryptedDataKeys| == 1, ""expectation violation""
    var edk := encryptionMaterialsOut.encryptedDataKeys[0];
    var unserializableEncryptionContext := generateUnserializableEncryptionContext();
    ExpectNonSerializableEncryptionContext(unserializableEncryptionContext);
    var verificationKey := seq(32, (i: int) => 0);
    var decryptionMaterialsIn := Materials.DecryptionMaterials.WithoutPlaintextDataKey(unserializableEncryptionContext, wrappingAlgorithmID, Some(verificationKey));
    var decryptionMaterialsOut := rawAESKeyring.OnDecrypt(decryptionMaterialsIn, [edk]);
    expect decryptionMaterialsOut.Failure?, ""expectation violation""
  }

  method {:test} TestDeserializeEDKCiphertext()
  {
    var ciphertext := [0, 1, 2, 3];
    var authTag := [4, 5, 6, 7];
    var serializedEDKCiphertext := ciphertext + authTag;
    var encOutput := RawAESKeyringDef.DeserializeEDKCiphertext(serializedEDKCiphertext, |authTag|);
    expect encOutput.cipherText == ciphertext, ""expectation violation""
    expect encOutput.authTag == authTag, ""expectation violation""
  }

  method {:test} TestSerializeEDKCiphertext()
  {
    var ciphertext := [0, 1, 2, 3];
    var authTag := [4, 5, 6, 7];
    var encOutput := AESEncryption.EncryptionOutput(ciphertext, authTag);
    var serializedEDKCiphertext := RawAESKeyringDef.SerializeEDKCiphertext(encOutput);
    expect serializedEDKCiphertext == ciphertext + authTag, ""expectation violation""
  }

  method generateUnserializableEncryptionContext() returns (encCtx: EncryptionContext.Map)
  {
    var keyA :- UTF8.Encode(""keyA"");
    var invalidVal := seq(65536, (_: int) => 0);
    AssumeLongSeqIsValidUTF8(invalidVal);
    return map[keyA := invalidVal];
  }
}

module TestRSAKeyring {

  import opened Wrappers = Wrappers

  import opened UInt = StandardLibrary.UInt

  import RSA = RSAEncryption

  import RawRSAKeyringDef = RawRSAKeyringDef

  import AlgorithmSuite = AlgorithmSuite

  import UTF8 = UTF8

  import Materials = Materials

  import TestUtils = TestUtils
  const allPaddingModes := {RSA.PKCS1, RSA.OAEP_SHA1, RSA.OAEP_SHA256, RSA.OAEP_SHA384, RSA.OAEP_SHA512}

  method {:test} TestOnEncryptOnDecryptGenerateDataKey()
  {
    var remainingPaddingModes := allPaddingModes;
    var namespace, name := TestUtils.NamespaceAndName(0);
    while remainingPaddingModes != {}
      decreases remainingPaddingModes
    {
      var paddingMode :| paddingMode in remainingPaddingModes;
      remainingPaddingModes := remainingPaddingModes - {paddingMode};
      var publicKey, privateKey := RSA.GenerateKeyPair(2048, paddingMode);
      var rawRSAKeyring := new RawRSAKeyringDef.RawRSAKeyring(namespace, name, paddingMode, Some(publicKey), Some(privateKey));
      var encryptionContext := TestUtils.SmallEncryptionContext(TestUtils.SmallEncryptionContextVariation.A);
      var algorithmSuiteID := AlgorithmSuite.AES_256_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384;
      var signingKey := seq(32, (i: int) => 0);
      var encryptionMaterialsIn := Materials.EncryptionMaterials.WithoutDataKeys(encryptionContext, algorithmSuiteID, Some(signingKey));
      var encryptionMaterialsOut :- rawRSAKeyring.OnEncrypt(encryptionMaterialsIn);
      expect encryptionMaterialsOut.plaintextDataKey.Some?, ""expectation violation""
      expect |encryptionMaterialsOut.encryptedDataKeys| == 1, ""expectation violation""
      var plaintextDataKey := encryptionMaterialsOut.plaintextDataKey;
      var encryptedDataKey := encryptionMaterialsOut.encryptedDataKeys[0];
      var verificationKey := seq(32, (i: int) => 0);
      var decryptionMaterialsIn := Materials.DecryptionMaterials.WithoutPlaintextDataKey(encryptionContext, algorithmSuiteID, Some(verificationKey));
      var decryptionMaterialsOut :- rawRSAKeyring.OnDecrypt(decryptionMaterialsIn, [encryptedDataKey]);
      expect encryptionMaterialsOut.plaintextDataKey == plaintextDataKey, ""expectation violation""
    }
  }

  method {:test} TestOnEncryptOnDecryptSuppliedDataKey()
  {
    var remainingPaddingModes := allPaddingModes;
    var namespace, name := TestUtils.NamespaceAndName(0);
    while remainingPaddingModes != {}
      decreases remainingPaddingModes
    {
      var paddingMode :| paddingMode in remainingPaddingModes;
      remainingPaddingModes := remainingPaddingModes - {paddingMode};
      var publicKey, privateKey := RSA.GenerateKeyPair(2048, paddingMode);
      var rawRSAKeyring := new RawRSAKeyringDef.RawRSAKeyring(namespace, name, paddingMode, Some(publicKey), Some(privateKey));
      var encryptionContext := TestUtils.SmallEncryptionContext(TestUtils.SmallEncryptionContextVariation.A);
      var plaintextDataKey := seq(32, (i: int) => 0);
      var algorithmSuiteID := AlgorithmSuite.AES_256_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384;
      var signingKey := seq(32, (i: int) => 0);
      var encryptionMaterialsIn := Materials.EncryptionMaterials.WithoutDataKeys(encryptionContext, algorithmSuiteID, Some(signingKey)).WithKeys(Some(plaintextDataKey), []);
      var encryptionMaterialsOut :- rawRSAKeyring.OnEncrypt(encryptionMaterialsIn);
      expect encryptionMaterialsOut.plaintextDataKey.Some?, ""expectation violation""
      expect |encryptionMaterialsOut.encryptedDataKeys| == 1, ""expectation violation""
      expect encryptionMaterialsOut.plaintextDataKey.value == plaintextDataKey, ""expectation violation""
      var encryptedDataKey := encryptionMaterialsOut.encryptedDataKeys[0];
      var verificationKey := seq(32, (i: int) => 0);
      var decryptionMaterialsIn := Materials.DecryptionMaterials.WithoutPlaintextDataKey(encryptionContext, algorithmSuiteID, Some(verificationKey));
      var decryptionMaterialsOut :- rawRSAKeyring.OnDecrypt(decryptionMaterialsIn, [encryptedDataKey]);
      expect decryptionMaterialsOut.plaintextDataKey.Some? && decryptionMaterialsOut.plaintextDataKey.value == plaintextDataKey, ""expectation violation""
    }
  }
}

module TestKeyrings {

  import opened Wrappers = Wrappers

  import opened KeyringDefs = KeyringDefs

  import Materials = Materials
  class NoOpKeyring extends Keyring {
    constructor ()
    {
      Repr := {};
    }

    predicate Valid()
      reads this, Repr
      decreases Repr + {this}
    {
      true
    }

    method OnEncrypt(materials: Materials.ValidEncryptionMaterials) returns (res: Result<Materials.ValidEncryptionMaterials, string>)
      requires Valid()
      ensures Valid()
      ensures OnEncryptPure(materials, res)
      decreases materials
    {
      return Success(materials);
    }

    method OnDecrypt(materials: Materials.ValidDecryptionMaterials, encryptedDataKeys: seq<Materials.EncryptedDataKey>) returns (res: Result<Materials.ValidDecryptionMaterials, string>)
      requires Valid()
      ensures Valid()
      ensures OnDecryptPure(materials, res)
      decreases materials, encryptedDataKeys
    {
      if materials.plaintextDataKey.None? {
        return Failure(""No data key"");
      }
      return Success(materials);
    }
  }

  class AlwaysFailingKeyring extends Keyring {
    constructor ()
    {
      Repr := {};
    }

    predicate Valid()
      reads this, Repr
      decreases Repr + {this}
    {
      true
    }

    method OnEncrypt(materials: Materials.ValidEncryptionMaterials) returns (res: Result<Materials.ValidEncryptionMaterials, string>)
      requires Valid()
      ensures Valid()
      ensures OnEncryptPure(materials, res)
      decreases materials
    {
      return Failure(""Surprise, AlwaysFailingKeyring always fails!"");
    }

    method OnDecrypt(materials: Materials.ValidDecryptionMaterials, encryptedDataKeys: seq<Materials.EncryptedDataKey>) returns (res: Result<Materials.ValidDecryptionMaterials, string>)
      requires Valid()
      ensures Valid()
      ensures OnDecryptPure(materials, res)
      decreases materials, encryptedDataKeys
    {
      if materials.plaintextDataKey.Some? {
        return Success(materials);
      }
      return Failure(""Surprise, AlwaysFailingKeyring always fails!"");
    }
  }
}

module {:extern ""TestMaterials""} TestMaterials {

  import opened Wrappers = Wrappers

  import opened Materials = Materials

  import AlgorithmSuite = AlgorithmSuite
  method {:test} TestWithKeysSettingPlaintextDataKey()
  {
    var encryptionContext := map[];
    var algorithmSuiteID := AlgorithmSuite.AES_256_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384;
    var signingKey := seq(32, (i: int) => 0);
    var encryptionMaterials1 := EncryptionMaterials(encryptionContext, algorithmSuiteID, None, [], Some(signingKey));
    var pdk := seq(32, (i: int) => 0);
    var edk := EncryptedDataKey([], [2], [2]);
    var encryptionMaterials2 := encryptionMaterials1.WithKeys(Some(pdk), [edk]);
    expect Some(pdk) == encryptionMaterials2.plaintextDataKey, ""expectation violation""
    expect encryptionMaterials1.algorithmSuiteID == encryptionMaterials2.algorithmSuiteID, ""expectation violation""
    expect [edk] == encryptionMaterials2.encryptedDataKeys, ""expectation violation""
  }

  method {:test} TestWithKeysKeepingPlaintextDataKey()
  {
    var encryptionContext := map[];
    var edk1 := EncryptedDataKey([], [1], [1]);
    var pdk := seq(32, (i: int) => 0);
    var algorithmSuiteID := AlgorithmSuite.AES_256_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384;
    var signingKey := seq(32, (i: int) => 0);
    var encryptionMaterials1 := EncryptionMaterials(encryptionContext, algorithmSuiteID, Some(pdk), [edk1], Some(signingKey));
    var edk2 := EncryptedDataKey([], [2], [2]);
    var encryptionMaterials2 := encryptionMaterials1.WithKeys(Some(pdk), [edk2]);
    expect Some(pdk) == encryptionMaterials1.plaintextDataKey == encryptionMaterials2.plaintextDataKey, ""expectation violation""
    expect encryptionMaterials1.algorithmSuiteID == encryptionMaterials2.algorithmSuiteID, ""expectation violation""
    expect encryptionMaterials1.encryptedDataKeys + [edk2] == encryptionMaterials2.encryptedDataKeys, ""expectation violation""
  }
}

module TestMessageHeader {

  import AlgorithmSuite = AlgorithmSuite

  import opened StandardLibrary = StandardLibrary

  import opened UInt = StandardLibrary.UInt

  import Materials = Materials

  import UTF8 = UTF8

  import EncryptionContext = EncryptionContext

  import opened TestUtils = TestUtils
  method {:test} TestKVPairSequenceToMapEmpty()
  {
    var kvPairs := [];
    var output := EncryptionContext.LinearToMap(kvPairs);
    var expected := map[];
    expect output == expected, ""expectation violation""
  }

  method {:test} TestKVPairSequenceToMap()
  {
    var keyA :- UTF8.Encode(""keyA"");
    var valA :- UTF8.Encode(""valA"");
    var keyB :- UTF8.Encode(""keyB"");
    var valB :- UTF8.Encode(""valB"");
    var kvPairs := [(keyA, valA), (keyB, valB)];
    var output := EncryptionContext.LinearToMap(kvPairs);
    var expected := map[keyA := valA, keyB := valB];
    expect output == expected, ""expectation violation""
  }

  method {:test} TestCheckSerializableEmpty()
  {
    var encCtx := map[];
    ExpectSerializableEncryptionContext(encCtx);
  }

  method {:test} TestCheckSerializableOnePair()
  {
    var keyA :- UTF8.Encode(""keyA"");
    var valA :- UTF8.Encode(""valA"");
    var encCtx := map[keyA := valA];
    ExpectSerializableEncryptionContext(encCtx);
  }

  method {:test} TestCheckSerializableOnePairMaxSize()
  {
    var keyA :- UTF8.Encode(""A"");
    var largeVal := seq(65528, (_: int) => 0);
    var encCtx := map[keyA := largeVal];
    TestUtils.AssumeLongSeqIsValidUTF8(largeVal);
    ExpectSerializableEncryptionContext(encCtx);
  }

  method {:test} TestCheckSerializableTooLarge()
  {
    var keyA :- UTF8.Encode(""keyA"");
    var keyB :- UTF8.Encode(""keyB"");
    var invalidVal := seq(65528, (_: int) => 0);
    TestUtils.AssumeLongSeqIsValidUTF8(invalidVal);
    var encCtx := map[keyA := invalidVal, keyB := invalidVal];
    ExpectNonSerializableEncryptionContext(encCtx);
  }

  method {:test} TestCheckSerializablePairTooBig()
  {
    var key :- UTF8.Encode(""keyA"");
    var invalidVal := seq(65536, (_: int) => 0);
    var encCtx := map[key := invalidVal];
    TestUtils.AssumeLongSeqIsValidUTF8(invalidVal);
    ExpectNonSerializableEncryptionContext(encCtx);
  }

  method {:test} TestComputeKVPairsLengthEmpty()
  {
    var encCtx := map[];
    var len := EncryptionContext.ComputeLength(encCtx);
    expect len as int == 0, ""expectation violation""
  }

  method {:test} TestComputeKVPairsLengthOnePair()
  {
    var keyA :- UTF8.Encode(""keyA"");
    var valA :- UTF8.Encode(""valA"");
    var encCtx := map[keyA := valA];
    var expectedSerialization := [0, 1, 0, 4, 107, 101, 121, 65, 0, 4, 118, 97, 108, 65];
    var len := EncryptionContext.ComputeLength(encCtx);
    expect len as int == |expectedSerialization|, ""expectation violation""
  }

  method {:test} TestComputeKVPairsLengthLong()
  {
    var keyA :- UTF8.Encode(""A"");
    var largeVal := seq(65536, (_: int) => 0);
    TestUtils.AssumeLongSeqIsValidUTF8(largeVal);
    var encCtx := map[keyA := largeVal];
    var len := EncryptionContext.ComputeLength(encCtx);
    expect len as int == 7 + |largeVal|, ""expectation violation""
  }

  method {:test} TestComputeOpoerationsOnLargeValidEC()
  {
    var encCtx := TestUtils.GenerateLargeValidEncryptionContext();
    var len := EncryptionContext.ComputeLength(encCtx);
    expect len as int == 2 + |encCtx| as int * 7, ""expectation violation""
    ExpectSerializableEncryptionContext(encCtx);
  }
}

module TestSerialize {

  import opened StandardLibrary = StandardLibrary

  import opened UInt = StandardLibrary.UInt

  import opened Serialize = Serialize

  import UTF8 = UTF8

  import EncryptionContext = EncryptionContext

  import TestUtils = TestUtils
  method {:test} TestSerializeAAD()
  {
    var wr := new Streams.ByteWriter();
    var keyA :- UTF8.Encode(""keyA"");
    var valA :- UTF8.Encode(""valA"");
    var keyB :- UTF8.Encode(""keyB"");
    var valB :- UTF8.Encode(""valB"");
    var encryptionContext := map[keyB := valB, keyA := valA];
    TestUtils.ValidSmallEncryptionContext(encryptionContext);
    var expectedSerializedAAD := [0, 26, 0, 2, 0, 4, 107, 101, 121, 65, 0, 4, 118, 97, 108, 65, 0, 4, 107, 101, 121, 66, 0, 4, 118, 97, 108, 66];
    var len :- SerializeAAD(wr, encryptionContext);
    expect wr.GetDataWritten() == expectedSerializedAAD, ""expectation violation""
  }

  method {:test} TestSerializeAADEmpty()
  {
    reveal EncryptionContext.Serializable();
    var wr := new Streams.ByteWriter();
    var encryptionContext := map[];
    var expectedSerializedAAD := [0, 0];
    var len :- SerializeAAD(wr, encryptionContext);
    expect wr.GetDataWritten() == expectedSerializedAAD, ""expectation violation""
  }

  method {:test} TestSerializeLargeValidEC()
  {
    var wr := new Streams.ByteWriter();
    var encCtx := TestUtils.GenerateLargeValidEncryptionContext();
    var len :- SerializeAAD(wr, encCtx);
    expect len == 4 + |encCtx| as int * 7, ""expectation violation""
  }

  method {:test} TestSerializeKVPairs()
  {
    var wr := new Streams.ByteWriter();
    var keyA :- UTF8.Encode(""keyA"");
    var valA :- UTF8.Encode(""valA"");
    var keyB :- UTF8.Encode(""keyB"");
    var valB :- UTF8.Encode(""valB"");
    var encryptionContext := map[keyB := valB, keyA := valA];
    TestUtils.ValidSmallEncryptionContext(encryptionContext);
    var expectedSerializedAAD := [0, 2, 0, 4, 107, 101, 121, 65, 0, 4, 118, 97, 108, 65, 0, 4, 107, 101, 121, 66, 0, 4, 118, 97, 108, 66];
    var len :- SerializeKVPairs(wr, encryptionContext);
    expect wr.GetDataWritten() == expectedSerializedAAD, ""expectation violation""
  }

  method {:test} TestSerializeKVPairsEmpty()
  {
    reveal EncryptionContext.Serializable();
    var wr := new Streams.ByteWriter();
    var encryptionContext := map[];
    var expectedSerializedAAD := [];
    var len :- SerializeKVPairs(wr, encryptionContext);
    expect wr.GetDataWritten() == expectedSerializedAAD, ""expectation violation""
  }
}

module TestBase64 {

  import opened Wrappers = Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened Base64 = Base64
  const BASE64_TEST_VECTORS_ENCODED := ["""", ""VA=="", ""VGU="", ""VGVz"", ""VGVzdA=="", ""VGVzdGk="", ""VGVzdGlu"", ""VGVzdGluZw=="", ""VGVzdGluZys="", ""VGVzdGluZysx""]
  const BASE64_TEST_VECTORS_DECODED := ["""", ""T"", ""Te"", ""Tes"", ""Test"", ""Testi"", ""Testin"", ""Testing"", ""Testing+"", ""Testing+1""]
  const BASE64_TEST_VECTORS_DECODED_UINT8: seq<seq<uint8>> := [[], [84], [84, 101], [84, 101, 115], [84, 101, 115, 116], [84, 101, 115, 116, 105], [84, 101, 115, 116, 105, 110], [84, 101, 115, 116, 105, 110, 103], [84, 101, 115, 116, 105, 110, 103, 43], [84, 101, 115, 116, 105, 110, 103, 43, 49]]
  const BASE64_CHARS := ""+/0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz""

  lemma {:axiom} Base64TestVectorIsValid(i: int)
    requires 0 <= i < |BASE64_TEST_VECTORS_ENCODED|
    ensures IsBase64String(BASE64_TEST_VECTORS_ENCODED[i])
    decreases i

  method {:test} TestIsBase64CharSuccess()
  {
    expect forall c: char :: c in BASE64_CHARS ==> IsBase64Char(c), ""expectation violation""
  }

  method {:test} TestIsBase64CharFailure()
  {
    expect forall c: char :: c !in BASE64_CHARS ==> !IsBase64Char(c), ""expectation violation""
  }

  method {:test} TestIsUnpaddedBase64StringSuccess()
  {
    expect IsUnpaddedBase64String(""VGVz""), ""expectation violation""
  }

  method {:test} TestIsUnpaddedBase64StringTooShort()
  {
    expect !IsUnpaddedBase64String(""VGV""), ""expectation violation""
  }

  method {:test} TestIsUnpaddedBase64StringNotBase64()
  {
    expect !IsUnpaddedBase64String(""VGV$""), ""expectation violation""
  }

  method {:test} TestIndexToChar63()
  {
    expect IndexToChar(63) == '/', ""expectation violation""
  }

  method {:test} TestIndexToChar62()
  {
    expect IndexToChar(62) == '+', ""expectation violation""
  }

  method {:test} TestIndexToCharDigits()
  {
    var digits := ""0123456789"";
    expect forall i: index :: 52 <= i <= 61 ==> IndexToChar(i) in digits, ""expectation violation""
  }

  method {:test} TestIndexToCharLowercase()
  {
    var lowercase := ""abcdefghijklmnopqrstuvwxyz"";
    expect forall i: index :: 26 <= i <= 51 ==> IndexToChar(i) in lowercase, ""expectation violation""
  }

  method {:test} TestIndexToCharUppercase()
  {
    var uppercase := ""ABCDEFGHIJKLMNOPQRSTUVWXYZ"";
    expect forall i: index :: 0 <= i <= 25 ==> IndexToChar(i) in uppercase, ""expectation violation""
  }

  method {:test} TestCharToIndex63()
  {
    expect CharToIndex('/') == 63, ""expectation violation""
  }

  method {:test} TestCharToIndex62()
  {
    expect CharToIndex('+') == 62, ""expectation violation""
  }

  method {:test} TestCharToIndexDigits()
  {
    var digits := ""0123456789"";
    expect forall i: int :: 0 <= i < |digits| ==> CharToIndex(digits[i]) == (i + 52) as index, ""expectation violation""
  }

  method {:test} TestCharToIndexLowercase()
  {
    var lowercase := ""abcdefghijklmnopqrstuvwxyz"";
    expect forall i: int :: 0 <= i < |lowercase| ==> CharToIndex(lowercase[i]) == (i + 26) as index, ""expectation violation""
  }

  method {:test} TestCharToIndexUppercase()
  {
    var uppercase := ""ABCDEFGHIJKLMNOPQRSTUVWXYZ"";
    expect forall i: int :: 0 <= i < |uppercase| ==> CharToIndex(uppercase[i]) == i as index, ""expectation violation""
  }

  method {:test} TestUInt24ToSeq()
  {
    var input: uint24 := 1048833;
    var output := [16, 1, 1];
    expect output == UInt24ToSeq(input), ""expectation violation""
  }

  method {:test} TestSeqToUInt24()
  {
    var input := [16, 1, 1];
    var output: uint24 := 1048833;
    expect output == SeqToUInt24(input), ""expectation violation""
  }

  method {:test} TestUInt24ToIndexSeq()
  {
    var input: uint24 := 1048833;
    var output := [4, 0, 4, 1];
    expect output == UInt24ToIndexSeq(input), ""expectation violation""
  }

  method {:test} TestIndexSeqToUInt24()
  {
    var input := [4, 0, 4, 1];
    var output: uint24 := 1048833;
    expect output == IndexSeqToUInt24(input), ""expectation violation""
  }

  method {:test} TestDecodeBlock()
  {
    var input := [4, 0, 4, 1];
    var output := [16, 1, 1];
    expect output == DecodeBlock(input), ""expectation violation""
  }

  method {:test} TestEncodeBlock()
  {
    var input := [16, 1, 1];
    var output := [4, 0, 4, 1];
    expect output == EncodeBlock(input), ""expectation violation""
  }

  method {:test} TestDecodeRecursively()
  {
    var input := [4, 0, 4, 1, 4, 0, 4, 1];
    var output := [16, 1, 1, 16, 1, 1];
    expect output == DecodeRecursively(input), ""expectation violation""
  }

  method {:test} TestEncodeRecursively()
  {
    var input := [16, 1, 1, 16, 1, 1];
    var output := [4, 0, 4, 1, 4, 0, 4, 1];
    expect output == EncodeRecursively(input), ""expectation violation""
  }

  method {:test} TestFromCharsToIndices()
  {
    var input := ""aA1+/"";
    var output := [26, 0, 53, 62, 63];
    expect output == FromCharsToIndices(input), ""expectation violation""
  }

  method {:test} TestFromIndicesToChars()
  {
    var input := [26, 0, 53, 62, 63];
    var output := ""aA1+/"";
    expect output == FromIndicesToChars(input), ""expectation violation""
  }

  method {:test} TestDecodeUnpadded()
  {
    var input := ""VGVzdGluZysx"";
    var output := [84, 101, 115, 116, 105, 110, 103, 43, 49];
    expect output == DecodeUnpadded(input), ""expectation violation""
  }

  method {:test} TestEncodeUnpadded()
  {
    var input := [84, 101, 115, 116, 105, 110, 103, 43, 49];
    var output := ""VGVzdGluZysx"";
    expect output == EncodeUnpadded(input), ""expectation violation""
  }

  method {:test} TestDecodeUnpaddedEmpty()
  {
    expect [] == DecodeUnpadded([]), ""expectation violation""
  }

  method {:test} TestEncodeUnpaddedEmpty()
  {
    expect [] == EncodeUnpadded([]), ""expectation violation""
  }

  method {:test} TestIs1PaddingSuccess()
  {
    expect Is1Padding(""VGU=""), ""expectation violation""
  }

  method {:test} TestIs1PaddingTooShort()
  {
    expect !Is1Padding(""VG=""), ""expectation violation""
  }

  method {:test} TestIs1PaddingTooLong()
  {
    expect !Is1Padding(""VGUU=""), ""expectation violation""
  }

  method {:test} TestIs1PaddingInvalidChar0()
  {
    expect !Is1Padding(""$GU=""), ""expectation violation""
  }

  method {:test} TestIs1PaddingInvalidChar1()
  {
    expect !Is1Padding(""V$U=""), ""expectation violation""
  }

  method {:test} TestIs1PaddingInvalidChar2()
  {
    expect !Is1Padding(""VG$=""), ""expectation violation""
  }

  method {:test} TestIs1PaddingInvalidChar3()
  {
    expect !Is1Padding(""VGVz""), ""expectation violation""
  }

  method {:test} TestIs1PaddingInvalidChar2Modulus()
  {
    expect !Is1Padding(""VGV=""), ""expectation violation""
  }

  method {:test} TestDecode1Padding()
  {
    var input := ""VGU="";
    var output := [84, 101];
    expect output == Decode1Padding(input), ""expectation violation""
  }

  method {:test} TestEncode1Padding()
  {
    var input := [84, 101];
    var output := ""VGU="";
    expect output == Encode1Padding(input), ""expectation violation""
  }

  method {:test} TestIs2PaddingSuccess()
  {
    expect Is2Padding(""VA==""), ""expectation violation""
  }

  method {:test} TestIs2PaddingTooShort()
  {
    expect !Is2Padding(""VA=""), ""expectation violation""
  }

  method {:test} TestIs2PaddingTooLong()
  {
    expect !Is2Padding(""VAA==""), ""expectation violation""
  }

  method {:test} TestIs2PaddingInvalidChar0()
  {
    expect !Is2Padding(""$A==""), ""expectation violation""
  }

  method {:test} TestIs2PaddingInvalidChar1()
  {
    expect !Is2Padding(""V$==""), ""expectation violation""
  }

  method {:test} TestIs2PaddingInvalidChar2()
  {
    expect !Is2Padding(""VAA=""), ""expectation violation""
  }

  method {:test} TestIs2PaddingInvalidChar3()
  {
    expect !Is2Padding(""VA=A""), ""expectation violation""
  }

  method {:test} TestIs2PaddingInvalidChar1Modulus()
  {
    expect !Is2Padding(""VB==""), ""expectation violation""
  }

  method {:test} TestDecode2Padding()
  {
    var input := ""VA=="";
    var output := [84];
    expect output == Decode2Padding(input), ""expectation violation""
  }

  method {:test} TestEncode2Padding()
  {
    var input := [84];
    var output := ""VA=="";
    expect output == Encode2Padding(input), ""expectation violation""
  }

  method {:test} TestIsBase64StringTestVectors()
  {
    expect forall i: string :: i in BASE64_TEST_VECTORS_ENCODED ==> IsBase64String(i) == true, ""expectation violation""
  }

  method {:test} TestIsBase64StringBadLength()
  {
    expect !IsBase64String(""VG=""), ""expectation violation""
  }

  method {:test} TestIsBase64StringBadString()
  {
    expect !IsBase64String(""VC==""), ""expectation violation""
  }

  method {:test} TestSanityCheckDecodedTestVectors()
  {
    var testVectorIndex := 0;
    while testVectorIndex < |BASE64_TEST_VECTORS_DECODED|
      invariant 0 <= testVectorIndex <= |BASE64_TEST_VECTORS_DECODED|
      decreases |BASE64_TEST_VECTORS_DECODED| - testVectorIndex
    {
      var uint8Message: seq<uint8> := [];
      var strMessage := BASE64_TEST_VECTORS_DECODED[testVectorIndex];
      var msgIndex := 0;
      while msgIndex < |strMessage|
        invariant 0 <= msgIndex <= |strMessage|
        decreases |strMessage| - msgIndex
      {
        uint8Message := uint8Message + [strMessage[msgIndex] as uint8];
        msgIndex := msgIndex + 1;
      }
      expect BASE64_TEST_VECTORS_DECODED_UINT8[testVectorIndex] == uint8Message, ""expectation violation""
      testVectorIndex := testVectorIndex + 1;
    }
  }

  method {:test} TestDecodeValidTestVectors()
  {
    expect forall i: int :: 0 <= i < |BASE64_TEST_VECTORS_ENCODED| ==> DecodeValid(BASE64_TEST_VECTORS_ENCODED[i]) == BASE64_TEST_VECTORS_DECODED_UINT8[i], ""expectation violation""
  }

  method {:test} TestDecodeTestVectors()
  {
    expect forall i: int :: 0 <= i < |BASE64_TEST_VECTORS_ENCODED| ==> Decode(BASE64_TEST_VECTORS_ENCODED[i]) == Success(BASE64_TEST_VECTORS_DECODED_UINT8[i]), ""expectation violation""
  }

  method {:test} TestDecodeFailure()
  {
    expect Failure(""The encoding is malformed"") == Decode(""$""), ""expectation violation""
  }

  method {:test} TestEncode()
  {
    expect forall i: int :: 0 <= i < |BASE64_TEST_VECTORS_DECODED_UINT8| ==> Encode(BASE64_TEST_VECTORS_DECODED_UINT8[i]) == BASE64_TEST_VECTORS_ENCODED[i], ""expectation violation""
  }

  method {:test} TestEncodeDecode()
  {
    expect forall i: int :: 0 <= i < |BASE64_TEST_VECTORS_DECODED_UINT8| ==> Decode(Encode(BASE64_TEST_VECTORS_DECODED_UINT8[i])) == Success(BASE64_TEST_VECTORS_DECODED_UINT8[i]), ""expectation violation""
  }

  method {:test} TestDecodeEncode()
  {
    expect forall i: int :: 0 <= i < |BASE64_TEST_VECTORS_ENCODED| ==> Decode(BASE64_TEST_VECTORS_ENCODED[i]).Success? && Encode(Decode(BASE64_TEST_VECTORS_ENCODED[i]).value) == BASE64_TEST_VECTORS_ENCODED[i], ""expectation violation""
  }
}

module TestStandardLibrary {

  import opened Wrappers = Wrappers

  import opened StandardLibrary = StandardLibrary
  method {:test} TestJoinMultiElementSeq()
  {
    var input := [""comma"", ""separated"", ""list""];
    var output := Join(input, "","");
    expect ""comma,separated,list"" == output, ""expectation violation""
  }

  method {:test} TestJoinSingleElementSeq()
  {
    var input := [""one""];
    var output := Join(input, "","");
    expect ""one"" == output, ""expectation violation""
  }

  method {:test} TestJoinSplit()
  {
    var input := ""comma,separated,list"";
    var output := Join(Split(input, ','), "","");
    expect input == output, ""expectation violation""
  }

  method {:test} TestSplitJoin()
  {
    var input := [""comma"", ""separated"", ""list""];
    var output := Split(Join(input, "",""), ',');
    expect input == output, ""expectation violation""
  }

  method {:test} TestSplitByteSeq()
  {
    var input := ""comma,separated,list"";
    var output := Split(input, ',');
    expect [""comma"", ""separated"", ""list""] == output, ""expectation violation""
  }

  method {:test} TestSplitNumSeq()
  {
    var input := [1, 2, 3, 0, 1, 2, 3];
    var output := Split(input, 0);
    expect [[1, 2, 3], [1, 2, 3]] == output, ""expectation violation""
  }

  method {:test} TestSplitFinalElementDelim()
  {
    var input := ""one,"";
    var output := Split(input, ',');
    expect [""one"", """"] == output, ""expectation violation""
  }

  method {:test} TestSplitNoDelim()
  {
    var input := ""no comma"";
    var output := Split(input, ',');
    expect [""no comma""] == output, ""expectation violation""
  }

  method {:test} TestSplitOnlyElemIsDelim()
  {
    var input := "","";
    var output := Split(input, ',');
    expect ["""", """"] == output, ""expectation violation""
  }

  method {:test} TestSplitEmpty()
  {
    var input := """";
    var output := Split(input, ',');
    expect [""""] == output, ""expectation violation""
  }

  method {:test} TestFindIndexMatchingSimple()
  {
    var input := ""abcd"";
    var output := FindIndexMatching(input, 'c', 0);
    expect Some(2) == output, ""expectation violation""
  }

  method {:test} TestFindIndexMatchingDuplicates()
  {
    var input := ""abcdc"";
    var output := FindIndexMatching(input, 'c', 0);
    expect Some(2) == output, ""expectation violation""
  }

  method {:test} TestFindIndexMatchingNone()
  {
    var input := ""abcd"";
    var output := FindIndexMatching(input, 'e', 0);
    expect None == output, ""expectation violation""
  }

  method {:test} TestFindIndexSimple()
  {
    var input := ""abcd"";
    var output := FindIndex(input, (x: char) => x == 'c', 0);
    expect Some(2) == output, ""expectation violation""
  }

  method {:test} TestFindIndexComplex()
  {
    var input := ""abcd"";
    var output := FindIndex(input, (x: char) => x in ""crepe"", 0);
    expect Some(2) == output, ""expectation violation""
  }

  method {:test} TestFindIndexDuplicates()
  {
    var input := ""abcdc"";
    var output := FindIndex(input, (x: char) => x == 'c', 0);
    expect Some(2) == output, ""expectation violation""
  }

  method {:test} TestFindIndexNone()
  {
    var input := ""abcd"";
    var output := FindIndex(input, (x: char) => false, 0);
    expect None == output, ""expectation violation""
  }

  predicate method TestFilterPredicate(entry: seq<char>)
    decreases entry
  {
    entry in [""a""]
  }

  method {:test} TestFilterSomeValid()
  {
    var input := [""a"", ""b"", ""a""];
    var output := Filter(input, TestFilterPredicate);
    expect [""a"", ""a""] == output, ""expectation violation""
  }

  method {:test} TestFilterNoneValid()
  {
    var input := [""c"", ""b"", ""c""];
    var output := Filter(input, TestFilterPredicate);
    expect [] == output, ""expectation violation""
  }

  method {:test} TestFilterNothing()
  {
    var input := [];
    var output := Filter(input, TestFilterPredicate);
    expect [] == output, ""expectation violation""
  }

  method {:test} TestFillZero()
  {
    var output := Fill(0, 50);
    expect seq(50, (_: int) => 0) == output, ""expectation violation""
  }

  method {:test} TestFillChars()
  {
    var output := Fill(""a"", 25);
    expect seq(25, (_: int) => ""a"") == output, ""expectation violation""
  }

  method {:test} TestMinPositives()
  {
    expect 1 == Min(1, 2), ""expectation violation""
  }

  method {:test} TestMinNegatives()
  {
    expect -2 == Min(-1, -2), ""expectation violation""
  }

  method {:test} TestMinPositivesNegatives()
  {
    expect -1 == Min(-1, 1), ""expectation violation""
  }

  method {:test} TestMinDuplicateNumber()
  {
    expect 0 == Min(0, 0), ""expectation violation""
  }

  method {:test} TestSeqToArray()
  {
    var input: seq<int> := [1, 2, 3];
    var output := SeqToArray(input);
    var expected := new int[3] ((i: nat) => i + 1);
    expect expected.Length == output.Length, ""expectation violation""
    expect expected[0] == output[0], ""expectation violation""
    expect expected[1] == output[1], ""expectation violation""
    expect expected[2] == output[2], ""expectation violation""
  }

  method {:test} TestSeqToArrayEmpty()
  {
    var input: seq<char> := [];
    var output := SeqToArray(input);
    expect 0 == output.Length, ""expectation violation""
  }

  predicate method TestStandardLibraryLessPredicate(a: int, b: int)
    decreases a, b
  {
    a < b
  }

  method {:test} TestLexicographicLessOrEqualTrue()
  {
    var a: seq<int> := [1, 2, 3];
    var b: seq<int> := [1, 2, 4];
    expect LexicographicLessOrEqual(a, b, TestStandardLibraryLessPredicate), ""expectation violation""
  }

  method {:test} TestLexicographicLessOrEqualFalse()
  {
    var a: seq<int> := [1, 2, 3];
    var b: seq<int> := [1, 2, 4];
    expect !LexicographicLessOrEqual(b, a, TestStandardLibraryLessPredicate), ""expectation violation""
  }

  method {:test} TestLexicographicLessOrEqualAllEqual()
  {
    var a: seq<int> := [1, 2, 3];
    var b: seq<int> := [1, 2, 3];
    expect LexicographicLessOrEqual(a, b, TestStandardLibraryLessPredicate), ""expectation violation""
  }

  method {:test} TestLexicographicLessOrEqualNoneEqual()
  {
    var a: seq<int> := [1];
    var b: seq<int> := [2];
    expect LexicographicLessOrEqual(a, b, TestStandardLibraryLessPredicate), ""expectation violation""
  }

  method {:test} TestLexicographicLessOrEqualEmpty()
  {
    var a: seq<int> := [];
    var b: seq<int> := [];
    expect LexicographicLessOrEqual(a, b, TestStandardLibraryLessPredicate), ""expectation violation""
  }
}

module TestUInt {

  import opened UInt = StandardLibrary.UInt
  method {:test} TestUInt16ToSeq()
  {
    var x: uint16 := 290;
    expect [1, 34] == UInt16ToSeq(x), ""expectation violation""
  }

  method {:test} TestSeqToUInt16()
  {
    var s := [1, 34];
    expect 290 as uint16 == SeqToUInt16(s), ""expectation violation""
  }

  method {:test} TestUInt32ToSeq()
  {
    var x := 16920644;
    expect [1, 2, 48, 68] == UInt32ToSeq(x), ""expectation violation""
  }

  method {:test} TestSeqToUInt32()
  {
    var s := [1, 2, 48, 68];
    expect 16920644 as uint32 == SeqToUInt32(s), ""expectation violation""
  }

  method {:test} TestUInt64ToSeq()
  {
    var x: uint64 := 72673614040037256;
    expect [1, 2, 48, 68, 85, 102, 119, 136] == UInt64ToSeq(x), ""expectation violation""
  }

  method {:test} TestSeqToUInt64()
  {
    var s := [1, 2, 48, 68, 85, 102, 119, 136];
    expect 72673614040037256 as uint64 == SeqToUInt64(s), ""expectation violation""
  }
}

module TestSeqReaderReadElements {

  import opened StandardLibrary = StandardLibrary

  import opened UInt = StandardLibrary.UInt

  import opened Sets = Sets
  method {:test} TestSetToOrderedSequenceEmpty()
  {
    var output := ComputeSetToOrderedSequence({}, UInt8Less);
    var expected := [];
    expect output == expected, ""expectation violation""
  }

  method {:test} TestSetToOrderedSequenceOneItem()
  {
    var a := {[0]};
    var output := ComputeSetToOrderedSequence(a, UInt8Less);
    var expected := [[0]];
    expect output == expected, ""expectation violation""
  }

  method {:test} TestSetToOrderedSequenceSimple()
  {
    var a := {[0, 2], [0, 1]};
    var output := ComputeSetToOrderedSequence(a, UInt8Less);
    var expected := [[0, 1], [0, 2]];
    expect output == expected, ""expectation violation""
  }

  method {:test} TestSetToOrderedSequencePrefix()
  {
    var a := {[0, 1, 2], [0, 1]};
    var output := ComputeSetToOrderedSequence(a, UInt8Less);
    var expected := [[0, 1], [0, 1, 2]];
    expect output == expected, ""expectation violation""
  }

  method {:test} TestSetToOrderedSequenceComplex()
  {
    var a := {[0, 1, 2], [1, 1, 2], [0, 1]};
    var output := ComputeSetToOrderedSequence(a, UInt8Less);
    var expected := [[0, 1], [0, 1, 2], [1, 1, 2]];
    expect output == expected, ""expectation violation""
  }

  method {:test} TestSetToOrderedSequenceManyItems()
  {
    var a := set x: uint16 {:trigger UInt16ToSeq(x)} | 0 <= x < 65535 :: UInt16ToSeq(x);
    var output := ComputeSetToOrderedSequence(a, UInt8Less);
    var expected: seq<seq<uint8>> := seq(65535, (i: int) requires 0 <= i < 65535 => UInt16ToSeq(i as uint16));
    expect output == expected, ""expectation violation""
  }
}

module TestStreams {

  import opened UInt = StandardLibrary.UInt

  import opened Streams = Streams
  method {:test} TestSeqReaderReadElements()
  {
    var s: seq<nat> := [0, 100, 200, 300, 400];
    var reader := new Streams.SeqReader<nat>(s);
    var res := reader.ReadElements(3);
    expect [0, 100, 200] == res, ""expectation violation""
    res := reader.ReadElements(0);
    expect [] == res, ""expectation violation""
    res := reader.ReadElements(2);
    expect [300, 400] == res, ""expectation violation""
  }

  method {:test} TestSeqReaderReadExact()
  {
    var s: seq<nat> := [0, 100, 200, 300, 400];
    var reader := new Streams.SeqReader<nat>(s);
    var res :- reader.ReadExact(3);
    expect [0, 100, 200] == res, ""expectation violation""
    res :- reader.ReadExact(0);
    expect [] == res, ""expectation violation""
    res :- reader.ReadExact(2);
    expect [300, 400] == res, ""expectation violation""
    var isFailure := reader.ReadExact(1);
    expect isFailure.Failure?, ""expectation violation""
  }

  method {:test} TestByteReader()
  {
    var s: seq<uint8> := [0, 3, 10, 20, 50, 100, 150, 200, 250, 255];
    var reader := new Streams.ByteReader(s);
    var uint8Res :- reader.ReadByte();
    var sizeRead := reader.GetSizeRead();
    var isDoneReading := reader.IsDoneReading();
    expect 0 == uint8Res, ""expectation violation""
    expect 1 == sizeRead, ""expectation violation""
    expect !isDoneReading, ""expectation violation""
    var sRes :- reader.ReadBytes(0);
    sizeRead := reader.GetSizeRead();
    isDoneReading := reader.IsDoneReading();
    expect [] == sRes, ""expectation violation""
    expect 1 == sizeRead, ""expectation violation""
    expect !isDoneReading, ""expectation violation""
    sRes :- reader.ReadBytes(3);
    sizeRead := reader.GetSizeRead();
    isDoneReading := reader.IsDoneReading();
    expect [3, 10, 20] == sRes, ""expectation violation""
    expect 4 == sizeRead, ""expectation violation""
    expect !isDoneReading, ""expectation violation""
    var uint16 :- reader.ReadUInt16();
    var expectedUint16 := SeqToUInt16([50, 100]);
    sizeRead := reader.GetSizeRead();
    isDoneReading := reader.IsDoneReading();
    expect expectedUint16 == uint16, ""expectation violation""
    expect 6 == sizeRead, ""expectation violation""
    expect !isDoneReading, ""expectation violation""
    var uint32 :- reader.ReadUInt32();
    var expectedUint32 := SeqToUInt32([150, 200, 250, 255]);
    sizeRead := reader.GetSizeRead();
    isDoneReading := reader.IsDoneReading();
    expect expectedUint32 == uint32, ""expectation violation""
    expect 10 == sizeRead, ""expectation violation""
    expect isDoneReading, ""expectation violation""
    var isByteFailure := reader.ReadByte();
    sizeRead := reader.GetSizeRead();
    isDoneReading := reader.IsDoneReading();
    expect isByteFailure.Failure?, ""expectation violation""
    expect 10 == sizeRead, ""expectation violation""
    expect isDoneReading, ""expectation violation""
    var isBytesFailure := reader.ReadBytes(1);
    sizeRead := reader.GetSizeRead();
    isDoneReading := reader.IsDoneReading();
    expect isBytesFailure.Failure?, ""expectation violation""
    expect 10 == sizeRead, ""expectation violation""
    expect isDoneReading, ""expectation violation""
    var isUint16Failure := reader.ReadUInt16();
    sizeRead := reader.GetSizeRead();
    isDoneReading := reader.IsDoneReading();
    expect isUint16Failure.Failure?, ""expectation violation""
    expect 10 == sizeRead, ""expectation violation""
    expect isDoneReading, ""expectation violation""
    var isUint32Failure := reader.ReadUInt32();
    sizeRead := reader.GetSizeRead();
    isDoneReading := reader.IsDoneReading();
    expect isUint32Failure.Failure?, ""expectation violation""
    expect 10 == sizeRead, ""expectation violation""
    expect isDoneReading, ""expectation violation""
  }

  method {:test} TestSeqWriter()
  {
    var writer := new Streams.SeqWriter<nat>();
    expect [] == writer.data, ""expectation violation""
    var elemSize := writer.WriteElements([]);
    expect 0 == elemSize, ""expectation violation""
    expect [] == writer.data, ""expectation violation""
    elemSize := writer.WriteElements([0, 100, 200]);
    expect 3 == elemSize, ""expectation violation""
    expect [0, 100, 200] == writer.data, ""expectation violation""
    elemSize := writer.WriteElements([300, 400, 500, 600]);
    expect 4 == elemSize, ""expectation violation""
    expect [0, 100, 200, 300, 400, 500, 600] == writer.data, ""expectation violation""
  }

  method {:test} TestByteWriter()
  {
    var writer := new Streams.ByteWriter();
    var dataWritten := writer.GetDataWritten();
    expect [] == dataWritten, ""expectation violation""
    var sizeWritten := writer.GetSizeWritten();
    expect 0 == sizeWritten, ""expectation violation""
    var res := writer.WriteByte(0);
    expect 1 == res, ""expectation violation""
    dataWritten := writer.GetDataWritten();
    expect [0] == dataWritten, ""expectation violation""
    sizeWritten := writer.GetSizeWritten();
    expect 1 == sizeWritten, ""expectation violation""
    res := writer.WriteBytes([]);
    expect 0 == res, ""expectation violation""
    dataWritten := writer.GetDataWritten();
    expect [0] == dataWritten, ""expectation violation""
    sizeWritten := writer.GetSizeWritten();
    expect 1 == sizeWritten, ""expectation violation""
    res := writer.WriteBytes([5, 50, 100]);
    expect 3 == res, ""expectation violation""
    dataWritten := writer.GetDataWritten();
    expect [0, 5, 50, 100] == dataWritten, ""expectation violation""
    sizeWritten := writer.GetSizeWritten();
    expect 4 == sizeWritten, ""expectation violation""
    var uint16Written := SeqToUInt16([150, 200]);
    res := writer.WriteUInt16(uint16Written);
    expect 2 == res, ""expectation violation""
    dataWritten := writer.GetDataWritten();
    expect [0, 5, 50, 100, 150, 200] == dataWritten, ""expectation violation""
    sizeWritten := writer.GetSizeWritten();
    expect 6 == sizeWritten, ""expectation violation""
    var uint32Written := SeqToUInt32([50, 150, 200, 255]);
    res := writer.WriteUInt32(uint32Written);
    expect 4 == res, ""expectation violation""
    dataWritten := writer.GetDataWritten();
    expect [0, 5, 50, 100, 150, 200, 50, 150, 200, 255] == dataWritten, ""expectation violation""
    sizeWritten := writer.GetSizeWritten();
    expect 10 == sizeWritten, ""expectation violation""
  }
}

module {:extern ""TestUtils""} TestUtils {

  import opened StandardLibrary = StandardLibrary

  import opened Wrappers = Wrappers

  import opened UInt = StandardLibrary.UInt

  import UTF8 = UTF8

  import Materials = Materials

  import EncryptionContext = EncryptionContext

  import MessageHeader = MessageHeader

  import RSA = RSAEncryption

  import RawRSAKeyringDef = RawRSAKeyringDef
  datatype SmallEncryptionContextVariation = Empty | A | AB | BA

  const SHARED_TEST_KEY_ARN := ""arn:aws:kms:us-west-2:658956600833:key/b3537ef1-d8dc-4780-9f5a-55776cbb2f7f""

  lemma {:axiom} AssumeLongSeqIsValidUTF8(s: seq<uint8>)
    requires |s| >= 4096
    ensures UTF8.ValidUTF8Seq(s)
    decreases s

  method GenerateInvalidEncryptionContext() returns (encCtx: EncryptionContext.Map)
    ensures !EncryptionContext.Serializable(encCtx)
  {
    var validUTF8char: UTF8.ValidUTF8Bytes :- UTF8.Encode(""a"");
    var key: UTF8.ValidUTF8Bytes := [];
    while |key| < UINT16_LIMIT
      decreases UINT16_LIMIT - |key|
    {
      UTF8.ValidUTF8Concat(key, validUTF8char);
      key := key + validUTF8char;
    }
    encCtx := map[key := [0]];
    reveal EncryptionContext.Serializable();
    assert !EncryptionContext.Serializable(encCtx);
  }

  method GenerateLargeValidEncryptionContext() returns (r: EncryptionContext.Map)
    ensures EncryptionContext.Serializable(r)
  {
    assert (65536 - 1 - 2) / (2 + 2 + 2 + 1) == (65536 - 3) / 7 == 9361;
    var numMaxPairs := 9361;
    var val :- UTF8.Encode(""a"");
    var encCtx: map<UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes> := map[];
    var i := 0;
    while |encCtx| < numMaxPairs && i < 65536
      invariant forall k: seq<uint8> :: k in encCtx ==> |k| + |encCtx[k]| == 3
      decreases 65536 - i
    {
      var key := UInt16ToSeq(i as uint16);
      if UTF8.ValidUTF8Seq(key) {
        encCtx := encCtx[key := val];
      }
      i := i + 1;
    }
    expect |encCtx| == numMaxPairs, ""expectation violation""
    assert EncryptionContext.Serializable(encCtx) by {
      reveal EncryptionContext.Serializable();
      assert EncryptionContext.Length(encCtx) < UINT16_LIMIT by {
        ghost var keys: seq<UTF8.ValidUTF8Bytes> := SetToOrderedSequence(encCtx.Keys, UInt.UInt8Less);
        ghost var kvPairs := seq(|keys|, (i: int) requires 0 <= i < |keys| => (keys[i], encCtx[keys[i]]));
        KVPairsLengthBound(kvPairs, |kvPairs|, 3);
        assert EncryptionContext.LinearLength(kvPairs, 0, |kvPairs|) <= 2 + numMaxPairs * 7;
      }
    }
    return encCtx;
  }

  method ExpectSerializableEncryptionContext(encCtx: EncryptionContext.Map)
    ensures EncryptionContext.Serializable(encCtx)
    decreases encCtx
  {
    var valid := EncryptionContext.CheckSerializable(encCtx);
    expect valid, ""expectation violation""
  }

  method ExpectNonSerializableEncryptionContext(encCtx: EncryptionContext.Map)
    decreases encCtx
  {
    var valid := EncryptionContext.CheckSerializable(encCtx);
    expect !valid, ""expectation violation""
  }

  method SmallEncryptionContext(v: SmallEncryptionContextVariation) returns (encryptionContext: EncryptionContext.Map)
    ensures EncryptionContext.Serializable(encryptionContext)
    ensures encryptionContext.Keys !! Materials.RESERVED_KEY_VALUES
    decreases v
  {
    var keyA :- UTF8.Encode(""keyA"");
    var valA :- UTF8.Encode(""valA"");
    var keyB :- UTF8.Encode(""keyB"");
    var valB :- UTF8.Encode(""valB"");
    match v {
      case {:split false} Empty() =>
        encryptionContext := map[];
      case {:split false} A() =>
        encryptionContext := map[keyA := valA];
      case {:split false} AB() =>
        encryptionContext := map[keyA := valA, keyB := valB];
      case {:split false} BA() =>
        encryptionContext := map[keyB := valB, keyA := valA];
    }
    ValidSmallEncryptionContext(encryptionContext);
  }

  lemma ValidSmallEncryptionContext(encryptionContext: EncryptionContext.Map)
    requires |encryptionContext| <= 5
    requires forall k: seq<uint8> :: k in encryptionContext.Keys ==> |k| < 100 && |encryptionContext[k]| < 100
    ensures EncryptionContext.Serializable(encryptionContext)
    decreases encryptionContext
  {
    reveal EncryptionContext.Serializable();
    assert EncryptionContext.Length(encryptionContext) < UINT16_LIMIT by {
      if |encryptionContext| != 0 {
        ghost var keys: seq<UTF8.ValidUTF8Bytes> := SetToOrderedSequence(encryptionContext.Keys, UInt.UInt8Less);
        ghost var kvPairs := seq(|keys|, (i: int) requires 0 <= i < |keys| => (keys[i], encryptionContext[keys[i]]));
        assert EncryptionContext.Length(encryptionContext) == 2 + EncryptionContext.LinearLength(kvPairs, 0, |kvPairs|);
        ghost var n := |kvPairs|;
        assert n <= 5;
        assert EncryptionContext.LinearLength(kvPairs, 0, n) <= n * 204 by {
          KVPairsLengthBound(kvPairs, |kvPairs|, 200);
        }
        assert n * 204 <= 1020 < UINT16_LIMIT;
      }
    }
  }

  lemma /*{:_induction kvPairs, n}*/ KVPairsLengthBound(kvPairs: EncryptionContext.Linear, n: nat, kvBound: int)
    requires n <= |kvPairs|
    requires forall i: int :: 0 <= i < n ==> |kvPairs[i].0| + |kvPairs[i].1| <= kvBound
    ensures EncryptionContext.LinearLength(kvPairs, 0, n) <= n * (4 + kvBound)
    decreases kvPairs, n, kvBound
  {
  }

  method MakeRSAKeyring() returns (res: Result<RawRSAKeyringDef.RawRSAKeyring, string>)
    ensures res.Success? ==> res.value.Valid()
    ensures res.Success? ==> fresh(res.value) && fresh(res.value.Repr)
  {
    var namespace :- UTF8.Encode(""namespace"");
    var name :- UTF8.Encode(""MyKeyring"");
    var ek, dk := RSA.GenerateKeyPair(2048, RSA.PKCS1);
    var keyring := new RawRSAKeyringDef.RawRSAKeyring(namespace, name, RSA.PaddingMode.PKCS1, Some(ek), Some(dk));
    return Success(keyring);
  }

  method NamespaceAndName(n: nat) returns (namespace: UTF8.ValidUTF8Bytes, name: UTF8.ValidUTF8Bytes)
    requires 0 <= n < 10
    ensures |namespace| < UINT16_LIMIT
    ensures |name| < UINT16_LIMIT
    decreases n
  {
    var s := ""child"" + [n as char + '0'];
    namespace :- UTF8.Encode(s + "" Namespace"");
    name :- UTF8.Encode(s + "" Name"");
  }
}

module TestUTF8 {

  import opened UInt = StandardLibrary.UInt

  import opened UTF8 = UTF8
  method {:test} TestEncodeHappyCase()
  {
    var unicodeString := ""abc\u0306\u01FD\u03B2"";
    var expectedBytes := [97, 98, 99, 204, 134, 199, 189, 206, 178];
    var encoded :- UTF8.Encode(unicodeString);
    expect expectedBytes == encoded, ""expectation violation""
  }

  method {:test} TestEncodeInvalidUnicode()
  {
    var invalidUnicode := ""abc\uD800"";
    var encoded := UTF8.Encode(invalidUnicode);
    expect encoded.Failure?, ""expectation violation""
  }

  method {:test} TestDecodeHappyCase()
  {
    var unicodeBytes := [97, 98, 99, 204, 134, 199, 189, 206, 178];
    assert UTF8.ValidUTF8Range(unicodeBytes, 3, 9);
    assert UTF8.ValidUTF8Range(unicodeBytes, 0, 9);
    var expectedString := ""abc\u0306\u01FD\u03B2"";
    var decoded :- UTF8.Decode(unicodeBytes);
    expect expectedString == decoded, ""expectation violation""
  }

  method {:test} TestDecodeInvalidUnicode()
  {
    var invalidUnicode := [97, 98, 99, 237, 160, 128];
    expect !ValidUTF8Seq(invalidUnicode), ""expectation violation""
  }

  method {:test} Test1Byte()
  {
    var decoded := ""\u0000"";
    var encoded :- UTF8.Encode(decoded);
    expect [0] == encoded, ""expectation violation""
    expect Uses1Byte(encoded), ""expectation violation""
    var redecoded :- UTF8.Decode(encoded);
    expect decoded == redecoded, ""expectation violation""
    decoded := ""\u0020"";
    encoded :- UTF8.Encode(decoded);
    expect [32] == encoded, ""expectation violation""
    expect Uses1Byte(encoded), ""expectation violation""
    redecoded :- UTF8.Decode(encoded);
    expect decoded == redecoded, ""expectation violation""
    decoded := ""$"";
    encoded :- UTF8.Encode(decoded);
    expect [36] == encoded, ""expectation violation""
    expect Uses1Byte(encoded), ""expectation violation""
    redecoded :- UTF8.Decode(encoded);
    expect decoded == redecoded, ""expectation violation""
    decoded := ""0"";
    encoded :- UTF8.Encode(decoded);
    expect [48] == encoded, ""expectation violation""
    expect Uses1Byte(encoded), ""expectation violation""
    redecoded :- UTF8.Decode(encoded);
    expect decoded == redecoded, ""expectation violation""
    decoded := ""A"";
    encoded :- UTF8.Encode(decoded);
    expect [65] == encoded, ""expectation violation""
    expect Uses1Byte(encoded), ""expectation violation""
    redecoded :- UTF8.Decode(encoded);
    expect decoded == redecoded, ""expectation violation""
    decoded := ""a"";
    encoded :- UTF8.Encode(decoded);
    expect [97] == encoded, ""expectation violation""
    expect Uses1Byte(encoded), ""expectation violation""
    redecoded :- UTF8.Decode(encoded);
    expect decoded == redecoded, ""expectation violation""
  }

  method {:test} Test2Bytes()
  {
    var decoded := ""\u00A3"";
    var encoded :- UTF8.Encode(decoded);
    expect [194, 163] == encoded, ""expectation violation""
    expect Uses2Bytes(encoded), ""expectation violation""
    var redecoded :- UTF8.Decode(encoded);
    expect decoded == redecoded, ""expectation violation""
    decoded := ""\u00A9"";
    encoded :- UTF8.Encode(decoded);
    expect [194, 169] == encoded, ""expectation violation""
    expect Uses2Bytes(encoded), ""expectation violation""
    redecoded :- UTF8.Decode(encoded);
    expect decoded == redecoded, ""expectation violation""
    decoded := ""\u00AE"";
    encoded :- UTF8.Encode(decoded);
    expect [194, 174] == encoded, ""expectation violation""
    expect Uses2Bytes(encoded), ""expectation violation""
    redecoded :- UTF8.Decode(encoded);
    expect decoded == redecoded, ""expectation violation""
    decoded := ""\u03C0"";
    encoded :- UTF8.Encode(decoded);
    expect [207, 128] == encoded, ""expectation violation""
    expect Uses2Bytes(encoded), ""expectation violation""
    redecoded :- UTF8.Decode(encoded);
    expect decoded == redecoded, ""expectation violation""
  }

  method {:test} Test3Bytes()
  {
    var decoded := ""\u2386"";
    var encoded :- UTF8.Encode(decoded);
    expect [226, 142, 134] == encoded, ""expectation violation""
    expect Uses3Bytes(encoded), ""expectation violation""
    var redecoded :- UTF8.Decode(encoded);
    expect decoded == redecoded, ""expectation violation""
    decoded := ""\u2387"";
    encoded :- UTF8.Encode(decoded);
    expect [226, 142, 135] == encoded, ""expectation violation""
    expect Uses3Bytes(encoded), ""expectation violation""
    redecoded :- UTF8.Decode(encoded);
    expect decoded == redecoded, ""expectation violation""
    decoded := ""\u231B"";
    encoded :- UTF8.Encode(decoded);
    expect [226, 140, 155] == encoded, ""expectation violation""
    expect Uses3Bytes(encoded), ""expectation violation""
    redecoded :- UTF8.Decode(encoded);
    expect decoded == redecoded, ""expectation violation""
    decoded := ""\u1D78"";
    encoded :- UTF8.Encode(decoded);
    expect [225, 181, 184] == encoded, ""expectation violation""
    expect Uses3Bytes(encoded), ""expectation violation""
    redecoded :- UTF8.Decode(encoded);
    expect decoded == redecoded, ""expectation violation""
    decoded := ""\u732B"";
    encoded :- UTF8.Encode(decoded);
    expect [231, 140, 171] == encoded, ""expectation violation""
    expect Uses3Bytes(encoded), ""expectation violation""
    redecoded :- UTF8.Decode(encoded);
    expect decoded == redecoded, ""expectation violation""
  }

  method {:test} Test4Bytes()
  {
    var decoded := ""\uD808\uDC00"";
    var encoded :- UTF8.Encode(decoded);
    expect [240, 146, 128, 128] == encoded, ""expectation violation""
    expect Uses4Bytes(encoded), ""expectation violation""
    var redecoded :- UTF8.Decode(encoded);
    expect decoded == redecoded, ""expectation violation""
    decoded := ""\uD835\uDFC1"";
    encoded :- UTF8.Encode(decoded);
    expect [240, 157, 159, 129] == encoded, ""expectation violation""
    expect Uses4Bytes(encoded), ""expectation violation""
    redecoded :- UTF8.Decode(encoded);
    expect decoded == redecoded, ""expectation violation""
  }
}

module Wrappers {
  datatype Option<+T> = None | Some(value: T) {
    function method ToResult(): Result<T, string>
      decreases this
    {
      match this
      case Some(v) =>
        Success(v)
      case None() =>
        Failure(""Option is None"")
    }

    function method UnwrapOr(default: T): T
      decreases this
    {
      match this
      case Some(v) =>
        v
      case None() =>
        default
    }

    predicate method IsFailure()
      decreases this
    {
      None?
    }

    function method PropagateFailure<U>(): Option<U>
      requires None?
      decreases this
    {
      None
    }

    function method Extract(): T
      requires Some?
      decreases this
    {
      value
    }
  }

  datatype Result<+T, +R> = Success(value: T) | Failure(error: R) {
    function method ToOption(): Option<T>
      decreases this
    {
      match this
      case Success(s) =>
        Some(s)
      case Failure(e) =>
        None()
    }

    function method UnwrapOr(default: T): T
      decreases this
    {
      match this
      case Success(s) =>
        s
      case Failure(e) =>
        default
    }

    predicate method IsFailure()
      decreases this
    {
      Failure?
    }

    function method PropagateFailure<U>(): Result<U, R>
      requires Failure?
      decreases this
    {
      Failure(this.error)
    }

    function method Extract(): T
      requires Success?
      decreases this
    {
      value
    }
  }

  datatype Outcome<E> = Pass | Fail(error: E) {
    predicate method IsFailure()
      decreases this
    {
      Fail?
    }

    function method PropagateFailure<U>(): Result<U, E>
      requires Fail?
      decreases this
    {
      Failure(this.error)
    }
  }

  function method Need<E>(condition: bool, error: E): (result: Outcome<E>)
    decreases condition
  {
    if condition then
      Pass
    else
      Fail(error)
  }
}

module Seq {

  import opened Wrappers = Wrappers

  import Math = Math
  function method First<T>(s: seq<T>): T
    requires |s| > 0
    decreases s
  {
    s[0]
  }

  function method DropFirst<T>(s: seq<T>): seq<T>
    requires |s| > 0
    decreases s
  {
    s[1..]
  }

  function method Last<T>(s: seq<T>): T
    requires |s| > 0
    decreases s
  {
    s[|s| - 1]
  }

  function method DropLast<T>(s: seq<T>): seq<T>
    requires |s| > 0
    decreases s
  {
    s[..|s| - 1]
  }

  lemma LemmaLast<T>(s: seq<T>)
    requires |s| > 0
    ensures DropLast(s) + [Last(s)] == s
    decreases s
  {
  }

  lemma LemmaAppendLast<T>(a: seq<T>, b: seq<T>)
    requires 0 < |a + b| && 0 < |b|
    ensures Last(a + b) == Last(b)
    decreases a, b
  {
  }

  lemma LemmaConcatIsAssociative<T>(a: seq<T>, b: seq<T>, c: seq<T>)
    ensures a + (b + c) == a + b + c
    decreases a, b, c
  {
  }

  predicate IsPrefix<T>(a: seq<T>, b: seq<T>)
    ensures IsPrefix(a, b) ==> |a| <= |b| && a == b[..|a|]
    decreases a, b
  {
    a <= b
  }

  predicate IsSuffix<T>(a: seq<T>, b: seq<T>)
    decreases a, b
  {
    |a| <= |b| &&
    a == b[|b| - |a|..]
  }

  lemma LemmaSplitAt<T>(s: seq<T>, pos: nat)
    requires pos < |s|
    ensures s[..pos] + s[pos..] == s
    decreases s, pos
  {
  }

  lemma LemmaElementFromSlice<T>(s: seq<T>, s': seq<T>, a: int, b: int, pos: nat)
    requires 0 <= a <= b <= |s|
    requires s' == s[a .. b]
    requires a <= pos < b
    ensures pos - a < |s'|
    ensures s'[pos - a] == s[pos]
    decreases s, s', a, b, pos
  {
  }

  lemma LemmaSliceOfSlice<T>(s: seq<T>, s1: int, e1: int, s2: int, e2: int)
    requires 0 <= s1 <= e1 <= |s|
    requires 0 <= s2 <= e2 <= e1 - s1
    ensures s[s1 .. e1][s2 .. e2] == s[s1 + s2 .. s1 + e2]
    decreases s, s1, e1, s2, e2
  {
  }

  method ToArray<T>(s: seq<T>) returns (a: array<T>)
    ensures fresh(a)
    ensures a.Length == |s|
    ensures forall i: int :: 0 <= i < |s| ==> a[i] == s[i]
    decreases s
  {
    a := new T[|s|] ((i: int) requires 0 <= i < |s| => s[i]);
  }

  function method {:opaque} {:fuel 0, 0} ToSet<T>(s: seq<T>): set<T>
    decreases s
  {
    set x: T {:trigger x in s} | x in s
  }

  lemma LemmaCardinalityOfSet<T>(s: seq<T>)
    ensures |ToSet(s)| <= |s|
    decreases s
  {
  }

  lemma LemmaCardinalityOfEmptySetIs0<T>(s: seq<T>)
    ensures |ToSet(s)| == 0 <==> |s| == 0
    decreases s
  {
  }

  predicate {:opaque} {:fuel 0, 0} HasNoDuplicates<T>(s: seq<T>)
    decreases s
  {
    forall i: int, j: int {:trigger s[i], s[j]} :: 
      0 <= i < |s| &&
      0 <= j < |s| &&
      i != j ==>
        s[i] != s[j]
  }

  lemma {:timeLimitMultiplier 3} /*{:_timeLimit 30}*/ LemmaNoDuplicatesInConcat<T>(a: seq<T>, b: seq<T>)
    requires HasNoDuplicates(a)
    requires HasNoDuplicates(b)
    requires multiset(a) !! multiset(b)
    ensures HasNoDuplicates(a + b)
    decreases a, b
  {
  }

  lemma LemmaCardinalityOfSetNoDuplicates<T>(s: seq<T>)
    requires HasNoDuplicates(s)
    ensures |ToSet(s)| == |s|
    decreases s
  {
  }

  lemma LemmaNoDuplicatesCardinalityOfSet<T>(s: seq<T>)
    requires |ToSet(s)| == |s|
    ensures HasNoDuplicates(s)
    decreases s
  {
  }

  lemma LemmaMultisetHasNoDuplicates<T>(s: seq<T>)
    requires HasNoDuplicates(s)
    ensures forall x: T {:trigger multiset(s)[x]} | x in multiset(s) :: multiset(s)[x] == 1
    decreases s
  {
  }

  function method {:opaque} {:fuel 0, 0} IndexOf<T(==)>(s: seq<T>, v: T): (i: nat)
    requires v in s
    ensures i < |s| && s[i] == v
    ensures forall j: int {:trigger s[j]} :: 0 <= j < i ==> s[j] != v
    decreases s
  {
    if s[0] == v then
      0
    else
      1 + IndexOf(s[1..], v)
  }

  function method {:opaque} {:fuel 0, 0} IndexOfOption<T(==)>(s: seq<T>, v: T): (o: Option<nat>)
    ensures if o.Some? then o.value < |s| && s[o.value] == v && forall j: int {:trigger s[j]} :: 0 <= j < o.value ==> s[j] != v else v !in s
    decreases s
  {
    if |s| == 0 then
      None()
    else if s[0] == v then
      Some(0)
    else
      var o': Option<nat> := IndexOfOption(s[1..], v); if o'.Some? then Some(o'.value + 1) else None()
  }

  function method {:opaque} {:fuel 0, 0} LastIndexOf<T(==)>(s: seq<T>, v: T): (i: nat)
    requires v in s
    ensures i < |s| && s[i] == v
    ensures forall j: int {:trigger s[j]} :: i < j < |s| ==> s[j] != v
    decreases s
  {
    if s[|s| - 1] == v then
      |s| - 1
    else
      LastIndexOf(s[..|s| - 1], v)
  }

  function method {:opaque} {:fuel 0, 0} LastIndexOfOption<T(==)>(s: seq<T>, v: T): (o: Option<nat>)
    ensures if o.Some? then o.value < |s| && s[o.value] == v && forall j: int {:trigger s[j]} :: o.value < j < |s| ==> s[j] != v else v !in s
    decreases s
  {
    if |s| == 0 then
      None()
    else if s[|s| - 1] == v then
      Some(|s| - 1)
    else
      LastIndexOfOption(s[..|s| - 1], v)
  }

  function method {:opaque} {:fuel 0, 0} Remove<T>(s: seq<T>, pos: nat): (s': seq<T>)
    requires pos < |s|
    ensures |s'| == |s| - 1
    ensures forall i: int {:trigger s'[i], s[i]} | 0 <= i < pos :: s'[i] == s[i]
    ensures forall i: int {:trigger s'[i]} | pos <= i < |s| - 1 :: s'[i] == s[i + 1]
    decreases s, pos
  {
    s[..pos] + s[pos + 1..]
  }

  function method {:opaque} {:fuel 0, 0} RemoveValue<T(==)>(s: seq<T>, v: T): (s': seq<T>)
    ensures v !in s ==> s == s'
    ensures v in s ==> |multiset(s')| == |multiset(s)| - 1
    ensures v in s ==> multiset(s')[v] == multiset(s)[v] - 1
    ensures HasNoDuplicates(s) ==> HasNoDuplicates(s') && ToSet(s') == ToSet(s) - {v}
    decreases s
  {
    reveal HasNoDuplicates();
    reveal ToSet();
    if v !in s then
      s
    else
      var i: nat := IndexOf(s, v); assert s == s[..i] + [v] + s[i + 1..]; s[..i] + s[i + 1..]
  }

  function method {:opaque} {:fuel 0, 0} Insert<T>(s: seq<T>, a: T, pos: nat): seq<T>
    requires pos <= |s|
    ensures |Insert(s, a, pos)| == |s| + 1
    ensures forall i: int {:trigger Insert(s, a, pos)[i], s[i]} :: 0 <= i < pos ==> Insert(s, a, pos)[i] == s[i]
    ensures forall i: int {:trigger s[i]} :: pos <= i < |s| ==> Insert(s, a, pos)[i + 1] == s[i]
    ensures Insert(s, a, pos)[pos] == a
    ensures multiset(Insert(s, a, pos)) == multiset(s) + multiset{a}
    decreases s, pos
  {
    assert s == s[..pos] + s[pos..];
    s[..pos] + [a] + s[pos..]
  }

  function method {:opaque} {:fuel 0, 0} Reverse<T>(s: seq<T>): (s': seq<T>)
    ensures |s'| == |s|
    ensures forall i: int {:trigger s'[i]} {:trigger s[|s| - i - 1]} :: 0 <= i < |s| ==> s'[i] == s[|s| - i - 1]
    decreases s
  {
    if s == [] then
      []
    else
      [s[|s| - 1]] + Reverse(s[0 .. |s| - 1])
  }

  function method {:opaque} {:fuel 0, 0} Repeat<T>(v: T, length: nat): (s: seq<T>)
    ensures |s| == length
    ensures forall i: nat {:trigger s[i]} | i < |s| :: s[i] == v
    decreases length
  {
    if length == 0 then
      []
    else
      [v] + Repeat(v, length - 1)
  }

  function method {:opaque} {:fuel 0, 0} Unzip<A, B>(s: seq<(A, B)>): (seq<A>, seq<B>)
    ensures |Unzip(s).0| == |Unzip(s).1| == |s|
    ensures forall i: int {:trigger Unzip(s).0[i]} {:trigger Unzip(s).1[i]} :: 0 <= i < |s| ==> (Unzip(s).0[i], Unzip(s).1[i]) == s[i]
    decreases s
  {
    if |s| == 0 then
      ([], [])
    else
      var (a: seq<A>, b: seq<B>) := Unzip(DropLast(s)); (a + [Last(s).0], b + [Last(s).1])
  }

  function method {:opaque} {:fuel 0, 0} Zip<A, B>(a: seq<A>, b: seq<B>): seq<(A, B)>
    requires |a| == |b|
    ensures |Zip(a, b)| == |a|
    ensures forall i: int {:trigger Zip(a, b)[i]} :: 0 <= i < |Zip(a, b)| ==> Zip(a, b)[i] == (a[i], b[i])
    ensures Unzip(Zip(a, b)).0 == a
    ensures Unzip(Zip(a, b)).1 == b
    decreases a, b
  {
    if |a| == 0 then
      []
    else
      Zip(DropLast(a), DropLast(b)) + [(Last(a), Last(b))]
  }

  lemma /*{:_induction s}*/ LemmaZipOfUnzip<A, B>(s: seq<(A, B)>)
    ensures Zip(Unzip(s).0, Unzip(s).1) == s
    decreases s
  {
  }

  function method {:opaque} {:fuel 0, 0} Max(s: seq<int>): int
    requires 0 < |s|
    ensures forall k: int {:trigger k in s} :: k in s ==> Max(s) >= k
    ensures Max(s) in s
    decreases s
  {
    assert s == [s[0]] + s[1..];
    if |s| == 1 then
      s[0]
    else
      Math.Max(s[0], Max(s[1..]))
  }

  lemma /*{:_induction a, b}*/ LemmaMaxOfConcat(a: seq<int>, b: seq<int>)
    requires 0 < |a| && 0 < |b|
    ensures Max(a + b) >= Max(a)
    ensures Max(a + b) >= Max(b)
    ensures forall i: int {:trigger i in [Max(a + b)]} :: i in a + b ==> Max(a + b) >= i
    decreases a, b
  {
  }

  function method {:opaque} {:fuel 0, 0} Min(s: seq<int>): int
    requires 0 < |s|
    ensures forall k: int {:trigger k in s} :: k in s ==> Min(s) <= k
    ensures Min(s) in s
    decreases s
  {
    assert s == [s[0]] + s[1..];
    if |s| == 1 then
      s[0]
    else
      Math.Min(s[0], Min(s[1..]))
  }

  lemma /*{:_induction a, b}*/ LemmaMinOfConcat(a: seq<int>, b: seq<int>)
    requires 0 < |a| && 0 < |b|
    ensures Min(a + b) <= Min(a)
    ensures Min(a + b) <= Min(b)
    ensures forall i: int {:trigger i in a + b} :: i in a + b ==> Min(a + b) <= i
    decreases a, b
  {
  }

  lemma /*{:_induction s}*/ LemmaSubseqMax(s: seq<int>, from: nat, to: nat)
    requires from < to <= |s|
    ensures Max(s[from .. to]) <= Max(s)
    decreases s, from, to
  {
  }

  lemma /*{:_induction s}*/ LemmaSubseqMin(s: seq<int>, from: nat, to: nat)
    requires from < to <= |s|
    ensures Min(s[from .. to]) >= Min(s)
    decreases s, from, to
  {
  }

  function method Flatten<T>(s: seq<seq<T>>): seq<T>
    decreases |s|
  {
    if |s| == 0 then
      []
    else
      s[0] + Flatten(s[1..])
  }

  lemma /*{:_induction a, b}*/ LemmaFlattenConcat<T>(a: seq<seq<T>>, b: seq<seq<T>>)
    ensures Flatten(a + b) == Flatten(a) + Flatten(b)
    decreases a, b
  {
  }

  function method FlattenReverse<T>(s: seq<seq<T>>): seq<T>
    decreases |s|
  {
    if |s| == 0 then
      []
    else
      FlattenReverse(DropLast(s)) + Last(s)
  }

  lemma /*{:_induction a, b}*/ LemmaFlattenReverseConcat<T>(a: seq<seq<T>>, b: seq<seq<T>>)
    ensures FlattenReverse(a + b) == FlattenReverse(a) + FlattenReverse(b)
    decreases a, b
  {
  }

  lemma /*{:_induction s}*/ LemmaFlattenAndFlattenReverseAreEquivalent<T>(s: seq<seq<T>>)
    ensures Flatten(s) == FlattenReverse(s)
    decreases s
  {
  }

  lemma /*{:_induction s}*/ LemmaFlattenLengthGeSingleElementLength<T>(s: seq<seq<T>>, i: int)
    requires 0 <= i < |s|
    ensures |FlattenReverse(s)| >= |s[i]|
    decreases s, i
  {
  }

  lemma /*{:_induction s}*/ LemmaFlattenLengthLeMul<T>(s: seq<seq<T>>, j: int)
    requires forall i: int {:trigger s[i]} | 0 <= i < |s| :: |s[i]| <= j
    ensures |FlattenReverse(s)| <= |s| * j
    decreases s, j
  {
  }

  function method {:opaque} {:fuel 0, 0} Map<T, R>(f: T ~> R, s: seq<T>): (result: seq<R>)
    requires forall i: int {:trigger s[i]} :: 0 <= i < |s| ==> f.requires(s[i])
    reads set i: int, o: object? {:trigger o in f.reads(s[i])} | 0 <= i < |s| && o in f.reads(s[i]) :: o
    ensures |result| == |s|
    ensures forall i: int {:trigger result[i]} :: 0 <= i < |s| ==> result[i] == f(s[i])
    decreases set i: int, o: object? {:trigger o in f.reads(s[i])} | 0 <= i < |s| && o in f.reads(s[i]) :: o, s
  {
    if |s| == 0 then
      []
    else
      [f(s[0])] + Map(f, s[1..])
  }

  lemma {:opaque} /*{:_induction f, a, b}*/ LemmaMapDistributesOverConcat<T, R>(f: T ~> R, a: seq<T>, b: seq<T>)
    requires forall i: int {:trigger a[i]} :: 0 <= i < |a| ==> f.requires(a[i])
    requires forall j: int {:trigger b[j]} :: 0 <= j < |b| ==> f.requires(b[j])
    ensures Map(f, a + b) == Map(f, a) + Map(f, b)
    decreases a, b
  {
  }

  function method {:opaque} {:fuel 0, 0} Filter<T>(f: T ~> bool, s: seq<T>): (result: seq<T>)
    requires forall i: int :: 0 <= i < |s| ==> f.requires(s[i])
    reads f.reads
    ensures |result| <= |s|
    ensures forall i: nat {:trigger result[i]} :: i < |result| && f.requires(result[i]) ==> f(result[i])
    decreases set _x0: T, _o0: object? | _o0 in f.reads(_x0) :: _o0, s
  {
    if |s| == 0 then
      []
    else
      (if f(s[0]) then [s[0]] else []) + Filter(f, s[1..])
  }

  lemma {:opaque} /*{:_induction f, a, b}*/ LemmaFilterDistributesOverConcat<T>(f: T ~> bool, a: seq<T>, b: seq<T>)
    requires forall i: int {:trigger a[i]} :: 0 <= i < |a| ==> f.requires(a[i])
    requires forall j: int {:trigger b[j]} :: 0 <= j < |b| ==> f.requires(b[j])
    ensures Filter(f, a + b) == Filter(f, a) + Filter(f, b)
    decreases a, b
  {
  }

  function method {:opaque} {:fuel 0, 0} FoldLeft<A, T>(f: (A, T) -> A, init: A, s: seq<T>): A
    decreases s
  {
    if |s| == 0 then
      init
    else
      FoldLeft(f, f(init, s[0]), s[1..])
  }

  lemma {:opaque} /*{:_induction f, a, b}*/ LemmaFoldLeftDistributesOverConcat<A, T>(f: (A, T) -> A, init: A, a: seq<T>, b: seq<T>)
    requires 0 <= |a + b|
    ensures FoldLeft(f, init, a + b) == FoldLeft(f, FoldLeft(f, init, a), b)
    decreases a, b
  {
  }

  predicate InvFoldLeft<A(!new), B(!new)>(inv: (B, seq<A>) -> bool, stp: (B, A, B) -> bool)
  {
    forall x: A, xs: seq<A>, b: B, b': B :: 
      inv(b, [x] + xs) &&
      stp(b, x, b') ==>
        inv(b', xs)
  }

  lemma /*{:_induction f, xs}*/ LemmaInvFoldLeft<A, B>(inv: (B, seq<A>) -> bool, stp: (B, A, B) -> bool, f: (B, A) -> B, b: B, xs: seq<A>)
    requires InvFoldLeft(inv, stp)
    requires forall b: B, a: A :: stp(b, a, f(b, a))
    requires inv(b, xs)
    ensures inv(FoldLeft(f, b, xs), [])
    decreases xs
  {
  }

  function method {:opaque} {:fuel 0, 0} FoldRight<A, T>(f: (T, A) -> A, s: seq<T>, init: A): A
    decreases s
  {
    if |s| == 0 then
      init
    else
      f(s[0], FoldRight(f, s[1..], init))
  }

  lemma {:opaque} /*{:_induction f, a, b}*/ LemmaFoldRightDistributesOverConcat<A, T>(f: (T, A) -> A, init: A, a: seq<T>, b: seq<T>)
    requires 0 <= |a + b|
    ensures FoldRight(f, a + b, init) == FoldRight(f, a, FoldRight(f, b, init))
    decreases a, b
  {
  }

  predicate InvFoldRight<A(!new), B(!new)>(inv: (seq<A>, B) -> bool, stp: (A, B, B) -> bool)
  {
    forall x: A, xs: seq<A>, b: B, b': B :: 
      inv(xs, b) &&
      stp(x, b, b') ==>
        inv([x] + xs, b')
  }

  lemma /*{:_induction f, xs}*/ LemmaInvFoldRight<A, B>(inv: (seq<A>, B) -> bool, stp: (A, B, B) -> bool, f: (A, B) -> B, b: B, xs: seq<A>)
    requires InvFoldRight(inv, stp)
    requires forall a: A, b: B :: stp(a, b, f(a, b))
    requires inv([], b)
    ensures inv(xs, FoldRight(f, xs, b))
    decreases xs
  {
  }
}

module Math {
  function method Min(a: int, b: int): int
    decreases a, b
  {
    if a < b then
      a
    else
      b
  }

  function method Max(a: int, b: int): int
    decreases a, b
  {
    if a < b then
      b
    else
      a
  }
}
")]

// Copyright by the contributors to the Dafny Project
// SPDX-License-Identifier: MIT

#if ISDAFNYRUNTIMELIB
using System; // for Func
using System.Numerics;
#endif

namespace DafnyAssembly {
  [AttributeUsage(AttributeTargets.Assembly)]
  public class DafnySourceAttribute : Attribute {
    public readonly string dafnySourceText;
    public DafnySourceAttribute(string txt) { dafnySourceText = txt; }
  }
}

namespace Dafny
{
  using System.Collections.Generic;
  using System.Collections.Immutable;
  using System.Linq;

  public interface ISet<out T>
  {
    int Count { get; }
    long LongCount { get; }
    IEnumerable<T> Elements { get; }
    IEnumerable<ISet<T>> AllSubsets { get; }
    bool Contains<G>(G t);
    bool EqualsAux(ISet<object> other);
    ISet<U> DowncastClone<U>(Func<T, U> converter);
  }

  public class Set<T> : ISet<T>
  {
    readonly ImmutableHashSet<T> setImpl;
    readonly bool containsNull;
    Set(ImmutableHashSet<T> d, bool containsNull) {
      this.setImpl = d;
      this.containsNull = containsNull;
    }
    public static readonly ISet<T> Empty = new Set<T>(ImmutableHashSet<T>.Empty, false);

    private static readonly TypeDescriptor<ISet<T>> _TYPE = new Dafny.TypeDescriptor<ISet<T>>(Empty);
    public static TypeDescriptor<ISet<T>> _TypeDescriptor() {
      return _TYPE;
    }

    public static ISet<T> FromElements(params T[] values) {
      return FromCollection(values);
    }

    public static Set<T> FromISet(ISet<T> s) {
      return s as Set<T> ?? FromCollection(s.Elements);
    }
    public static Set<T> FromCollection(IEnumerable<T> values) {
      var d = ImmutableHashSet<T>.Empty.ToBuilder();
      var containsNull = false;
      foreach (T t in values) {
        if (t == null) {
          containsNull = true;
        } else {
          d.Add(t);
        }
      }
      return new Set<T>(d.ToImmutable(), containsNull);
    }
    public static ISet<T> FromCollectionPlusOne(IEnumerable<T> values, T oneMoreValue) {
      var d = ImmutableHashSet<T>.Empty.ToBuilder();
      var containsNull = false;
      if (oneMoreValue == null) {
        containsNull = true;
      } else {
        d.Add(oneMoreValue);
      }
      foreach (T t in values) {
        if (t == null) {
          containsNull = true;
        } else {
          d.Add(t);
        }
      }
      return new Set<T>(d.ToImmutable(), containsNull);
    }
    public ISet<U> DowncastClone<U>(Func<T, U> converter) {
      if (this is ISet<U> th) {
        return th;
      } else {
        var d = ImmutableHashSet<U>.Empty.ToBuilder();
        foreach (var t in this.setImpl) {
          var u = converter(t);
          d.Add(u);
        }
        return new Set<U>(d.ToImmutable(), this.containsNull);
      }
    }
    public int Count {
      get { return this.setImpl.Count + (containsNull ? 1 : 0); }
    }
    public long LongCount {
      get { return this.setImpl.Count + (containsNull ? 1 : 0); }
    }
    public IEnumerable<T> Elements {
      get {
        if (containsNull) {
          yield return default(T);
        }
        foreach (var t in this.setImpl) {
          yield return t;
        }
      }
    }

    /// <summary>
    /// This is an inefficient iterator for producing all subsets of "this".
    /// </summary>
    public IEnumerable<ISet<T>> AllSubsets {
      get {
        // Start by putting all set elements into a list, but don't include null
        var elmts = new List<T>();
        elmts.AddRange(this.setImpl);
        var n = elmts.Count;
        var which = new bool[n];
        var s = ImmutableHashSet<T>.Empty.ToBuilder();
        while (true) {
          // yield both the subset without null and, if null is in the original set, the subset with null included
          var ihs = s.ToImmutable();
          yield return new Set<T>(ihs, false);
          if (containsNull) {
            yield return new Set<T>(ihs, true);
          }
          // "add 1" to "which", as if doing a carry chain.  For every digit changed, change the membership of the corresponding element in "s".
          int i = 0;
          for (; i < n && which[i]; i++) {
            which[i] = false;
            s.Remove(elmts[i]);
          }
          if (i == n) {
            // we have cycled through all the subsets
            break;
          }
          which[i] = true;
          s.Add(elmts[i]);
        }
      }
    }
    public bool Equals(ISet<T> other) {
      if (other == null || Count != other.Count) {
        return false;
      } else if (this == other) {
        return true;
      }
      foreach (var elmt in Elements) {
        if (!other.Contains(elmt)) {
          return false;
        }
      }
      return true;
    }
    public override bool Equals(object other) {
      if (other is ISet<T>) {
        return Equals((ISet<T>)other);
      }
      var th = this as ISet<object>;
      var oth = other as ISet<object>;
      if (th != null && oth != null) {
        // We'd like to obtain the more specific type parameter U for oth's type ISet<U>.
        // We do that by making a dynamically dispatched call, like:
        //     oth.Equals(this)
        // The hope is then that its comparison "this is ISet<U>" (that is, the first "if" test
        // above, but in the call "oth.Equals(this)") will be true and the non-virtual Equals
        // can be called. However, such a recursive call to "oth.Equals(this)" could turn
        // into infinite recursion. Therefore, we instead call "oth.EqualsAux(this)", which
        // performs the desired type test, but doesn't recurse any further.
        return oth.EqualsAux(th);
      } else {
        return false;
      }
    }

    public bool EqualsAux(ISet<object> other) {
      var s = other as ISet<T>;
      if (s != null) {
        return Equals(s);
      } else {
        return false;
      }
    }

    public override int GetHashCode() {
      var hashCode = 1;
      if (containsNull) {
        hashCode = hashCode * (Dafny.Helpers.GetHashCode(default(T)) + 3);
      }
      foreach (var t in this.setImpl) {
        hashCode = hashCode * (Dafny.Helpers.GetHashCode(t) + 3);
      }
      return hashCode;
    }
    public override string ToString() {
      var s = "{";
      var sep = "";
      if (containsNull) {
        s += sep + Dafny.Helpers.ToString(default(T));
        sep = ", ";
      }
      foreach (var t in this.setImpl) {
        s += sep + Dafny.Helpers.ToString(t);
        sep = ", ";
      }
      return s + "}";
    }
    public static bool IsProperSubsetOf(ISet<T> th, ISet<T> other) {
      return th.Count < other.Count && IsSubsetOf(th, other);
    }
    public static bool IsSubsetOf(ISet<T> th, ISet<T> other) {
      if (other.Count < th.Count) {
        return false;
      }
      foreach (T t in th.Elements) {
        if (!other.Contains(t)) {
          return false;
        }
      }
      return true;
    }
    public static bool IsDisjointFrom(ISet<T> th, ISet<T> other) {
      ISet<T> a, b;
      if (th.Count < other.Count) {
        a = th; b = other;
      } else {
        a = other; b = th;
      }
      foreach (T t in a.Elements) {
        if (b.Contains(t)) {
          return false;
        }
      }
      return true;
    }
    public bool Contains<G>(G t) {
      return t == null ? containsNull : t is T && this.setImpl.Contains((T)(object)t);
    }
    public static ISet<T> Union(ISet<T> th, ISet<T> other) {
      var a = FromISet(th);
      var b = FromISet(other);
      return new Set<T>(a.setImpl.Union(b.setImpl), a.containsNull || b.containsNull);
    }
    public static ISet<T> Intersect(ISet<T> th, ISet<T> other) {
      var a = FromISet(th);
      var b = FromISet(other);
      return new Set<T>(a.setImpl.Intersect(b.setImpl), a.containsNull && b.containsNull);
    }
    public static ISet<T> Difference(ISet<T> th, ISet<T> other) {
      var a = FromISet(th);
      var b = FromISet(other);
      return new Set<T>(a.setImpl.Except(b.setImpl), a.containsNull && !b.containsNull);
    }
  }

  public interface IMultiSet<out T>
  {
    bool IsEmpty { get; }
    int Count { get; }
    long LongCount { get; }
    IEnumerable<T> Elements { get; }
    IEnumerable<T> UniqueElements { get; }
    bool Contains<G>(G t);
    BigInteger Select<G>(G t);
    IMultiSet<T> Update<G>(G t, BigInteger i);
    bool EqualsAux(IMultiSet<object> other);
    IMultiSet<U> DowncastClone<U>(Func<T, U> converter);
  }

  public class MultiSet<T> : IMultiSet<T>
  {
    readonly ImmutableDictionary<T, BigInteger> dict;
    readonly BigInteger occurrencesOfNull;  // stupidly, a Dictionary in .NET cannot use "null" as a key
    MultiSet(ImmutableDictionary<T, BigInteger>.Builder d, BigInteger occurrencesOfNull) {
      dict = d.ToImmutable();
      this.occurrencesOfNull = occurrencesOfNull;
    }
    public static readonly MultiSet<T> Empty = new MultiSet<T>(ImmutableDictionary<T, BigInteger>.Empty.ToBuilder(), BigInteger.Zero);

    private static readonly TypeDescriptor<IMultiSet<T>> _TYPE = new Dafny.TypeDescriptor<IMultiSet<T>>(Empty);
    public static TypeDescriptor<IMultiSet<T>> _TypeDescriptor() {
      return _TYPE;
    }

    public static MultiSet<T> FromIMultiSet(IMultiSet<T> s) {
      return s as MultiSet<T> ?? FromCollection(s.Elements);
    }
    public static MultiSet<T> FromElements(params T[] values) {
      var d = ImmutableDictionary<T, BigInteger>.Empty.ToBuilder();
      var occurrencesOfNull = BigInteger.Zero;
      foreach (T t in values) {
        if (t == null) {
          occurrencesOfNull++;
        } else {
          BigInteger i;
          if (!d.TryGetValue(t, out i)) {
            i = BigInteger.Zero;
          }
          d[t] = i + 1;
        }
      }
      return new MultiSet<T>(d, occurrencesOfNull);
    }
    public static MultiSet<T> FromCollection(IEnumerable<T> values) {
      var d = ImmutableDictionary<T, BigInteger>.Empty.ToBuilder();
      var occurrencesOfNull = BigInteger.Zero;
      foreach (T t in values) {
        if (t == null) {
          occurrencesOfNull++;
        } else {
          BigInteger i;
          if (!d.TryGetValue(t, out i)) {
            i = BigInteger.Zero;
          }
          d[t] = i + 1;
        }
      }
      return new MultiSet<T>(d, occurrencesOfNull);
    }
    public static MultiSet<T> FromSeq(ISequence<T> values) {
      var d = ImmutableDictionary<T, BigInteger>.Empty.ToBuilder();
      var occurrencesOfNull = BigInteger.Zero;
      foreach (T t in values.Elements) {
        if (t == null) {
          occurrencesOfNull++;
        } else {
          BigInteger i;
          if (!d.TryGetValue(t, out i)) {
            i = BigInteger.Zero;
          }
          d[t] = i + 1;
        }
      }
      return new MultiSet<T>(d, occurrencesOfNull);
    }
    public static MultiSet<T> FromSet(ISet<T> values) {
      var d = ImmutableDictionary<T, BigInteger>.Empty.ToBuilder();
      var containsNull = false;
      foreach (T t in values.Elements) {
        if (t == null) {
          containsNull = true;
        } else {
          d[t] = BigInteger.One;
        }
      }
      return new MultiSet<T>(d, containsNull ? BigInteger.One : BigInteger.Zero);
    }
    public IMultiSet<U> DowncastClone<U>(Func<T, U> converter) {
      if (this is IMultiSet<U> th) {
        return th;
      } else {
        var d = ImmutableDictionary<U, BigInteger>.Empty.ToBuilder();
        foreach (var item in this.dict) {
          var k = converter(item.Key);
          d.Add(k, item.Value);
        }
        return new MultiSet<U>(d, this.occurrencesOfNull);
      }
    }

    public bool Equals(IMultiSet<T> other) {
      return IsSubsetOf(this, other) && IsSubsetOf(other, this);
    }
    public override bool Equals(object other) {
      if (other is IMultiSet<T>) {
        return Equals((IMultiSet<T>)other);
      }
      var th = this as IMultiSet<object>;
      var oth = other as IMultiSet<object>;
      if (th != null && oth != null) {
        // See comment in Set.Equals
        return oth.EqualsAux(th);
      } else {
        return false;
      }
    }

    public bool EqualsAux(IMultiSet<object> other) {
      var s = other as IMultiSet<T>;
      if (s != null) {
        return Equals(s);
      } else {
        return false;
      }
    }

    public override int GetHashCode() {
      var hashCode = 1;
      if (occurrencesOfNull > 0) {
        var key = Dafny.Helpers.GetHashCode(default(T));
        key = (key << 3) | (key >> 29) ^ occurrencesOfNull.GetHashCode();
        hashCode = hashCode * (key + 3);
      }
      foreach (var kv in dict) {
        var key = Dafny.Helpers.GetHashCode(kv.Key);
        key = (key << 3) | (key >> 29) ^ kv.Value.GetHashCode();
        hashCode = hashCode * (key + 3);
      }
      return hashCode;
    }
    public override string ToString() {
      var s = "multiset{";
      var sep = "";
      for (var i = BigInteger.Zero; i < occurrencesOfNull; i++) {
        s += sep + Dafny.Helpers.ToString(default(T));
        sep = ", ";
      }
      foreach (var kv in dict) {
        var t = Dafny.Helpers.ToString(kv.Key);
        for (var i = BigInteger.Zero; i < kv.Value; i++) {
          s += sep + t;
          sep = ", ";
        }
      }
      return s + "}";
    }
    public static bool IsProperSubsetOf(IMultiSet<T> th, IMultiSet<T> other) {
      return th.Count < other.Count && IsSubsetOf(th, other);
    }
    public static bool IsSubsetOf(IMultiSet<T> th, IMultiSet<T> other) {
      var a = FromIMultiSet(th);
      var b = FromIMultiSet(other);
      if (b.occurrencesOfNull < a.occurrencesOfNull) {
        return false;
      }
      foreach (T t in a.dict.Keys) {
        if (!b.dict.ContainsKey(t) || b.dict[t] < a.dict[t]) {
          return false;
        }
      }
      return true;
    }
    public static bool IsDisjointFrom(IMultiSet<T> th, IMultiSet<T> other) {
      foreach (T t in th.UniqueElements) {
        if (other.Contains(t)) {
          return false;
        }
      }
      return true;
    }

    public bool Contains<G>(G t) {
      return t == null ? occurrencesOfNull > 0 : t is T && dict.ContainsKey((T)(object)t);
    }
    public BigInteger Select<G>(G t) {
      if (t == null) {
        return occurrencesOfNull;
      }
      BigInteger m;
      if (t is T && dict.TryGetValue((T)(object)t, out m)) {
        return m;
      } else {
        return BigInteger.Zero;
      }
    }
    public IMultiSet<T> Update<G>(G t, BigInteger i) {
      if (Select(t) == i) {
        return this;
      } else if (t == null) {
        var r = dict.ToBuilder();
        return new MultiSet<T>(r, i);
      } else {
        var r = dict.ToBuilder();
        r[(T)(object)t] = i;
        return new MultiSet<T>(r, occurrencesOfNull);
      }
    }
    public static IMultiSet<T> Union(IMultiSet<T> th, IMultiSet<T> other) {
      if (th.IsEmpty) {
        return other;
      } else if (other.IsEmpty) {
        return th;
      }
      var a = FromIMultiSet(th);
      var b = FromIMultiSet(other);
      var r = ImmutableDictionary<T, BigInteger>.Empty.ToBuilder();
      foreach (T t in a.dict.Keys) {
        BigInteger i;
        if (!r.TryGetValue(t, out i)) {
          i = BigInteger.Zero;
        }
        r[t] = i + a.dict[t];
      }
      foreach (T t in b.dict.Keys) {
        BigInteger i;
        if (!r.TryGetValue(t, out i)) {
          i = BigInteger.Zero;
        }
        r[t] = i + b.dict[t];
      }
      return new MultiSet<T>(r, a.occurrencesOfNull + b.occurrencesOfNull);
    }
    public static IMultiSet<T> Intersect(IMultiSet<T> th, IMultiSet<T> other) {
      if (th.IsEmpty) {
        return th;
      } else if (other.IsEmpty) {
        return other;
      }
      var a = FromIMultiSet(th);
      var b = FromIMultiSet(other);
      var r = ImmutableDictionary<T, BigInteger>.Empty.ToBuilder();
      foreach (T t in a.dict.Keys) {
        if (b.dict.ContainsKey(t)) {
          r.Add(t, a.dict[t] < b.dict[t] ? a.dict[t] : b.dict[t]);
        }
      }
      return new MultiSet<T>(r, a.occurrencesOfNull < b.occurrencesOfNull ? a.occurrencesOfNull : b.occurrencesOfNull);
    }
    public static IMultiSet<T> Difference(IMultiSet<T> th, IMultiSet<T> other) { // \result == this - other
      if (other.IsEmpty) {
        return th;
      }
      var a = FromIMultiSet(th);
      var b = FromIMultiSet(other);
      var r = ImmutableDictionary<T, BigInteger>.Empty.ToBuilder();
      foreach (T t in a.dict.Keys) {
        if (!b.dict.ContainsKey(t)) {
          r.Add(t, a.dict[t]);
        } else if (b.dict[t] < a.dict[t]) {
          r.Add(t, a.dict[t] - b.dict[t]);
        }
      }
      return new MultiSet<T>(r, b.occurrencesOfNull < a.occurrencesOfNull ? a.occurrencesOfNull - b.occurrencesOfNull : BigInteger.Zero);
    }

    public bool IsEmpty { get { return occurrencesOfNull == 0 && dict.IsEmpty; } }

    public int Count {
      get { return (int)ElementCount(); }
    }
    public long LongCount {
      get { return (long)ElementCount(); }
    }
    private BigInteger ElementCount() {
      // This is inefficient
      var c = occurrencesOfNull;
      foreach (var item in dict) {
        c += item.Value;
      }
      return c;
    }

    public IEnumerable<T> Elements {
      get {
        for (var i = BigInteger.Zero; i < occurrencesOfNull; i++) {
          yield return default(T);
        }
        foreach (var item in dict) {
          for (var i = BigInteger.Zero; i < item.Value; i++) {
            yield return item.Key;
          }
        }
      }
    }

    public IEnumerable<T> UniqueElements {
      get {
        if (!occurrencesOfNull.IsZero) {
          yield return default(T);
        }
        foreach (var key in dict.Keys) {
          yield return key;
        }
      }
    }
  }

  public interface IMap<out U, out V>
  {
    int Count { get; }
    long LongCount { get; }
    ISet<U> Keys { get; }
    ISet<V> Values { get; }
    IEnumerable<IPair<U, V>> ItemEnumerable { get; }
    bool Contains<G>(G t);
    /// <summary>
    /// Returns "true" iff "this is IMap<object, object>" and "this" equals "other".
    /// </summary>
    bool EqualsObjObj(IMap<object, object> other);
    IMap<UU, VV> DowncastClone<UU, VV>(Func<U, UU> keyConverter, Func<V, VV> valueConverter);
  }

  public class Map<U, V> : IMap<U, V>
  {
    readonly ImmutableDictionary<U, V> dict;
    readonly bool hasNullKey;  // true when "null" is a key of the Map
    readonly V nullValue;  // if "hasNullKey", the value that "null" maps to

    private Map(ImmutableDictionary<U, V>.Builder d, bool hasNullKey, V nullValue) {
      dict = d.ToImmutable();
      this.hasNullKey = hasNullKey;
      this.nullValue = nullValue;
    }
    public static readonly Map<U, V> Empty = new Map<U, V>(ImmutableDictionary<U, V>.Empty.ToBuilder(), false, default(V));

    private Map(ImmutableDictionary<U, V> d, bool hasNullKey, V nullValue) {
      dict = d;
      this.hasNullKey = hasNullKey;
      this.nullValue = nullValue;
    }

    private static readonly TypeDescriptor<IMap<U, V>> _TYPE = new Dafny.TypeDescriptor<IMap<U, V>>(Empty);
    public static TypeDescriptor<IMap<U, V>> _TypeDescriptor() {
      return _TYPE;
    }

    public static Map<U, V> FromElements(params IPair<U, V>[] values) {
      var d = ImmutableDictionary<U, V>.Empty.ToBuilder();
      var hasNullKey = false;
      var nullValue = default(V);
      foreach (var p in values) {
        if (p.Car == null) {
          hasNullKey = true;
          nullValue = p.Cdr;
        } else {
          d[p.Car] = p.Cdr;
        }
      }
      return new Map<U, V>(d, hasNullKey, nullValue);
    }
    public static Map<U, V> FromCollection(IEnumerable<IPair<U, V>> values) {
      var d = ImmutableDictionary<U, V>.Empty.ToBuilder();
      var hasNullKey = false;
      var nullValue = default(V);
      foreach (var p in values) {
        if (p.Car == null) {
          hasNullKey = true;
          nullValue = p.Cdr;
        } else {
          d[p.Car] = p.Cdr;
        }
      }
      return new Map<U, V>(d, hasNullKey, nullValue);
    }
    public static Map<U, V> FromIMap(IMap<U, V> m) {
      return m as Map<U, V> ?? FromCollection(m.ItemEnumerable);
    }
    public IMap<UU, VV> DowncastClone<UU, VV>(Func<U, UU> keyConverter, Func<V, VV> valueConverter) {
      if (this is IMap<UU, VV> th) {
        return th;
      } else {
        var d = ImmutableDictionary<UU, VV>.Empty.ToBuilder();
        foreach (var item in this.dict) {
          var k = keyConverter(item.Key);
          var v = valueConverter(item.Value);
          d.Add(k, v);
        }
        return new Map<UU, VV>(d, this.hasNullKey, (VV)(object)this.nullValue);
      }
    }
    public int Count {
      get { return dict.Count + (hasNullKey ? 1 : 0); }
    }
    public long LongCount {
      get { return dict.Count + (hasNullKey ? 1 : 0); }
    }

    public bool Equals(IMap<U, V> other) {
      if (other == null || LongCount != other.LongCount) {
        return false;
      } else if (this == other) {
        return true;
      }
      if (hasNullKey) {
        if (!other.Contains(default(U)) || !object.Equals(nullValue, Select(other, default(U)))) {
          return false;
        }
      }
      foreach (var item in dict) {
        if (!other.Contains(item.Key) || !object.Equals(item.Value, Select(other, item.Key))) {
          return false;
        }
      }
      return true;
    }
    public bool EqualsObjObj(IMap<object, object> other) {
      if (!(this is IMap<object, object>) || other == null || LongCount != other.LongCount) {
        return false;
      } else if (this == other) {
        return true;
      }
      var oth = Map<object, object>.FromIMap(other);
      if (hasNullKey) {
        if (!oth.Contains(default(U)) || !object.Equals(nullValue, Map<object, object>.Select(oth, default(U)))) {
          return false;
        }
      }
      foreach (var item in dict) {
        if (!other.Contains(item.Key) || !object.Equals(item.Value, Map<object, object>.Select(oth, item.Key))) {
          return false;
        }
      }
      return true;
    }
    public override bool Equals(object other) {
      // See comment in Set.Equals
      var m = other as IMap<U, V>;
      if (m != null) {
        return Equals(m);
      }
      var imapoo = other as IMap<object, object>;
      if (imapoo != null) {
        return EqualsObjObj(imapoo);
      } else {
        return false;
      }
    }

    public override int GetHashCode() {
      var hashCode = 1;
      if (hasNullKey) {
        var key = Dafny.Helpers.GetHashCode(default(U));
        key = (key << 3) | (key >> 29) ^ Dafny.Helpers.GetHashCode(nullValue);
        hashCode = hashCode * (key + 3);
      }
      foreach (var kv in dict) {
        var key = Dafny.Helpers.GetHashCode(kv.Key);
        key = (key << 3) | (key >> 29) ^ Dafny.Helpers.GetHashCode(kv.Value);
        hashCode = hashCode * (key + 3);
      }
      return hashCode;
    }
    public override string ToString() {
      var s = "map[";
      var sep = "";
      if (hasNullKey) {
        s += sep + Dafny.Helpers.ToString(default(U)) + " := " + Dafny.Helpers.ToString(nullValue);
        sep = ", ";
      }
      foreach (var kv in dict) {
        s += sep + Dafny.Helpers.ToString(kv.Key) + " := " + Dafny.Helpers.ToString(kv.Value);
        sep = ", ";
      }
      return s + "]";
    }
    public bool Contains<G>(G u) {
      return u == null ? hasNullKey : u is U && dict.ContainsKey((U)(object)u);
    }
    public static V Select(IMap<U, V> th, U index) {
      // the following will throw an exception if "index" in not a key of the map
      var m = FromIMap(th);
      return index == null && m.hasNullKey ? m.nullValue : m.dict[index];
    }
    public static IMap<U, V> Update(IMap<U, V> th, U index, V val) {
      var m = FromIMap(th);
      var d = m.dict.ToBuilder();
      if (index == null) {
        return new Map<U, V>(d, true, val);
      } else {
        d[index] = val;
        return new Map<U, V>(d, m.hasNullKey, m.nullValue);
      }
    }

    public static IMap<U, V> Merge(IMap<U, V> th, IMap<U, V> other) {
      var a = FromIMap(th);
      var b = FromIMap(other);
      ImmutableDictionary<U, V> d = a.dict.SetItems(b.dict);
      return new Map<U, V>(d, a.hasNullKey || b.hasNullKey, b.hasNullKey ? b.nullValue : a.nullValue);
    }

    public static IMap<U, V> Subtract(IMap<U, V> th, ISet<U> keys) {
      var a = FromIMap(th);
      ImmutableDictionary<U, V> d = a.dict.RemoveRange(keys.Elements);
      return new Map<U, V>(d, a.hasNullKey && !keys.Contains<object>(null), a.nullValue);
    }

    public ISet<U> Keys {
      get {
        if (hasNullKey) {
          return Dafny.Set<U>.FromCollectionPlusOne(dict.Keys, default(U));
        } else {
          return Dafny.Set<U>.FromCollection(dict.Keys);
        }
      }
    }
    public ISet<V> Values {
      get {
        if (hasNullKey) {
          return Dafny.Set<V>.FromCollectionPlusOne(dict.Values, nullValue);
        } else {
          return Dafny.Set<V>.FromCollection(dict.Values);
        }
      }
    }

    public IEnumerable<IPair<U, V>> ItemEnumerable {
      get {
        if (hasNullKey) {
          yield return new Pair<U, V>(default(U), nullValue);
        }
        foreach (KeyValuePair<U, V> kvp in dict) {
          yield return new Pair<U, V>(kvp.Key, kvp.Value);
        }
      }
    }

    public static ISet<_System.Tuple2<U, V>> Items(IMap<U, V> m) {
      var result = new HashSet<_System.Tuple2<U, V>>();
      foreach (var item in m.ItemEnumerable) {
        result.Add(_System.Tuple2<U, V>.create(item.Car, item.Cdr));
      }
      return Dafny.Set<_System.Tuple2<U, V>>.FromCollection(result);
    }
  }

  public interface ISequence<out T> {
    long LongCount { get; }
    int Count { get; }
    T[] Elements { get; }
    IEnumerable<T> UniqueElements { get; }
    T Select(ulong index);
    T Select(long index);
    T Select(uint index);
    T Select(int index);
    T Select(BigInteger index);
    bool Contains<G>(G g);
    ISequence<T> Take(long m);
    ISequence<T> Take(ulong n);
    ISequence<T> Take(BigInteger n);
    ISequence<T> Drop(long m);
    ISequence<T> Drop(ulong n);
    ISequence<T> Drop(BigInteger n);
    ISequence<T> Subsequence(long lo, long hi);
    ISequence<T> Subsequence(long lo, ulong hi);
    ISequence<T> Subsequence(long lo, BigInteger hi);
    ISequence<T> Subsequence(ulong lo, long hi);
    ISequence<T> Subsequence(ulong lo, ulong hi);
    ISequence<T> Subsequence(ulong lo, BigInteger hi);
    ISequence<T> Subsequence(BigInteger lo, long hi);
    ISequence<T> Subsequence(BigInteger lo, ulong hi);
    ISequence<T> Subsequence(BigInteger lo, BigInteger hi);
    bool EqualsAux(ISequence<object> other);
    ISequence<U> DowncastClone<U>(Func<T, U> converter);
  }

  public abstract class Sequence<T> : ISequence<T>
  {
    public static readonly ISequence<T> Empty = new ArraySequence<T>(new T[0]);

    private static readonly TypeDescriptor<ISequence<T>> _TYPE = new Dafny.TypeDescriptor<ISequence<T>>(Empty);
    public static TypeDescriptor<ISequence<T>> _TypeDescriptor() {
      return _TYPE;
    }

    public static ISequence<T> Create(BigInteger length, System.Func<BigInteger, T> init) {
      var len = (int)length;
      var values = new T[len];
      for (int i = 0; i < len; i++) {
        values[i] = init(new BigInteger(i));
      }
      return new ArraySequence<T>(values);
    }
    public static ISequence<T> FromArray(T[] values) {
      return new ArraySequence<T>(values);
    }
    public static ISequence<T> FromElements(params T[] values) {
      return new ArraySequence<T>(values);
    }
    public static ISequence<char> FromString(string s) {
      return new ArraySequence<char>(s.ToCharArray());
    }
    public ISequence<U> DowncastClone<U>(Func<T, U> converter) {
      if (this is ISequence<U> th) {
        return th;
      } else {
        var values = new U[this.LongCount];
        for (long i = 0; i < this.LongCount; i++) {
          var val = converter(this.Select(i));
          values[i] = val;
        }
        return new ArraySequence<U>(values);
      }
    }
    public static ISequence<T> Update(ISequence<T> sequence, long index, T t) {
      T[] tmp = (T[])sequence.Elements.Clone();
      tmp[index] = t;
      return new ArraySequence<T>(tmp);
    }
    public static ISequence<T> Update(ISequence<T> sequence, ulong index, T t) {
      return Update(sequence, (long)index, t);
    }
    public static ISequence<T> Update(ISequence<T> sequence, BigInteger index, T t) {
      return Update(sequence, (long)index, t);
    }
    public static bool EqualUntil(ISequence<T> left, ISequence<T> right, int n) {
      T[] leftElmts = left.Elements, rightElmts = right.Elements;
      for (int i = 0; i < n; i++) {
        if (!object.Equals(leftElmts[i], rightElmts[i]))
          return false;
      }
      return true;
    }
    public static bool IsPrefixOf(ISequence<T> left, ISequence<T> right) {
      int n = left.Elements.Length;
      return n <= right.Elements.Length && EqualUntil(left, right, n);
    }
    public static bool IsProperPrefixOf(ISequence<T> left, ISequence<T> right) {
      int n = left.Elements.Length;
      return n < right.Elements.Length && EqualUntil(left, right, n);
    }
    public static ISequence<T> Concat(ISequence<T> left, ISequence<T> right) {
      if (left.Count == 0) {
        return right;
      }
      if (right.Count == 0) {
        return left;
      }
      return new ConcatSequence<T>(left, right);
    }
    // Make Count a public abstract instead of LongCount, since the "array size is limited to a total of 4 billion
    // elements, and to a maximum index of 0X7FEFFFFF". Therefore, as a protection, limit this to int32.
    // https://docs.microsoft.com/en-us/dotnet/api/system.array
    public abstract int Count  { get; }
    public long LongCount {
      get { return Count; }
    }
    // ImmutableElements cannot be public in the interface since ImmutableArray<T> leads to a
    // "covariant type T occurs in invariant position" error. There do not appear to be interfaces for ImmutableArray<T>
    // that resolve this.
    protected abstract ImmutableArray<T> ImmutableElements { get; }

    public T[] Elements
    {
      get { return ImmutableElements.ToArray(); }
    }
    public IEnumerable<T> UniqueElements {
      get {
        var st = Set<T>.FromCollection(ImmutableElements);
        return st.Elements;
      }
    }

    public T Select(ulong index) {
      return ImmutableElements[checked((int)index)];
    }
    public T Select(long index) {
      return ImmutableElements[checked((int)index)];
    }
    public T Select(uint index) {
      return ImmutableElements[checked((int)index)];
    }
    public T Select(int index) {
      return ImmutableElements[index];
    }
    public T Select(BigInteger index) {
      return ImmutableElements[(int)index];
    }
    public bool Equals(ISequence<T> other) {
      int n = ImmutableElements.Length;
      return n == other.Elements.Length && EqualUntil(this, other, n);
    }
    public override bool Equals(object other) {
      if (other is ISequence<T>) {
        return Equals((ISequence<T>)other);
      }
      var th = this as ISequence<object>;
      var oth = other as ISequence<object>;
      if (th != null && oth != null) {
        // see explanation in Set.Equals
        return oth.EqualsAux(th);
      } else {
        return false;
      }
    }
    public bool EqualsAux(ISequence<object> other) {
      var s = other as ISequence<T>;
      if (s != null) {
        return Equals(s);
      } else {
        return false;
      }
    }
    public override int GetHashCode() {
      ImmutableArray<T> elmts = ImmutableElements;
      // https://devblogs.microsoft.com/dotnet/please-welcome-immutablearrayt/
      if (elmts.IsDefaultOrEmpty)
        return 0;
      var hashCode = 0;
      for (var i = 0; i < elmts.Length; i++) {
        hashCode = (hashCode << 3) | (hashCode >> 29) ^ Dafny.Helpers.GetHashCode(elmts[i]);
      }
      return hashCode;
    }
    public override string ToString() {
      // This is required because (ImmutableElements is ImmutableArray<char>) is not a valid type check
      var typeCheckTmp = new T[0];
      ImmutableArray<T> elmts = ImmutableElements;
      if (typeCheckTmp is char[]) {
        var s = "";
        foreach (var t in elmts) {
          s += t.ToString();
        }
        return s;
      } else {
        var s = "[";
        var sep = "";
        foreach (var t in elmts) {
          s += sep + Dafny.Helpers.ToString(t);
          sep = ", ";
        }
        return s + "]";
      }
    }
    public bool Contains<G>(G g) {
      if (g == null || g is T) {
        var t = (T)(object)g;
        return ImmutableElements.Contains(t);
      }
      return false;
    }
    public ISequence<T> Take(long m) {
      if (ImmutableElements.Length == m)
        return this;
      int length = checked((int)m);
      T[] tmp = new T[length];
      ImmutableElements.CopyTo(0, tmp, 0, length);
      return new ArraySequence<T>(tmp);
    }
    public ISequence<T> Take(ulong n) {
      return Take((long)n);
    }
    public ISequence<T> Take(BigInteger n) {
      return Take((long)n);
    }
    public ISequence<T> Drop(long m)
    {
      int startingElement = checked((int)m);
      if (startingElement == 0)
        return this;
      int length = ImmutableElements.Length - startingElement;
      T[] tmp = new T[length];
      ImmutableElements.CopyTo(startingElement, tmp, 0, length);
      return new ArraySequence<T>(tmp);
    }
    public ISequence<T> Drop(ulong n) {
      return Drop((long)n);
    }
    public ISequence<T> Drop(BigInteger n) {
      if (n.IsZero)
        return this;
      return Drop((long)n);
    }
    public ISequence<T> Subsequence(long lo, long hi) {
      if (lo == 0 && hi == ImmutableElements.Length) {
        return this;
      }
      int startingIndex = checked((int) lo);
      int endingIndex = checked((int)hi);
      var length = endingIndex - startingIndex;
      T[] tmp = new T[length];
      ImmutableElements.CopyTo(startingIndex, tmp, 0, length);
      return new ArraySequence<T>(tmp);
    }
    public ISequence<T> Subsequence(long lo, ulong hi) {
      return Subsequence(lo, (long)hi);
    }
    public ISequence<T> Subsequence(long lo, BigInteger hi) {
      return Subsequence(lo, (long)hi);
    }
    public ISequence<T> Subsequence(ulong lo, long hi) {
      return Subsequence((long)lo, hi);
    }
    public ISequence<T> Subsequence(ulong lo, ulong hi) {
      return Subsequence((long)lo, (long)hi);
    }
    public ISequence<T> Subsequence(ulong lo, BigInteger hi) {
      return Subsequence((long)lo, (long)hi);
    }
    public ISequence<T> Subsequence(BigInteger lo, long hi) {
      return Subsequence((long)lo, hi);
    }
    public ISequence<T> Subsequence(BigInteger lo, ulong hi) {
      return Subsequence((long)lo, (long)hi);
    }
    public ISequence<T> Subsequence(BigInteger lo, BigInteger hi) {
      return Subsequence((long)lo, (long)hi);
    }
  }
  internal class ArraySequence<T> : Sequence<T> {
    private readonly ImmutableArray<T> elmts;

    internal ArraySequence(ImmutableArray<T> ee) {
      elmts = ee;
    }
    internal ArraySequence(T[] ee) {
      elmts = ImmutableArray.Create<T>(ee);
    }

    protected override ImmutableArray<T> ImmutableElements {
      get
      {
        return elmts;
      }
    }
    public override int Count {
      get {
        return elmts.Length;
      }
    }
  }
  internal class ConcatSequence<T> : Sequence<T> {
    // INVARIANT: Either left != null, right != null, and elmts's underlying array == null or
    // left == null, right == null, and elmts's underlying array != null
    private ISequence<T> left, right;
    private ImmutableArray<T> elmts;
    private readonly int count;

    internal ConcatSequence(ISequence<T> left, ISequence<T> right) {
      this.left = left;
      this.right = right;
      this.count = left.Count + right.Count;
    }

    protected override ImmutableArray<T> ImmutableElements {
      get {
        // IsDefault returns true if the underlying array is a null reference
        // https://devblogs.microsoft.com/dotnet/please-welcome-immutablearrayt/
        if (elmts.IsDefault) {
          elmts = ComputeElements();
          // We don't need the original sequences anymore; let them be
          // garbage-collected
          left = null;
          right = null;
        }
        return elmts;
      }
    }

    public override int Count {
      get {
        return count;
      }
    }

    private ImmutableArray<T> ComputeElements() {
      // Traverse the tree formed by all descendants which are ConcatSequences
      var ansBuilder = ImmutableArray.CreateBuilder<T>();
      var toVisit = new Stack<ISequence<T>>();
      toVisit.Push(right);
      toVisit.Push(left);

      while (toVisit.Count != 0) {
        var seq = toVisit.Pop();
        var cs = seq as ConcatSequence<T>;
        if (cs != null && cs.elmts.IsDefault) {
          toVisit.Push(cs.right);
          toVisit.Push(cs.left);
        } else {
          var array = seq.Elements;
          ansBuilder.AddRange(array);
        }
      }
      return ansBuilder.ToImmutable();
    }
  }

  public interface IPair<out A, out B>
  {
    A Car { get; }
    B Cdr { get; }
  }
  public class Pair<A, B> : IPair<A, B>
  {
    private A car;
    private B cdr;
    public A Car { get { return car; } }
    public B Cdr { get { return cdr; } }
    public Pair(A a, B b) {
      this.car = a;
      this.cdr = b;
    }
  }

  public class TypeDescriptor<T>
  {
    private readonly T initValue;
    public TypeDescriptor(T initValue) {
      this.initValue = initValue;
    }
    public T Default() {
      return initValue;
    }
  }

  public partial class Helpers
  {
    public static int GetHashCode<G>(G g) {
      return g == null ? 1001 : g.GetHashCode();
    }

    public static int ToIntChecked(BigInteger i, string msg) {
      if (i > Int32.MaxValue || i < Int32.MinValue) {
        if (msg == null) msg = "value out of range for a 32-bit int";
        throw new HaltException(msg + ": " + i);
      }
      return (int)i;
    }
    public static int ToIntChecked(long i, string msg) {
      if (i > Int32.MaxValue || i < Int32.MinValue) {
        if (msg == null) msg = "value out of range for a 32-bit int";
        throw new HaltException(msg + ": " + i);
      }
      return (int)i;
    }
    public static int ToIntChecked(int i, string msg) {
      return i;
    }

    public static string ToString<G>(G g) {
      if (g == null) {
        return "null";
      } else if (g is bool) {
        return (bool)(object)g ? "true" : "false";  // capitalize boolean literals like in Dafny
      } else {
        return g.ToString();
      }
    }
    public static void Print<G>(G g) {
      System.Console.Write(ToString(g));
    }

    public static readonly TypeDescriptor<bool> BOOL = new TypeDescriptor<bool>(false);
    public static readonly TypeDescriptor<char> CHAR = new TypeDescriptor<char>('D');  // See CharType.DefaultValue in Dafny source code
    public static readonly TypeDescriptor<BigInteger> INT = new TypeDescriptor<BigInteger>(BigInteger.Zero);
    public static readonly TypeDescriptor<BigRational> REAL = new TypeDescriptor<BigRational>(BigRational.ZERO);
    public static readonly TypeDescriptor<byte> UINT8 = new TypeDescriptor<byte>(0);
    public static readonly TypeDescriptor<ushort> UINT16 = new TypeDescriptor<ushort>(0);
    public static readonly TypeDescriptor<uint> UINT32 = new TypeDescriptor<uint>(0);
    public static readonly TypeDescriptor<ulong> UINT64 = new TypeDescriptor<ulong>(0);

    public static TypeDescriptor<T> NULL<T>() where T : class {
      return new TypeDescriptor<T>(null);
    }

    public static TypeDescriptor<A[]> ARRAY<A>() {
      return new TypeDescriptor<A[]>(new A[0]);
    }

    public static bool Quantifier<T>(IEnumerable<T> vals, bool frall, System.Predicate<T> pred) {
      foreach (var u in vals) {
        if (pred(u) != frall) { return !frall; }
      }
      return frall;
    }
    // Enumerating other collections
    public static IEnumerable<bool> AllBooleans() {
      yield return false;
      yield return true;
    }
    public static IEnumerable<char> AllChars() {
      for (int i = 0; i < 0x10000; i++) {
        yield return (char)i;
      }
    }
    public static IEnumerable<BigInteger> AllIntegers() {
      yield return new BigInteger(0);
      for (var j = new BigInteger(1);; j++) {
        yield return j;
        yield return -j;
      }
    }
    public static IEnumerable<BigInteger> IntegerRange(Nullable<BigInteger> lo, Nullable<BigInteger> hi) {
      if (lo == null) {
        for (var j = (BigInteger)hi; true; ) {
          j--;
          yield return j;
        }
      } else if (hi == null) {
        for (var j = (BigInteger)lo; true; j++) {
          yield return j;
        }
      } else {
        for (var j = (BigInteger)lo; j < hi; j++) {
          yield return j;
        }
      }
    }
    public static IEnumerable<T> SingleValue<T>(T e) {
      yield return e;
    }
    // pre: b != 0
    // post: result == a/b, as defined by Euclidean Division (http://en.wikipedia.org/wiki/Modulo_operation)
    public static sbyte EuclideanDivision_sbyte(sbyte a, sbyte b) {
      return (sbyte)EuclideanDivision_int(a, b);
    }
    public static short EuclideanDivision_short(short a, short b) {
      return (short)EuclideanDivision_int(a, b);
    }
    public static int EuclideanDivision_int(int a, int b) {
      if (0 <= a) {
        if (0 <= b) {
          // +a +b: a/b
          return (int)(((uint)(a)) / ((uint)(b)));
        } else {
          // +a -b: -(a/(-b))
          return -((int)(((uint)(a)) / ((uint)(unchecked(-b)))));
        }
      } else {
        if (0 <= b) {
          // -a +b: -((-a-1)/b) - 1
          return -((int)(((uint)(-(a + 1))) / ((uint)(b)))) - 1;
        } else {
          // -a -b: ((-a-1)/(-b)) + 1
          return ((int)(((uint)(-(a + 1))) / ((uint)(unchecked(-b))))) + 1;
        }
      }
    }
    public static long EuclideanDivision_long(long a, long b) {
      if (0 <= a) {
        if (0 <= b) {
          // +a +b: a/b
          return (long)(((ulong)(a)) / ((ulong)(b)));
        } else {
          // +a -b: -(a/(-b))
          return -((long)(((ulong)(a)) / ((ulong)(unchecked(-b)))));
        }
      } else {
        if (0 <= b) {
          // -a +b: -((-a-1)/b) - 1
          return -((long)(((ulong)(-(a + 1))) / ((ulong)(b)))) - 1;
        } else {
          // -a -b: ((-a-1)/(-b)) + 1
          return ((long)(((ulong)(-(a + 1))) / ((ulong)(unchecked(-b))))) + 1;
        }
      }
    }
    public static BigInteger EuclideanDivision(BigInteger a, BigInteger b) {
      if (0 <= a.Sign) {
        if (0 <= b.Sign) {
          // +a +b: a/b
          return BigInteger.Divide(a, b);
        } else {
          // +a -b: -(a/(-b))
          return BigInteger.Negate(BigInteger.Divide(a, BigInteger.Negate(b)));
        }
      } else {
        if (0 <= b.Sign) {
          // -a +b: -((-a-1)/b) - 1
          return BigInteger.Negate(BigInteger.Divide(BigInteger.Negate(a) - 1, b)) - 1;
        } else {
          // -a -b: ((-a-1)/(-b)) + 1
          return BigInteger.Divide(BigInteger.Negate(a) - 1, BigInteger.Negate(b)) + 1;
        }
      }
    }
    // pre: b != 0
    // post: result == a%b, as defined by Euclidean Division (http://en.wikipedia.org/wiki/Modulo_operation)
    public static sbyte EuclideanModulus_sbyte(sbyte a, sbyte b) {
      return (sbyte)EuclideanModulus_int(a, b);
    }
    public static short EuclideanModulus_short(short a, short b) {
      return (short)EuclideanModulus_int(a, b);
    }
    public static int EuclideanModulus_int(int a, int b) {
      uint bp = (0 <= b) ? (uint)b : (uint)(unchecked(-b));
      if (0 <= a) {
        // +a: a % b'
        return (int)(((uint)a) % bp);
      } else {
        // c = ((-a) % b')
        // -a: b' - c if c > 0
        // -a: 0 if c == 0
        uint c = ((uint)(unchecked(-a))) % bp;
        return (int)(c == 0 ? c : bp - c);
      }
    }
    public static long EuclideanModulus_long(long a, long b) {
      ulong bp = (0 <= b) ? (ulong)b : (ulong)(unchecked(-b));
      if (0 <= a) {
        // +a: a % b'
        return (long)(((ulong)a) % bp);
      } else {
        // c = ((-a) % b')
        // -a: b' - c if c > 0
        // -a: 0 if c == 0
        ulong c = ((ulong)(unchecked(-a))) % bp;
        return (long)(c == 0 ? c : bp - c);
      }
    }
    public static BigInteger EuclideanModulus(BigInteger a, BigInteger b) {
      var bp = BigInteger.Abs(b);
      if (0 <= a.Sign) {
        // +a: a % b'
        return BigInteger.Remainder(a, bp);
      } else {
        // c = ((-a) % b')
        // -a: b' - c if c > 0
        // -a: 0 if c == 0
        var c = BigInteger.Remainder(BigInteger.Negate(a), bp);
        return c.IsZero ? c : BigInteger.Subtract(bp, c);
      }
    }

    public static U CastConverter<T, U>(T t) {
      return (U)(object)t;
    }

    public static Sequence<T> SeqFromArray<T>(T[] array) {
      return new ArraySequence<T>((T[])array.Clone());
    }
    // In .NET version 4.5, it is possible to mark a method with "AggressiveInlining", which says to inline the
    // method if possible.  Method "ExpressionSequence" would be a good candidate for it:
    // [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
    public static U ExpressionSequence<T, U>(T t, U u)
    {
      return u;
    }

    public static U Let<T, U>(T t, Func<T,U> f) {
      return f(t);
    }

    public static A Id<A>(A a) {
      return a;
    }

    public static void WithHaltHandling(Action action) {
      try {
        action();
      } catch (HaltException e) {
        Console.WriteLine("[Program halted] " + e.Message);
      }
    }
  }

  public class BigOrdinal {
    public static bool IsLimit(BigInteger ord) {
      return ord == 0;
    }
    public static bool IsSucc(BigInteger ord) {
      return 0 < ord;
    }
    public static BigInteger Offset(BigInteger ord) {
      return ord;
    }
    public static bool IsNat(BigInteger ord) {
      return true;  // at run time, every ORDINAL is a natural number
    }
  }

  public struct BigRational
  {
    public static readonly BigRational ZERO = new BigRational(0);

    // We need to deal with the special case "num == 0 && den == 0", because
    // that's what C#'s default struct constructor will produce for BigRational. :(
    // To deal with it, we ignore "den" when "num" is 0.
    BigInteger num, den;  // invariant 1 <= den || (num == 0 && den == 0)
    public override string ToString() {
      int log10;
      if (num.IsZero || den.IsOne) {
        return string.Format("{0}.0", num);
      } else if (IsPowerOf10(den, out log10)) {
        string sign;
        string digits;
        if (num.Sign < 0) {
          sign = "-"; digits = (-num).ToString();
        } else {
          sign = ""; digits = num.ToString();
        }
        if (log10 < digits.Length) {
          var n = digits.Length - log10;
          return string.Format("{0}{1}.{2}", sign, digits.Substring(0, n), digits.Substring(n));
        } else {
          return string.Format("{0}0.{1}{2}", sign, new string('0', log10 - digits.Length), digits);
        }
      } else {
        return string.Format("({0}.0 / {1}.0)", num, den);
      }
    }
    public bool IsPowerOf10(BigInteger x, out int log10) {
      log10 = 0;
      if (x.IsZero) {
        return false;
      }
      while (true) {  // invariant: x != 0 && x * 10^log10 == old(x)
        if (x.IsOne) {
          return true;
        } else if (x % 10 == 0) {
          log10++;
          x /= 10;
        } else {
          return false;
        }
      }
    }
    public BigRational(int n) {
      num = new BigInteger(n);
      den = BigInteger.One;
    }
    public BigRational(BigInteger n, BigInteger d) {
      // requires 1 <= d
      num = n;
      den = d;
    }
    public BigInteger ToBigInteger() {
      if (num.IsZero || den.IsOne) {
        return num;
      } else if (0 < num.Sign) {
        return num / den;
      } else {
        return (num - den + 1) / den;
      }
    }
    /// <summary>
    /// Returns values such that aa/dd == a and bb/dd == b.
    /// </summary>
    private static void Normalize(BigRational a, BigRational b, out BigInteger aa, out BigInteger bb, out BigInteger dd) {
      if (a.num.IsZero) {
        aa = a.num;
        bb = b.num;
        dd = b.den;
      } else if (b.num.IsZero) {
        aa = a.num;
        dd = a.den;
        bb = b.num;
      } else {
        var gcd = BigInteger.GreatestCommonDivisor(a.den, b.den);
        var xx = a.den / gcd;
        var yy = b.den / gcd;
        // We now have a == a.num / (xx * gcd) and b == b.num / (yy * gcd).
        aa = a.num * yy;
        bb = b.num * xx;
        dd = a.den * yy;
      }
    }
    public int CompareTo(BigRational that) {
      // simple things first
      int asign = this.num.Sign;
      int bsign = that.num.Sign;
      if (asign < 0 && 0 <= bsign) {
        return -1;
      } else if (asign <= 0 && 0 < bsign) {
        return -1;
      } else if (bsign < 0 && 0 <= asign) {
        return 1;
      } else if (bsign <= 0 && 0 < asign) {
        return 1;
      }
      BigInteger aa, bb, dd;
      Normalize(this, that, out aa, out bb, out dd);
      return aa.CompareTo(bb);
    }
    public int Sign {
      get {
        return num.Sign;
      }
    }
    public override int GetHashCode() {
      return num.GetHashCode() + 29 * den.GetHashCode();
    }
    public override bool Equals(object obj) {
      if (obj is BigRational) {
        return this == (BigRational)obj;
      } else {
        return false;
      }
    }
    public static bool operator ==(BigRational a, BigRational b) {
      return a.CompareTo(b) == 0;
    }
    public static bool operator !=(BigRational a, BigRational b) {
      return a.CompareTo(b) != 0;
    }
    public static bool operator >(BigRational a, BigRational b) {
      return a.CompareTo(b) > 0;
    }
    public static bool operator >=(BigRational a, BigRational b) {
      return a.CompareTo(b) >= 0;
    }
    public static bool operator <(BigRational a, BigRational b) {
      return a.CompareTo(b) < 0;
    }
    public static bool operator <=(BigRational a, BigRational b) {
      return a.CompareTo(b) <= 0;
    }
    public static BigRational operator +(BigRational a, BigRational b) {
      BigInteger aa, bb, dd;
      Normalize(a, b, out aa, out bb, out dd);
      return new BigRational(aa + bb, dd);
    }
    public static BigRational operator -(BigRational a, BigRational b) {
      BigInteger aa, bb, dd;
      Normalize(a, b, out aa, out bb, out dd);
      return new BigRational(aa - bb, dd);
    }
    public static BigRational operator -(BigRational a) {
      return new BigRational(-a.num, a.den);
    }
    public static BigRational operator *(BigRational a, BigRational b) {
      return new BigRational(a.num * b.num, a.den * b.den);
    }
    public static BigRational operator /(BigRational a, BigRational b) {
      // Compute the reciprocal of b
      BigRational bReciprocal;
      if (0 < b.num.Sign) {
        bReciprocal = new BigRational(b.den, b.num);
      } else {
        // this is the case b.num < 0
        bReciprocal = new BigRational(-b.den, -b.num);
      }
      return a * bReciprocal;
    }
  }

  public class HaltException : Exception {
    public HaltException(object message) : base(message.ToString())
    {
    }
  }
}

namespace @_System
{
  public class Tuple2<T0,T1> {
    public readonly T0 _0;
    public readonly T1 _1;
    public Tuple2(T0 _0, T1 _1) {
      this._0 = _0;
      this._1 = _1;
    }
    public override bool Equals(object other) {
      var oth = other as _System.Tuple2<T0,T1>;
      return oth != null && object.Equals(this._0, oth._0) && object.Equals(this._1, oth._1);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._0));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._1));
      return (int) hash;
    }
    public override string ToString() {
      string s = "";
      s += "(";
      s += Dafny.Helpers.ToString(this._0);
      s += ", ";
      s += Dafny.Helpers.ToString(this._1);
      s += ")";
      return s;
    }
    public static Tuple2<T0,T1> Default(T0 _default_T0, T1 _default_T1) {
      return create(_default_T0, _default_T1);
    }
    public static Dafny.TypeDescriptor<_System.Tuple2<T0, T1>> _TypeDescriptor(Dafny.TypeDescriptor<T0> _td_T0, Dafny.TypeDescriptor<T1> _td_T1) {
      return new Dafny.TypeDescriptor<_System.Tuple2<T0, T1>>(_System.Tuple2<T0, T1>.Default(_td_T0.Default(), _td_T1.Default()));
    }
    public static Tuple2<T0,T1> create(T0 _0, T1 _1) {
      return new Tuple2<T0,T1>(_0, _1);
    }
    public bool is____hMake2 { get { return true; } }
    public T0 dtor__0 {
      get {
        return this._0;
      }
    }
    public T1 dtor__1 {
      get {
        return this._1;
      }
    }
  }

} // end of namespace _System
namespace Dafny {
  internal class ArrayHelpers {
    public static T[] InitNewArray1<T>(T z, BigInteger size0) {
      int s0 = (int)size0;
      T[] a = new T[s0];
      for (int i0 = 0; i0 < s0; i0++) {
        a[i0] = z;
      }
      return a;
    }
  }
} // end of namespace Dafny
namespace _System {


  public partial class nat {
    private static readonly Dafny.TypeDescriptor<BigInteger> _TYPE = new Dafny.TypeDescriptor<BigInteger>(BigInteger.Zero);
    public static Dafny.TypeDescriptor<BigInteger> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public class Tuple0 {
    public Tuple0() {
    }
    public override bool Equals(object other) {
      var oth = other as _System.Tuple0;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      return (int) hash;
    }
    public override string ToString() {
      return "()";
    }
    private static readonly Tuple0 theDefault = create();
    public static Tuple0 Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<_System.Tuple0> _TYPE = new Dafny.TypeDescriptor<_System.Tuple0>(_System.Tuple0.Default());
    public static Dafny.TypeDescriptor<_System.Tuple0> _TypeDescriptor() {
      return _TYPE;
    }
    public static Tuple0 create() {
      return new Tuple0();
    }
    public static System.Collections.Generic.IEnumerable<Tuple0> AllSingletonConstructors {
      get {
        yield return Tuple0.create();
      }
    }
  }

  public class Tuple3<T0, T1, T2> {
    public readonly T0 _0;
    public readonly T1 _1;
    public readonly T2 _2;
    public Tuple3(T0 _0, T1 _1, T2 _2) {
      this._0 = _0;
      this._1 = _1;
      this._2 = _2;
    }
    public override bool Equals(object other) {
      var oth = other as _System.Tuple3<T0, T1, T2>;
      return oth != null && object.Equals(this._0, oth._0) && object.Equals(this._1, oth._1) && object.Equals(this._2, oth._2);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._0));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._1));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._2));
      return (int) hash;
    }
    public override string ToString() {
      string s = "";
      s += "(";
      s += Dafny.Helpers.ToString(this._0);
      s += ", ";
      s += Dafny.Helpers.ToString(this._1);
      s += ", ";
      s += Dafny.Helpers.ToString(this._2);
      s += ")";
      return s;
    }
    public static Tuple3<T0, T1, T2> Default(T0 _default_T0, T1 _default_T1, T2 _default_T2) {
      return create(_default_T0, _default_T1, _default_T2);
    }
    public static Dafny.TypeDescriptor<_System.Tuple3<T0, T1, T2>> _TypeDescriptor(Dafny.TypeDescriptor<T0> _td_T0, Dafny.TypeDescriptor<T1> _td_T1, Dafny.TypeDescriptor<T2> _td_T2) {
      return new Dafny.TypeDescriptor<_System.Tuple3<T0, T1, T2>>(_System.Tuple3<T0, T1, T2>.Default(_td_T0.Default(), _td_T1.Default(), _td_T2.Default()));
    }
    public static Tuple3<T0, T1, T2> create(T0 _0, T1 _1, T2 _2) {
      return new Tuple3<T0, T1, T2>(_0, _1, _2);
    }
    public T0 dtor__0 {
      get {
        return this._0;
      }
    }
    public T1 dtor__1 {
      get {
        return this._1;
      }
    }
    public T2 dtor__2 {
      get {
        return this._2;
      }
    }
  }







} // end of namespace _System
namespace Wrappers_Compile {

  public abstract class Option<T> {
    public Option() { }
    public static Option<T> Default() {
      return create_None();
    }
    public static Dafny.TypeDescriptor<Wrappers_Compile.Option<T>> _TypeDescriptor() {
      return new Dafny.TypeDescriptor<Wrappers_Compile.Option<T>>(Wrappers_Compile.Option<T>.Default());
    }
    public static Option<T> create_None() {
      return new Option_None<T>();
    }
    public static Option<T> create_Some(T @value) {
      return new Option_Some<T>(@value);
    }
    public bool is_None { get { return this is Option_None<T>; } }
    public bool is_Some { get { return this is Option_Some<T>; } }
    public T dtor_value {
      get {
        var d = this;
        return ((Option_Some<T>)d).@value; 
      }
    }
    public Wrappers_Compile.Result<T, Dafny.ISequence<char>> ToResult() {
      Wrappers_Compile.Option<T> _source0 = this;
      if (_source0.is_None) {
        return @Wrappers_Compile.Result<T, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Option is None"));
      } else {
        T _20666___mcc_h0 = ((Wrappers_Compile.Option_Some<T>)_source0).@value;
        T _20667_v = _20666___mcc_h0;
        return @Wrappers_Compile.Result<T, Dafny.ISequence<char>>.create_Success(_20667_v);
      }
    }
    public T UnwrapOr(T @default) {
      Wrappers_Compile.Option<T> _source1 = this;
      if (_source1.is_None) {
        return @default;
      } else {
        T _20668___mcc_h0 = ((Wrappers_Compile.Option_Some<T>)_source1).@value;
        T _20669_v = _20668___mcc_h0;
        return _20669_v;
      }
    }
    public bool IsFailure() {
      return (this).is_None;
    }
    public Wrappers_Compile.Option<__U> PropagateFailure<__U>() {
      return @Wrappers_Compile.Option<__U>.create_None();
    }
    public T Extract() {
      return (this).dtor_value;
    }
  }
  public class Option_None<T> : Option<T> {
    public Option_None() {
    }
    public override bool Equals(object other) {
      var oth = other as Wrappers_Compile.Option_None<T>;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      return (int) hash;
    }
    public override string ToString() {
      string s = "Wrappers_Compile.Option.None";
      return s;
    }
  }
  public class Option_Some<T> : Option<T> {
    public readonly T @value;
    public Option_Some(T @value) {
      this.@value = @value;
    }
    public override bool Equals(object other) {
      var oth = other as Wrappers_Compile.Option_Some<T>;
      return oth != null && object.Equals(this.@value, oth.@value);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.@value));
      return (int) hash;
    }
    public override string ToString() {
      string s = "Wrappers_Compile.Option.Some";
      s += "(";
      s += Dafny.Helpers.ToString(this.@value);
      s += ")";
      return s;
    }
  }

  public abstract class Result<T, R> {
    public Result() { }
    public static Result<T, R> Default(T _default_T) {
      return create_Success(_default_T);
    }
    public static Dafny.TypeDescriptor<Wrappers_Compile.Result<T, R>> _TypeDescriptor(Dafny.TypeDescriptor<T> _td_T) {
      return new Dafny.TypeDescriptor<Wrappers_Compile.Result<T, R>>(Wrappers_Compile.Result<T, R>.Default(_td_T.Default()));
    }
    public static Result<T, R> create_Success(T @value) {
      return new Result_Success<T, R>(@value);
    }
    public static Result<T, R> create_Failure(R error) {
      return new Result_Failure<T, R>(error);
    }
    public bool is_Success { get { return this is Result_Success<T, R>; } }
    public bool is_Failure { get { return this is Result_Failure<T, R>; } }
    public T dtor_value {
      get {
        var d = this;
        return ((Result_Success<T, R>)d).@value; 
      }
    }
    public R dtor_error {
      get {
        var d = this;
        return ((Result_Failure<T, R>)d).error; 
      }
    }
    public Wrappers_Compile.Option<T> ToOption() {
      Wrappers_Compile.Result<T, R> _source2 = this;
      if (_source2.is_Success) {
        T _20670___mcc_h0 = ((Wrappers_Compile.Result_Success<T, R>)_source2).@value;
        T _20671_s = _20670___mcc_h0;
        return @Wrappers_Compile.Option<T>.create_Some(_20671_s);
      } else {
        R _20672___mcc_h1 = ((Wrappers_Compile.Result_Failure<T, R>)_source2).error;
        R _20673_e = _20672___mcc_h1;
        return @Wrappers_Compile.Option<T>.create_None();
      }
    }
    public T UnwrapOr(T @default) {
      Wrappers_Compile.Result<T, R> _source3 = this;
      if (_source3.is_Success) {
        T _20674___mcc_h0 = ((Wrappers_Compile.Result_Success<T, R>)_source3).@value;
        T _20675_s = _20674___mcc_h0;
        return _20675_s;
      } else {
        R _20676___mcc_h1 = ((Wrappers_Compile.Result_Failure<T, R>)_source3).error;
        R _20677_e = _20676___mcc_h1;
        return @default;
      }
    }
    public bool IsFailure() {
      return (this).is_Failure;
    }
    public Wrappers_Compile.Result<__U, R> PropagateFailure<__U>() {
      return @Wrappers_Compile.Result<__U, R>.create_Failure((this).dtor_error);
    }
    public T Extract() {
      return (this).dtor_value;
    }
  }
  public class Result_Success<T, R> : Result<T, R> {
    public readonly T @value;
    public Result_Success(T @value) {
      this.@value = @value;
    }
    public override bool Equals(object other) {
      var oth = other as Wrappers_Compile.Result_Success<T, R>;
      return oth != null && object.Equals(this.@value, oth.@value);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.@value));
      return (int) hash;
    }
    public override string ToString() {
      string s = "Wrappers_Compile.Result.Success";
      s += "(";
      s += Dafny.Helpers.ToString(this.@value);
      s += ")";
      return s;
    }
  }
  public class Result_Failure<T, R> : Result<T, R> {
    public readonly R error;
    public Result_Failure(R error) {
      this.error = error;
    }
    public override bool Equals(object other) {
      var oth = other as Wrappers_Compile.Result_Failure<T, R>;
      return oth != null && object.Equals(this.error, oth.error);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.error));
      return (int) hash;
    }
    public override string ToString() {
      string s = "Wrappers_Compile.Result.Failure";
      s += "(";
      s += Dafny.Helpers.ToString(this.error);
      s += ")";
      return s;
    }
  }

  public abstract class Outcome<E> {
    public Outcome() { }
    public static Outcome<E> Default() {
      return create_Pass();
    }
    public static Dafny.TypeDescriptor<Wrappers_Compile.Outcome<E>> _TypeDescriptor() {
      return new Dafny.TypeDescriptor<Wrappers_Compile.Outcome<E>>(Wrappers_Compile.Outcome<E>.Default());
    }
    public static Outcome<E> create_Pass() {
      return new Outcome_Pass<E>();
    }
    public static Outcome<E> create_Fail(E error) {
      return new Outcome_Fail<E>(error);
    }
    public bool is_Pass { get { return this is Outcome_Pass<E>; } }
    public bool is_Fail { get { return this is Outcome_Fail<E>; } }
    public E dtor_error {
      get {
        var d = this;
        return ((Outcome_Fail<E>)d).error; 
      }
    }
    public bool IsFailure() {
      return (this).is_Fail;
    }
    public Wrappers_Compile.Result<__U, E> PropagateFailure<__U>() {
      return @Wrappers_Compile.Result<__U, E>.create_Failure((this).dtor_error);
    }
  }
  public class Outcome_Pass<E> : Outcome<E> {
    public Outcome_Pass() {
    }
    public override bool Equals(object other) {
      var oth = other as Wrappers_Compile.Outcome_Pass<E>;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      return (int) hash;
    }
    public override string ToString() {
      string s = "Wrappers_Compile.Outcome.Pass";
      return s;
    }
  }
  public class Outcome_Fail<E> : Outcome<E> {
    public readonly E error;
    public Outcome_Fail(E error) {
      this.error = error;
    }
    public override bool Equals(object other) {
      var oth = other as Wrappers_Compile.Outcome_Fail<E>;
      return oth != null && object.Equals(this.error, oth.error);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.error));
      return (int) hash;
    }
    public override string ToString() {
      string s = "Wrappers_Compile.Outcome.Fail";
      s += "(";
      s += Dafny.Helpers.ToString(this.error);
      s += ")";
      return s;
    }
  }

  public partial class __default {
    public static Wrappers_Compile.Outcome<__E> Need<__E>(bool condition, __E error)
    {
      if (condition) {
        return @Wrappers_Compile.Outcome<__E>.create_Pass();
      } else {
        return @Wrappers_Compile.Outcome<__E>.create_Fail(error);
      }
    }
  }
} // end of namespace Wrappers_Compile
namespace StandardLibrary_mUInt_Compile {

  public partial class uint8 {
    public static System.Collections.Generic.IEnumerable<byte> IntegerRange(BigInteger lo, BigInteger hi) {
      for (var j = lo; j < hi; j++) { yield return (byte)j; }
    }
    private static readonly Dafny.TypeDescriptor<byte> _TYPE = new Dafny.TypeDescriptor<byte>(0);
    public static Dafny.TypeDescriptor<byte> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public partial class uint16 {
    public static System.Collections.Generic.IEnumerable<ushort> IntegerRange(BigInteger lo, BigInteger hi) {
      for (var j = lo; j < hi; j++) { yield return (ushort)j; }
    }
    private static readonly Dafny.TypeDescriptor<ushort> _TYPE = new Dafny.TypeDescriptor<ushort>(0);
    public static Dafny.TypeDescriptor<ushort> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public partial class uint32 {
    public static System.Collections.Generic.IEnumerable<uint> IntegerRange(BigInteger lo, BigInteger hi) {
      for (var j = lo; j < hi; j++) { yield return (uint)j; }
    }
    private static readonly Dafny.TypeDescriptor<uint> _TYPE = new Dafny.TypeDescriptor<uint>(0);
    public static Dafny.TypeDescriptor<uint> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public partial class uint64 {
    public static System.Collections.Generic.IEnumerable<ulong> IntegerRange(BigInteger lo, BigInteger hi) {
      for (var j = lo; j < hi; j++) { yield return (ulong)j; }
    }
    private static readonly Dafny.TypeDescriptor<ulong> _TYPE = new Dafny.TypeDescriptor<ulong>(0);
    public static Dafny.TypeDescriptor<ulong> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public partial class int32 {
    public static System.Collections.Generic.IEnumerable<int> IntegerRange(BigInteger lo, BigInteger hi) {
      for (var j = lo; j < hi; j++) { yield return (int)j; }
    }
    private static readonly Dafny.TypeDescriptor<int> _TYPE = new Dafny.TypeDescriptor<int>(0);
    public static Dafny.TypeDescriptor<int> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public partial class __default {
    public static bool UInt8Less(byte a, byte b)
    {
      return (a) < (b);
    }
    public static Dafny.ISequence<byte> UInt16ToSeq(ushort x) {
      byte _20678_b0 = (byte)((ushort)((x) / (256)));
      byte _20679_b1 = (byte)((ushort)((x) % (256)));
      return Dafny.Sequence<byte>.FromElements(_20678_b0, _20679_b1);
    }
    public static ushort SeqToUInt16(Dafny.ISequence<byte> s) {
      ushort _20680_x0 = (ushort)(((ushort)((s).Select(BigInteger.Zero))) * (256));
      return (ushort)((_20680_x0) + ((ushort)((s).Select(BigInteger.One))));
    }
    public static Dafny.ISequence<byte> UInt32ToSeq(uint x) {
      byte _20681_b0 = (byte)((x) / (16777216U));
      uint _20682_x0 = (x) - (((uint)(_20681_b0)) * (16777216U));
      byte _20683_b1 = (byte)((_20682_x0) / (65536U));
      uint _20684_x1 = (_20682_x0) - (((uint)(_20683_b1)) * (65536U));
      byte _20685_b2 = (byte)((_20684_x1) / (256U));
      byte _20686_b3 = (byte)((_20684_x1) % (256U));
      return Dafny.Sequence<byte>.FromElements(_20681_b0, _20683_b1, _20685_b2, _20686_b3);
    }
    public static uint SeqToUInt32(Dafny.ISequence<byte> s) {
      uint _20687_x0 = ((uint)((s).Select(BigInteger.Zero))) * (16777216U);
      uint _20688_x1 = (_20687_x0) + (((uint)((s).Select(BigInteger.One))) * (65536U));
      uint _20689_x2 = (_20688_x1) + (((uint)((s).Select(new BigInteger(2)))) * (256U));
      return (_20689_x2) + ((uint)((s).Select(new BigInteger(3))));
    }
    public static Dafny.ISequence<byte> UInt64ToSeq(ulong x) {
      byte _20690_b0 = (byte)((x) / (72057594037927936UL));
      ulong _20691_x0 = (x) - (((ulong)(_20690_b0)) * (72057594037927936UL));
      byte _20692_b1 = (byte)((_20691_x0) / (281474976710656UL));
      ulong _20693_x1 = (_20691_x0) - (((ulong)(_20692_b1)) * (281474976710656UL));
      byte _20694_b2 = (byte)((_20693_x1) / (1099511627776UL));
      ulong _20695_x2 = (_20693_x1) - (((ulong)(_20694_b2)) * (1099511627776UL));
      byte _20696_b3 = (byte)((_20695_x2) / (4294967296UL));
      ulong _20697_x3 = (_20695_x2) - (((ulong)(_20696_b3)) * (4294967296UL));
      byte _20698_b4 = (byte)((_20697_x3) / (16777216UL));
      ulong _20699_x4 = (_20697_x3) - (((ulong)(_20698_b4)) * (16777216UL));
      byte _20700_b5 = (byte)((_20699_x4) / (65536UL));
      ulong _20701_x5 = (_20699_x4) - (((ulong)(_20700_b5)) * (65536UL));
      byte _20702_b6 = (byte)((_20701_x5) / (256UL));
      byte _20703_b7 = (byte)((_20701_x5) % (256UL));
      return Dafny.Sequence<byte>.FromElements(_20690_b0, _20692_b1, _20694_b2, _20696_b3, _20698_b4, _20700_b5, _20702_b6, _20703_b7);
    }
    public static ulong SeqToUInt64(Dafny.ISequence<byte> s) {
      ulong _20704_x0 = ((ulong)((s).Select(BigInteger.Zero))) * (72057594037927936UL);
      ulong _20705_x1 = (_20704_x0) + (((ulong)((s).Select(BigInteger.One))) * (281474976710656UL));
      ulong _20706_x2 = (_20705_x1) + (((ulong)((s).Select(new BigInteger(2)))) * (1099511627776UL));
      ulong _20707_x3 = (_20706_x2) + (((ulong)((s).Select(new BigInteger(3)))) * (4294967296UL));
      ulong _20708_x4 = (_20707_x3) + (((ulong)((s).Select(new BigInteger(4)))) * (16777216UL));
      ulong _20709_x5 = (_20708_x4) + (((ulong)((s).Select(new BigInteger(5)))) * (65536UL));
      ulong _20710_x6 = (_20709_x5) + (((ulong)((s).Select(new BigInteger(6)))) * (256UL));
      ulong _20711_x = (_20710_x6) + ((ulong)((s).Select(new BigInteger(7))));
      return _20711_x;
    }
    public static BigInteger UINT32__LIMIT { get {
      return new BigInteger(4294967296L);
    } }
    public static BigInteger UINT16__LIMIT { get {
      return new BigInteger(65536);
    } }
    public static BigInteger INT32__MAX__LIMIT { get {
      return new BigInteger(2147483648L);
    } }
  }
} // end of namespace StandardLibrary_mUInt_Compile
namespace StandardLibrary_Compile {



  public partial class __default {
    public static Dafny.ISequence<__T> Join<__T>(Dafny.ISequence<Dafny.ISequence<__T>> ss, Dafny.ISequence<__T> joiner)
    {
      Dafny.ISequence<__T> _20712___accumulator = Dafny.Sequence<__T>.FromElements();
    TAIL_CALL_START: ;
      if ((new BigInteger((ss).Count)) == (BigInteger.One)) {
        return Dafny.Sequence<__T>.Concat(_20712___accumulator, (ss).Select(BigInteger.Zero));
      } else {
        _20712___accumulator = Dafny.Sequence<__T>.Concat(_20712___accumulator, Dafny.Sequence<__T>.Concat((ss).Select(BigInteger.Zero), joiner));
        Dafny.ISequence<Dafny.ISequence<__T>> _in0 = (ss).Drop(BigInteger.One);
        Dafny.ISequence<__T> _in1 = joiner;
        ss = _in0;
        joiner = _in1;
        goto TAIL_CALL_START;
      }
    }
    public static Dafny.ISequence<Dafny.ISequence<__T>> Split<__T>(Dafny.ISequence<__T> s, __T delim)
    {
      Dafny.ISequence<Dafny.ISequence<__T>> _20713___accumulator = Dafny.Sequence<Dafny.ISequence<__T>>.FromElements();
    TAIL_CALL_START: ;
      Wrappers_Compile.Option<BigInteger> _20714_i = StandardLibrary_Compile.__default.FindIndexMatching<__T>(s, delim, BigInteger.Zero);
      if ((_20714_i).is_Some) {
        _20713___accumulator = Dafny.Sequence<Dafny.ISequence<__T>>.Concat(_20713___accumulator, Dafny.Sequence<Dafny.ISequence<__T>>.FromElements((s).Take((_20714_i).dtor_value)));
        Dafny.ISequence<__T> _in2 = (s).Drop(((_20714_i).dtor_value) + (BigInteger.One));
        __T _in3 = delim;
        s = _in2;
        delim = _in3;
        goto TAIL_CALL_START;
      } else {
        return Dafny.Sequence<Dafny.ISequence<__T>>.Concat(_20713___accumulator, Dafny.Sequence<Dafny.ISequence<__T>>.FromElements(s));
      }
    }
    public static Wrappers_Compile.Option<BigInteger> FindIndexMatching<__T>(Dafny.ISequence<__T> s, __T c, BigInteger i)
    {
      return StandardLibrary_Compile.__default.FindIndex<__T>(s, Dafny.Helpers.Id<Func<__T, Func<__T, bool>>>((_20715_c) => ((System.Func<__T, bool>)((_20716_x) => {
        return object.Equals(_20716_x, _20715_c);
      })))(c), i);
    }
    public static Wrappers_Compile.Option<BigInteger> FindIndex<__T>(Dafny.ISequence<__T> s, Func<__T, bool> f, BigInteger i)
    {
    TAIL_CALL_START: ;
      if ((i) == (new BigInteger((s).Count))) {
        return @Wrappers_Compile.Option<BigInteger>.create_None();
      } else if (Dafny.Helpers.Id<Func<__T, bool>>(f)((s).Select(i))) {
        return @Wrappers_Compile.Option<BigInteger>.create_Some(i);
      } else {
        Dafny.ISequence<__T> _in4 = s;
        Func<__T, bool> _in5 = f;
        BigInteger _in6 = (i) + (BigInteger.One);
        s = _in4;
        f = _in5;
        i = _in6;
        goto TAIL_CALL_START;
      }
    }
    public static Dafny.ISequence<__T> Filter<__T>(Dafny.ISequence<__T> s, Func<__T, bool> f)
    {
      Dafny.ISequence<__T> _20717___accumulator = Dafny.Sequence<__T>.FromElements();
    TAIL_CALL_START: ;
      if ((new BigInteger((s).Count)).Sign == 0) {
        return Dafny.Sequence<__T>.Concat(_20717___accumulator, Dafny.Sequence<__T>.FromElements());
      } else if (Dafny.Helpers.Id<Func<__T, bool>>(f)((s).Select(BigInteger.Zero))) {
        _20717___accumulator = Dafny.Sequence<__T>.Concat(_20717___accumulator, Dafny.Sequence<__T>.FromElements((s).Select(BigInteger.Zero)));
        Dafny.ISequence<__T> _in7 = (s).Drop(BigInteger.One);
        Func<__T, bool> _in8 = f;
        s = _in7;
        f = _in8;
        goto TAIL_CALL_START;
      } else {
        Dafny.ISequence<__T> _in9 = (s).Drop(BigInteger.One);
        Func<__T, bool> _in10 = f;
        s = _in9;
        f = _in10;
        goto TAIL_CALL_START;
      }
    }
    public static BigInteger Min(BigInteger a, BigInteger b)
    {
      if ((a) < (b)) {
        return a;
      } else {
        return b;
      }
    }
    public static Dafny.ISequence<__T> Fill<__T>(__T @value, BigInteger n)
    {
      return ((System.Func<Dafny.ISequence<__T>>) (() => {
        BigInteger dim0 = n;
        var arr0 = new __T[Dafny.Helpers.ToIntChecked(dim0,"C# array size must not be larger than max 32-bit int")];
        for (int i0 = 0; i0 < dim0; i0++) {
          var _20718___v0 = (BigInteger) i0;
          arr0[(int)(_20718___v0)] = @value;
        }
        return Dafny.Sequence<__T>.FromArray(arr0);
      }))();
    }
    public static __T[] SeqToArray<__T>(Dafny.ISequence<__T> s)
    {
      __T[] a = new __T[0];
      __T[] _nw0 = new __T[Dafny.Helpers.ToIntChecked(Dafny.Helpers.ToIntChecked(new BigInteger((s).Count), "C# arrays may not be larger than the max 32-bit integer"),"C# array size must not be larger than max 32-bit int")];
      Func<BigInteger, __T> _arrayinit0 = Dafny.Helpers.Id<Func<Dafny.ISequence<__T>, Func<BigInteger, __T>>>((_20719_s) => ((System.Func<BigInteger, __T>)((_20720_i) => {
        return (_20719_s).Select(_20720_i);
      })))(s);
      for (var _arrayinit_00 = 0; _arrayinit_00 < new BigInteger(_nw0.Length); _arrayinit_00++) {
        _nw0[(int)(_arrayinit_00)] = _arrayinit0(_arrayinit_00);
      }
      a = _nw0;
      return a;
    }
    public static bool LexicographicLessOrEqual<__T>(Dafny.ISequence<__T> a, Dafny.ISequence<__T> b, Func<__T, __T, bool> less)
    {
      return Dafny.Helpers.Id<Func<Dafny.ISequence<__T>, Dafny.ISequence<__T>, Func<__T, __T, bool>, bool>>((_20721_a, _20722_b, _20723_less) => Dafny.Helpers.Quantifier<BigInteger>(Dafny.Helpers.IntegerRange(BigInteger.Zero, (new BigInteger((_20721_a).Count)) + (BigInteger.One)), false, (((_20724_k) => {
        return (((_20724_k).Sign != -1) && ((_20724_k) <= (new BigInteger((_20721_a).Count)))) && (StandardLibrary_Compile.__default.LexicographicLessOrEqualAux<__T>(_20721_a, _20722_b, _20723_less, _20724_k));
      }))))(a, b, less);
    }
    public static bool LexicographicLessOrEqualAux<__T>(Dafny.ISequence<__T> a, Dafny.ISequence<__T> b, Func<__T, __T, bool> less, BigInteger lengthOfCommonPrefix)
    {
      return (((lengthOfCommonPrefix) <= (new BigInteger((b).Count))) && (Dafny.Helpers.Id<Func<BigInteger, Dafny.ISequence<__T>, Dafny.ISequence<__T>, bool>>((_20725_lengthOfCommonPrefix, _20726_a, _20727_b) => Dafny.Helpers.Quantifier<BigInteger>(Dafny.Helpers.IntegerRange(BigInteger.Zero, _20725_lengthOfCommonPrefix), true, (((_20728_i) => {
        return !(((_20728_i).Sign != -1) && ((_20728_i) < (_20725_lengthOfCommonPrefix))) || (object.Equals((_20726_a).Select(_20728_i), (_20727_b).Select(_20728_i)));
      }))))(lengthOfCommonPrefix, a, b))) && (((lengthOfCommonPrefix) == (new BigInteger((a).Count))) || (((lengthOfCommonPrefix) < (new BigInteger((b).Count))) && (Dafny.Helpers.Id<Func<__T, __T, bool>>(less)((a).Select(lengthOfCommonPrefix), (b).Select(lengthOfCommonPrefix)))));
    }
    public static Dafny.ISequence<Dafny.ISequence<__T>> SetToOrderedSequence<__T>(Dafny.ISet<Dafny.ISequence<__T>> s, Func<__T, __T, bool> less)
    {
      Dafny.ISequence<Dafny.ISequence<__T>> _20729___accumulator = Dafny.Sequence<Dafny.ISequence<__T>>.FromElements();
    TAIL_CALL_START: ;
      if ((s).Equals((Dafny.Set<Dafny.ISequence<__T>>.FromElements()))) {
        return Dafny.Sequence<Dafny.ISequence<__T>>.Concat(_20729___accumulator, Dafny.Sequence<Dafny.ISequence<__T>>.FromElements());
      } else {
        return Dafny.Helpers.Let<int, Dafny.ISequence<Dafny.ISequence<__T>>>(0, _let_dummy_0 =>  {
          Dafny.ISequence<__T> _20730_a = Dafny.Sequence<__T>.Empty;
          foreach (Dafny.ISequence<__T> _assign_such_that_0 in (s).Elements) {
            _20730_a = (Dafny.ISequence<__T>)_assign_such_that_0;
            if (((s).Contains((_20730_a))) && (StandardLibrary_Compile.__default.IsMinimum<__T>(_20730_a, s, less))) {
              goto after__ASSIGN_SUCH_THAT_0;
            }
          }
          throw new System.Exception("assign-such-that search produced no value (line 343)");
        after__ASSIGN_SUCH_THAT_0: ;
          return Dafny.Sequence<Dafny.ISequence<__T>>.Concat(Dafny.Sequence<Dafny.ISequence<__T>>.FromElements(_20730_a), StandardLibrary_Compile.__default.SetToOrderedSequence<__T>(Dafny.Set<Dafny.ISequence<__T>>.Difference(s, Dafny.Set<Dafny.ISequence<__T>>.FromElements(_20730_a)), less));
        });
      }
    }
    public static bool IsMinimum<__T>(Dafny.ISequence<__T> a, Dafny.ISet<Dafny.ISequence<__T>> s, Func<__T, __T, bool> less)
    {
      return ((s).Contains((a))) && (Dafny.Helpers.Id<Func<Dafny.ISet<Dafny.ISequence<__T>>, Dafny.ISequence<__T>, Func<__T, __T, bool>, bool>>((_20731_s, _20732_a, _20733_less) => Dafny.Helpers.Quantifier<Dafny.ISequence<__T>>((_20731_s).Elements, true, (((_20734_z) => {
        return !((_20731_s).Contains((_20734_z))) || (StandardLibrary_Compile.__default.LexicographicLessOrEqual<__T>(_20732_a, _20734_z, _20733_less));
      }))))(s, a, less));
    }
  }

} // end of namespace StandardLibrary_Compile
namespace EncryptionSuites {


  public class EncryptionAlgorithm {
    public readonly EncryptionSuites.AESMode mode;
    public EncryptionAlgorithm(EncryptionSuites.AESMode mode) {
      this.mode = mode;
    }
    public override bool Equals(object other) {
      var oth = other as EncryptionSuites.EncryptionAlgorithm;
      return oth != null && object.Equals(this.mode, oth.mode);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.mode));
      return (int) hash;
    }
    public override string ToString() {
      string s = "EncryptionSuites_Compile.EncryptionAlgorithm.AES";
      s += "(";
      s += Dafny.Helpers.ToString(this.mode);
      s += ")";
      return s;
    }
    private static readonly EncryptionAlgorithm theDefault = create(EncryptionSuites.AESMode.Default());
    public static EncryptionAlgorithm Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<EncryptionSuites.EncryptionAlgorithm> _TYPE = new Dafny.TypeDescriptor<EncryptionSuites.EncryptionAlgorithm>(EncryptionSuites.EncryptionAlgorithm.Default());
    public static Dafny.TypeDescriptor<EncryptionSuites.EncryptionAlgorithm> _TypeDescriptor() {
      return _TYPE;
    }
    public static EncryptionAlgorithm create(EncryptionSuites.AESMode mode) {
      return new EncryptionAlgorithm(mode);
    }
    public bool is_AES { get { return true; } }
    public EncryptionSuites.AESMode dtor_mode {
      get {
        return this.mode;
      }
    }
  }

  public class AESMode {
    public AESMode() {
    }
    public override bool Equals(object other) {
      var oth = other as EncryptionSuites.AESMode;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      return (int) hash;
    }
    public override string ToString() {
      string s = "EncryptionSuites_Compile.AESMode.GCM";
      return s;
    }
    private static readonly AESMode theDefault = create();
    public static AESMode Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<EncryptionSuites.AESMode> _TYPE = new Dafny.TypeDescriptor<EncryptionSuites.AESMode>(EncryptionSuites.AESMode.Default());
    public static Dafny.TypeDescriptor<EncryptionSuites.AESMode> _TypeDescriptor() {
      return _TYPE;
    }
    public static AESMode create() {
      return new AESMode();
    }
    public bool is_GCM { get { return true; } }
    public static System.Collections.Generic.IEnumerable<AESMode> AllSingletonConstructors {
      get {
        yield return AESMode.create();
      }
    }
  }

  public class EncryptionSuite {
    public readonly EncryptionSuites.EncryptionAlgorithm alg;
    public readonly byte keyLen;
    public readonly byte tagLen;
    public readonly byte ivLen;
    public EncryptionSuite(EncryptionSuites.EncryptionAlgorithm alg, byte keyLen, byte tagLen, byte ivLen) {
      this.alg = alg;
      this.keyLen = keyLen;
      this.tagLen = tagLen;
      this.ivLen = ivLen;
    }
    public override bool Equals(object other) {
      var oth = other as EncryptionSuites.EncryptionSuite;
      return oth != null && object.Equals(this.alg, oth.alg) && this.keyLen == oth.keyLen && this.tagLen == oth.tagLen && this.ivLen == oth.ivLen;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.alg));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.keyLen));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.tagLen));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.ivLen));
      return (int) hash;
    }
    public override string ToString() {
      string s = "EncryptionSuites_Compile.EncryptionSuite.EncryptionSuite";
      s += "(";
      s += Dafny.Helpers.ToString(this.alg);
      s += ", ";
      s += Dafny.Helpers.ToString(this.keyLen);
      s += ", ";
      s += Dafny.Helpers.ToString(this.tagLen);
      s += ", ";
      s += Dafny.Helpers.ToString(this.ivLen);
      s += ")";
      return s;
    }
    private static readonly EncryptionSuite theDefault = create(EncryptionSuites.EncryptionAlgorithm.Default(), 0, 0, 0);
    public static EncryptionSuite Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<EncryptionSuites.EncryptionSuite> _TYPE = new Dafny.TypeDescriptor<EncryptionSuites.EncryptionSuite>(EncryptionSuites.EncryptionSuite.Default());
    public static Dafny.TypeDescriptor<EncryptionSuites.EncryptionSuite> _TypeDescriptor() {
      return _TYPE;
    }
    public static EncryptionSuite create(EncryptionSuites.EncryptionAlgorithm alg, byte keyLen, byte tagLen, byte ivLen) {
      return new EncryptionSuite(alg, keyLen, tagLen, ivLen);
    }
    public bool is_EncryptionSuite { get { return true; } }
    public EncryptionSuites.EncryptionAlgorithm dtor_alg {
      get {
        return this.alg;
      }
    }
    public byte dtor_keyLen {
      get {
        return this.keyLen;
      }
    }
    public byte dtor_tagLen {
      get {
        return this.tagLen;
      }
    }
    public byte dtor_ivLen {
      get {
        return this.ivLen;
      }
    }
  }

  public partial class __default {
    public static byte AES__TAG__LEN { get {
      return (byte)(16);
    } }
    public static byte AES__IV__LEN { get {
      return (byte)(12);
    } }
    public static EncryptionSuites.EncryptionSuite AES__GCM__128 { get {
      return @EncryptionSuites.EncryptionSuite.create(@EncryptionSuites.EncryptionAlgorithm.create(@EncryptionSuites.AESMode.create()), 16, EncryptionSuites.__default.AES__TAG__LEN, EncryptionSuites.__default.AES__IV__LEN);
    } }
    public static EncryptionSuites.EncryptionSuite AES__GCM__192 { get {
      return @EncryptionSuites.EncryptionSuite.create(@EncryptionSuites.EncryptionAlgorithm.create(@EncryptionSuites.AESMode.create()), 24, EncryptionSuites.__default.AES__TAG__LEN, EncryptionSuites.__default.AES__IV__LEN);
    } }
    public static EncryptionSuites.EncryptionSuite AES__GCM__256 { get {
      return @EncryptionSuites.EncryptionSuite.create(@EncryptionSuites.EncryptionAlgorithm.create(@EncryptionSuites.AESMode.create()), 32, EncryptionSuites.__default.AES__TAG__LEN, EncryptionSuites.__default.AES__IV__LEN);
    } }
    public static Dafny.ISet<BigInteger> AES__CIPHER__KEY__LENGTHS { get {
      return Dafny.Set<BigInteger>.FromElements(new BigInteger(32), new BigInteger(24), new BigInteger(16));
    } }
    public static BigInteger AES__MAX__KEY__LEN { get {
      return new BigInteger(32);
    } }
  }
} // end of namespace EncryptionSuites
namespace AESEncryption {





  public class EncryptionOutput {
    public readonly Dafny.ISequence<byte> cipherText;
    public readonly Dafny.ISequence<byte> authTag;
    public EncryptionOutput(Dafny.ISequence<byte> cipherText, Dafny.ISequence<byte> authTag) {
      this.cipherText = cipherText;
      this.authTag = authTag;
    }
    public override bool Equals(object other) {
      var oth = other as AESEncryption.EncryptionOutput;
      return oth != null && object.Equals(this.cipherText, oth.cipherText) && object.Equals(this.authTag, oth.authTag);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.cipherText));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.authTag));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AESEncryption_Compile.EncryptionOutput.EncryptionOutput";
      s += "(";
      s += Dafny.Helpers.ToString(this.cipherText);
      s += ", ";
      s += Dafny.Helpers.ToString(this.authTag);
      s += ")";
      return s;
    }
    private static readonly EncryptionOutput theDefault = create(Dafny.Sequence<byte>.Empty, Dafny.Sequence<byte>.Empty);
    public static EncryptionOutput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<AESEncryption.EncryptionOutput> _TYPE = new Dafny.TypeDescriptor<AESEncryption.EncryptionOutput>(AESEncryption.EncryptionOutput.Default());
    public static Dafny.TypeDescriptor<AESEncryption.EncryptionOutput> _TypeDescriptor() {
      return _TYPE;
    }
    public static EncryptionOutput create(Dafny.ISequence<byte> cipherText, Dafny.ISequence<byte> authTag) {
      return new EncryptionOutput(cipherText, authTag);
    }
    public bool is_EncryptionOutput { get { return true; } }
    public Dafny.ISequence<byte> dtor_cipherText {
      get {
        return this.cipherText;
      }
    }
    public Dafny.ISequence<byte> dtor_authTag {
      get {
        return this.authTag;
      }
    }
  }

  public partial class __default {
    public static AESEncryption.EncryptionOutput EncryptionOutputFromByteSeq(Dafny.ISequence<byte> s, EncryptionSuites.EncryptionSuite encAlg)
    {
      return @AESEncryption.EncryptionOutput.create((s).Take((new BigInteger((s).Count)) - (new BigInteger((encAlg).dtor_tagLen))), (s).Drop((new BigInteger((s).Count)) - (new BigInteger((encAlg).dtor_tagLen))));
    }
    public static Wrappers_Compile.Result<AESEncryption.EncryptionOutput, Dafny.ISequence<char>> AESEncrypt(EncryptionSuites.EncryptionSuite encAlg, Dafny.ISequence<byte> iv, Dafny.ISequence<byte> key, Dafny.ISequence<byte> msg, Dafny.ISequence<byte> aad)
    {
      Wrappers_Compile.Result<AESEncryption.EncryptionOutput, Dafny.ISequence<char>> res = Wrappers_Compile.Result<AESEncryption.EncryptionOutput, Dafny.ISequence<char>>.Default(AESEncryption.EncryptionOutput.Default());
      Wrappers_Compile.Result<AESEncryption.EncryptionOutput, Dafny.ISequence<char>> _out0;
      _out0 = AESEncryption.AES_GCM.AESEncryptExtern(encAlg, iv, key, msg, aad);
      res = _out0;
      if (((res).is_Success) && ((new BigInteger((((res).dtor_value).dtor_cipherText).Count)) != (new BigInteger((msg).Count)))) {
        res = @Wrappers_Compile.Result<AESEncryption.EncryptionOutput, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("AESEncrypt did not return cipherText of expected length"));
      }
      if (((res).is_Success) && ((new BigInteger((((res).dtor_value).dtor_authTag).Count)) != (new BigInteger((encAlg).dtor_tagLen)))) {
        res = @Wrappers_Compile.Result<AESEncryption.EncryptionOutput, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("AESEncryption did not return valid tag"));
      }
      return res;
    }
    public static Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> AESDecrypt(EncryptionSuites.EncryptionSuite encAlg, Dafny.ISequence<byte> key, Dafny.ISequence<byte> cipherTxt, Dafny.ISequence<byte> authTag, Dafny.ISequence<byte> iv, Dafny.ISequence<byte> aad)
    {
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> res = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out1;
      _out1 = AESEncryption.AES_GCM.AESDecryptExtern(encAlg, key, cipherTxt, authTag, iv, aad);
      res = _out1;
      if (((res).is_Success) && ((new BigInteger((cipherTxt).Count)) != (new BigInteger(((res).dtor_value).Count)))) {
        res = @Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("AESDecrypt did not return plaintext of expected length"));
      }
      return res;
    }
  }
} // end of namespace AESEncryption
namespace CryptoDatatypes_Compile {

  public class DigestAlgorithm {
    public DigestAlgorithm() {
    }
    public override bool Equals(object other) {
      var oth = other as CryptoDatatypes_Compile.DigestAlgorithm;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      return (int) hash;
    }
    public override string ToString() {
      string s = "CryptoDatatypes_Compile.DigestAlgorithm.SHA_512";
      return s;
    }
    private static readonly DigestAlgorithm theDefault = create();
    public static DigestAlgorithm Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<CryptoDatatypes_Compile.DigestAlgorithm> _TYPE = new Dafny.TypeDescriptor<CryptoDatatypes_Compile.DigestAlgorithm>(CryptoDatatypes_Compile.DigestAlgorithm.Default());
    public static Dafny.TypeDescriptor<CryptoDatatypes_Compile.DigestAlgorithm> _TypeDescriptor() {
      return _TYPE;
    }
    public static DigestAlgorithm create() {
      return new DigestAlgorithm();
    }
    public bool is_SHA__512 { get { return true; } }
    public static System.Collections.Generic.IEnumerable<DigestAlgorithm> AllSingletonConstructors {
      get {
        yield return DigestAlgorithm.create();
      }
    }
  }

} // end of namespace CryptoDatatypes_Compile
namespace ExternDigest {




} // end of namespace ExternDigest
namespace Digest_Compile {





  public partial class __default {
    public static BigInteger Length(CryptoDatatypes_Compile.DigestAlgorithm alg) {
      CryptoDatatypes_Compile.DigestAlgorithm _source4 = alg;
      {
        return new BigInteger(64);
      }
    }
    public static Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> Digest(CryptoDatatypes_Compile.DigestAlgorithm alg, Dafny.ISequence<byte> msg)
    {
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> res = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _20735_result;
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out2;
      _out2 = ExternDigest.__default.Digest(alg, msg);
      _20735_result = _out2;
      if (((_20735_result).is_Success) && ((new BigInteger(((_20735_result).dtor_value).Count)) != (Digest_Compile.__default.Length(alg)))) {
        res = @Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Incorrect length digest from ExternDigest."));
        return res;
      }
      res = _20735_result;
      return res;
      return res;
    }
  }
} // end of namespace Digest_Compile
namespace KeyDerivationAlgorithms {


  public abstract class KeyDerivationAlgorithm {
    public KeyDerivationAlgorithm() { }
    private static readonly KeyDerivationAlgorithm theDefault = create_HKDF__WITH__SHA__384();
    public static KeyDerivationAlgorithm Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<KeyDerivationAlgorithms.KeyDerivationAlgorithm> _TYPE = new Dafny.TypeDescriptor<KeyDerivationAlgorithms.KeyDerivationAlgorithm>(KeyDerivationAlgorithms.KeyDerivationAlgorithm.Default());
    public static Dafny.TypeDescriptor<KeyDerivationAlgorithms.KeyDerivationAlgorithm> _TypeDescriptor() {
      return _TYPE;
    }
    public static KeyDerivationAlgorithm create_HKDF__WITH__SHA__384() {
      return new KeyDerivationAlgorithm_HKDF__WITH__SHA__384();
    }
    public static KeyDerivationAlgorithm create_HKDF__WITH__SHA__256() {
      return new KeyDerivationAlgorithm_HKDF__WITH__SHA__256();
    }
    public static KeyDerivationAlgorithm create_IDENTITY() {
      return new KeyDerivationAlgorithm_IDENTITY();
    }
    public bool is_HKDF__WITH__SHA__384 { get { return this is KeyDerivationAlgorithm_HKDF__WITH__SHA__384; } }
    public bool is_HKDF__WITH__SHA__256 { get { return this is KeyDerivationAlgorithm_HKDF__WITH__SHA__256; } }
    public bool is_IDENTITY { get { return this is KeyDerivationAlgorithm_IDENTITY; } }
    public static System.Collections.Generic.IEnumerable<KeyDerivationAlgorithm> AllSingletonConstructors {
      get {
        yield return KeyDerivationAlgorithm.create_HKDF__WITH__SHA__384();
        yield return KeyDerivationAlgorithm.create_HKDF__WITH__SHA__256();
        yield return KeyDerivationAlgorithm.create_IDENTITY();
      }
    }
  }
  public class KeyDerivationAlgorithm_HKDF__WITH__SHA__384 : KeyDerivationAlgorithm {
    public KeyDerivationAlgorithm_HKDF__WITH__SHA__384() {
    }
    public override bool Equals(object other) {
      var oth = other as KeyDerivationAlgorithms.KeyDerivationAlgorithm_HKDF__WITH__SHA__384;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      return (int) hash;
    }
    public override string ToString() {
      string s = "KeyDerivationAlgorithms_Compile.KeyDerivationAlgorithm.HKDF_WITH_SHA_384";
      return s;
    }
  }
  public class KeyDerivationAlgorithm_HKDF__WITH__SHA__256 : KeyDerivationAlgorithm {
    public KeyDerivationAlgorithm_HKDF__WITH__SHA__256() {
    }
    public override bool Equals(object other) {
      var oth = other as KeyDerivationAlgorithms.KeyDerivationAlgorithm_HKDF__WITH__SHA__256;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      return (int) hash;
    }
    public override string ToString() {
      string s = "KeyDerivationAlgorithms_Compile.KeyDerivationAlgorithm.HKDF_WITH_SHA_256";
      return s;
    }
  }
  public class KeyDerivationAlgorithm_IDENTITY : KeyDerivationAlgorithm {
    public KeyDerivationAlgorithm_IDENTITY() {
    }
    public override bool Equals(object other) {
      var oth = other as KeyDerivationAlgorithms.KeyDerivationAlgorithm_IDENTITY;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 2;
      return (int) hash;
    }
    public override string ToString() {
      string s = "KeyDerivationAlgorithms_Compile.KeyDerivationAlgorithm.IDENTITY";
      return s;
    }
  }

  public partial class HKDFAlgorithms {
    private static readonly KeyDerivationAlgorithms.KeyDerivationAlgorithm Witness = @KeyDerivationAlgorithms.KeyDerivationAlgorithm.create_HKDF__WITH__SHA__384();
    public static KeyDerivationAlgorithms.KeyDerivationAlgorithm Default() {
      return Witness;
    }
    private static readonly Dafny.TypeDescriptor<KeyDerivationAlgorithms.KeyDerivationAlgorithm> _TYPE = new Dafny.TypeDescriptor<KeyDerivationAlgorithms.KeyDerivationAlgorithm>(KeyDerivationAlgorithms.HKDFAlgorithms.Default());
    public static Dafny.TypeDescriptor<KeyDerivationAlgorithms.KeyDerivationAlgorithm> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public partial class IdentityAlgorithm {
    private static readonly KeyDerivationAlgorithms.KeyDerivationAlgorithm Witness = @KeyDerivationAlgorithms.KeyDerivationAlgorithm.create_IDENTITY();
    public static KeyDerivationAlgorithms.KeyDerivationAlgorithm Default() {
      return Witness;
    }
    private static readonly Dafny.TypeDescriptor<KeyDerivationAlgorithms.KeyDerivationAlgorithm> _TYPE = new Dafny.TypeDescriptor<KeyDerivationAlgorithms.KeyDerivationAlgorithm>(KeyDerivationAlgorithms.IdentityAlgorithm.Default());
    public static Dafny.TypeDescriptor<KeyDerivationAlgorithms.KeyDerivationAlgorithm> _TypeDescriptor() {
      return _TYPE;
    }
  }

} // end of namespace KeyDerivationAlgorithms
namespace HMAC {




  public abstract class Digests {
    public Digests() { }
    private static readonly Digests theDefault = create_SHA__256();
    public static Digests Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<HMAC.Digests> _TYPE = new Dafny.TypeDescriptor<HMAC.Digests>(HMAC.Digests.Default());
    public static Dafny.TypeDescriptor<HMAC.Digests> _TypeDescriptor() {
      return _TYPE;
    }
    public static Digests create_SHA__256() {
      return new Digests_SHA__256();
    }
    public static Digests create_SHA__384() {
      return new Digests_SHA__384();
    }
    public bool is_SHA__256 { get { return this is Digests_SHA__256; } }
    public bool is_SHA__384 { get { return this is Digests_SHA__384; } }
    public static System.Collections.Generic.IEnumerable<Digests> AllSingletonConstructors {
      get {
        yield return Digests.create_SHA__256();
        yield return Digests.create_SHA__384();
      }
    }
  }
  public class Digests_SHA__256 : Digests {
    public Digests_SHA__256() {
    }
    public override bool Equals(object other) {
      var oth = other as HMAC.Digests_SHA__256;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      return (int) hash;
    }
    public override string ToString() {
      string s = "HMAC_Compile.Digests.SHA_256";
      return s;
    }
  }
  public class Digests_SHA__384 : Digests {
    public Digests_SHA__384() {
    }
    public override bool Equals(object other) {
      var oth = other as HMAC.Digests_SHA__384;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      return (int) hash;
    }
    public override string ToString() {
      string s = "HMAC_Compile.Digests.SHA_384";
      return s;
    }
  }


  public partial class __default {
    public static BigInteger GetHashLength(HMAC.Digests digest) {
      HMAC.Digests _source5 = digest;
      if (_source5.is_SHA__256) {
        return new BigInteger(32);
      } else {
        return new BigInteger(48);
      }
    }
  }
} // end of namespace HMAC
namespace HKDF_Compile {





  public partial class __default {
    public static HMAC.Digests GetHMACDigestFromHKDFAlgorithm(KeyDerivationAlgorithms.KeyDerivationAlgorithm algorithm) {
      KeyDerivationAlgorithms.KeyDerivationAlgorithm _source6 = algorithm;
      if (_source6.is_HKDF__WITH__SHA__384) {
        return @HMAC.Digests.create_SHA__384();
      } else {
        return @HMAC.Digests.create_SHA__256();
      }
    }
    public static Dafny.ISequence<byte> Extract(HMAC.HMac hmac, Dafny.ISequence<byte> salt, Dafny.ISequence<byte> ikm)
    {
      Dafny.ISequence<byte> prk = Dafny.Sequence<byte>.Empty;
      (hmac).Init(salt);
      (hmac).BlockUpdate(ikm);
      Dafny.ISequence<byte> _out3;
      _out3 = (hmac).GetResult();
      prk = _out3;
      prk = prk;
      return prk;
      return prk;
    }
    public static Dafny.ISequence<byte> Expand(HMAC.HMac hmac, Dafny.ISequence<byte> prk, Dafny.ISequence<byte> info, BigInteger expectedLength, HMAC.Digests digest)
    {
      Dafny.ISequence<byte> okm = Dafny.Sequence<byte>.Empty;
      BigInteger _20736_hashLength;
      _20736_hashLength = HMAC.__default.GetHashLength(digest);
      BigInteger _20737_n;
      _20737_n = Dafny.Helpers.EuclideanDivision(((_20736_hashLength) + (expectedLength)) - (BigInteger.One), _20736_hashLength);
      (hmac).Init(prk);
      Dafny.ISequence<byte> _20738_t__prev;
      _20738_t__prev = Dafny.Sequence<byte>.FromElements();
      Dafny.ISequence<byte> _20739_t__n;
      _20739_t__n = _20738_t__prev;
      BigInteger _20740_i;
      _20740_i = BigInteger.One;
      while ((_20740_i) <= (_20737_n)) {
        (hmac).BlockUpdate(_20738_t__prev);
        (hmac).BlockUpdate(info);
        (hmac).BlockUpdate(Dafny.Sequence<byte>.FromElements((byte)(_20740_i)));
        Dafny.ISequence<byte> _out4;
        _out4 = (hmac).GetResult();
        _20738_t__prev = _out4;
        _20739_t__n = Dafny.Sequence<byte>.Concat(_20739_t__n, _20738_t__prev);
        _20740_i = (_20740_i) + (BigInteger.One);
      }
      okm = _20739_t__n;
      if ((expectedLength) < (new BigInteger((okm).Count))) {
        okm = (okm).Take(expectedLength);
      }
      return okm;
    }
    public static Dafny.ISequence<byte> Hkdf(KeyDerivationAlgorithms.KeyDerivationAlgorithm algorithm, Wrappers_Compile.Option<Dafny.ISequence<byte>> salt, Dafny.ISequence<byte> ikm, Dafny.ISequence<byte> info, BigInteger L)
    {
      Dafny.ISequence<byte> okm = Dafny.Sequence<byte>.Empty;
      if ((L).Sign == 0) {
        okm = Dafny.Sequence<byte>.FromElements();
        return okm;
      }
      HMAC.Digests _20741_digest;
      _20741_digest = HKDF_Compile.__default.GetHMACDigestFromHKDFAlgorithm(algorithm);
      HMAC.HMac _20742_hmac;
      HMAC.HMac _nw1 = new HMAC.HMac(_20741_digest);
      _20742_hmac = _nw1;
      BigInteger _20743_hashLength;
      _20743_hashLength = HMAC.__default.GetHashLength(_20741_digest);
      Dafny.ISequence<byte> _20744_nonEmptySalt = Dafny.Sequence<byte>.Empty;
      Wrappers_Compile.Option<Dafny.ISequence<byte>> _source7 = salt;
      if (_source7.is_None) {
        {
          _20744_nonEmptySalt = StandardLibrary_Compile.__default.Fill<byte>(0, _20743_hashLength);
        }
      } else {
        Dafny.ISequence<byte> _20745___mcc_h0 = ((Wrappers_Compile.Option_Some<Dafny.ISequence<byte>>)_source7).@value;
        {
          Dafny.ISequence<byte> _20746_s = _20745___mcc_h0;
          _20744_nonEmptySalt = _20746_s;
        }
      }
      Dafny.ISequence<byte> _20747_prk;
      Dafny.ISequence<byte> _out5;
      _out5 = HKDF_Compile.__default.Extract(_20742_hmac, _20744_nonEmptySalt, ikm);
      _20747_prk = _out5;
      Dafny.ISequence<byte> _out6;
      _out6 = HKDF_Compile.__default.Expand(_20742_hmac, _20747_prk, info, L, _20741_digest);
      okm = _out6;
      return okm;
    }
  }
} // end of namespace HKDF_Compile
namespace ExternRandom {



} // end of namespace ExternRandom
namespace Random_Compile {





  public partial class __default {
    public static Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> GenerateBytes(int i)
    {
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> res = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _20748_result;
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out7;
      _out7 = ExternRandom.__default.GenerateBytes(i);
      _20748_result = _out7;
      if (((_20748_result).is_Success) && ((new BigInteger(((_20748_result).dtor_value).Count)) != (new BigInteger(i)))) {
        res = @Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Incorrect length from ExternRandom."));
        return res;
      }
      res = _20748_result;
      return res;
      return res;
    }
  }
} // end of namespace Random_Compile
namespace RSAEncryption {



  public abstract class PaddingMode {
    public PaddingMode() { }
    private static readonly PaddingMode theDefault = create_PKCS1();
    public static PaddingMode Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<RSAEncryption.PaddingMode> _TYPE = new Dafny.TypeDescriptor<RSAEncryption.PaddingMode>(RSAEncryption.PaddingMode.Default());
    public static Dafny.TypeDescriptor<RSAEncryption.PaddingMode> _TypeDescriptor() {
      return _TYPE;
    }
    public static PaddingMode create_PKCS1() {
      return new PaddingMode_PKCS1();
    }
    public static PaddingMode create_OAEP__SHA1() {
      return new PaddingMode_OAEP__SHA1();
    }
    public static PaddingMode create_OAEP__SHA256() {
      return new PaddingMode_OAEP__SHA256();
    }
    public static PaddingMode create_OAEP__SHA384() {
      return new PaddingMode_OAEP__SHA384();
    }
    public static PaddingMode create_OAEP__SHA512() {
      return new PaddingMode_OAEP__SHA512();
    }
    public bool is_PKCS1 { get { return this is PaddingMode_PKCS1; } }
    public bool is_OAEP__SHA1 { get { return this is PaddingMode_OAEP__SHA1; } }
    public bool is_OAEP__SHA256 { get { return this is PaddingMode_OAEP__SHA256; } }
    public bool is_OAEP__SHA384 { get { return this is PaddingMode_OAEP__SHA384; } }
    public bool is_OAEP__SHA512 { get { return this is PaddingMode_OAEP__SHA512; } }
    public static System.Collections.Generic.IEnumerable<PaddingMode> AllSingletonConstructors {
      get {
        yield return PaddingMode.create_PKCS1();
        yield return PaddingMode.create_OAEP__SHA1();
        yield return PaddingMode.create_OAEP__SHA256();
        yield return PaddingMode.create_OAEP__SHA384();
        yield return PaddingMode.create_OAEP__SHA512();
      }
    }
  }
  public class PaddingMode_PKCS1 : PaddingMode {
    public PaddingMode_PKCS1() {
    }
    public override bool Equals(object other) {
      var oth = other as RSAEncryption.PaddingMode_PKCS1;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      return (int) hash;
    }
    public override string ToString() {
      string s = "RSAEncryption_Compile.PaddingMode.PKCS1";
      return s;
    }
  }
  public class PaddingMode_OAEP__SHA1 : PaddingMode {
    public PaddingMode_OAEP__SHA1() {
    }
    public override bool Equals(object other) {
      var oth = other as RSAEncryption.PaddingMode_OAEP__SHA1;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      return (int) hash;
    }
    public override string ToString() {
      string s = "RSAEncryption_Compile.PaddingMode.OAEP_SHA1";
      return s;
    }
  }
  public class PaddingMode_OAEP__SHA256 : PaddingMode {
    public PaddingMode_OAEP__SHA256() {
    }
    public override bool Equals(object other) {
      var oth = other as RSAEncryption.PaddingMode_OAEP__SHA256;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 2;
      return (int) hash;
    }
    public override string ToString() {
      string s = "RSAEncryption_Compile.PaddingMode.OAEP_SHA256";
      return s;
    }
  }
  public class PaddingMode_OAEP__SHA384 : PaddingMode {
    public PaddingMode_OAEP__SHA384() {
    }
    public override bool Equals(object other) {
      var oth = other as RSAEncryption.PaddingMode_OAEP__SHA384;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 3;
      return (int) hash;
    }
    public override string ToString() {
      string s = "RSAEncryption_Compile.PaddingMode.OAEP_SHA384";
      return s;
    }
  }
  public class PaddingMode_OAEP__SHA512 : PaddingMode {
    public PaddingMode_OAEP__SHA512() {
    }
    public override bool Equals(object other) {
      var oth = other as RSAEncryption.PaddingMode_OAEP__SHA512;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 4;
      return (int) hash;
    }
    public override string ToString() {
      string s = "RSAEncryption_Compile.PaddingMode.OAEP_SHA512";
      return s;
    }
  }

  public partial class StrengthBits {
    public static System.Collections.Generic.IEnumerable<int> IntegerRange(BigInteger lo, BigInteger hi) {
      for (var j = lo; j < hi; j++) { yield return (int)j; }
    }
    public static readonly int Witness = (int)(new BigInteger(81));
    private static readonly Dafny.TypeDescriptor<int> _TYPE = new Dafny.TypeDescriptor<int>(RSAEncryption.StrengthBits.Witness);
    public static Dafny.TypeDescriptor<int> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public interface Key {
    Dafny.ISequence<byte> pem { get; }
  }
  public class _Companion_Key {
  }

  public partial class PrivateKey : RSAEncryption.Key {
    public PrivateKey() {
      this._pem = Dafny.Sequence<byte>.Empty;
    }
    public Dafny.ISequence<byte> _pem;public Dafny.ISequence<byte> pem { get {
      return this._pem;
    } }
    public void __ctor(Dafny.ISequence<byte> pem)
    {
      (this)._pem = pem;
    }
  }

  public partial class PublicKey : RSAEncryption.Key {
    public PublicKey() {
      this._pem = Dafny.Sequence<byte>.Empty;
    }
    public Dafny.ISequence<byte> _pem;public Dafny.ISequence<byte> pem { get {
      return this._pem;
    } }
    public void __ctor(Dafny.ISequence<byte> pem)
    {
      (this)._pem = pem;
    }
  }

  public partial class __default {
    public static void GenerateKeyPair(int strength, RSAEncryption.PaddingMode padding, out RSAEncryption.PublicKey publicKey, out RSAEncryption.PrivateKey privateKey)
    {
      publicKey = default(RSAEncryption.PublicKey);
      privateKey = default(RSAEncryption.PrivateKey);
      Dafny.ISequence<byte> _20749_pemPublic;
      Dafny.ISequence<byte> _20750_pemPrivate;
      Dafny.ISequence<byte> _out8;
      Dafny.ISequence<byte> _out9;
      RSAEncryption.RSA.GenerateKeyPairExtern(strength, padding, out _out8, out _out9);
      _20749_pemPublic = _out8;
      _20750_pemPrivate = _out9;
      RSAEncryption.PrivateKey _nw2 = new RSAEncryption.PrivateKey();
      _nw2.__ctor(_20750_pemPrivate);
      privateKey = _nw2;
      RSAEncryption.PublicKey _nw3 = new RSAEncryption.PublicKey();
      _nw3.__ctor(_20749_pemPublic);
      publicKey = _nw3;
    }
    public static Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> Decrypt(RSAEncryption.PaddingMode padding, RSAEncryption.PrivateKey privateKey, Dafny.ISequence<byte> cipherText)
    {
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> res = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out10;
      _out10 = RSAEncryption.RSA.DecryptExtern(padding, (privateKey).pem, cipherText);
      res = _out10;
      return res;
    }
    public static Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> Encrypt(RSAEncryption.PaddingMode padding, RSAEncryption.PublicKey publicKey, Dafny.ISequence<byte> plaintextData)
    {
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> res = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out11;
      _out11 = RSAEncryption.RSA.EncryptExtern(padding, (publicKey).pem, plaintextData);
      res = _out11;
      return res;
    }
    public static BigInteger SHA1__HASH__BYTES { get {
      return new BigInteger(20);
    } }
    public static BigInteger SHA256__HASH__BYTES { get {
      return new BigInteger(32);
    } }
    public static BigInteger SHA384__HASH__BYTES { get {
      return new BigInteger(48);
    } }
    public static BigInteger SHA512__HASH__BYTES { get {
      return new BigInteger(64);
    } }
  }
} // end of namespace RSAEncryption
namespace Signature {




  public class SignatureKeyPair {
    public readonly Dafny.ISequence<byte> verificationKey;
    public readonly Dafny.ISequence<byte> signingKey;
    public SignatureKeyPair(Dafny.ISequence<byte> verificationKey, Dafny.ISequence<byte> signingKey) {
      this.verificationKey = verificationKey;
      this.signingKey = signingKey;
    }
    public override bool Equals(object other) {
      var oth = other as Signature.SignatureKeyPair;
      return oth != null && object.Equals(this.verificationKey, oth.verificationKey) && object.Equals(this.signingKey, oth.signingKey);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.verificationKey));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.signingKey));
      return (int) hash;
    }
    public override string ToString() {
      string s = "Signature_Compile.SignatureKeyPair.SignatureKeyPair";
      s += "(";
      s += Dafny.Helpers.ToString(this.verificationKey);
      s += ", ";
      s += Dafny.Helpers.ToString(this.signingKey);
      s += ")";
      return s;
    }
    private static readonly SignatureKeyPair theDefault = create(Dafny.Sequence<byte>.Empty, Dafny.Sequence<byte>.Empty);
    public static SignatureKeyPair Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<Signature.SignatureKeyPair> _TYPE = new Dafny.TypeDescriptor<Signature.SignatureKeyPair>(Signature.SignatureKeyPair.Default());
    public static Dafny.TypeDescriptor<Signature.SignatureKeyPair> _TypeDescriptor() {
      return _TYPE;
    }
    public static SignatureKeyPair create(Dafny.ISequence<byte> verificationKey, Dafny.ISequence<byte> signingKey) {
      return new SignatureKeyPair(verificationKey, signingKey);
    }
    public bool is_SignatureKeyPair { get { return true; } }
    public Dafny.ISequence<byte> dtor_verificationKey {
      get {
        return this.verificationKey;
      }
    }
    public Dafny.ISequence<byte> dtor_signingKey {
      get {
        return this.signingKey;
      }
    }
  }

  public abstract class ECDSAParams {
    public ECDSAParams() { }
    private static readonly ECDSAParams theDefault = create_ECDSA__P384();
    public static ECDSAParams Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<Signature.ECDSAParams> _TYPE = new Dafny.TypeDescriptor<Signature.ECDSAParams>(Signature.ECDSAParams.Default());
    public static Dafny.TypeDescriptor<Signature.ECDSAParams> _TypeDescriptor() {
      return _TYPE;
    }
    public static ECDSAParams create_ECDSA__P384() {
      return new ECDSAParams_ECDSA__P384();
    }
    public static ECDSAParams create_ECDSA__P256() {
      return new ECDSAParams_ECDSA__P256();
    }
    public bool is_ECDSA__P384 { get { return this is ECDSAParams_ECDSA__P384; } }
    public bool is_ECDSA__P256 { get { return this is ECDSAParams_ECDSA__P256; } }
    public static System.Collections.Generic.IEnumerable<ECDSAParams> AllSingletonConstructors {
      get {
        yield return ECDSAParams.create_ECDSA__P384();
        yield return ECDSAParams.create_ECDSA__P256();
      }
    }
    public ushort SignatureLength() {
      Signature.ECDSAParams _source8 = this;
      if (_source8.is_ECDSA__P384) {
        return 103;
      } else {
        return 71;
      }
    }
    public BigInteger FieldSize() {
      Signature.ECDSAParams _source9 = this;
      if (_source9.is_ECDSA__P384) {
        return new BigInteger(49);
      } else {
        return new BigInteger(33);
      }
    }
  }
  public class ECDSAParams_ECDSA__P384 : ECDSAParams {
    public ECDSAParams_ECDSA__P384() {
    }
    public override bool Equals(object other) {
      var oth = other as Signature.ECDSAParams_ECDSA__P384;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      return (int) hash;
    }
    public override string ToString() {
      string s = "Signature_Compile.ECDSAParams.ECDSA_P384";
      return s;
    }
  }
  public class ECDSAParams_ECDSA__P256 : ECDSAParams {
    public ECDSAParams_ECDSA__P256() {
    }
    public override bool Equals(object other) {
      var oth = other as Signature.ECDSAParams_ECDSA__P256;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      return (int) hash;
    }
    public override string ToString() {
      string s = "Signature_Compile.ECDSAParams.ECDSA_P256";
      return s;
    }
  }

  public partial class __default {
    public static Wrappers_Compile.Result<Signature.SignatureKeyPair, Dafny.ISequence<char>> KeyGen(Signature.ECDSAParams s)
    {
      Wrappers_Compile.Result<Signature.SignatureKeyPair, Dafny.ISequence<char>> res = Wrappers_Compile.Result<Signature.SignatureKeyPair, Dafny.ISequence<char>>.Default(Signature.SignatureKeyPair.Default());
      Signature.SignatureKeyPair _20751_sigKeyPair = Signature.SignatureKeyPair.Default();
      Wrappers_Compile.Result<Signature.SignatureKeyPair, Dafny.ISequence<char>> _20752_valueOrError0 = Wrappers_Compile.Result<Signature.SignatureKeyPair, Dafny.ISequence<char>>.Default(Signature.SignatureKeyPair.Default());
      Wrappers_Compile.Result<Signature.SignatureKeyPair, Dafny.ISequence<char>> _out12;
      _out12 = Signature.ECDSA.ExternKeyGen(s);
      _20752_valueOrError0 = _out12;
      if ((_20752_valueOrError0).IsFailure()) {
        res = (_20752_valueOrError0).PropagateFailure<Signature.SignatureKeyPair>();
        return res;
      }
      _20751_sigKeyPair = (_20752_valueOrError0).Extract();
      if ((new BigInteger(((_20751_sigKeyPair).dtor_verificationKey).Count)) == ((s).FieldSize())) {
        res = @Wrappers_Compile.Result<Signature.SignatureKeyPair, Dafny.ISequence<char>>.create_Success(_20751_sigKeyPair);
        return res;
      } else {
        res = @Wrappers_Compile.Result<Signature.SignatureKeyPair, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Incorrect verification-key length from ExternKeyGen."));
        return res;
      }
      return res;
    }
  }
} // end of namespace Signature
namespace Amazon.KeyManagementService {


} // end of namespace Amazon.KeyManagementService
namespace Math_Compile {

  public partial class __default {
    public static BigInteger Min(BigInteger a, BigInteger b)
    {
      if ((a) < (b)) {
        return a;
      } else {
        return b;
      }
    }
    public static BigInteger Max(BigInteger a, BigInteger b)
    {
      if ((a) < (b)) {
        return b;
      } else {
        return a;
      }
    }
  }
} // end of namespace Math_Compile
namespace Seq_Compile {



  public partial class __default {
    public static __T First<__T>(Dafny.ISequence<__T> s) {
      return (s).Select(BigInteger.Zero);
    }
    public static Dafny.ISequence<__T> DropFirst<__T>(Dafny.ISequence<__T> s) {
      return (s).Drop(BigInteger.One);
    }
    public static __T Last<__T>(Dafny.ISequence<__T> s) {
      return (s).Select((new BigInteger((s).Count)) - (BigInteger.One));
    }
    public static Dafny.ISequence<__T> DropLast<__T>(Dafny.ISequence<__T> s) {
      return (s).Take((new BigInteger((s).Count)) - (BigInteger.One));
    }
    public static __T[] ToArray<__T>(Dafny.ISequence<__T> s)
    {
      __T[] a = new __T[0];
      __T[] _nw4 = new __T[Dafny.Helpers.ToIntChecked(Dafny.Helpers.ToIntChecked(new BigInteger((s).Count), "C# arrays may not be larger than the max 32-bit integer"),"C# array size must not be larger than max 32-bit int")];
      Func<BigInteger, __T> _arrayinit1 = Dafny.Helpers.Id<Func<Dafny.ISequence<__T>, Func<BigInteger, __T>>>((_20753_s) => ((System.Func<BigInteger, __T>)((_20754_i) => {
        return (_20753_s).Select(_20754_i);
      })))(s);
      for (var _arrayinit_01 = 0; _arrayinit_01 < new BigInteger(_nw4.Length); _arrayinit_01++) {
        _nw4[(int)(_arrayinit_01)] = _arrayinit1(_arrayinit_01);
      }
      a = _nw4;
      return a;
    }
    public static Dafny.ISet<__T> ToSet<__T>(Dafny.ISequence<__T> s) {
      return Dafny.Helpers.Id<Func<Dafny.ISequence<__T>, Dafny.ISet<__T>>>((_20755_s) => ((System.Func<Dafny.ISet<__T>>)(() => {
        var _coll0 = new System.Collections.Generic.List<__T>();
        foreach (__T _compr_0 in (_20755_s).Elements) {
          __T _20756_x = (__T)_compr_0;
          if ((_20755_s).Contains((_20756_x))) {
            _coll0.Add(_20756_x);
          }
        }
        return Dafny.Set<__T>.FromCollection(_coll0);
      }))())(s);
    }
    public static BigInteger IndexOf<__T>(Dafny.ISequence<__T> s, __T v)
    {
      BigInteger _20757___accumulator = BigInteger.Zero;
    TAIL_CALL_START: ;
      if (object.Equals((s).Select(BigInteger.Zero), v)) {
        return (BigInteger.Zero) + (_20757___accumulator);
      } else {
        _20757___accumulator = (_20757___accumulator) + (BigInteger.One);
        Dafny.ISequence<__T> _in11 = (s).Drop(BigInteger.One);
        __T _in12 = v;
        s = _in11;
        v = _in12;
        goto TAIL_CALL_START;
      }
    }
    public static Wrappers_Compile.Option<BigInteger> IndexOfOption<__T>(Dafny.ISequence<__T> s, __T v)
    {
      if ((new BigInteger((s).Count)).Sign == 0) {
        return @Wrappers_Compile.Option<BigInteger>.create_None();
      } else if (object.Equals((s).Select(BigInteger.Zero), v)) {
        return @Wrappers_Compile.Option<BigInteger>.create_Some(BigInteger.Zero);
      } else {
        Wrappers_Compile.Option<BigInteger> _20758_o_k = Seq_Compile.__default.IndexOfOption<__T>((s).Drop(BigInteger.One), v);
        if ((_20758_o_k).is_Some) {
          return @Wrappers_Compile.Option<BigInteger>.create_Some(((_20758_o_k).dtor_value) + (BigInteger.One));
        } else {
          return @Wrappers_Compile.Option<BigInteger>.create_None();
        }
      }
    }
    public static BigInteger LastIndexOf<__T>(Dafny.ISequence<__T> s, __T v)
    {
    TAIL_CALL_START: ;
      if (object.Equals((s).Select((new BigInteger((s).Count)) - (BigInteger.One)), v)) {
        return (new BigInteger((s).Count)) - (BigInteger.One);
      } else {
        Dafny.ISequence<__T> _in13 = (s).Take((new BigInteger((s).Count)) - (BigInteger.One));
        __T _in14 = v;
        s = _in13;
        v = _in14;
        goto TAIL_CALL_START;
      }
    }
    public static Wrappers_Compile.Option<BigInteger> LastIndexOfOption<__T>(Dafny.ISequence<__T> s, __T v)
    {
    TAIL_CALL_START: ;
      if ((new BigInteger((s).Count)).Sign == 0) {
        return @Wrappers_Compile.Option<BigInteger>.create_None();
      } else if (object.Equals((s).Select((new BigInteger((s).Count)) - (BigInteger.One)), v)) {
        return @Wrappers_Compile.Option<BigInteger>.create_Some((new BigInteger((s).Count)) - (BigInteger.One));
      } else {
        Dafny.ISequence<__T> _in15 = (s).Take((new BigInteger((s).Count)) - (BigInteger.One));
        __T _in16 = v;
        s = _in15;
        v = _in16;
        goto TAIL_CALL_START;
      }
    }
    public static Dafny.ISequence<__T> Remove<__T>(Dafny.ISequence<__T> s, BigInteger pos)
    {
      return Dafny.Sequence<__T>.Concat((s).Take(pos), (s).Drop((pos) + (BigInteger.One)));
    }
    public static Dafny.ISequence<__T> RemoveValue<__T>(Dafny.ISequence<__T> s, __T v)
    {
      if (!(s).Contains((v))) {
        return s;
      } else {
        BigInteger _20759_i = Seq_Compile.__default.IndexOf<__T>(s, v);
        return Dafny.Sequence<__T>.Concat((s).Take(_20759_i), (s).Drop((_20759_i) + (BigInteger.One)));
      }
    }
    public static Dafny.ISequence<__T> Insert<__T>(Dafny.ISequence<__T> s, __T a, BigInteger pos)
    {
      return Dafny.Sequence<__T>.Concat(Dafny.Sequence<__T>.Concat((s).Take(pos), Dafny.Sequence<__T>.FromElements(a)), (s).Drop(pos));
    }
    public static Dafny.ISequence<__T> Reverse<__T>(Dafny.ISequence<__T> s) {
      Dafny.ISequence<__T> _20760___accumulator = Dafny.Sequence<__T>.FromElements();
    TAIL_CALL_START: ;
      if ((s).Equals((Dafny.Sequence<__T>.FromElements()))) {
        return Dafny.Sequence<__T>.Concat(_20760___accumulator, Dafny.Sequence<__T>.FromElements());
      } else {
        _20760___accumulator = Dafny.Sequence<__T>.Concat(_20760___accumulator, Dafny.Sequence<__T>.FromElements((s).Select((new BigInteger((s).Count)) - (BigInteger.One))));
        Dafny.ISequence<__T> _in17 = (s).Subsequence(BigInteger.Zero, (new BigInteger((s).Count)) - (BigInteger.One));
        s = _in17;
        goto TAIL_CALL_START;
      }
    }
    public static Dafny.ISequence<__T> Repeat<__T>(__T v, BigInteger length)
    {
      Dafny.ISequence<__T> _20761___accumulator = Dafny.Sequence<__T>.FromElements();
    TAIL_CALL_START: ;
      if ((length).Sign == 0) {
        return Dafny.Sequence<__T>.Concat(_20761___accumulator, Dafny.Sequence<__T>.FromElements());
      } else {
        _20761___accumulator = Dafny.Sequence<__T>.Concat(_20761___accumulator, Dafny.Sequence<__T>.FromElements(v));
        __T _in18 = v;
        BigInteger _in19 = (length) - (BigInteger.One);
        v = _in18;
        length = _in19;
        goto TAIL_CALL_START;
      }
    }
    public static _System.Tuple2<Dafny.ISequence<__A>, Dafny.ISequence<__B>> Unzip<__A, __B>(Dafny.ISequence<_System.Tuple2<__A, __B>> s) {
      if ((new BigInteger((s).Count)).Sign == 0) {
        return @_System.Tuple2<Dafny.ISequence<__A>, Dafny.ISequence<__B>>.create(Dafny.Sequence<__A>.FromElements(), Dafny.Sequence<__B>.FromElements());
      } else {
        _System.Tuple2<Dafny.ISequence<__A>, Dafny.ISequence<__B>> _let_tmp_rhs0 = Seq_Compile.__default.Unzip<__A, __B>(Seq_Compile.__default.DropLast<_System.Tuple2<__A, __B>>(s));
        Dafny.ISequence<__A> _20762_a = ((_System.Tuple2<Dafny.ISequence<__A>, Dafny.ISequence<__B>>)_let_tmp_rhs0)._0;
        Dafny.ISequence<__B> _20763_b = ((_System.Tuple2<Dafny.ISequence<__A>, Dafny.ISequence<__B>>)_let_tmp_rhs0)._1;
        return @_System.Tuple2<Dafny.ISequence<__A>, Dafny.ISequence<__B>>.create(Dafny.Sequence<__A>.Concat(_20762_a, Dafny.Sequence<__A>.FromElements((Seq_Compile.__default.Last<_System.Tuple2<__A, __B>>(s)).dtor__0)), Dafny.Sequence<__B>.Concat(_20763_b, Dafny.Sequence<__B>.FromElements((Seq_Compile.__default.Last<_System.Tuple2<__A, __B>>(s)).dtor__1)));
      }
    }
    public static Dafny.ISequence<_System.Tuple2<__A, __B>> Zip<__A, __B>(Dafny.ISequence<__A> a, Dafny.ISequence<__B> b)
    {
      Dafny.ISequence<_System.Tuple2<__A, __B>> _20764___accumulator = Dafny.Sequence<_System.Tuple2<__A, __B>>.FromElements();
    TAIL_CALL_START: ;
      if ((new BigInteger((a).Count)).Sign == 0) {
        return Dafny.Sequence<_System.Tuple2<__A, __B>>.Concat(Dafny.Sequence<_System.Tuple2<__A, __B>>.FromElements(), _20764___accumulator);
      } else {
        _20764___accumulator = Dafny.Sequence<_System.Tuple2<__A, __B>>.Concat(Dafny.Sequence<_System.Tuple2<__A, __B>>.FromElements(@_System.Tuple2<__A, __B>.create(Seq_Compile.__default.Last<__A>(a), Seq_Compile.__default.Last<__B>(b))), _20764___accumulator);
        Dafny.ISequence<__A> _in20 = Seq_Compile.__default.DropLast<__A>(a);
        Dafny.ISequence<__B> _in21 = Seq_Compile.__default.DropLast<__B>(b);
        a = _in20;
        b = _in21;
        goto TAIL_CALL_START;
      }
    }
    public static BigInteger Max(Dafny.ISequence<BigInteger> s) {
      if ((new BigInteger((s).Count)) == (BigInteger.One)) {
        return (s).Select(BigInteger.Zero);
      } else {
        return Math_Compile.__default.Max((s).Select(BigInteger.Zero), Seq_Compile.__default.Max((s).Drop(BigInteger.One)));
      }
    }
    public static BigInteger Min(Dafny.ISequence<BigInteger> s) {
      if ((new BigInteger((s).Count)) == (BigInteger.One)) {
        return (s).Select(BigInteger.Zero);
      } else {
        return Math_Compile.__default.Min((s).Select(BigInteger.Zero), Seq_Compile.__default.Min((s).Drop(BigInteger.One)));
      }
    }
    public static Dafny.ISequence<__T> Flatten<__T>(Dafny.ISequence<Dafny.ISequence<__T>> s) {
      Dafny.ISequence<__T> _20765___accumulator = Dafny.Sequence<__T>.FromElements();
    TAIL_CALL_START: ;
      if ((new BigInteger((s).Count)).Sign == 0) {
        return Dafny.Sequence<__T>.Concat(_20765___accumulator, Dafny.Sequence<__T>.FromElements());
      } else {
        _20765___accumulator = Dafny.Sequence<__T>.Concat(_20765___accumulator, (s).Select(BigInteger.Zero));
        Dafny.ISequence<Dafny.ISequence<__T>> _in22 = (s).Drop(BigInteger.One);
        s = _in22;
        goto TAIL_CALL_START;
      }
    }
    public static Dafny.ISequence<__T> FlattenReverse<__T>(Dafny.ISequence<Dafny.ISequence<__T>> s) {
      Dafny.ISequence<__T> _20766___accumulator = Dafny.Sequence<__T>.FromElements();
    TAIL_CALL_START: ;
      if ((new BigInteger((s).Count)).Sign == 0) {
        return Dafny.Sequence<__T>.Concat(Dafny.Sequence<__T>.FromElements(), _20766___accumulator);
      } else {
        _20766___accumulator = Dafny.Sequence<__T>.Concat(Seq_Compile.__default.Last<Dafny.ISequence<__T>>(s), _20766___accumulator);
        Dafny.ISequence<Dafny.ISequence<__T>> _in23 = Seq_Compile.__default.DropLast<Dafny.ISequence<__T>>(s);
        s = _in23;
        goto TAIL_CALL_START;
      }
    }
    public static Dafny.ISequence<__R> Map<__T, __R>(Func<__T, __R> f, Dafny.ISequence<__T> s)
    {
      Dafny.ISequence<__R> _20767___accumulator = Dafny.Sequence<__R>.FromElements();
    TAIL_CALL_START: ;
      if ((new BigInteger((s).Count)).Sign == 0) {
        return Dafny.Sequence<__R>.Concat(_20767___accumulator, Dafny.Sequence<__R>.FromElements());
      } else {
        _20767___accumulator = Dafny.Sequence<__R>.Concat(_20767___accumulator, Dafny.Sequence<__R>.FromElements(Dafny.Helpers.Id<Func<__T, __R>>(f)((s).Select(BigInteger.Zero))));
        Func<__T, __R> _in24 = f;
        Dafny.ISequence<__T> _in25 = (s).Drop(BigInteger.One);
        f = _in24;
        s = _in25;
        goto TAIL_CALL_START;
      }
    }
    public static Dafny.ISequence<__T> Filter<__T>(Func<__T, bool> f, Dafny.ISequence<__T> s)
    {
      Dafny.ISequence<__T> _20768___accumulator = Dafny.Sequence<__T>.FromElements();
    TAIL_CALL_START: ;
      if ((new BigInteger((s).Count)).Sign == 0) {
        return Dafny.Sequence<__T>.Concat(_20768___accumulator, Dafny.Sequence<__T>.FromElements());
      } else {
        _20768___accumulator = Dafny.Sequence<__T>.Concat(_20768___accumulator, ((Dafny.Helpers.Id<Func<__T, bool>>(f)((s).Select(BigInteger.Zero))) ? (Dafny.Sequence<__T>.FromElements((s).Select(BigInteger.Zero))) : (Dafny.Sequence<__T>.FromElements())));
        Func<__T, bool> _in26 = f;
        Dafny.ISequence<__T> _in27 = (s).Drop(BigInteger.One);
        f = _in26;
        s = _in27;
        goto TAIL_CALL_START;
      }
    }
    public static __A FoldLeft<__A, __T>(Func<__A, __T, __A> f, __A init, Dafny.ISequence<__T> s)
    {
    TAIL_CALL_START: ;
      if ((new BigInteger((s).Count)).Sign == 0) {
        return init;
      } else {
        Func<__A, __T, __A> _in28 = f;
        __A _in29 = Dafny.Helpers.Id<Func<__A, __T, __A>>(f)(init, (s).Select(BigInteger.Zero));
        Dafny.ISequence<__T> _in30 = (s).Drop(BigInteger.One);
        f = _in28;
        init = _in29;
        s = _in30;
        goto TAIL_CALL_START;
      }
    }
    public static __A FoldRight<__A, __T>(Func<__T, __A, __A> f, Dafny.ISequence<__T> s, __A init)
    {
      if ((new BigInteger((s).Count)).Sign == 0) {
        return init;
      } else {
        return Dafny.Helpers.Id<Func<__T, __A, __A>>(f)((s).Select(BigInteger.Zero), Seq_Compile.__default.FoldRight<__A, __T>(f, (s).Drop(BigInteger.One), init));
      }
    }
  }
} // end of namespace Seq_Compile
namespace UTF8 {



  public partial class ValidUTF8Bytes {
    private static readonly Dafny.ISequence<byte> Witness = Dafny.Sequence<byte>.FromElements();
    public static Dafny.ISequence<byte> Default() {
      return Witness;
    }
    private static readonly Dafny.TypeDescriptor<Dafny.ISequence<byte>> _TYPE = new Dafny.TypeDescriptor<Dafny.ISequence<byte>>(UTF8.ValidUTF8Bytes.Default());
    public static Dafny.TypeDescriptor<Dafny.ISequence<byte>> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public partial class __default {
    public static bool IsASCIIString(Dafny.ISequence<char> s) {
      return Dafny.Helpers.Id<Func<Dafny.ISequence<char>, bool>>((_20769_s) => Dafny.Helpers.Quantifier<BigInteger>(Dafny.Helpers.IntegerRange(BigInteger.Zero, new BigInteger((_20769_s).Count)), true, (((_20770_i) => {
        return !(((_20770_i).Sign != -1) && ((_20770_i) < (new BigInteger((_20769_s).Count)))) || ((new BigInteger((_20769_s).Select(_20770_i))) < (new BigInteger(128)));
      }))))(s);
    }
    public static bool Uses1Byte(Dafny.ISequence<byte> s) {
      return ((0) <= ((s).Select(BigInteger.Zero))) && (((s).Select(BigInteger.Zero)) <= (127));
    }
    public static bool Uses2Bytes(Dafny.ISequence<byte> s) {
      return (((194) <= ((s).Select(BigInteger.Zero))) && (((s).Select(BigInteger.Zero)) <= (223))) && (((128) <= ((s).Select(BigInteger.One))) && (((s).Select(BigInteger.One)) <= (191)));
    }
    public static bool Uses3Bytes(Dafny.ISequence<byte> s) {
      return (((((((s).Select(BigInteger.Zero)) == (224)) && (((160) <= ((s).Select(BigInteger.One))) && (((s).Select(BigInteger.One)) <= (191)))) && (((128) <= ((s).Select(new BigInteger(2)))) && (((s).Select(new BigInteger(2))) <= (191)))) || (((((225) <= ((s).Select(BigInteger.Zero))) && (((s).Select(BigInteger.Zero)) <= (236))) && (((128) <= ((s).Select(BigInteger.One))) && (((s).Select(BigInteger.One)) <= (191)))) && (((128) <= ((s).Select(new BigInteger(2)))) && (((s).Select(new BigInteger(2))) <= (191))))) || (((((s).Select(BigInteger.Zero)) == (237)) && (((128) <= ((s).Select(BigInteger.One))) && (((s).Select(BigInteger.One)) <= (159)))) && (((128) <= ((s).Select(new BigInteger(2)))) && (((s).Select(new BigInteger(2))) <= (191))))) || (((((238) <= ((s).Select(BigInteger.Zero))) && (((s).Select(BigInteger.Zero)) <= (239))) && (((128) <= ((s).Select(BigInteger.One))) && (((s).Select(BigInteger.One)) <= (191)))) && (((128) <= ((s).Select(new BigInteger(2)))) && (((s).Select(new BigInteger(2))) <= (191))));
    }
    public static bool Uses4Bytes(Dafny.ISequence<byte> s) {
      return (((((((s).Select(BigInteger.Zero)) == (240)) && (((144) <= ((s).Select(BigInteger.One))) && (((s).Select(BigInteger.One)) <= (191)))) && (((128) <= ((s).Select(new BigInteger(2)))) && (((s).Select(new BigInteger(2))) <= (191)))) && (((128) <= ((s).Select(new BigInteger(3)))) && (((s).Select(new BigInteger(3))) <= (191)))) || ((((((241) <= ((s).Select(BigInteger.Zero))) && (((s).Select(BigInteger.Zero)) <= (243))) && (((128) <= ((s).Select(BigInteger.One))) && (((s).Select(BigInteger.One)) <= (191)))) && (((128) <= ((s).Select(new BigInteger(2)))) && (((s).Select(new BigInteger(2))) <= (191)))) && (((128) <= ((s).Select(new BigInteger(3)))) && (((s).Select(new BigInteger(3))) <= (191))))) || ((((((s).Select(BigInteger.Zero)) == (244)) && (((128) <= ((s).Select(BigInteger.One))) && (((s).Select(BigInteger.One)) <= (143)))) && (((128) <= ((s).Select(new BigInteger(2)))) && (((s).Select(new BigInteger(2))) <= (191)))) && (((128) <= ((s).Select(new BigInteger(3)))) && (((s).Select(new BigInteger(3))) <= (191))));
    }
    public static bool ValidUTF8Range(Dafny.ISequence<byte> a, BigInteger lo, BigInteger hi)
    {
      if ((lo) == (hi)) {
        return true;
      } else {
        Dafny.ISequence<byte> _20771_r = (a).Subsequence(lo, hi);
        if (UTF8.__default.Uses1Byte(_20771_r)) {
          return UTF8.__default.ValidUTF8Range(a, (lo) + (BigInteger.One), hi);
        } else if (((new BigInteger(2)) <= (new BigInteger((_20771_r).Count))) && (UTF8.__default.Uses2Bytes(_20771_r))) {
          return UTF8.__default.ValidUTF8Range(a, (lo) + (new BigInteger(2)), hi);
        } else if (((new BigInteger(3)) <= (new BigInteger((_20771_r).Count))) && (UTF8.__default.Uses3Bytes(_20771_r))) {
          return UTF8.__default.ValidUTF8Range(a, (lo) + (new BigInteger(3)), hi);
        } else {
          return (((new BigInteger(4)) <= (new BigInteger((_20771_r).Count))) && (UTF8.__default.Uses4Bytes(_20771_r))) && (UTF8.__default.ValidUTF8Range(a, (lo) + (new BigInteger(4)), hi));
        }
      }
    }
    public static bool ValidUTF8Seq(Dafny.ISequence<byte> s) {
      return UTF8.__default.ValidUTF8Range(s, BigInteger.Zero, new BigInteger((s).Count));
    }
  }
} // end of namespace UTF8
namespace AwsKmsArnParsing_Compile {





  public class AwsResource {
    public readonly Dafny.ISequence<char> resourceType;
    public readonly Dafny.ISequence<char> @value;
    public AwsResource(Dafny.ISequence<char> resourceType, Dafny.ISequence<char> @value) {
      this.resourceType = resourceType;
      this.@value = @value;
    }
    public override bool Equals(object other) {
      var oth = other as AwsKmsArnParsing_Compile.AwsResource;
      return oth != null && object.Equals(this.resourceType, oth.resourceType) && object.Equals(this.@value, oth.@value);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.resourceType));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.@value));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsKmsArnParsing_Compile.AwsResource.AwsResource";
      s += "(";
      s += Dafny.Helpers.ToString(this.resourceType);
      s += ", ";
      s += Dafny.Helpers.ToString(this.@value);
      s += ")";
      return s;
    }
    private static readonly AwsResource theDefault = create(Dafny.Sequence<char>.Empty, Dafny.Sequence<char>.Empty);
    public static AwsResource Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<AwsKmsArnParsing_Compile.AwsResource> _TYPE = new Dafny.TypeDescriptor<AwsKmsArnParsing_Compile.AwsResource>(AwsKmsArnParsing_Compile.AwsResource.Default());
    public static Dafny.TypeDescriptor<AwsKmsArnParsing_Compile.AwsResource> _TypeDescriptor() {
      return _TYPE;
    }
    public static AwsResource create(Dafny.ISequence<char> resourceType, Dafny.ISequence<char> @value) {
      return new AwsResource(resourceType, @value);
    }
    public bool is_AwsResource { get { return true; } }
    public Dafny.ISequence<char> dtor_resourceType {
      get {
        return this.resourceType;
      }
    }
    public Dafny.ISequence<char> dtor_value {
      get {
        return this.@value;
      }
    }
    public bool Valid() {
      return (true) && ((new BigInteger(((this).dtor_value).Count)).Sign == 1);
    }
    public Dafny.ISequence<char> _ToString() {
      return Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat((this).dtor_resourceType, Dafny.Sequence<char>.FromString("/")), (this).dtor_value);
    }
  }

  public class AwsArn {
    public readonly Dafny.ISequence<char> arnLiteral;
    public readonly Dafny.ISequence<char> partition;
    public readonly Dafny.ISequence<char> service;
    public readonly Dafny.ISequence<char> region;
    public readonly Dafny.ISequence<char> account;
    public readonly AwsKmsArnParsing_Compile.AwsResource resource;
    public AwsArn(Dafny.ISequence<char> arnLiteral, Dafny.ISequence<char> partition, Dafny.ISequence<char> service, Dafny.ISequence<char> region, Dafny.ISequence<char> account, AwsKmsArnParsing_Compile.AwsResource resource) {
      this.arnLiteral = arnLiteral;
      this.partition = partition;
      this.service = service;
      this.region = region;
      this.account = account;
      this.resource = resource;
    }
    public override bool Equals(object other) {
      var oth = other as AwsKmsArnParsing_Compile.AwsArn;
      return oth != null && object.Equals(this.arnLiteral, oth.arnLiteral) && object.Equals(this.partition, oth.partition) && object.Equals(this.service, oth.service) && object.Equals(this.region, oth.region) && object.Equals(this.account, oth.account) && object.Equals(this.resource, oth.resource);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.arnLiteral));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.partition));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.service));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.region));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.account));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.resource));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsKmsArnParsing_Compile.AwsArn.AwsArn";
      s += "(";
      s += Dafny.Helpers.ToString(this.arnLiteral);
      s += ", ";
      s += Dafny.Helpers.ToString(this.partition);
      s += ", ";
      s += Dafny.Helpers.ToString(this.service);
      s += ", ";
      s += Dafny.Helpers.ToString(this.region);
      s += ", ";
      s += Dafny.Helpers.ToString(this.account);
      s += ", ";
      s += Dafny.Helpers.ToString(this.resource);
      s += ")";
      return s;
    }
    private static readonly AwsArn theDefault = create(Dafny.Sequence<char>.Empty, Dafny.Sequence<char>.Empty, Dafny.Sequence<char>.Empty, Dafny.Sequence<char>.Empty, Dafny.Sequence<char>.Empty, AwsKmsArnParsing_Compile.AwsResource.Default());
    public static AwsArn Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<AwsKmsArnParsing_Compile.AwsArn> _TYPE = new Dafny.TypeDescriptor<AwsKmsArnParsing_Compile.AwsArn>(AwsKmsArnParsing_Compile.AwsArn.Default());
    public static Dafny.TypeDescriptor<AwsKmsArnParsing_Compile.AwsArn> _TypeDescriptor() {
      return _TYPE;
    }
    public static AwsArn create(Dafny.ISequence<char> arnLiteral, Dafny.ISequence<char> partition, Dafny.ISequence<char> service, Dafny.ISequence<char> region, Dafny.ISequence<char> account, AwsKmsArnParsing_Compile.AwsResource resource) {
      return new AwsArn(arnLiteral, partition, service, region, account, resource);
    }
    public bool is_AwsArn { get { return true; } }
    public Dafny.ISequence<char> dtor_arnLiteral {
      get {
        return this.arnLiteral;
      }
    }
    public Dafny.ISequence<char> dtor_partition {
      get {
        return this.partition;
      }
    }
    public Dafny.ISequence<char> dtor_service {
      get {
        return this.service;
      }
    }
    public Dafny.ISequence<char> dtor_region {
      get {
        return this.region;
      }
    }
    public Dafny.ISequence<char> dtor_account {
      get {
        return this.account;
      }
    }
    public AwsKmsArnParsing_Compile.AwsResource dtor_resource {
      get {
        return this.resource;
      }
    }
    public bool Valid() {
      return (((((((this).dtor_arnLiteral).Equals((Dafny.Sequence<char>.FromString("arn")))) && ((new BigInteger(((this).dtor_partition).Count)).Sign == 1)) && ((new BigInteger(((this).dtor_service).Count)).Sign == 1)) && ((new BigInteger(((this).dtor_region).Count)).Sign == 1)) && ((new BigInteger(((this).dtor_account).Count)).Sign == 1)) && (((this).dtor_resource).Valid());
    }
    public Dafny.ISequence<char> _ToString() {
      return (this).ToArnString(@Wrappers_Compile.Option<Dafny.ISequence<char>>.create_None());
    }
    public Dafny.ISequence<char> ToArnString(Wrappers_Compile.Option<Dafny.ISequence<char>> customRegion) {
      var _this = this;
    TAIL_CALL_START: ;
      Wrappers_Compile.Option<Dafny.ISequence<char>> _source10 = customRegion;
      if (_source10.is_None) {
        var _in31 = _this;
        Wrappers_Compile.Option<Dafny.ISequence<char>> _in32 = @Wrappers_Compile.Option<Dafny.ISequence<char>>.create_Some((_this).dtor_region);
        _this = _in31;
        customRegion = _in32;
        goto TAIL_CALL_START;
      } else {
        Dafny.ISequence<char> _20772___mcc_h0 = ((Wrappers_Compile.Option_Some<Dafny.ISequence<char>>)_source10).@value;
        Dafny.ISequence<char> _20773_customRegion = _20772___mcc_h0;
        return StandardLibrary_Compile.__default.Join<char>(Dafny.Sequence<Dafny.ISequence<char>>.FromElements((_this).dtor_arnLiteral, (_this).dtor_partition, (_this).dtor_service, _20773_customRegion, (_this).dtor_account, ((_this).dtor_resource)._ToString()), Dafny.Sequence<char>.FromString(":"));
      }
    }
  }

  public partial class AwsKmsArn {
    private static readonly Dafny.TypeDescriptor<AwsKmsArnParsing_Compile.AwsArn> _TYPE = new Dafny.TypeDescriptor<AwsKmsArnParsing_Compile.AwsArn>(AwsKmsArnParsing_Compile.AwsArn.Default());
    public static Dafny.TypeDescriptor<AwsKmsArnParsing_Compile.AwsArn> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public partial class AwsKmsResource {
    private static readonly Dafny.TypeDescriptor<AwsKmsArnParsing_Compile.AwsResource> _TYPE = new Dafny.TypeDescriptor<AwsKmsArnParsing_Compile.AwsResource>(AwsKmsArnParsing_Compile.AwsResource.Default());
    public static Dafny.TypeDescriptor<AwsKmsArnParsing_Compile.AwsResource> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public abstract class AwsKmsIdentifier {
    public AwsKmsIdentifier() { }
    private static readonly AwsKmsIdentifier theDefault = create_AwsKmsArnIdentifier(AwsKmsArnParsing_Compile.AwsArn.Default());
    public static AwsKmsIdentifier Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<AwsKmsArnParsing_Compile.AwsKmsIdentifier> _TYPE = new Dafny.TypeDescriptor<AwsKmsArnParsing_Compile.AwsKmsIdentifier>(AwsKmsArnParsing_Compile.AwsKmsIdentifier.Default());
    public static Dafny.TypeDescriptor<AwsKmsArnParsing_Compile.AwsKmsIdentifier> _TypeDescriptor() {
      return _TYPE;
    }
    public static AwsKmsIdentifier create_AwsKmsArnIdentifier(AwsKmsArnParsing_Compile.AwsArn a) {
      return new AwsKmsIdentifier_AwsKmsArnIdentifier(a);
    }
    public static AwsKmsIdentifier create_AwsKmsRawResourceIdentifier(AwsKmsArnParsing_Compile.AwsResource r) {
      return new AwsKmsIdentifier_AwsKmsRawResourceIdentifier(r);
    }
    public bool is_AwsKmsArnIdentifier { get { return this is AwsKmsIdentifier_AwsKmsArnIdentifier; } }
    public bool is_AwsKmsRawResourceIdentifier { get { return this is AwsKmsIdentifier_AwsKmsRawResourceIdentifier; } }
    public AwsKmsArnParsing_Compile.AwsArn dtor_a {
      get {
        var d = this;
        return ((AwsKmsIdentifier_AwsKmsArnIdentifier)d).a; 
      }
    }
    public AwsKmsArnParsing_Compile.AwsResource dtor_r {
      get {
        var d = this;
        return ((AwsKmsIdentifier_AwsKmsRawResourceIdentifier)d).r; 
      }
    }
    public Dafny.ISequence<char> _ToString() {
      AwsKmsArnParsing_Compile.AwsKmsIdentifier _source11 = this;
      if (_source11.is_AwsKmsArnIdentifier) {
        AwsKmsArnParsing_Compile.AwsArn _20774___mcc_h0 = ((AwsKmsArnParsing_Compile.AwsKmsIdentifier_AwsKmsArnIdentifier)_source11).a;
        AwsKmsArnParsing_Compile.AwsArn _20775_a = _20774___mcc_h0;
        return (_20775_a)._ToString();
      } else {
        AwsKmsArnParsing_Compile.AwsResource _20776___mcc_h1 = ((AwsKmsArnParsing_Compile.AwsKmsIdentifier_AwsKmsRawResourceIdentifier)_source11).r;
        AwsKmsArnParsing_Compile.AwsResource _20777_r = _20776___mcc_h1;
        return (_20777_r)._ToString();
      }
    }
  }
  public class AwsKmsIdentifier_AwsKmsArnIdentifier : AwsKmsIdentifier {
    public readonly AwsKmsArnParsing_Compile.AwsArn a;
    public AwsKmsIdentifier_AwsKmsArnIdentifier(AwsKmsArnParsing_Compile.AwsArn a) {
      this.a = a;
    }
    public override bool Equals(object other) {
      var oth = other as AwsKmsArnParsing_Compile.AwsKmsIdentifier_AwsKmsArnIdentifier;
      return oth != null && object.Equals(this.a, oth.a);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.a));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsKmsArnParsing_Compile.AwsKmsIdentifier.AwsKmsArnIdentifier";
      s += "(";
      s += Dafny.Helpers.ToString(this.a);
      s += ")";
      return s;
    }
  }
  public class AwsKmsIdentifier_AwsKmsRawResourceIdentifier : AwsKmsIdentifier {
    public readonly AwsKmsArnParsing_Compile.AwsResource r;
    public AwsKmsIdentifier_AwsKmsRawResourceIdentifier(AwsKmsArnParsing_Compile.AwsResource r) {
      this.r = r;
    }
    public override bool Equals(object other) {
      var oth = other as AwsKmsArnParsing_Compile.AwsKmsIdentifier_AwsKmsRawResourceIdentifier;
      return oth != null && object.Equals(this.r, oth.r);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.r));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsKmsArnParsing_Compile.AwsKmsIdentifier.AwsKmsRawResourceIdentifier";
      s += "(";
      s += Dafny.Helpers.ToString(this.r);
      s += ")";
      return s;
    }
  }

  public partial class AwsKmsIdentifierString {
    private static readonly Dafny.TypeDescriptor<Dafny.ISequence<char>> _TYPE = new Dafny.TypeDescriptor<Dafny.ISequence<char>>(Dafny.Sequence<char>.Empty);
    public static Dafny.TypeDescriptor<Dafny.ISequence<char>> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public partial class __default {
    public static bool ValidAwsKmsResource(AwsKmsArnParsing_Compile.AwsResource resource) {
      return ((resource).Valid()) && ((((resource).dtor_resourceType).Equals((Dafny.Sequence<char>.FromString("key")))) || (((resource).dtor_resourceType).Equals((Dafny.Sequence<char>.FromString("alias")))));
    }
    public static bool ValidAwsKmsArn(AwsKmsArnParsing_Compile.AwsArn arn) {
      return (((arn).Valid()) && (((arn).dtor_service).Equals((Dafny.Sequence<char>.FromString("kms"))))) && (AwsKmsArnParsing_Compile.__default.ValidAwsKmsResource((arn).dtor_resource));
    }
    public static Wrappers_Compile.Result<AwsKmsArnParsing_Compile.AwsResource, Dafny.ISequence<char>> ParseAwsKmsRawResources(Dafny.ISequence<char> identifier) {
      Dafny.ISequence<Dafny.ISequence<char>> _20778_info = StandardLibrary_Compile.__default.Split<char>(identifier, '/');
      Wrappers_Compile.Outcome<Dafny.ISequence<char>> _20779_valueOrError0 = Wrappers_Compile.__default.Need<Dafny.ISequence<char>>(!((_20778_info).Select(BigInteger.Zero)).Equals((Dafny.Sequence<char>.FromString("key"))), Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Malformed raw key id: "), identifier));
      if ((_20779_valueOrError0).IsFailure()) {
        return (_20779_valueOrError0).PropagateFailure<AwsKmsArnParsing_Compile.AwsResource>();
      } else if ((new BigInteger((_20778_info).Count)) == (BigInteger.One)) {
        return AwsKmsArnParsing_Compile.__default.ParseAwsKmsResources(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("key/"), identifier));
      } else {
        return AwsKmsArnParsing_Compile.__default.ParseAwsKmsResources(identifier);
      }
    }
    public static Wrappers_Compile.Result<AwsKmsArnParsing_Compile.AwsResource, Dafny.ISequence<char>> ParseAwsKmsResources(Dafny.ISequence<char> identifier) {
      Dafny.ISequence<Dafny.ISequence<char>> _20780_info = StandardLibrary_Compile.__default.Split<char>(identifier, '/');
      Wrappers_Compile.Outcome<Dafny.ISequence<char>> _20781_valueOrError0 = Wrappers_Compile.__default.Need<Dafny.ISequence<char>>((new BigInteger((_20780_info).Count)) > (BigInteger.One), Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Malformed resource: "), identifier));
      if ((_20781_valueOrError0).IsFailure()) {
        return (_20781_valueOrError0).PropagateFailure<AwsKmsArnParsing_Compile.AwsResource>();
      } else {
        Dafny.ISequence<char> _20782_resourceType = (_20780_info).Select(BigInteger.Zero);
        Dafny.ISequence<char> _20783_value = StandardLibrary_Compile.__default.Join<char>((_20780_info).Drop(BigInteger.One), Dafny.Sequence<char>.FromString("/"));
        AwsKmsArnParsing_Compile.AwsResource _20784_resource = @AwsKmsArnParsing_Compile.AwsResource.create(_20782_resourceType, _20783_value);
        Wrappers_Compile.Outcome<Dafny.ISequence<char>> _20785_valueOrError1 = Wrappers_Compile.__default.Need<Dafny.ISequence<char>>(AwsKmsArnParsing_Compile.__default.ValidAwsKmsResource(_20784_resource), Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Malformed resource: "), identifier));
        if ((_20785_valueOrError1).IsFailure()) {
          return (_20785_valueOrError1).PropagateFailure<AwsKmsArnParsing_Compile.AwsResource>();
        } else {
          return @Wrappers_Compile.Result<AwsKmsArnParsing_Compile.AwsResource, Dafny.ISequence<char>>.create_Success(_20784_resource);
        }
      }
    }
    public static Wrappers_Compile.Result<AwsKmsArnParsing_Compile.AwsArn, Dafny.ISequence<char>> ParseAwsKmsArn(Dafny.ISequence<char> identifier) {
      Dafny.ISequence<Dafny.ISequence<char>> _20786_components = StandardLibrary_Compile.__default.Split<char>(identifier, ':');
      Wrappers_Compile.Outcome<Dafny.ISequence<char>> _20787_valueOrError0 = Wrappers_Compile.__default.Need<Dafny.ISequence<char>>((new BigInteger(6)) == (new BigInteger((_20786_components).Count)), Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Malformed arn: "), identifier));
      if ((_20787_valueOrError0).IsFailure()) {
        return (_20787_valueOrError0).PropagateFailure<AwsKmsArnParsing_Compile.AwsArn>();
      } else {
        Wrappers_Compile.Result<AwsKmsArnParsing_Compile.AwsResource, Dafny.ISequence<char>> _20788_valueOrError1 = AwsKmsArnParsing_Compile.__default.ParseAwsKmsResources((_20786_components).Select(new BigInteger(5)));
        if ((_20788_valueOrError1).IsFailure()) {
          return (_20788_valueOrError1).PropagateFailure<AwsKmsArnParsing_Compile.AwsArn>();
        } else {
          AwsKmsArnParsing_Compile.AwsResource _20789_resource = (_20788_valueOrError1).Extract();
          AwsKmsArnParsing_Compile.AwsArn _20790_arn = @AwsKmsArnParsing_Compile.AwsArn.create((_20786_components).Select(BigInteger.Zero), (_20786_components).Select(BigInteger.One), (_20786_components).Select(new BigInteger(2)), (_20786_components).Select(new BigInteger(3)), (_20786_components).Select(new BigInteger(4)), _20789_resource);
          Wrappers_Compile.Outcome<Dafny.ISequence<char>> _20791_valueOrError2 = Wrappers_Compile.__default.Need<Dafny.ISequence<char>>(AwsKmsArnParsing_Compile.__default.ValidAwsKmsArn(_20790_arn), Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Malformed Arn:"), identifier));
          if ((_20791_valueOrError2).IsFailure()) {
            return (_20791_valueOrError2).PropagateFailure<AwsKmsArnParsing_Compile.AwsArn>();
          } else {
            return @Wrappers_Compile.Result<AwsKmsArnParsing_Compile.AwsArn, Dafny.ISequence<char>>.create_Success(_20790_arn);
          }
        }
      }
    }
    public static Wrappers_Compile.Result<AwsKmsArnParsing_Compile.AwsKmsIdentifier, Dafny.ISequence<char>> ParseAwsKmsIdentifier(Dafny.ISequence<char> identifier) {
      if (Dafny.Sequence<char>.IsPrefixOf(Dafny.Sequence<char>.FromString("arn:"), identifier)) {
        Wrappers_Compile.Result<AwsKmsArnParsing_Compile.AwsArn, Dafny.ISequence<char>> _20792_valueOrError0 = AwsKmsArnParsing_Compile.__default.ParseAwsKmsArn(identifier);
        if ((_20792_valueOrError0).IsFailure()) {
          return (_20792_valueOrError0).PropagateFailure<AwsKmsArnParsing_Compile.AwsKmsIdentifier>();
        } else {
          AwsKmsArnParsing_Compile.AwsArn _20793_arn = (_20792_valueOrError0).Extract();
          return @Wrappers_Compile.Result<AwsKmsArnParsing_Compile.AwsKmsIdentifier, Dafny.ISequence<char>>.create_Success(@AwsKmsArnParsing_Compile.AwsKmsIdentifier.create_AwsKmsArnIdentifier(_20793_arn));
        }
      } else {
        Wrappers_Compile.Result<AwsKmsArnParsing_Compile.AwsResource, Dafny.ISequence<char>> _20794_valueOrError1 = AwsKmsArnParsing_Compile.__default.ParseAwsKmsRawResources(identifier);
        if ((_20794_valueOrError1).IsFailure()) {
          return (_20794_valueOrError1).PropagateFailure<AwsKmsArnParsing_Compile.AwsKmsIdentifier>();
        } else {
          AwsKmsArnParsing_Compile.AwsResource _20795_r = (_20794_valueOrError1).Extract();
          return @Wrappers_Compile.Result<AwsKmsArnParsing_Compile.AwsKmsIdentifier, Dafny.ISequence<char>>.create_Success(@AwsKmsArnParsing_Compile.AwsKmsIdentifier.create_AwsKmsRawResourceIdentifier(_20795_r));
        }
      }
    }
    public static bool IsMultiRegionAwsKmsArn(AwsKmsArnParsing_Compile.AwsArn arn) {
      return AwsKmsArnParsing_Compile.__default.IsMultiRegionAwsKmsResource((arn).dtor_resource);
    }
    public static bool IsMultiRegionAwsKmsIdentifier(AwsKmsArnParsing_Compile.AwsKmsIdentifier identifier) {
      AwsKmsArnParsing_Compile.AwsKmsIdentifier _source12 = identifier;
      if (_source12.is_AwsKmsArnIdentifier) {
        AwsKmsArnParsing_Compile.AwsArn _20796___mcc_h0 = ((AwsKmsArnParsing_Compile.AwsKmsIdentifier_AwsKmsArnIdentifier)_source12).a;
        AwsKmsArnParsing_Compile.AwsArn _20797_arn = _20796___mcc_h0;
        return AwsKmsArnParsing_Compile.__default.IsMultiRegionAwsKmsArn(_20797_arn);
      } else {
        AwsKmsArnParsing_Compile.AwsResource _20798___mcc_h1 = ((AwsKmsArnParsing_Compile.AwsKmsIdentifier_AwsKmsRawResourceIdentifier)_source12).r;
        AwsKmsArnParsing_Compile.AwsResource _20799_r = _20798___mcc_h1;
        return AwsKmsArnParsing_Compile.__default.IsMultiRegionAwsKmsResource(_20799_r);
      }
    }
    public static bool IsMultiRegionAwsKmsResource(AwsKmsArnParsing_Compile.AwsResource resource) {
      return (((resource).dtor_resourceType).Equals((Dafny.Sequence<char>.FromString("key")))) && (Dafny.Sequence<char>.IsPrefixOf(Dafny.Sequence<char>.FromString("mrk-"), (resource).dtor_value));
    }
    public static Wrappers_Compile.Option<Dafny.ISequence<char>> GetRegion(AwsKmsArnParsing_Compile.AwsKmsIdentifier identifier) {
      AwsKmsArnParsing_Compile.AwsKmsIdentifier _source13 = identifier;
      if (_source13.is_AwsKmsArnIdentifier) {
        AwsKmsArnParsing_Compile.AwsArn _20800___mcc_h0 = ((AwsKmsArnParsing_Compile.AwsKmsIdentifier_AwsKmsArnIdentifier)_source13).a;
        AwsKmsArnParsing_Compile.AwsArn _20801_a = _20800___mcc_h0;
        return @Wrappers_Compile.Option<Dafny.ISequence<char>>.create_Some((_20801_a).dtor_region);
      } else {
        AwsKmsArnParsing_Compile.AwsResource _20802___mcc_h1 = ((AwsKmsArnParsing_Compile.AwsKmsIdentifier_AwsKmsRawResourceIdentifier)_source13).r;
        return @Wrappers_Compile.Option<Dafny.ISequence<char>>.create_None();
      }
    }
    public static BigInteger MAX__AWS__KMS__IDENTIFIER__LENGTH { get {
      return new BigInteger(2048);
    } }
  }
} // end of namespace AwsKmsArnParsing_Compile
namespace Sets {


} // end of namespace Sets
namespace EncryptionContext {








  public partial class __default {
    public static bool SerializableKVPairs(Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext) {
      return ((new BigInteger((encryptionContext).Count)) < (StandardLibrary_mUInt_Compile.__default.UINT16__LIMIT)) && (Dafny.Helpers.Id<Func<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, bool>>((_20803_encryptionContext) => Dafny.Helpers.Quantifier<Dafny.ISequence<byte>>(((_20803_encryptionContext).Keys).Elements, true, (((_20804_key) => {
        return !(((_20803_encryptionContext).Keys).Contains((_20804_key))) || (EncryptionContext.__default.SerializableKVPair(@_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.create(_20804_key, Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Select(_20803_encryptionContext,_20804_key))));
      }))))(encryptionContext));
    }
    public static bool SerializableKVPair(_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>> kvPair) {
      return ((((new BigInteger(((kvPair).dtor__0).Count)) < (StandardLibrary_mUInt_Compile.__default.UINT16__LIMIT)) && ((new BigInteger(((kvPair).dtor__1).Count)) < (StandardLibrary_mUInt_Compile.__default.UINT16__LIMIT))) && (UTF8.__default.ValidUTF8Seq((kvPair).dtor__0))) && (UTF8.__default.ValidUTF8Seq((kvPair).dtor__1));
    }
    public static BigInteger ComputeLength(Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext)
    {
      BigInteger res = BigInteger.Zero;
      if ((new BigInteger((encryptionContext).Count)).Sign == 0) {
        res = BigInteger.Zero;
        return res;
      }
      Dafny.ISequence<Dafny.ISequence<byte>> _20805_keys;
      Dafny.ISequence<Dafny.ISequence<byte>> _out13;
      _out13 = Sets.__default.SetToOrderedSequence<byte>((encryptionContext).Keys, StandardLibrary_mUInt_Compile.__default.UInt8Less);
      _20805_keys = _out13;
      Dafny.ISequence<_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>> _20806_kvPairs;
      _20806_kvPairs = ((System.Func<Dafny.ISequence<_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>>>) (() => {
        BigInteger dim1 = new BigInteger((_20805_keys).Count);
        var arr1 = new _System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>[Dafny.Helpers.ToIntChecked(dim1,"C# array size must not be larger than max 32-bit int")];
        for (int i1 = 0; i1 < dim1; i1++) {
          var _20807_i = (BigInteger) i1;
          arr1[(int)(_20807_i)] = @_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.create((_20805_keys).Select(_20807_i), Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Select(encryptionContext,(_20805_keys).Select(_20807_i)));
        }
        return Dafny.Sequence<_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>>.FromArray(arr1);
      }))();
      BigInteger _20808_len;
      _20808_len = new BigInteger(2);
      BigInteger _20809_i;
      _20809_i = BigInteger.Zero;
      while ((_20809_i) < (new BigInteger((_20806_kvPairs).Count))) {
        _System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>> _20810_kvPair;
        _20810_kvPair = (_20806_kvPairs).Select(_20809_i);
        _20808_len = (((_20808_len) + (new BigInteger(4))) + (new BigInteger(((_20810_kvPair).dtor__0).Count))) + (new BigInteger(((_20810_kvPair).dtor__1).Count));
        _20809_i = (_20809_i) + (BigInteger.One);
      }
      res = _20808_len;
      return res;
      return res;
    }
    public static bool CheckSerializable(Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext)
    {
      bool res = false;
      if ((new BigInteger((encryptionContext).Count)).Sign == 0) {
        res = true;
        return res;
      } else if ((new BigInteger((encryptionContext).Count)) >= (StandardLibrary_mUInt_Compile.__default.UINT16__LIMIT)) {
        res = false;
        return res;
      }
      Dafny.ISequence<Dafny.ISequence<byte>> _20811_keys;
      Dafny.ISequence<Dafny.ISequence<byte>> _out14;
      _out14 = Sets.__default.SetToOrderedSequence<byte>((encryptionContext).Keys, StandardLibrary_mUInt_Compile.__default.UInt8Less);
      _20811_keys = _out14;
      Dafny.ISequence<_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>> _20812_kvPairs;
      _20812_kvPairs = ((System.Func<Dafny.ISequence<_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>>>) (() => {
        BigInteger dim2 = new BigInteger((_20811_keys).Count);
        var arr2 = new _System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>[Dafny.Helpers.ToIntChecked(dim2,"C# array size must not be larger than max 32-bit int")];
        for (int i2 = 0; i2 < dim2; i2++) {
          var _20813_i = (BigInteger) i2;
          arr2[(int)(_20813_i)] = @_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.create((_20811_keys).Select(_20813_i), Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Select(encryptionContext,(_20811_keys).Select(_20813_i)));
        }
        return Dafny.Sequence<_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>>.FromArray(arr2);
      }))();
      BigInteger _20814_kvPairsLen;
      _20814_kvPairsLen = new BigInteger(2);
      BigInteger _20815_i;
      _20815_i = BigInteger.Zero;
      while ((_20815_i) < (new BigInteger((_20812_kvPairs).Count))) {
        _System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>> _20816_kvPair;
        _20816_kvPair = (_20812_kvPairs).Select(_20815_i);
        _20814_kvPairsLen = (((_20814_kvPairsLen) + (new BigInteger(4))) + (new BigInteger(((_20816_kvPair).dtor__0).Count))) + (new BigInteger(((_20816_kvPair).dtor__1).Count));
        if (!(((new BigInteger(((_20816_kvPair).dtor__0).Count)) < (StandardLibrary_mUInt_Compile.__default.UINT16__LIMIT)) && ((new BigInteger(((_20816_kvPair).dtor__1).Count)) < (StandardLibrary_mUInt_Compile.__default.UINT16__LIMIT)))) {
          res = false;
          return res;
        } else if ((_20814_kvPairsLen) >= (StandardLibrary_mUInt_Compile.__default.UINT16__LIMIT)) {
          res = false;
          return res;
        }
        _20815_i = (_20815_i) + (BigInteger.One);
      }
      res = true;
      return res;
      return res;
    }
  }
} // end of namespace EncryptionContext
namespace KMSUtils {









  public partial class GrantTokens {
    private static readonly Dafny.TypeDescriptor<Dafny.ISequence<Dafny.ISequence<char>>> _TYPE = new Dafny.TypeDescriptor<Dafny.ISequence<Dafny.ISequence<char>>>(Dafny.Sequence<Dafny.ISequence<char>>.Empty);
    public static Dafny.TypeDescriptor<Dafny.ISequence<Dafny.ISequence<char>>> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public partial class GrantToken {
    private static readonly Dafny.TypeDescriptor<Dafny.ISequence<char>> _TYPE = new Dafny.TypeDescriptor<Dafny.ISequence<char>>(Dafny.Sequence<char>.Empty);
    public static Dafny.TypeDescriptor<Dafny.ISequence<char>> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public class ResponseMetadata {
    public readonly Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>> metadata;
    public readonly Dafny.ISequence<char> requestID;
    public ResponseMetadata(Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>> metadata, Dafny.ISequence<char> requestID) {
      this.metadata = metadata;
      this.requestID = requestID;
    }
    public override bool Equals(object other) {
      var oth = other as KMSUtils.ResponseMetadata;
      return oth != null && object.Equals(this.metadata, oth.metadata) && object.Equals(this.requestID, oth.requestID);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.metadata));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.requestID));
      return (int) hash;
    }
    public override string ToString() {
      string s = "KMSUtils_Compile.ResponseMetadata.ResponseMetadata";
      s += "(";
      s += Dafny.Helpers.ToString(this.metadata);
      s += ", ";
      s += Dafny.Helpers.ToString(this.requestID);
      s += ")";
      return s;
    }
    private static readonly ResponseMetadata theDefault = create(Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<char>>.Empty, Dafny.Sequence<char>.Empty);
    public static ResponseMetadata Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<KMSUtils.ResponseMetadata> _TYPE = new Dafny.TypeDescriptor<KMSUtils.ResponseMetadata>(KMSUtils.ResponseMetadata.Default());
    public static Dafny.TypeDescriptor<KMSUtils.ResponseMetadata> _TypeDescriptor() {
      return _TYPE;
    }
    public static ResponseMetadata create(Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>> metadata, Dafny.ISequence<char> requestID) {
      return new ResponseMetadata(metadata, requestID);
    }
    public bool is_ResponseMetadata { get { return true; } }
    public Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>> dtor_metadata {
      get {
        return this.metadata;
      }
    }
    public Dafny.ISequence<char> dtor_requestID {
      get {
        return this.requestID;
      }
    }
  }


  public class GenerateDataKeyRequest {
    public readonly Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext;
    public readonly Dafny.ISequence<Dafny.ISequence<char>> grantTokens;
    public readonly Dafny.ISequence<char> keyID;
    public readonly int numberOfBytes;
    public GenerateDataKeyRequest(Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext, Dafny.ISequence<Dafny.ISequence<char>> grantTokens, Dafny.ISequence<char> keyID, int numberOfBytes) {
      this.encryptionContext = encryptionContext;
      this.grantTokens = grantTokens;
      this.keyID = keyID;
      this.numberOfBytes = numberOfBytes;
    }
    public override bool Equals(object other) {
      var oth = other as KMSUtils.GenerateDataKeyRequest;
      return oth != null && object.Equals(this.encryptionContext, oth.encryptionContext) && object.Equals(this.grantTokens, oth.grantTokens) && object.Equals(this.keyID, oth.keyID) && this.numberOfBytes == oth.numberOfBytes;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.encryptionContext));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.grantTokens));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.keyID));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.numberOfBytes));
      return (int) hash;
    }
    public override string ToString() {
      string s = "KMSUtils_Compile.GenerateDataKeyRequest.GenerateDataKeyRequest";
      s += "(";
      s += Dafny.Helpers.ToString(this.encryptionContext);
      s += ", ";
      s += Dafny.Helpers.ToString(this.grantTokens);
      s += ", ";
      s += Dafny.Helpers.ToString(this.keyID);
      s += ", ";
      s += Dafny.Helpers.ToString(this.numberOfBytes);
      s += ")";
      return s;
    }
    private static readonly GenerateDataKeyRequest theDefault = create(Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Empty, Dafny.Sequence<Dafny.ISequence<char>>.Empty, Dafny.Sequence<char>.Empty, 0);
    public static GenerateDataKeyRequest Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<KMSUtils.GenerateDataKeyRequest> _TYPE = new Dafny.TypeDescriptor<KMSUtils.GenerateDataKeyRequest>(KMSUtils.GenerateDataKeyRequest.Default());
    public static Dafny.TypeDescriptor<KMSUtils.GenerateDataKeyRequest> _TypeDescriptor() {
      return _TYPE;
    }
    public static GenerateDataKeyRequest create(Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext, Dafny.ISequence<Dafny.ISequence<char>> grantTokens, Dafny.ISequence<char> keyID, int numberOfBytes) {
      return new GenerateDataKeyRequest(encryptionContext, grantTokens, keyID, numberOfBytes);
    }
    public bool is_GenerateDataKeyRequest { get { return true; } }
    public Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> dtor_encryptionContext {
      get {
        return this.encryptionContext;
      }
    }
    public Dafny.ISequence<Dafny.ISequence<char>> dtor_grantTokens {
      get {
        return this.grantTokens;
      }
    }
    public Dafny.ISequence<char> dtor_keyID {
      get {
        return this.keyID;
      }
    }
    public int dtor_numberOfBytes {
      get {
        return this.numberOfBytes;
      }
    }
  }

  public class GenerateDataKeyResponse {
    public readonly Dafny.ISequence<byte> ciphertextBlob;
    public readonly Dafny.ISequence<char> keyID;
    public readonly Dafny.ISequence<byte> plaintext;
    public GenerateDataKeyResponse(Dafny.ISequence<byte> ciphertextBlob, Dafny.ISequence<char> keyID, Dafny.ISequence<byte> plaintext) {
      this.ciphertextBlob = ciphertextBlob;
      this.keyID = keyID;
      this.plaintext = plaintext;
    }
    public override bool Equals(object other) {
      var oth = other as KMSUtils.GenerateDataKeyResponse;
      return oth != null && object.Equals(this.ciphertextBlob, oth.ciphertextBlob) && object.Equals(this.keyID, oth.keyID) && object.Equals(this.plaintext, oth.plaintext);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.ciphertextBlob));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.keyID));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.plaintext));
      return (int) hash;
    }
    public override string ToString() {
      string s = "KMSUtils_Compile.GenerateDataKeyResponse.GenerateDataKeyResponse";
      s += "(";
      s += Dafny.Helpers.ToString(this.ciphertextBlob);
      s += ", ";
      s += Dafny.Helpers.ToString(this.keyID);
      s += ", ";
      s += Dafny.Helpers.ToString(this.plaintext);
      s += ")";
      return s;
    }
    private static readonly GenerateDataKeyResponse theDefault = create(Dafny.Sequence<byte>.Empty, Dafny.Sequence<char>.Empty, Dafny.Sequence<byte>.Empty);
    public static GenerateDataKeyResponse Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<KMSUtils.GenerateDataKeyResponse> _TYPE = new Dafny.TypeDescriptor<KMSUtils.GenerateDataKeyResponse>(KMSUtils.GenerateDataKeyResponse.Default());
    public static Dafny.TypeDescriptor<KMSUtils.GenerateDataKeyResponse> _TypeDescriptor() {
      return _TYPE;
    }
    public static GenerateDataKeyResponse create(Dafny.ISequence<byte> ciphertextBlob, Dafny.ISequence<char> keyID, Dafny.ISequence<byte> plaintext) {
      return new GenerateDataKeyResponse(ciphertextBlob, keyID, plaintext);
    }
    public bool is_GenerateDataKeyResponse { get { return true; } }
    public Dafny.ISequence<byte> dtor_ciphertextBlob {
      get {
        return this.ciphertextBlob;
      }
    }
    public Dafny.ISequence<char> dtor_keyID {
      get {
        return this.keyID;
      }
    }
    public Dafny.ISequence<byte> dtor_plaintext {
      get {
        return this.plaintext;
      }
    }
    public bool IsWellFormed() {
      return ((new BigInteger(((this).dtor_keyID).Count)) < (StandardLibrary_mUInt_Compile.__default.UINT16__LIMIT)) && ((new BigInteger(((this).dtor_ciphertextBlob).Count)) < (StandardLibrary_mUInt_Compile.__default.UINT16__LIMIT));
    }
  }

  public class EncryptRequest {
    public readonly Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext;
    public readonly Dafny.ISequence<Dafny.ISequence<char>> grantTokens;
    public readonly Dafny.ISequence<char> keyID;
    public readonly Dafny.ISequence<byte> plaintext;
    public EncryptRequest(Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext, Dafny.ISequence<Dafny.ISequence<char>> grantTokens, Dafny.ISequence<char> keyID, Dafny.ISequence<byte> plaintext) {
      this.encryptionContext = encryptionContext;
      this.grantTokens = grantTokens;
      this.keyID = keyID;
      this.plaintext = plaintext;
    }
    public override bool Equals(object other) {
      var oth = other as KMSUtils.EncryptRequest;
      return oth != null && object.Equals(this.encryptionContext, oth.encryptionContext) && object.Equals(this.grantTokens, oth.grantTokens) && object.Equals(this.keyID, oth.keyID) && object.Equals(this.plaintext, oth.plaintext);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.encryptionContext));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.grantTokens));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.keyID));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.plaintext));
      return (int) hash;
    }
    public override string ToString() {
      string s = "KMSUtils_Compile.EncryptRequest.EncryptRequest";
      s += "(";
      s += Dafny.Helpers.ToString(this.encryptionContext);
      s += ", ";
      s += Dafny.Helpers.ToString(this.grantTokens);
      s += ", ";
      s += Dafny.Helpers.ToString(this.keyID);
      s += ", ";
      s += Dafny.Helpers.ToString(this.plaintext);
      s += ")";
      return s;
    }
    private static readonly EncryptRequest theDefault = create(Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Empty, Dafny.Sequence<Dafny.ISequence<char>>.Empty, Dafny.Sequence<char>.Empty, Dafny.Sequence<byte>.Empty);
    public static EncryptRequest Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<KMSUtils.EncryptRequest> _TYPE = new Dafny.TypeDescriptor<KMSUtils.EncryptRequest>(KMSUtils.EncryptRequest.Default());
    public static Dafny.TypeDescriptor<KMSUtils.EncryptRequest> _TypeDescriptor() {
      return _TYPE;
    }
    public static EncryptRequest create(Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext, Dafny.ISequence<Dafny.ISequence<char>> grantTokens, Dafny.ISequence<char> keyID, Dafny.ISequence<byte> plaintext) {
      return new EncryptRequest(encryptionContext, grantTokens, keyID, plaintext);
    }
    public bool is_EncryptRequest { get { return true; } }
    public Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> dtor_encryptionContext {
      get {
        return this.encryptionContext;
      }
    }
    public Dafny.ISequence<Dafny.ISequence<char>> dtor_grantTokens {
      get {
        return this.grantTokens;
      }
    }
    public Dafny.ISequence<char> dtor_keyID {
      get {
        return this.keyID;
      }
    }
    public Dafny.ISequence<byte> dtor_plaintext {
      get {
        return this.plaintext;
      }
    }
  }

  public class EncryptResponse {
    public readonly Dafny.ISequence<byte> ciphertextBlob;
    public readonly BigInteger contentLength;
    public readonly BigInteger httpStatusCode;
    public readonly Dafny.ISequence<char> keyID;
    public readonly KMSUtils.ResponseMetadata responseMetadata;
    public EncryptResponse(Dafny.ISequence<byte> ciphertextBlob, BigInteger contentLength, BigInteger httpStatusCode, Dafny.ISequence<char> keyID, KMSUtils.ResponseMetadata responseMetadata) {
      this.ciphertextBlob = ciphertextBlob;
      this.contentLength = contentLength;
      this.httpStatusCode = httpStatusCode;
      this.keyID = keyID;
      this.responseMetadata = responseMetadata;
    }
    public override bool Equals(object other) {
      var oth = other as KMSUtils.EncryptResponse;
      return oth != null && object.Equals(this.ciphertextBlob, oth.ciphertextBlob) && this.contentLength == oth.contentLength && this.httpStatusCode == oth.httpStatusCode && object.Equals(this.keyID, oth.keyID) && object.Equals(this.responseMetadata, oth.responseMetadata);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.ciphertextBlob));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.contentLength));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.httpStatusCode));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.keyID));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.responseMetadata));
      return (int) hash;
    }
    public override string ToString() {
      string s = "KMSUtils_Compile.EncryptResponse.EncryptResponse";
      s += "(";
      s += Dafny.Helpers.ToString(this.ciphertextBlob);
      s += ", ";
      s += Dafny.Helpers.ToString(this.contentLength);
      s += ", ";
      s += Dafny.Helpers.ToString(this.httpStatusCode);
      s += ", ";
      s += Dafny.Helpers.ToString(this.keyID);
      s += ", ";
      s += Dafny.Helpers.ToString(this.responseMetadata);
      s += ")";
      return s;
    }
    private static readonly EncryptResponse theDefault = create(Dafny.Sequence<byte>.Empty, BigInteger.Zero, BigInteger.Zero, Dafny.Sequence<char>.Empty, KMSUtils.ResponseMetadata.Default());
    public static EncryptResponse Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<KMSUtils.EncryptResponse> _TYPE = new Dafny.TypeDescriptor<KMSUtils.EncryptResponse>(KMSUtils.EncryptResponse.Default());
    public static Dafny.TypeDescriptor<KMSUtils.EncryptResponse> _TypeDescriptor() {
      return _TYPE;
    }
    public static EncryptResponse create(Dafny.ISequence<byte> ciphertextBlob, BigInteger contentLength, BigInteger httpStatusCode, Dafny.ISequence<char> keyID, KMSUtils.ResponseMetadata responseMetadata) {
      return new EncryptResponse(ciphertextBlob, contentLength, httpStatusCode, keyID, responseMetadata);
    }
    public bool is_EncryptResponse { get { return true; } }
    public Dafny.ISequence<byte> dtor_ciphertextBlob {
      get {
        return this.ciphertextBlob;
      }
    }
    public BigInteger dtor_contentLength {
      get {
        return this.contentLength;
      }
    }
    public BigInteger dtor_httpStatusCode {
      get {
        return this.httpStatusCode;
      }
    }
    public Dafny.ISequence<char> dtor_keyID {
      get {
        return this.keyID;
      }
    }
    public KMSUtils.ResponseMetadata dtor_responseMetadata {
      get {
        return this.responseMetadata;
      }
    }
    public bool IsWellFormed() {
      return ((new BigInteger(((this).dtor_keyID).Count)) < (StandardLibrary_mUInt_Compile.__default.UINT16__LIMIT)) && ((new BigInteger(((this).dtor_ciphertextBlob).Count)) < (StandardLibrary_mUInt_Compile.__default.UINT16__LIMIT));
    }
  }

  public class DecryptRequest {
    public readonly Dafny.ISequence<char> keyId;
    public readonly Dafny.ISequence<byte> ciphertextBlob;
    public readonly Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext;
    public readonly Dafny.ISequence<Dafny.ISequence<char>> grantTokens;
    public DecryptRequest(Dafny.ISequence<char> keyId, Dafny.ISequence<byte> ciphertextBlob, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext, Dafny.ISequence<Dafny.ISequence<char>> grantTokens) {
      this.keyId = keyId;
      this.ciphertextBlob = ciphertextBlob;
      this.encryptionContext = encryptionContext;
      this.grantTokens = grantTokens;
    }
    public override bool Equals(object other) {
      var oth = other as KMSUtils.DecryptRequest;
      return oth != null && object.Equals(this.keyId, oth.keyId) && object.Equals(this.ciphertextBlob, oth.ciphertextBlob) && object.Equals(this.encryptionContext, oth.encryptionContext) && object.Equals(this.grantTokens, oth.grantTokens);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.keyId));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.ciphertextBlob));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.encryptionContext));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.grantTokens));
      return (int) hash;
    }
    public override string ToString() {
      string s = "KMSUtils_Compile.DecryptRequest.DecryptRequest";
      s += "(";
      s += Dafny.Helpers.ToString(this.keyId);
      s += ", ";
      s += Dafny.Helpers.ToString(this.ciphertextBlob);
      s += ", ";
      s += Dafny.Helpers.ToString(this.encryptionContext);
      s += ", ";
      s += Dafny.Helpers.ToString(this.grantTokens);
      s += ")";
      return s;
    }
    private static readonly DecryptRequest theDefault = create(Dafny.Sequence<char>.Empty, Dafny.Sequence<byte>.Empty, Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Empty, Dafny.Sequence<Dafny.ISequence<char>>.Empty);
    public static DecryptRequest Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<KMSUtils.DecryptRequest> _TYPE = new Dafny.TypeDescriptor<KMSUtils.DecryptRequest>(KMSUtils.DecryptRequest.Default());
    public static Dafny.TypeDescriptor<KMSUtils.DecryptRequest> _TypeDescriptor() {
      return _TYPE;
    }
    public static DecryptRequest create(Dafny.ISequence<char> keyId, Dafny.ISequence<byte> ciphertextBlob, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext, Dafny.ISequence<Dafny.ISequence<char>> grantTokens) {
      return new DecryptRequest(keyId, ciphertextBlob, encryptionContext, grantTokens);
    }
    public bool is_DecryptRequest { get { return true; } }
    public Dafny.ISequence<char> dtor_keyId {
      get {
        return this.keyId;
      }
    }
    public Dafny.ISequence<byte> dtor_ciphertextBlob {
      get {
        return this.ciphertextBlob;
      }
    }
    public Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> dtor_encryptionContext {
      get {
        return this.encryptionContext;
      }
    }
    public Dafny.ISequence<Dafny.ISequence<char>> dtor_grantTokens {
      get {
        return this.grantTokens;
      }
    }
  }

  public class DecryptResponse {
    public readonly BigInteger contentLength;
    public readonly BigInteger httpStatusCode;
    public readonly Dafny.ISequence<char> keyID;
    public readonly Dafny.ISequence<byte> plaintext;
    public readonly KMSUtils.ResponseMetadata responseMetadata;
    public DecryptResponse(BigInteger contentLength, BigInteger httpStatusCode, Dafny.ISequence<char> keyID, Dafny.ISequence<byte> plaintext, KMSUtils.ResponseMetadata responseMetadata) {
      this.contentLength = contentLength;
      this.httpStatusCode = httpStatusCode;
      this.keyID = keyID;
      this.plaintext = plaintext;
      this.responseMetadata = responseMetadata;
    }
    public override bool Equals(object other) {
      var oth = other as KMSUtils.DecryptResponse;
      return oth != null && this.contentLength == oth.contentLength && this.httpStatusCode == oth.httpStatusCode && object.Equals(this.keyID, oth.keyID) && object.Equals(this.plaintext, oth.plaintext) && object.Equals(this.responseMetadata, oth.responseMetadata);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.contentLength));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.httpStatusCode));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.keyID));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.plaintext));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.responseMetadata));
      return (int) hash;
    }
    public override string ToString() {
      string s = "KMSUtils_Compile.DecryptResponse.DecryptResponse";
      s += "(";
      s += Dafny.Helpers.ToString(this.contentLength);
      s += ", ";
      s += Dafny.Helpers.ToString(this.httpStatusCode);
      s += ", ";
      s += Dafny.Helpers.ToString(this.keyID);
      s += ", ";
      s += Dafny.Helpers.ToString(this.plaintext);
      s += ", ";
      s += Dafny.Helpers.ToString(this.responseMetadata);
      s += ")";
      return s;
    }
    private static readonly DecryptResponse theDefault = create(BigInteger.Zero, BigInteger.Zero, Dafny.Sequence<char>.Empty, Dafny.Sequence<byte>.Empty, KMSUtils.ResponseMetadata.Default());
    public static DecryptResponse Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<KMSUtils.DecryptResponse> _TYPE = new Dafny.TypeDescriptor<KMSUtils.DecryptResponse>(KMSUtils.DecryptResponse.Default());
    public static Dafny.TypeDescriptor<KMSUtils.DecryptResponse> _TypeDescriptor() {
      return _TYPE;
    }
    public static DecryptResponse create(BigInteger contentLength, BigInteger httpStatusCode, Dafny.ISequence<char> keyID, Dafny.ISequence<byte> plaintext, KMSUtils.ResponseMetadata responseMetadata) {
      return new DecryptResponse(contentLength, httpStatusCode, keyID, plaintext, responseMetadata);
    }
    public bool is_DecryptResponse { get { return true; } }
    public BigInteger dtor_contentLength {
      get {
        return this.contentLength;
      }
    }
    public BigInteger dtor_httpStatusCode {
      get {
        return this.httpStatusCode;
      }
    }
    public Dafny.ISequence<char> dtor_keyID {
      get {
        return this.keyID;
      }
    }
    public Dafny.ISequence<byte> dtor_plaintext {
      get {
        return this.plaintext;
      }
    }
    public KMSUtils.ResponseMetadata dtor_responseMetadata {
      get {
        return this.responseMetadata;
      }
    }
  }

  public interface DafnyAWSKMSClientSupplier {
    Wrappers_Compile.Result<Amazon.KeyManagementService.IAmazonKeyManagementService, Dafny.ISequence<char>> GetClient(Wrappers_Compile.Option<Dafny.ISequence<char>> region);
  }
  public class _Companion_DafnyAWSKMSClientSupplier {
  }

  public partial class BaseClientSupplier : KMSUtils.DafnyAWSKMSClientSupplier {
    public BaseClientSupplier() {
    }
    public void __ctor()
    {
    }
    public Wrappers_Compile.Result<Amazon.KeyManagementService.IAmazonKeyManagementService, Dafny.ISequence<char>> GetClient(Wrappers_Compile.Option<Dafny.ISequence<char>> region)
    {
      Wrappers_Compile.Result<Amazon.KeyManagementService.IAmazonKeyManagementService, Dafny.ISequence<char>> res = default(Wrappers_Compile.Result<Amazon.KeyManagementService.IAmazonKeyManagementService, Dafny.ISequence<char>>);
      Wrappers_Compile.Result<Amazon.KeyManagementService.IAmazonKeyManagementService, Dafny.ISequence<char>> _20817_resClient;
      Wrappers_Compile.Result<Amazon.KeyManagementService.IAmazonKeyManagementService, Dafny.ISequence<char>> _out15;
      _out15 = KMSUtils.ClientHelper.GetDefaultAWSKMSServiceClientExtern(region);
      _20817_resClient = _out15;
      res = _20817_resClient;
      return res;
      return res;
    }
  }

  public partial class __default {
    public static BigInteger MAX__GRANT__TOKENS { get {
      return new BigInteger(10);
    } }
  }
} // end of namespace KMSUtils
namespace AlgorithmSuite {






  public partial class ID {
    public static System.Collections.Generic.IEnumerable<ushort> IntegerRange(BigInteger lo, BigInteger hi) {
      for (var j = lo; j < hi; j++) { yield return (ushort)j; }
    }
    public static readonly ushort Witness = (ushort)(20);
    private static readonly Dafny.TypeDescriptor<ushort> _TYPE = new Dafny.TypeDescriptor<ushort>(AlgorithmSuite.ID.Witness);
    public static Dafny.TypeDescriptor<ushort> _TypeDescriptor() {
      return _TYPE;
    }
    public static EncryptionSuites.EncryptionSuite EncryptionSuite(ushort _this) {
      return (Dafny.Map<ushort, AlgorithmSuite.AlgSuite>.Select(AlgorithmSuite.__default.Suite,_this)).dtor_algorithm;
    }
    public static BigInteger KeyLength(ushort _this) {
      return new BigInteger(((Dafny.Map<ushort, AlgorithmSuite.AlgSuite>.Select(AlgorithmSuite.__default.Suite,_this)).dtor_algorithm).dtor_keyLen);
    }
    public static bool ContainsIdentityKDF(ushort _this) {
      return object.Equals((Dafny.Map<ushort, AlgorithmSuite.AlgSuite>.Select(AlgorithmSuite.__default.Suite,_this)).dtor_hkdf, @KeyDerivationAlgorithms.KeyDerivationAlgorithm.create_IDENTITY());
    }
    public static BigInteger KDFInputKeyLength(ushort _this) {
      KeyDerivationAlgorithms.KeyDerivationAlgorithm _source14 = (Dafny.Map<ushort, AlgorithmSuite.AlgSuite>.Select(AlgorithmSuite.__default.Suite,_this)).dtor_hkdf;
      if (_source14.is_HKDF__WITH__SHA__384) {
        return new BigInteger(((Dafny.Map<ushort, AlgorithmSuite.AlgSuite>.Select(AlgorithmSuite.__default.Suite,_this)).dtor_algorithm).dtor_keyLen);
      } else if (_source14.is_HKDF__WITH__SHA__256) {
        return new BigInteger(((Dafny.Map<ushort, AlgorithmSuite.AlgSuite>.Select(AlgorithmSuite.__default.Suite,_this)).dtor_algorithm).dtor_keyLen);
      } else {
        return new BigInteger(((Dafny.Map<ushort, AlgorithmSuite.AlgSuite>.Select(AlgorithmSuite.__default.Suite,_this)).dtor_algorithm).dtor_keyLen);
      }
    }
    public static BigInteger IVLength(ushort _this) {
      return new BigInteger(((Dafny.Map<ushort, AlgorithmSuite.AlgSuite>.Select(AlgorithmSuite.__default.Suite,_this)).dtor_algorithm).dtor_ivLen);
    }
    public static BigInteger TagLength(ushort _this) {
      return new BigInteger(((Dafny.Map<ushort, AlgorithmSuite.AlgSuite>.Select(AlgorithmSuite.__default.Suite,_this)).dtor_algorithm).dtor_tagLen);
    }
    public static Wrappers_Compile.Option<Signature.ECDSAParams> SignatureType(ushort _this) {
      return (Dafny.Map<ushort, AlgorithmSuite.AlgSuite>.Select(AlgorithmSuite.__default.Suite,_this)).dtor_sign;
    }
    public static bool ValidPlaintextDataKey(ushort _this, Dafny.ISequence<byte> plaintextDataKey) {
      return (new BigInteger((plaintextDataKey).Count)) == (AlgorithmSuite.ID.KDFInputKeyLength(_this));
    }
  }

  public class AlgSuite {
    public readonly EncryptionSuites.EncryptionSuite algorithm;
    public readonly KeyDerivationAlgorithms.KeyDerivationAlgorithm hkdf;
    public readonly Wrappers_Compile.Option<Signature.ECDSAParams> sign;
    public AlgSuite(EncryptionSuites.EncryptionSuite algorithm, KeyDerivationAlgorithms.KeyDerivationAlgorithm hkdf, Wrappers_Compile.Option<Signature.ECDSAParams> sign) {
      this.algorithm = algorithm;
      this.hkdf = hkdf;
      this.sign = sign;
    }
    public override bool Equals(object other) {
      var oth = other as AlgorithmSuite.AlgSuite;
      return oth != null && object.Equals(this.algorithm, oth.algorithm) && object.Equals(this.hkdf, oth.hkdf) && object.Equals(this.sign, oth.sign);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.algorithm));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.hkdf));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.sign));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AlgorithmSuite_Compile.AlgSuite.AlgSuite";
      s += "(";
      s += Dafny.Helpers.ToString(this.algorithm);
      s += ", ";
      s += Dafny.Helpers.ToString(this.hkdf);
      s += ", ";
      s += Dafny.Helpers.ToString(this.sign);
      s += ")";
      return s;
    }
    private static readonly AlgSuite theDefault = create(EncryptionSuites.EncryptionSuite.Default(), KeyDerivationAlgorithms.KeyDerivationAlgorithm.Default(), Wrappers_Compile.Option<Signature.ECDSAParams>.Default());
    public static AlgSuite Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<AlgorithmSuite.AlgSuite> _TYPE = new Dafny.TypeDescriptor<AlgorithmSuite.AlgSuite>(AlgorithmSuite.AlgSuite.Default());
    public static Dafny.TypeDescriptor<AlgorithmSuite.AlgSuite> _TypeDescriptor() {
      return _TYPE;
    }
    public static AlgSuite create(EncryptionSuites.EncryptionSuite algorithm, KeyDerivationAlgorithms.KeyDerivationAlgorithm hkdf, Wrappers_Compile.Option<Signature.ECDSAParams> sign) {
      return new AlgSuite(algorithm, hkdf, sign);
    }
    public bool is_AlgSuite { get { return true; } }
    public EncryptionSuites.EncryptionSuite dtor_algorithm {
      get {
        return this.algorithm;
      }
    }
    public KeyDerivationAlgorithms.KeyDerivationAlgorithm dtor_hkdf {
      get {
        return this.hkdf;
      }
    }
    public Wrappers_Compile.Option<Signature.ECDSAParams> dtor_sign {
      get {
        return this.sign;
      }
    }
  }

  public partial class __default {
    public static Dafny.ISet<ushort> VALID__IDS { get {
      return Dafny.Set<ushort>.FromElements(888, 838, 532, 376, 326, 276, 120, 70, 20);
    } }
    public static ushort AES__256__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384 { get {
      return 888;
    } }
    public static ushort AES__192__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384 { get {
      return 838;
    } }
    public static ushort AES__128__GCM__IV12__TAG16__HKDF__SHA256__ECDSA__P256 { get {
      return 532;
    } }
    public static ushort AES__256__GCM__IV12__TAG16__HKDF__SHA256__NO__SIGNATURE__ALG { get {
      return 376;
    } }
    public static ushort AES__192__GCM__IV12__TAG16__HKDF__SHA256__NO__SIGNATURE__ALG { get {
      return 326;
    } }
    public static ushort AES__128__GCM__IV12__TAG16__HKDF__SHA256__NO__SIGNATURE__ALG { get {
      return 276;
    } }
    public static ushort AES__256__GCM__IV12__TAG16__IDENTITY__NO__SIGNATURE__ALG { get {
      return 120;
    } }
    public static ushort AES__192__GCM__IV12__TAG16__IDENTITY__NO__SIGNATURE__ALG { get {
      return 70;
    } }
    public static ushort AES__128__GCM__IV12__TAG16__IDENTITY__NO__SIGNATURE__ALG { get {
      return 20;
    } }
    public static Dafny.IMap<ushort,AlgorithmSuite.AlgSuite> Suite { get {
      return Dafny.Map<ushort, AlgorithmSuite.AlgSuite>.FromElements(new Dafny.Pair<ushort,AlgorithmSuite.AlgSuite>(AlgorithmSuite.__default.AES__256__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384,@AlgorithmSuite.AlgSuite.create(EncryptionSuites.__default.AES__GCM__256, @KeyDerivationAlgorithms.KeyDerivationAlgorithm.create_HKDF__WITH__SHA__384(), @Wrappers_Compile.Option<Signature.ECDSAParams>.create_Some(@Signature.ECDSAParams.create_ECDSA__P384()))), new Dafny.Pair<ushort,AlgorithmSuite.AlgSuite>(AlgorithmSuite.__default.AES__192__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384,@AlgorithmSuite.AlgSuite.create(EncryptionSuites.__default.AES__GCM__192, @KeyDerivationAlgorithms.KeyDerivationAlgorithm.create_HKDF__WITH__SHA__384(), @Wrappers_Compile.Option<Signature.ECDSAParams>.create_Some(@Signature.ECDSAParams.create_ECDSA__P384()))), new Dafny.Pair<ushort,AlgorithmSuite.AlgSuite>(AlgorithmSuite.__default.AES__128__GCM__IV12__TAG16__HKDF__SHA256__ECDSA__P256,@AlgorithmSuite.AlgSuite.create(EncryptionSuites.__default.AES__GCM__128, @KeyDerivationAlgorithms.KeyDerivationAlgorithm.create_HKDF__WITH__SHA__256(), @Wrappers_Compile.Option<Signature.ECDSAParams>.create_Some(@Signature.ECDSAParams.create_ECDSA__P256()))), new Dafny.Pair<ushort,AlgorithmSuite.AlgSuite>(AlgorithmSuite.__default.AES__256__GCM__IV12__TAG16__HKDF__SHA256__NO__SIGNATURE__ALG,@AlgorithmSuite.AlgSuite.create(EncryptionSuites.__default.AES__GCM__256, @KeyDerivationAlgorithms.KeyDerivationAlgorithm.create_HKDF__WITH__SHA__256(), @Wrappers_Compile.Option<Signature.ECDSAParams>.create_None())), new Dafny.Pair<ushort,AlgorithmSuite.AlgSuite>(AlgorithmSuite.__default.AES__192__GCM__IV12__TAG16__HKDF__SHA256__NO__SIGNATURE__ALG,@AlgorithmSuite.AlgSuite.create(EncryptionSuites.__default.AES__GCM__192, @KeyDerivationAlgorithms.KeyDerivationAlgorithm.create_HKDF__WITH__SHA__256(), @Wrappers_Compile.Option<Signature.ECDSAParams>.create_None())), new Dafny.Pair<ushort,AlgorithmSuite.AlgSuite>(AlgorithmSuite.__default.AES__128__GCM__IV12__TAG16__HKDF__SHA256__NO__SIGNATURE__ALG,@AlgorithmSuite.AlgSuite.create(EncryptionSuites.__default.AES__GCM__128, @KeyDerivationAlgorithms.KeyDerivationAlgorithm.create_HKDF__WITH__SHA__256(), @Wrappers_Compile.Option<Signature.ECDSAParams>.create_None())), new Dafny.Pair<ushort,AlgorithmSuite.AlgSuite>(AlgorithmSuite.__default.AES__256__GCM__IV12__TAG16__IDENTITY__NO__SIGNATURE__ALG,@AlgorithmSuite.AlgSuite.create(EncryptionSuites.__default.AES__GCM__256, @KeyDerivationAlgorithms.KeyDerivationAlgorithm.create_IDENTITY(), @Wrappers_Compile.Option<Signature.ECDSAParams>.create_None())), new Dafny.Pair<ushort,AlgorithmSuite.AlgSuite>(AlgorithmSuite.__default.AES__192__GCM__IV12__TAG16__IDENTITY__NO__SIGNATURE__ALG,@AlgorithmSuite.AlgSuite.create(EncryptionSuites.__default.AES__GCM__192, @KeyDerivationAlgorithms.KeyDerivationAlgorithm.create_IDENTITY(), @Wrappers_Compile.Option<Signature.ECDSAParams>.create_None())), new Dafny.Pair<ushort,AlgorithmSuite.AlgSuite>(AlgorithmSuite.__default.AES__128__GCM__IV12__TAG16__IDENTITY__NO__SIGNATURE__ALG,@AlgorithmSuite.AlgSuite.create(EncryptionSuites.__default.AES__GCM__128, @KeyDerivationAlgorithms.KeyDerivationAlgorithm.create_IDENTITY(), @Wrappers_Compile.Option<Signature.ECDSAParams>.create_None())));
    } }
  }
} // end of namespace AlgorithmSuite
namespace Materials {







  public class EncryptedDataKey {
    public readonly Dafny.ISequence<byte> providerID;
    public readonly Dafny.ISequence<byte> providerInfo;
    public readonly Dafny.ISequence<byte> ciphertext;
    public EncryptedDataKey(Dafny.ISequence<byte> providerID, Dafny.ISequence<byte> providerInfo, Dafny.ISequence<byte> ciphertext) {
      this.providerID = providerID;
      this.providerInfo = providerInfo;
      this.ciphertext = ciphertext;
    }
    public override bool Equals(object other) {
      var oth = other as Materials.EncryptedDataKey;
      return oth != null && object.Equals(this.providerID, oth.providerID) && object.Equals(this.providerInfo, oth.providerInfo) && object.Equals(this.ciphertext, oth.ciphertext);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.providerID));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.providerInfo));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.ciphertext));
      return (int) hash;
    }
    public override string ToString() {
      string s = "Materials_Compile.EncryptedDataKey.EncryptedDataKey";
      s += "(";
      s += Dafny.Helpers.ToString(this.providerID);
      s += ", ";
      s += Dafny.Helpers.ToString(this.providerInfo);
      s += ", ";
      s += Dafny.Helpers.ToString(this.ciphertext);
      s += ")";
      return s;
    }
    private static readonly EncryptedDataKey theDefault = create(UTF8.ValidUTF8Bytes.Default(), Dafny.Sequence<byte>.Empty, Dafny.Sequence<byte>.Empty);
    public static EncryptedDataKey Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<Materials.EncryptedDataKey> _TYPE = new Dafny.TypeDescriptor<Materials.EncryptedDataKey>(Materials.EncryptedDataKey.Default());
    public static Dafny.TypeDescriptor<Materials.EncryptedDataKey> _TypeDescriptor() {
      return _TYPE;
    }
    public static EncryptedDataKey create(Dafny.ISequence<byte> providerID, Dafny.ISequence<byte> providerInfo, Dafny.ISequence<byte> ciphertext) {
      return new EncryptedDataKey(providerID, providerInfo, ciphertext);
    }
    public bool is_EncryptedDataKey { get { return true; } }
    public Dafny.ISequence<byte> dtor_providerID {
      get {
        return this.providerID;
      }
    }
    public Dafny.ISequence<byte> dtor_providerInfo {
      get {
        return this.providerInfo;
      }
    }
    public Dafny.ISequence<byte> dtor_ciphertext {
      get {
        return this.ciphertext;
      }
    }
    public static Materials.EncryptedDataKey ValidWitness() {
      return @Materials.EncryptedDataKey.create(Dafny.Sequence<byte>.FromElements(), Dafny.Sequence<byte>.FromElements(), Dafny.Sequence<byte>.FromElements());
    }
  }

  public partial class ValidEncryptedDataKey {
    private static readonly Materials.EncryptedDataKey Witness = Materials.EncryptedDataKey.ValidWitness();
    public static Materials.EncryptedDataKey Default() {
      return Witness;
    }
    private static readonly Dafny.TypeDescriptor<Materials.EncryptedDataKey> _TYPE = new Dafny.TypeDescriptor<Materials.EncryptedDataKey>(Materials.ValidEncryptedDataKey.Default());
    public static Dafny.TypeDescriptor<Materials.EncryptedDataKey> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public class EncryptionMaterials {
    public readonly Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext;
    public readonly ushort algorithmSuiteID;
    public readonly Wrappers_Compile.Option<Dafny.ISequence<byte>> plaintextDataKey;
    public readonly Dafny.ISequence<Materials.EncryptedDataKey> encryptedDataKeys;
    public readonly Wrappers_Compile.Option<Dafny.ISequence<byte>> signingKey;
    public EncryptionMaterials(Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext, ushort algorithmSuiteID, Wrappers_Compile.Option<Dafny.ISequence<byte>> plaintextDataKey, Dafny.ISequence<Materials.EncryptedDataKey> encryptedDataKeys, Wrappers_Compile.Option<Dafny.ISequence<byte>> signingKey) {
      this.encryptionContext = encryptionContext;
      this.algorithmSuiteID = algorithmSuiteID;
      this.plaintextDataKey = plaintextDataKey;
      this.encryptedDataKeys = encryptedDataKeys;
      this.signingKey = signingKey;
    }
    public override bool Equals(object other) {
      var oth = other as Materials.EncryptionMaterials;
      return oth != null && object.Equals(this.encryptionContext, oth.encryptionContext) && this.algorithmSuiteID == oth.algorithmSuiteID && object.Equals(this.plaintextDataKey, oth.plaintextDataKey) && object.Equals(this.encryptedDataKeys, oth.encryptedDataKeys) && object.Equals(this.signingKey, oth.signingKey);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.encryptionContext));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.algorithmSuiteID));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.plaintextDataKey));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.encryptedDataKeys));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.signingKey));
      return (int) hash;
    }
    public override string ToString() {
      string s = "Materials_Compile.EncryptionMaterials.EncryptionMaterials";
      s += "(";
      s += Dafny.Helpers.ToString(this.encryptionContext);
      s += ", ";
      s += Dafny.Helpers.ToString(this.algorithmSuiteID);
      s += ", ";
      s += Dafny.Helpers.ToString(this.plaintextDataKey);
      s += ", ";
      s += Dafny.Helpers.ToString(this.encryptedDataKeys);
      s += ", ";
      s += Dafny.Helpers.ToString(this.signingKey);
      s += ")";
      return s;
    }
    private static readonly EncryptionMaterials theDefault = create(Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Empty, AlgorithmSuite.ID.Witness, Wrappers_Compile.Option<Dafny.ISequence<byte>>.Default(), Dafny.Sequence<Materials.EncryptedDataKey>.Empty, Wrappers_Compile.Option<Dafny.ISequence<byte>>.Default());
    public static EncryptionMaterials Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<Materials.EncryptionMaterials> _TYPE = new Dafny.TypeDescriptor<Materials.EncryptionMaterials>(Materials.EncryptionMaterials.Default());
    public static Dafny.TypeDescriptor<Materials.EncryptionMaterials> _TypeDescriptor() {
      return _TYPE;
    }
    public static EncryptionMaterials create(Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext, ushort algorithmSuiteID, Wrappers_Compile.Option<Dafny.ISequence<byte>> plaintextDataKey, Dafny.ISequence<Materials.EncryptedDataKey> encryptedDataKeys, Wrappers_Compile.Option<Dafny.ISequence<byte>> signingKey) {
      return new EncryptionMaterials(encryptionContext, algorithmSuiteID, plaintextDataKey, encryptedDataKeys, signingKey);
    }
    public bool is_EncryptionMaterials { get { return true; } }
    public Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> dtor_encryptionContext {
      get {
        return this.encryptionContext;
      }
    }
    public ushort dtor_algorithmSuiteID {
      get {
        return this.algorithmSuiteID;
      }
    }
    public Wrappers_Compile.Option<Dafny.ISequence<byte>> dtor_plaintextDataKey {
      get {
        return this.plaintextDataKey;
      }
    }
    public Dafny.ISequence<Materials.EncryptedDataKey> dtor_encryptedDataKeys {
      get {
        return this.encryptedDataKeys;
      }
    }
    public Wrappers_Compile.Option<Dafny.ISequence<byte>> dtor_signingKey {
      get {
        return this.signingKey;
      }
    }
    public static Materials.EncryptionMaterials ValidWitness() {
      return @Materials.EncryptionMaterials.create(Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.FromElements(), AlgorithmSuite.__default.AES__256__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384, @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_None(), Dafny.Sequence<Materials.EncryptedDataKey>.FromElements(), @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(((System.Func<Dafny.ISequence<byte>>) (() => {
  BigInteger dim3 = new BigInteger(32);
  var arr3 = new byte[Dafny.Helpers.ToIntChecked(dim3,"C# array size must not be larger than max 32-bit int")];
  for (int i3 = 0; i3 < dim3; i3++) {
    var _20818_i = (BigInteger) i3;
    arr3[(int)(_20818_i)] = 0;
  }
  return Dafny.Sequence<byte>.FromArray(arr3);
}))()));
    }
    public static Materials.EncryptionMaterials WithoutDataKeys(Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext, ushort algorithmSuiteID, Wrappers_Compile.Option<Dafny.ISequence<byte>> signingKey)
    {
      Materials.EncryptionMaterials _20819_m = @Materials.EncryptionMaterials.create(encryptionContext, algorithmSuiteID, @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_None(), Dafny.Sequence<Materials.EncryptedDataKey>.FromElements(), signingKey);
      return _20819_m;
    }
    public Materials.EncryptionMaterials WithKeys(Wrappers_Compile.Option<Dafny.ISequence<byte>> newPlaintextDataKey, Dafny.ISequence<Materials.EncryptedDataKey> newEncryptedDataKeys)
    {
      Materials.EncryptionMaterials _20820_r = Dafny.Helpers.Let<Materials.EncryptionMaterials, Materials.EncryptionMaterials>(this, _pat_let1_0 => Dafny.Helpers.Let<Materials.EncryptionMaterials, Materials.EncryptionMaterials>(_pat_let1_0, _20821_dt__update__tmp_h0 => Dafny.Helpers.Let<Dafny.ISequence<Materials.EncryptedDataKey>, Materials.EncryptionMaterials>(Dafny.Sequence<Materials.EncryptedDataKey>.Concat((this).dtor_encryptedDataKeys, newEncryptedDataKeys), _pat_let2_0 => Dafny.Helpers.Let<Dafny.ISequence<Materials.EncryptedDataKey>, Materials.EncryptionMaterials>(_pat_let2_0, _20822_dt__update_hencryptedDataKeys_h0 => Dafny.Helpers.Let<Wrappers_Compile.Option<Dafny.ISequence<byte>>, Materials.EncryptionMaterials>(newPlaintextDataKey, _pat_let3_0 => Dafny.Helpers.Let<Wrappers_Compile.Option<Dafny.ISequence<byte>>, Materials.EncryptionMaterials>(_pat_let3_0, _20823_dt__update_hplaintextDataKey_h0 => @Materials.EncryptionMaterials.create((_20821_dt__update__tmp_h0).dtor_encryptionContext, (_20821_dt__update__tmp_h0).dtor_algorithmSuiteID, _20823_dt__update_hplaintextDataKey_h0, _20822_dt__update_hencryptedDataKeys_h0, (_20821_dt__update__tmp_h0).dtor_signingKey)))))));
      return _20820_r;
    }
  }

  public partial class ValidEncryptionMaterials {
    private static readonly Materials.EncryptionMaterials Witness = Materials.EncryptionMaterials.ValidWitness();
    public static Materials.EncryptionMaterials Default() {
      return Witness;
    }
    private static readonly Dafny.TypeDescriptor<Materials.EncryptionMaterials> _TYPE = new Dafny.TypeDescriptor<Materials.EncryptionMaterials>(Materials.ValidEncryptionMaterials.Default());
    public static Dafny.TypeDescriptor<Materials.EncryptionMaterials> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public partial class EmptyEncryptionMaterials {
    private static readonly Dafny.TypeDescriptor<Materials.EncryptionMaterials> _TYPE = new Dafny.TypeDescriptor<Materials.EncryptionMaterials>(Materials.EncryptionMaterials.Default());
    public static Dafny.TypeDescriptor<Materials.EncryptionMaterials> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public partial class UseableEncryptionMaterials {
    private static readonly Dafny.TypeDescriptor<Materials.EncryptionMaterials> _TYPE = new Dafny.TypeDescriptor<Materials.EncryptionMaterials>(Materials.EncryptionMaterials.Default());
    public static Dafny.TypeDescriptor<Materials.EncryptionMaterials> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public class DecryptionMaterials {
    public readonly ushort algorithmSuiteID;
    public readonly Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext;
    public readonly Wrappers_Compile.Option<Dafny.ISequence<byte>> plaintextDataKey;
    public readonly Wrappers_Compile.Option<Dafny.ISequence<byte>> verificationKey;
    public DecryptionMaterials(ushort algorithmSuiteID, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext, Wrappers_Compile.Option<Dafny.ISequence<byte>> plaintextDataKey, Wrappers_Compile.Option<Dafny.ISequence<byte>> verificationKey) {
      this.algorithmSuiteID = algorithmSuiteID;
      this.encryptionContext = encryptionContext;
      this.plaintextDataKey = plaintextDataKey;
      this.verificationKey = verificationKey;
    }
    public override bool Equals(object other) {
      var oth = other as Materials.DecryptionMaterials;
      return oth != null && this.algorithmSuiteID == oth.algorithmSuiteID && object.Equals(this.encryptionContext, oth.encryptionContext) && object.Equals(this.plaintextDataKey, oth.plaintextDataKey) && object.Equals(this.verificationKey, oth.verificationKey);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.algorithmSuiteID));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.encryptionContext));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.plaintextDataKey));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.verificationKey));
      return (int) hash;
    }
    public override string ToString() {
      string s = "Materials_Compile.DecryptionMaterials.DecryptionMaterials";
      s += "(";
      s += Dafny.Helpers.ToString(this.algorithmSuiteID);
      s += ", ";
      s += Dafny.Helpers.ToString(this.encryptionContext);
      s += ", ";
      s += Dafny.Helpers.ToString(this.plaintextDataKey);
      s += ", ";
      s += Dafny.Helpers.ToString(this.verificationKey);
      s += ")";
      return s;
    }
    private static readonly DecryptionMaterials theDefault = create(AlgorithmSuite.ID.Witness, Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Empty, Wrappers_Compile.Option<Dafny.ISequence<byte>>.Default(), Wrappers_Compile.Option<Dafny.ISequence<byte>>.Default());
    public static DecryptionMaterials Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<Materials.DecryptionMaterials> _TYPE = new Dafny.TypeDescriptor<Materials.DecryptionMaterials>(Materials.DecryptionMaterials.Default());
    public static Dafny.TypeDescriptor<Materials.DecryptionMaterials> _TypeDescriptor() {
      return _TYPE;
    }
    public static DecryptionMaterials create(ushort algorithmSuiteID, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext, Wrappers_Compile.Option<Dafny.ISequence<byte>> plaintextDataKey, Wrappers_Compile.Option<Dafny.ISequence<byte>> verificationKey) {
      return new DecryptionMaterials(algorithmSuiteID, encryptionContext, plaintextDataKey, verificationKey);
    }
    public bool is_DecryptionMaterials { get { return true; } }
    public ushort dtor_algorithmSuiteID {
      get {
        return this.algorithmSuiteID;
      }
    }
    public Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> dtor_encryptionContext {
      get {
        return this.encryptionContext;
      }
    }
    public Wrappers_Compile.Option<Dafny.ISequence<byte>> dtor_plaintextDataKey {
      get {
        return this.plaintextDataKey;
      }
    }
    public Wrappers_Compile.Option<Dafny.ISequence<byte>> dtor_verificationKey {
      get {
        return this.verificationKey;
      }
    }
    public static Materials.DecryptionMaterials ValidWitness() {
      return @Materials.DecryptionMaterials.create(AlgorithmSuite.__default.AES__256__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384, Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.FromElements(), @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(((System.Func<Dafny.ISequence<byte>>) (() => {
  BigInteger dim4 = new BigInteger(32);
  var arr4 = new byte[Dafny.Helpers.ToIntChecked(dim4,"C# array size must not be larger than max 32-bit int")];
  for (int i4 = 0; i4 < dim4; i4++) {
    var _20824_i = (BigInteger) i4;
    arr4[(int)(_20824_i)] = 0;
  }
  return Dafny.Sequence<byte>.FromArray(arr4);
}))()), @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(((System.Func<Dafny.ISequence<byte>>) (() => {
  BigInteger dim5 = new BigInteger(32);
  var arr5 = new byte[Dafny.Helpers.ToIntChecked(dim5,"C# array size must not be larger than max 32-bit int")];
  for (int i5 = 0; i5 < dim5; i5++) {
    var _20825_i = (BigInteger) i5;
    arr5[(int)(_20825_i)] = 0;
  }
  return Dafny.Sequence<byte>.FromArray(arr5);
}))()));
    }
    public static Materials.DecryptionMaterials WithoutPlaintextDataKey(Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext, ushort algorithmSuiteID, Wrappers_Compile.Option<Dafny.ISequence<byte>> verificationKey)
    {
      Materials.DecryptionMaterials _20826_m = @Materials.DecryptionMaterials.create(algorithmSuiteID, encryptionContext, @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_None(), verificationKey);
      return _20826_m;
    }
    public Materials.DecryptionMaterials WithPlaintextDataKey(Dafny.ISequence<byte> plaintextDataKey) {
      Materials.DecryptionMaterials _20827_m = Dafny.Helpers.Let<Materials.DecryptionMaterials, Materials.DecryptionMaterials>(this, _pat_let4_0 => Dafny.Helpers.Let<Materials.DecryptionMaterials, Materials.DecryptionMaterials>(_pat_let4_0, _20828_dt__update__tmp_h0 => Dafny.Helpers.Let<Wrappers_Compile.Option<Dafny.ISequence<byte>>, Materials.DecryptionMaterials>(@Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(plaintextDataKey), _pat_let5_0 => Dafny.Helpers.Let<Wrappers_Compile.Option<Dafny.ISequence<byte>>, Materials.DecryptionMaterials>(_pat_let5_0, _20829_dt__update_hplaintextDataKey_h0 => @Materials.DecryptionMaterials.create((_20828_dt__update__tmp_h0).dtor_algorithmSuiteID, (_20828_dt__update__tmp_h0).dtor_encryptionContext, _20829_dt__update_hplaintextDataKey_h0, (_20828_dt__update__tmp_h0).dtor_verificationKey)))));
      return _20827_m;
    }
  }

  public partial class PendingDecryptionMaterials {
    private static readonly Dafny.TypeDescriptor<Materials.DecryptionMaterials> _TYPE = new Dafny.TypeDescriptor<Materials.DecryptionMaterials>(Materials.DecryptionMaterials.Default());
    public static Dafny.TypeDescriptor<Materials.DecryptionMaterials> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public partial class CompleteDecryptionMaterials {
    private static readonly Dafny.TypeDescriptor<Materials.DecryptionMaterials> _TYPE = new Dafny.TypeDescriptor<Materials.DecryptionMaterials>(Materials.DecryptionMaterials.Default());
    public static Dafny.TypeDescriptor<Materials.DecryptionMaterials> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public partial class ValidDecryptionMaterials {
    private static readonly Materials.DecryptionMaterials Witness = Materials.DecryptionMaterials.ValidWitness();
    public static Materials.DecryptionMaterials Default() {
      return Witness;
    }
    private static readonly Dafny.TypeDescriptor<Materials.DecryptionMaterials> _TYPE = new Dafny.TypeDescriptor<Materials.DecryptionMaterials>(Materials.ValidDecryptionMaterials.Default());
    public static Dafny.TypeDescriptor<Materials.DecryptionMaterials> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public class EncryptionMaterialsRequest {
    public readonly Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext;
    public readonly Wrappers_Compile.Option<ushort> algorithmSuiteID;
    public readonly Wrappers_Compile.Option<BigInteger> plaintextLength;
    public EncryptionMaterialsRequest(Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext, Wrappers_Compile.Option<ushort> algorithmSuiteID, Wrappers_Compile.Option<BigInteger> plaintextLength) {
      this.encryptionContext = encryptionContext;
      this.algorithmSuiteID = algorithmSuiteID;
      this.plaintextLength = plaintextLength;
    }
    public override bool Equals(object other) {
      var oth = other as Materials.EncryptionMaterialsRequest;
      return oth != null && object.Equals(this.encryptionContext, oth.encryptionContext) && object.Equals(this.algorithmSuiteID, oth.algorithmSuiteID) && object.Equals(this.plaintextLength, oth.plaintextLength);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.encryptionContext));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.algorithmSuiteID));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.plaintextLength));
      return (int) hash;
    }
    public override string ToString() {
      string s = "Materials_Compile.EncryptionMaterialsRequest.EncryptionMaterialsRequest";
      s += "(";
      s += Dafny.Helpers.ToString(this.encryptionContext);
      s += ", ";
      s += Dafny.Helpers.ToString(this.algorithmSuiteID);
      s += ", ";
      s += Dafny.Helpers.ToString(this.plaintextLength);
      s += ")";
      return s;
    }
    private static readonly EncryptionMaterialsRequest theDefault = create(Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Empty, Wrappers_Compile.Option<ushort>.Default(), Wrappers_Compile.Option<BigInteger>.Default());
    public static EncryptionMaterialsRequest Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<Materials.EncryptionMaterialsRequest> _TYPE = new Dafny.TypeDescriptor<Materials.EncryptionMaterialsRequest>(Materials.EncryptionMaterialsRequest.Default());
    public static Dafny.TypeDescriptor<Materials.EncryptionMaterialsRequest> _TypeDescriptor() {
      return _TYPE;
    }
    public static EncryptionMaterialsRequest create(Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext, Wrappers_Compile.Option<ushort> algorithmSuiteID, Wrappers_Compile.Option<BigInteger> plaintextLength) {
      return new EncryptionMaterialsRequest(encryptionContext, algorithmSuiteID, plaintextLength);
    }
    public bool is_EncryptionMaterialsRequest { get { return true; } }
    public Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> dtor_encryptionContext {
      get {
        return this.encryptionContext;
      }
    }
    public Wrappers_Compile.Option<ushort> dtor_algorithmSuiteID {
      get {
        return this.algorithmSuiteID;
      }
    }
    public Wrappers_Compile.Option<BigInteger> dtor_plaintextLength {
      get {
        return this.plaintextLength;
      }
    }
  }

  public class DecryptionMaterialsRequest {
    public readonly ushort algorithmSuiteID;
    public readonly Dafny.ISequence<Materials.EncryptedDataKey> encryptedDataKeys;
    public readonly Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext;
    public DecryptionMaterialsRequest(ushort algorithmSuiteID, Dafny.ISequence<Materials.EncryptedDataKey> encryptedDataKeys, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext) {
      this.algorithmSuiteID = algorithmSuiteID;
      this.encryptedDataKeys = encryptedDataKeys;
      this.encryptionContext = encryptionContext;
    }
    public override bool Equals(object other) {
      var oth = other as Materials.DecryptionMaterialsRequest;
      return oth != null && this.algorithmSuiteID == oth.algorithmSuiteID && object.Equals(this.encryptedDataKeys, oth.encryptedDataKeys) && object.Equals(this.encryptionContext, oth.encryptionContext);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.algorithmSuiteID));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.encryptedDataKeys));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.encryptionContext));
      return (int) hash;
    }
    public override string ToString() {
      string s = "Materials_Compile.DecryptionMaterialsRequest.DecryptionMaterialsRequest";
      s += "(";
      s += Dafny.Helpers.ToString(this.algorithmSuiteID);
      s += ", ";
      s += Dafny.Helpers.ToString(this.encryptedDataKeys);
      s += ", ";
      s += Dafny.Helpers.ToString(this.encryptionContext);
      s += ")";
      return s;
    }
    private static readonly DecryptionMaterialsRequest theDefault = create(AlgorithmSuite.ID.Witness, Dafny.Sequence<Materials.EncryptedDataKey>.Empty, Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Empty);
    public static DecryptionMaterialsRequest Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<Materials.DecryptionMaterialsRequest> _TYPE = new Dafny.TypeDescriptor<Materials.DecryptionMaterialsRequest>(Materials.DecryptionMaterialsRequest.Default());
    public static Dafny.TypeDescriptor<Materials.DecryptionMaterialsRequest> _TypeDescriptor() {
      return _TYPE;
    }
    public static DecryptionMaterialsRequest create(ushort algorithmSuiteID, Dafny.ISequence<Materials.EncryptedDataKey> encryptedDataKeys, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext) {
      return new DecryptionMaterialsRequest(algorithmSuiteID, encryptedDataKeys, encryptionContext);
    }
    public bool is_DecryptionMaterialsRequest { get { return true; } }
    public ushort dtor_algorithmSuiteID {
      get {
        return this.algorithmSuiteID;
      }
    }
    public Dafny.ISequence<Materials.EncryptedDataKey> dtor_encryptedDataKeys {
      get {
        return this.encryptedDataKeys;
      }
    }
    public Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> dtor_encryptionContext {
      get {
        return this.encryptionContext;
      }
    }
    public static Materials.DecryptionMaterialsRequest ValidWitness() {
      return @Materials.DecryptionMaterialsRequest.create(AlgorithmSuite.__default.AES__256__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384, Dafny.Sequence<Materials.EncryptedDataKey>.FromElements(Materials.EncryptedDataKey.ValidWitness()), Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.FromElements());
    }
  }

  public partial class ValidDecryptionMaterialsRequest {
    private static readonly Materials.DecryptionMaterialsRequest Witness = Materials.DecryptionMaterialsRequest.ValidWitness();
    public static Materials.DecryptionMaterialsRequest Default() {
      return Witness;
    }
    private static readonly Dafny.TypeDescriptor<Materials.DecryptionMaterialsRequest> _TYPE = new Dafny.TypeDescriptor<Materials.DecryptionMaterialsRequest>(Materials.ValidDecryptionMaterialsRequest.Default());
    public static Dafny.TypeDescriptor<Materials.DecryptionMaterialsRequest> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public partial class __default {
    public static Dafny.ISequence<byte> EC__PUBLIC__KEY__FIELD { get {
      Dafny.ISequence<byte> _20830_s = Dafny.Sequence<byte>.FromElements(97, 119, 115, 45, 99, 114, 121, 112, 116, 111, 45, 112, 117, 98, 108, 105, 99, 45, 107, 101, 121);
      return _20830_s;
    } }
    public static Dafny.ISet<Dafny.ISequence<byte>> RESERVED__KEY__VALUES { get {
      return Dafny.Set<Dafny.ISequence<byte>>.FromElements(Materials.__default.EC__PUBLIC__KEY__FIELD);
    } }
  }
} // end of namespace Materials
namespace CMMDefs {







  public interface CMM {
    Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>> GetEncryptionMaterials(Materials.EncryptionMaterialsRequest materialsRequest);
    Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>> DecryptMaterials(Materials.DecryptionMaterialsRequest materialsRequest);
  }
  public class _Companion_CMM {
  }

} // end of namespace CMMDefs
namespace KeyringDefs {





  public interface Keyring {
    Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>> OnEncrypt(Materials.EncryptionMaterials materials);
    Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>> OnDecrypt(Materials.DecryptionMaterials materials, Dafny.ISequence<Materials.EncryptedDataKey> encryptedDataKeys);
  }
  public class _Companion_Keyring {
  }

} // end of namespace KeyringDefs
namespace Base64_Compile {



  public partial class index {
    public static System.Collections.Generic.IEnumerable<byte> IntegerRange(BigInteger lo, BigInteger hi) {
      for (var j = lo; j < hi; j++) { yield return (byte)j; }
    }
    private static readonly Dafny.TypeDescriptor<byte> _TYPE = new Dafny.TypeDescriptor<byte>(0);
    public static Dafny.TypeDescriptor<byte> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public partial class uint24 {
    public static System.Collections.Generic.IEnumerable<uint> IntegerRange(BigInteger lo, BigInteger hi) {
      for (var j = lo; j < hi; j++) { yield return (uint)j; }
    }
    private static readonly Dafny.TypeDescriptor<uint> _TYPE = new Dafny.TypeDescriptor<uint>(0);
    public static Dafny.TypeDescriptor<uint> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public partial class __default {
    public static bool IsBase64Char(char c) {
      return (((((c) == ('+')) || ((c) == ('/'))) || ((('0') <= (c)) && ((c) <= ('9')))) || ((('A') <= (c)) && ((c) <= ('Z')))) || ((('a') <= (c)) && ((c) <= ('z')));
    }
    public static bool IsUnpaddedBase64String(Dafny.ISequence<char> s) {
      return ((Dafny.Helpers.EuclideanModulus(new BigInteger((s).Count), new BigInteger(4))).Sign == 0) && (Dafny.Helpers.Id<Func<Dafny.ISequence<char>, bool>>((_20831_s) => Dafny.Helpers.Quantifier<char>((_20831_s).UniqueElements, true, (((_20832_k) => {
        return !((_20831_s).Contains((_20832_k))) || (Base64_Compile.__default.IsBase64Char(_20832_k));
      }))))(s));
    }
    public static char IndexToChar(byte i) {
      if ((i) == (63)) {
        return '/';
      } else if ((i) == (62)) {
        return '+';
      } else if (((52) <= (i)) && ((i) <= (61))) {
        return (char)((byte)((i) - (4)));
      } else if (((26) <= (i)) && ((i) <= (51))) {
        return (char)(((char)(i)) + ((char)(new BigInteger(71))));
      } else {
        return (char)(((char)(i)) + ((char)(new BigInteger(65))));
      }
    }
    public static byte CharToIndex(char c) {
      if ((c) == ('/')) {
        return 63;
      } else if ((c) == ('+')) {
        return 62;
      } else if ((('0') <= (c)) && ((c) <= ('9'))) {
        return (byte)((char)((c) + ((char)(new BigInteger(4)))));
      } else if ((('a') <= (c)) && ((c) <= ('z'))) {
        return (byte)((char)((c) - ((char)(new BigInteger(71)))));
      } else {
        return (byte)((char)((c) - ((char)(new BigInteger(65)))));
      }
    }
    public static Dafny.ISequence<byte> UInt24ToSeq(uint x) {
      byte _20833_b0 = (byte)((x) / (65536U));
      uint _20834_x0 = (x) - (((uint)(_20833_b0)) * (65536U));
      byte _20835_b1 = (byte)((_20834_x0) / (256U));
      byte _20836_b2 = (byte)((_20834_x0) % (256U));
      return Dafny.Sequence<byte>.FromElements(_20833_b0, _20835_b1, _20836_b2);
    }
    public static uint SeqToUInt24(Dafny.ISequence<byte> s) {
      return ((((uint)((s).Select(BigInteger.Zero))) * (65536U)) + (((uint)((s).Select(BigInteger.One))) * (256U))) + ((uint)((s).Select(new BigInteger(2))));
    }
    public static Dafny.ISequence<byte> UInt24ToIndexSeq(uint x) {
      byte _20837_b0 = (byte)((x) / (262144U));
      uint _20838_x0 = (x) - (((uint)(_20837_b0)) * (262144U));
      byte _20839_b1 = (byte)((_20838_x0) / (4096U));
      uint _20840_x1 = (_20838_x0) - (((uint)(_20839_b1)) * (4096U));
      byte _20841_b2 = (byte)((_20840_x1) / (64U));
      byte _20842_b3 = (byte)((_20840_x1) % (64U));
      return Dafny.Sequence<byte>.FromElements(_20837_b0, _20839_b1, _20841_b2, _20842_b3);
    }
    public static uint IndexSeqToUInt24(Dafny.ISequence<byte> s) {
      return (((((uint)((s).Select(BigInteger.Zero))) * (262144U)) + (((uint)((s).Select(BigInteger.One))) * (4096U))) + (((uint)((s).Select(new BigInteger(2)))) * (64U))) + ((uint)((s).Select(new BigInteger(3))));
    }
    public static Dafny.ISequence<byte> DecodeBlock(Dafny.ISequence<byte> s) {
      return Base64_Compile.__default.UInt24ToSeq(Base64_Compile.__default.IndexSeqToUInt24(s));
    }
    public static Dafny.ISequence<byte> EncodeBlock(Dafny.ISequence<byte> s) {
      return Base64_Compile.__default.UInt24ToIndexSeq(Base64_Compile.__default.SeqToUInt24(s));
    }
    public static Dafny.ISequence<byte> DecodeRecursively(Dafny.ISequence<byte> s) {
      Dafny.ISequence<byte> _20843___accumulator = Dafny.Sequence<byte>.FromElements();
    TAIL_CALL_START: ;
      if ((new BigInteger((s).Count)).Sign == 0) {
        return Dafny.Sequence<byte>.Concat(_20843___accumulator, Dafny.Sequence<byte>.FromElements());
      } else {
        _20843___accumulator = Dafny.Sequence<byte>.Concat(_20843___accumulator, Base64_Compile.__default.DecodeBlock((s).Take(new BigInteger(4))));
        Dafny.ISequence<byte> _in33 = (s).Drop(new BigInteger(4));
        s = _in33;
        goto TAIL_CALL_START;
      }
    }
    public static Dafny.ISequence<byte> EncodeRecursively(Dafny.ISequence<byte> b) {
      Dafny.ISequence<byte> _20844___accumulator = Dafny.Sequence<byte>.FromElements();
    TAIL_CALL_START: ;
      if ((new BigInteger((b).Count)).Sign == 0) {
        return Dafny.Sequence<byte>.Concat(_20844___accumulator, Dafny.Sequence<byte>.FromElements());
      } else {
        _20844___accumulator = Dafny.Sequence<byte>.Concat(_20844___accumulator, Base64_Compile.__default.EncodeBlock((b).Take(new BigInteger(3))));
        Dafny.ISequence<byte> _in34 = (b).Drop(new BigInteger(3));
        b = _in34;
        goto TAIL_CALL_START;
      }
    }
    public static Dafny.ISequence<byte> FromCharsToIndices(Dafny.ISequence<char> s) {
      return ((System.Func<Dafny.ISequence<byte>>) (() => {
        BigInteger dim6 = new BigInteger((s).Count);
        var arr6 = new byte[Dafny.Helpers.ToIntChecked(dim6,"C# array size must not be larger than max 32-bit int")];
        for (int i6 = 0; i6 < dim6; i6++) {
          var _20845_i = (BigInteger) i6;
          arr6[(int)(_20845_i)] = Base64_Compile.__default.CharToIndex((s).Select(_20845_i));
        }
        return Dafny.Sequence<byte>.FromArray(arr6);
      }))();
    }
    public static Dafny.ISequence<char> FromIndicesToChars(Dafny.ISequence<byte> b) {
      return ((System.Func<Dafny.ISequence<char>>) (() => {
        BigInteger dim7 = new BigInteger((b).Count);
        var arr7 = new char[Dafny.Helpers.ToIntChecked(dim7,"C# array size must not be larger than max 32-bit int")];
        for (int i7 = 0; i7 < dim7; i7++) {
          var _20846_i = (BigInteger) i7;
          arr7[(int)(_20846_i)] = Base64_Compile.__default.IndexToChar((b).Select(_20846_i));
        }
        return Dafny.Sequence<char>.FromArray(arr7);
      }))();
    }
    public static Dafny.ISequence<byte> DecodeUnpadded(Dafny.ISequence<char> s) {
      return Base64_Compile.__default.DecodeRecursively(Base64_Compile.__default.FromCharsToIndices(s));
    }
    public static Dafny.ISequence<char> EncodeUnpadded(Dafny.ISequence<byte> b) {
      return Base64_Compile.__default.FromIndicesToChars(Base64_Compile.__default.EncodeRecursively(b));
    }
    public static bool Is1Padding(Dafny.ISequence<char> s) {
      return ((((((new BigInteger((s).Count)) == (new BigInteger(4))) && (Base64_Compile.__default.IsBase64Char((s).Select(BigInteger.Zero)))) && (Base64_Compile.__default.IsBase64Char((s).Select(BigInteger.One)))) && (Base64_Compile.__default.IsBase64Char((s).Select(new BigInteger(2))))) && (((byte)((Base64_Compile.__default.CharToIndex((s).Select(new BigInteger(2)))) % (4))) == (0))) && (((s).Select(new BigInteger(3))) == ('='));
    }
    public static Dafny.ISequence<byte> Decode1Padding(Dafny.ISequence<char> s) {
      Dafny.ISequence<byte> _20847_d = Base64_Compile.__default.DecodeBlock(Dafny.Sequence<byte>.FromElements(Base64_Compile.__default.CharToIndex((s).Select(BigInteger.Zero)), Base64_Compile.__default.CharToIndex((s).Select(BigInteger.One)), Base64_Compile.__default.CharToIndex((s).Select(new BigInteger(2))), 0));
      return Dafny.Sequence<byte>.FromElements((_20847_d).Select(BigInteger.Zero), (_20847_d).Select(BigInteger.One));
    }
    public static Dafny.ISequence<char> Encode1Padding(Dafny.ISequence<byte> b) {
      Dafny.ISequence<byte> _20848_e = Base64_Compile.__default.EncodeBlock(Dafny.Sequence<byte>.FromElements((b).Select(BigInteger.Zero), (b).Select(BigInteger.One), 0));
      return Dafny.Sequence<char>.FromElements(Base64_Compile.__default.IndexToChar((_20848_e).Select(BigInteger.Zero)), Base64_Compile.__default.IndexToChar((_20848_e).Select(BigInteger.One)), Base64_Compile.__default.IndexToChar((_20848_e).Select(new BigInteger(2))), '=');
    }
    public static bool Is2Padding(Dafny.ISequence<char> s) {
      return ((((((new BigInteger((s).Count)) == (new BigInteger(4))) && (Base64_Compile.__default.IsBase64Char((s).Select(BigInteger.Zero)))) && (Base64_Compile.__default.IsBase64Char((s).Select(BigInteger.One)))) && (((byte)((Base64_Compile.__default.CharToIndex((s).Select(BigInteger.One))) % (16))) == (0))) && (((s).Select(new BigInteger(2))) == ('='))) && (((s).Select(new BigInteger(3))) == ('='));
    }
    public static Dafny.ISequence<byte> Decode2Padding(Dafny.ISequence<char> s) {
      Dafny.ISequence<byte> _20849_d = Base64_Compile.__default.DecodeBlock(Dafny.Sequence<byte>.FromElements(Base64_Compile.__default.CharToIndex((s).Select(BigInteger.Zero)), Base64_Compile.__default.CharToIndex((s).Select(BigInteger.One)), 0, 0));
      return Dafny.Sequence<byte>.FromElements((_20849_d).Select(BigInteger.Zero));
    }
    public static Dafny.ISequence<char> Encode2Padding(Dafny.ISequence<byte> b) {
      Dafny.ISequence<byte> _20850_e = Base64_Compile.__default.EncodeBlock(Dafny.Sequence<byte>.FromElements((b).Select(BigInteger.Zero), 0, 0));
      return Dafny.Sequence<char>.FromElements(Base64_Compile.__default.IndexToChar((_20850_e).Select(BigInteger.Zero)), Base64_Compile.__default.IndexToChar((_20850_e).Select(BigInteger.One)), '=', '=');
    }
    public static bool IsBase64String(Dafny.ISequence<char> s) {
      BigInteger _20851_finalBlockStart = (new BigInteger((s).Count)) - (new BigInteger(4));
      return ((Dafny.Helpers.EuclideanModulus(new BigInteger((s).Count), new BigInteger(4))).Sign == 0) && ((Base64_Compile.__default.IsUnpaddedBase64String(s)) || ((Base64_Compile.__default.IsUnpaddedBase64String((s).Take(_20851_finalBlockStart))) && ((Base64_Compile.__default.Is1Padding((s).Drop(_20851_finalBlockStart))) || (Base64_Compile.__default.Is2Padding((s).Drop(_20851_finalBlockStart))))));
    }
    public static Dafny.ISequence<byte> DecodeValid(Dafny.ISequence<char> s) {
      if ((s).Equals((Dafny.Sequence<char>.FromElements()))) {
        return Dafny.Sequence<byte>.FromElements();
      } else {
        BigInteger _20852_finalBlockStart = (new BigInteger((s).Count)) - (new BigInteger(4));
        Dafny.ISequence<char> _20853_prefix = (s).Take(_20852_finalBlockStart);
        Dafny.ISequence<char> _20854_suffix = (s).Drop(_20852_finalBlockStart);
        if (Base64_Compile.__default.Is1Padding(_20854_suffix)) {
          return Dafny.Sequence<byte>.Concat(Base64_Compile.__default.DecodeUnpadded(_20853_prefix), Base64_Compile.__default.Decode1Padding(_20854_suffix));
        } else if (Base64_Compile.__default.Is2Padding(_20854_suffix)) {
          return Dafny.Sequence<byte>.Concat(Base64_Compile.__default.DecodeUnpadded(_20853_prefix), Base64_Compile.__default.Decode2Padding(_20854_suffix));
        } else {
          return Base64_Compile.__default.DecodeUnpadded(s);
        }
      }
    }
    public static Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> Decode(Dafny.ISequence<char> s) {
      if (Base64_Compile.__default.IsBase64String(s)) {
        return @Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.create_Success(Base64_Compile.__default.DecodeValid(s));
      } else {
        return @Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("The encoding is malformed"));
      }
    }
    public static Dafny.ISequence<char> Encode(Dafny.ISequence<byte> b) {
      if ((Dafny.Helpers.EuclideanModulus(new BigInteger((b).Count), new BigInteger(3))).Sign == 0) {
        return Base64_Compile.__default.EncodeUnpadded(b);
      } else if ((Dafny.Helpers.EuclideanModulus(new BigInteger((b).Count), new BigInteger(3))) == (BigInteger.One)) {
        return Dafny.Sequence<char>.Concat(Base64_Compile.__default.EncodeUnpadded((b).Take((new BigInteger((b).Count)) - (BigInteger.One))), Base64_Compile.__default.Encode2Padding((b).Drop((new BigInteger((b).Count)) - (BigInteger.One))));
      } else {
        return Dafny.Sequence<char>.Concat(Base64_Compile.__default.EncodeUnpadded((b).Take((new BigInteger((b).Count)) - (new BigInteger(2)))), Base64_Compile.__default.Encode1Padding((b).Drop((new BigInteger((b).Count)) - (new BigInteger(2)))));
      }
    }
  }
} // end of namespace Base64_Compile
namespace MessageHeader {









  public class Header {
    public readonly MessageHeader.HeaderBody body;
    public readonly MessageHeader.HeaderAuthentication auth;
    public Header(MessageHeader.HeaderBody body, MessageHeader.HeaderAuthentication auth) {
      this.body = body;
      this.auth = auth;
    }
    public override bool Equals(object other) {
      var oth = other as MessageHeader.Header;
      return oth != null && object.Equals(this.body, oth.body) && object.Equals(this.auth, oth.auth);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.body));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.auth));
      return (int) hash;
    }
    public override string ToString() {
      string s = "MessageHeader_Compile.Header.Header";
      s += "(";
      s += Dafny.Helpers.ToString(this.body);
      s += ", ";
      s += Dafny.Helpers.ToString(this.auth);
      s += ")";
      return s;
    }
    private static readonly Header theDefault = create(MessageHeader.HeaderBody.Default(), MessageHeader.HeaderAuthentication.Default());
    public static Header Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<MessageHeader.Header> _TYPE = new Dafny.TypeDescriptor<MessageHeader.Header>(MessageHeader.Header.Default());
    public static Dafny.TypeDescriptor<MessageHeader.Header> _TypeDescriptor() {
      return _TYPE;
    }
    public static Header create(MessageHeader.HeaderBody body, MessageHeader.HeaderAuthentication auth) {
      return new Header(body, auth);
    }
    public bool is_Header { get { return true; } }
    public MessageHeader.HeaderBody dtor_body {
      get {
        return this.body;
      }
    }
    public MessageHeader.HeaderAuthentication dtor_auth {
      get {
        return this.auth;
      }
    }
  }

  public partial class Version {
    private static readonly byte Witness = MessageHeader.__default.VERSION__1;
    public static byte Default() {
      return Witness;
    }
    private static readonly Dafny.TypeDescriptor<byte> _TYPE = new Dafny.TypeDescriptor<byte>(MessageHeader.Version.Default());
    public static Dafny.TypeDescriptor<byte> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public partial class Type {
    private static readonly byte Witness = MessageHeader.__default.TYPE__CUSTOMER__AED;
    public static byte Default() {
      return Witness;
    }
    private static readonly Dafny.TypeDescriptor<byte> _TYPE = new Dafny.TypeDescriptor<byte>(MessageHeader.Type.Default());
    public static Dafny.TypeDescriptor<byte> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public partial class MessageID {
    private static readonly Dafny.ISequence<byte> Witness = Dafny.Sequence<byte>.FromElements(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    public static Dafny.ISequence<byte> Default() {
      return Witness;
    }
    private static readonly Dafny.TypeDescriptor<Dafny.ISequence<byte>> _TYPE = new Dafny.TypeDescriptor<Dafny.ISequence<byte>>(MessageHeader.MessageID.Default());
    public static Dafny.TypeDescriptor<Dafny.ISequence<byte>> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public abstract class ContentType {
    public ContentType() { }
    private static readonly ContentType theDefault = create_NonFramed();
    public static ContentType Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<MessageHeader.ContentType> _TYPE = new Dafny.TypeDescriptor<MessageHeader.ContentType>(MessageHeader.ContentType.Default());
    public static Dafny.TypeDescriptor<MessageHeader.ContentType> _TypeDescriptor() {
      return _TYPE;
    }
    public static ContentType create_NonFramed() {
      return new ContentType_NonFramed();
    }
    public static ContentType create_Framed() {
      return new ContentType_Framed();
    }
    public bool is_NonFramed { get { return this is ContentType_NonFramed; } }
    public bool is_Framed { get { return this is ContentType_Framed; } }
    public static System.Collections.Generic.IEnumerable<ContentType> AllSingletonConstructors {
      get {
        yield return ContentType.create_NonFramed();
        yield return ContentType.create_Framed();
      }
    }
  }
  public class ContentType_NonFramed : ContentType {
    public ContentType_NonFramed() {
    }
    public override bool Equals(object other) {
      var oth = other as MessageHeader.ContentType_NonFramed;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      return (int) hash;
    }
    public override string ToString() {
      string s = "MessageHeader_Compile.ContentType.NonFramed";
      return s;
    }
  }
  public class ContentType_Framed : ContentType {
    public ContentType_Framed() {
    }
    public override bool Equals(object other) {
      var oth = other as MessageHeader.ContentType_Framed;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      return (int) hash;
    }
    public override string ToString() {
      string s = "MessageHeader_Compile.ContentType.Framed";
      return s;
    }
  }

  public class EncryptedDataKeys {
    public readonly Dafny.ISequence<Materials.EncryptedDataKey> entries;
    public EncryptedDataKeys(Dafny.ISequence<Materials.EncryptedDataKey> entries) {
      this.entries = entries;
    }
    public override bool Equals(object other) {
      var oth = other as MessageHeader.EncryptedDataKeys;
      return oth != null && object.Equals(this.entries, oth.entries);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.entries));
      return (int) hash;
    }
    public override string ToString() {
      string s = "MessageHeader_Compile.EncryptedDataKeys.EncryptedDataKeys";
      s += "(";
      s += Dafny.Helpers.ToString(this.entries);
      s += ")";
      return s;
    }
    private static readonly EncryptedDataKeys theDefault = create(Dafny.Sequence<Materials.EncryptedDataKey>.Empty);
    public static EncryptedDataKeys Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<MessageHeader.EncryptedDataKeys> _TYPE = new Dafny.TypeDescriptor<MessageHeader.EncryptedDataKeys>(MessageHeader.EncryptedDataKeys.Default());
    public static Dafny.TypeDescriptor<MessageHeader.EncryptedDataKeys> _TypeDescriptor() {
      return _TYPE;
    }
    public static EncryptedDataKeys create(Dafny.ISequence<Materials.EncryptedDataKey> entries) {
      return new EncryptedDataKeys(entries);
    }
    public bool is_EncryptedDataKeys { get { return true; } }
    public Dafny.ISequence<Materials.EncryptedDataKey> dtor_entries {
      get {
        return this.entries;
      }
    }
  }

  public class HeaderBody {
    public readonly byte version;
    public readonly byte typ;
    public readonly ushort algorithmSuiteID;
    public readonly Dafny.ISequence<byte> messageID;
    public readonly Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> aad;
    public readonly MessageHeader.EncryptedDataKeys encryptedDataKeys;
    public readonly MessageHeader.ContentType contentType;
    public readonly byte ivLength;
    public readonly uint frameLength;
    public HeaderBody(byte version, byte typ, ushort algorithmSuiteID, Dafny.ISequence<byte> messageID, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> aad, MessageHeader.EncryptedDataKeys encryptedDataKeys, MessageHeader.ContentType contentType, byte ivLength, uint frameLength) {
      this.version = version;
      this.typ = typ;
      this.algorithmSuiteID = algorithmSuiteID;
      this.messageID = messageID;
      this.aad = aad;
      this.encryptedDataKeys = encryptedDataKeys;
      this.contentType = contentType;
      this.ivLength = ivLength;
      this.frameLength = frameLength;
    }
    public override bool Equals(object other) {
      var oth = other as MessageHeader.HeaderBody;
      return oth != null && this.version == oth.version && this.typ == oth.typ && this.algorithmSuiteID == oth.algorithmSuiteID && object.Equals(this.messageID, oth.messageID) && object.Equals(this.aad, oth.aad) && object.Equals(this.encryptedDataKeys, oth.encryptedDataKeys) && object.Equals(this.contentType, oth.contentType) && this.ivLength == oth.ivLength && this.frameLength == oth.frameLength;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.version));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.typ));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.algorithmSuiteID));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.messageID));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.aad));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.encryptedDataKeys));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.contentType));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.ivLength));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.frameLength));
      return (int) hash;
    }
    public override string ToString() {
      string s = "MessageHeader_Compile.HeaderBody.HeaderBody";
      s += "(";
      s += Dafny.Helpers.ToString(this.version);
      s += ", ";
      s += Dafny.Helpers.ToString(this.typ);
      s += ", ";
      s += Dafny.Helpers.ToString(this.algorithmSuiteID);
      s += ", ";
      s += Dafny.Helpers.ToString(this.messageID);
      s += ", ";
      s += Dafny.Helpers.ToString(this.aad);
      s += ", ";
      s += Dafny.Helpers.ToString(this.encryptedDataKeys);
      s += ", ";
      s += Dafny.Helpers.ToString(this.contentType);
      s += ", ";
      s += Dafny.Helpers.ToString(this.ivLength);
      s += ", ";
      s += Dafny.Helpers.ToString(this.frameLength);
      s += ")";
      return s;
    }
    private static readonly HeaderBody theDefault = create(MessageHeader.Version.Default(), MessageHeader.Type.Default(), AlgorithmSuite.ID.Witness, MessageHeader.MessageID.Default(), Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Empty, MessageHeader.EncryptedDataKeys.Default(), MessageHeader.ContentType.Default(), 0, 0);
    public static HeaderBody Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<MessageHeader.HeaderBody> _TYPE = new Dafny.TypeDescriptor<MessageHeader.HeaderBody>(MessageHeader.HeaderBody.Default());
    public static Dafny.TypeDescriptor<MessageHeader.HeaderBody> _TypeDescriptor() {
      return _TYPE;
    }
    public static HeaderBody create(byte version, byte typ, ushort algorithmSuiteID, Dafny.ISequence<byte> messageID, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> aad, MessageHeader.EncryptedDataKeys encryptedDataKeys, MessageHeader.ContentType contentType, byte ivLength, uint frameLength) {
      return new HeaderBody(version, typ, algorithmSuiteID, messageID, aad, encryptedDataKeys, contentType, ivLength, frameLength);
    }
    public bool is_HeaderBody { get { return true; } }
    public byte dtor_version {
      get {
        return this.version;
      }
    }
    public byte dtor_typ {
      get {
        return this.typ;
      }
    }
    public ushort dtor_algorithmSuiteID {
      get {
        return this.algorithmSuiteID;
      }
    }
    public Dafny.ISequence<byte> dtor_messageID {
      get {
        return this.messageID;
      }
    }
    public Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> dtor_aad {
      get {
        return this.aad;
      }
    }
    public MessageHeader.EncryptedDataKeys dtor_encryptedDataKeys {
      get {
        return this.encryptedDataKeys;
      }
    }
    public MessageHeader.ContentType dtor_contentType {
      get {
        return this.contentType;
      }
    }
    public byte dtor_ivLength {
      get {
        return this.ivLength;
      }
    }
    public uint dtor_frameLength {
      get {
        return this.frameLength;
      }
    }
  }

  public class HeaderAuthentication {
    public readonly Dafny.ISequence<byte> iv;
    public readonly Dafny.ISequence<byte> authenticationTag;
    public HeaderAuthentication(Dafny.ISequence<byte> iv, Dafny.ISequence<byte> authenticationTag) {
      this.iv = iv;
      this.authenticationTag = authenticationTag;
    }
    public override bool Equals(object other) {
      var oth = other as MessageHeader.HeaderAuthentication;
      return oth != null && object.Equals(this.iv, oth.iv) && object.Equals(this.authenticationTag, oth.authenticationTag);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.iv));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.authenticationTag));
      return (int) hash;
    }
    public override string ToString() {
      string s = "MessageHeader_Compile.HeaderAuthentication.HeaderAuthentication";
      s += "(";
      s += Dafny.Helpers.ToString(this.iv);
      s += ", ";
      s += Dafny.Helpers.ToString(this.authenticationTag);
      s += ")";
      return s;
    }
    private static readonly HeaderAuthentication theDefault = create(Dafny.Sequence<byte>.Empty, Dafny.Sequence<byte>.Empty);
    public static HeaderAuthentication Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<MessageHeader.HeaderAuthentication> _TYPE = new Dafny.TypeDescriptor<MessageHeader.HeaderAuthentication>(MessageHeader.HeaderAuthentication.Default());
    public static Dafny.TypeDescriptor<MessageHeader.HeaderAuthentication> _TypeDescriptor() {
      return _TYPE;
    }
    public static HeaderAuthentication create(Dafny.ISequence<byte> iv, Dafny.ISequence<byte> authenticationTag) {
      return new HeaderAuthentication(iv, authenticationTag);
    }
    public bool is_HeaderAuthentication { get { return true; } }
    public Dafny.ISequence<byte> dtor_iv {
      get {
        return this.iv;
      }
    }
    public Dafny.ISequence<byte> dtor_authenticationTag {
      get {
        return this.authenticationTag;
      }
    }
  }

  public partial class __default {
    public static byte ContentTypeToUInt8(MessageHeader.ContentType contentType) {
      MessageHeader.ContentType _source15 = contentType;
      if (_source15.is_NonFramed) {
        return 1;
      } else {
        return 2;
      }
    }
    public static Wrappers_Compile.Option<MessageHeader.ContentType> UInt8ToContentType(byte x) {
      if ((x) == (1)) {
        return @Wrappers_Compile.Option<MessageHeader.ContentType>.create_Some(@MessageHeader.ContentType.create_NonFramed());
      } else if ((x) == (2)) {
        return @Wrappers_Compile.Option<MessageHeader.ContentType>.create_Some(@MessageHeader.ContentType.create_Framed());
      } else {
        return @Wrappers_Compile.Option<MessageHeader.ContentType>.create_None();
      }
    }
    public static Dafny.ISequence<byte> EDKEntryToSeq(Materials.EncryptedDataKey edk) {
      return Dafny.Sequence<byte>.Concat(Dafny.Sequence<byte>.Concat(Dafny.Sequence<byte>.Concat(Dafny.Sequence<byte>.Concat(Dafny.Sequence<byte>.Concat(StandardLibrary_mUInt_Compile.__default.UInt16ToSeq((ushort)((edk).dtor_providerID).Count), (edk).dtor_providerID), StandardLibrary_mUInt_Compile.__default.UInt16ToSeq((ushort)((edk).dtor_providerInfo).Count)), (edk).dtor_providerInfo), StandardLibrary_mUInt_Compile.__default.UInt16ToSeq((ushort)((edk).dtor_ciphertext).Count)), (edk).dtor_ciphertext);
    }
    public static byte VERSION__1 { get {
      return 1;
    } }
    public static byte TYPE__CUSTOMER__AED { get {
      return 128;
    } }
    public static BigInteger MESSAGE__ID__LEN { get {
      return new BigInteger(16);
    } }
    public static Dafny.ISequence<byte> Reserved { get {
      return Dafny.Sequence<byte>.FromElements(0, 0, 0, 0);
    } }
  }
} // end of namespace MessageHeader
namespace Streams_Compile {



  public partial class SeqReader<T> {
    public SeqReader() {
      this.pos = BigInteger.Zero;
      this._data = Dafny.Sequence<T>.Empty;
    }
    public BigInteger pos;public void __ctor(Dafny.ISequence<T> s)
    {
      (this)._data = s;
      (this).pos = BigInteger.Zero;
    }
    public Dafny.ISequence<T> ReadElements(BigInteger n)
    {
      Dafny.ISequence<T> elems = Dafny.Sequence<T>.Empty;
      elems = (((this).data).Drop(this.pos)).Take(n);
      (this).pos = (this.pos) + (n);
      elems = elems;
      return elems;
      return elems;
    }
    public Wrappers_Compile.Result<Dafny.ISequence<T>, Dafny.ISequence<char>> ReadExact(BigInteger n)
    {
      Wrappers_Compile.Result<Dafny.ISequence<T>, Dafny.ISequence<char>> res = Wrappers_Compile.Result<Dafny.ISequence<T>, Dafny.ISequence<char>>.Default(Dafny.Sequence<T>.Empty);
      if ((n) > ((new BigInteger(((this).data).Count)) - (this.pos))) {
        res = @Wrappers_Compile.Result<Dafny.ISequence<T>, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("IO Error: Not enough elements left on stream."));
        return res;
      } else {
        Dafny.ISequence<T> _20855_elements;
        Dafny.ISequence<T> _out16;
        _out16 = (this).ReadElements(n);
        _20855_elements = _out16;
        res = @Wrappers_Compile.Result<Dafny.ISequence<T>, Dafny.ISequence<char>>.create_Success(_20855_elements);
        return res;
      }
      return res;
    }
    public Dafny.ISequence<T> _data;public Dafny.ISequence<T> data { get {
      return this._data;
    } }
  }

  public partial class ByteReader {
    public ByteReader() {
      this._reader = default(Streams_Compile.SeqReader<byte>);
    }
    public void __ctor(Dafny.ISequence<byte> s)
    {
      Streams_Compile.SeqReader<byte> _20856_mr;
      Streams_Compile.SeqReader<byte> _nw5 = new Streams_Compile.SeqReader<byte>();
      _nw5.__ctor(s);
      _20856_mr = _nw5;
      (this)._reader = _20856_mr;
    }
    public Wrappers_Compile.Result<byte, Dafny.ISequence<char>> ReadByte()
    {
      Wrappers_Compile.Result<byte, Dafny.ISequence<char>> res = Wrappers_Compile.Result<byte, Dafny.ISequence<char>>.Default(0);
      Dafny.ISequence<byte> _20857_bytes = Dafny.Sequence<byte>.Empty;
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _20858_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out17;
      _out17 = ((this).reader).ReadExact(BigInteger.One);
      _20858_valueOrError0 = _out17;
      if ((_20858_valueOrError0).IsFailure()) {
        res = (_20858_valueOrError0).PropagateFailure<byte>();
        return res;
      }
      _20857_bytes = (_20858_valueOrError0).Extract();
      res = @Wrappers_Compile.Result<byte, Dafny.ISequence<char>>.create_Success((_20857_bytes).Select(BigInteger.Zero));
      return res;
      return res;
    }
    public Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> ReadBytes(BigInteger n)
    {
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> res = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      Dafny.ISequence<byte> _20859_bytes = Dafny.Sequence<byte>.Empty;
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _20860_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out18;
      _out18 = ((this).reader).ReadExact(n);
      _20860_valueOrError0 = _out18;
      if ((_20860_valueOrError0).IsFailure()) {
        res = (_20860_valueOrError0).PropagateFailure<Dafny.ISequence<byte>>();
        return res;
      }
      _20859_bytes = (_20860_valueOrError0).Extract();
      res = @Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.create_Success(_20859_bytes);
      return res;
      return res;
    }
    public Wrappers_Compile.Result<ushort, Dafny.ISequence<char>> ReadUInt16()
    {
      Wrappers_Compile.Result<ushort, Dafny.ISequence<char>> res = Wrappers_Compile.Result<ushort, Dafny.ISequence<char>>.Default(0);
      Dafny.ISequence<byte> _20861_bytes = Dafny.Sequence<byte>.Empty;
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _20862_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out19;
      _out19 = ((this).reader).ReadExact(new BigInteger(2));
      _20862_valueOrError0 = _out19;
      if ((_20862_valueOrError0).IsFailure()) {
        res = (_20862_valueOrError0).PropagateFailure<ushort>();
        return res;
      }
      _20861_bytes = (_20862_valueOrError0).Extract();
      ushort _20863_n;
      _20863_n = StandardLibrary_mUInt_Compile.__default.SeqToUInt16(_20861_bytes);
      res = @Wrappers_Compile.Result<ushort, Dafny.ISequence<char>>.create_Success(_20863_n);
      return res;
      return res;
    }
    public Wrappers_Compile.Result<uint, Dafny.ISequence<char>> ReadUInt32()
    {
      Wrappers_Compile.Result<uint, Dafny.ISequence<char>> res = Wrappers_Compile.Result<uint, Dafny.ISequence<char>>.Default(0);
      Dafny.ISequence<byte> _20864_bytes = Dafny.Sequence<byte>.Empty;
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _20865_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out20;
      _out20 = ((this).reader).ReadExact(new BigInteger(4));
      _20865_valueOrError0 = _out20;
      if ((_20865_valueOrError0).IsFailure()) {
        res = (_20865_valueOrError0).PropagateFailure<uint>();
        return res;
      }
      _20864_bytes = (_20865_valueOrError0).Extract();
      uint _20866_n;
      _20866_n = StandardLibrary_mUInt_Compile.__default.SeqToUInt32(_20864_bytes);
      res = @Wrappers_Compile.Result<uint, Dafny.ISequence<char>>.create_Success(_20866_n);
      return res;
      return res;
    }
    public Wrappers_Compile.Result<ulong, Dafny.ISequence<char>> ReadUInt64()
    {
      Wrappers_Compile.Result<ulong, Dafny.ISequence<char>> res = Wrappers_Compile.Result<ulong, Dafny.ISequence<char>>.Default(0);
      Dafny.ISequence<byte> _20867_bytes = Dafny.Sequence<byte>.Empty;
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _20868_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out21;
      _out21 = ((this).reader).ReadExact(new BigInteger(8));
      _20868_valueOrError0 = _out21;
      if ((_20868_valueOrError0).IsFailure()) {
        res = (_20868_valueOrError0).PropagateFailure<ulong>();
        return res;
      }
      _20867_bytes = (_20868_valueOrError0).Extract();
      ulong _20869_n;
      _20869_n = StandardLibrary_mUInt_Compile.__default.SeqToUInt64(_20867_bytes);
      res = @Wrappers_Compile.Result<ulong, Dafny.ISequence<char>>.create_Success(_20869_n);
      return res;
      return res;
    }
    public bool IsDoneReading()
    {
      bool b = false;
      b = (new BigInteger((((this).reader).data).Count)) == ((this).reader.pos);
      return b;
      return b;
    }
    public BigInteger GetSizeRead()
    {
      BigInteger n = BigInteger.Zero;
      n = (this).reader.pos;
      return n;
      return n;
    }
    public Streams_Compile.SeqReader<byte> _reader;public Streams_Compile.SeqReader<byte> reader { get {
      return this._reader;
    } }
  }

  public partial class SeqWriter<T> {
    public SeqWriter() {
      this.data = Dafny.Sequence<T>.Empty;
    }
    public Dafny.ISequence<T> data;public void __ctor()
    {
      (this).data = Dafny.Sequence<T>.FromElements();
    }
    public BigInteger WriteElements(Dafny.ISequence<T> elems)
    {
      BigInteger n = BigInteger.Zero;
      (this).data = Dafny.Sequence<T>.Concat(this.data, elems);
      n = new BigInteger((elems).Count);
      return n;
      return n;
    }
  }

  public partial class ByteWriter {
    public ByteWriter() {
      this._writer = default(Streams_Compile.SeqWriter<byte>);
    }
    public void __ctor()
    {
      Streams_Compile.SeqWriter<byte> _20870_mw;
      Streams_Compile.SeqWriter<byte> _nw6 = new Streams_Compile.SeqWriter<byte>();
      _nw6.__ctor();
      _20870_mw = _nw6;
      (this)._writer = _20870_mw;
    }
    public BigInteger WriteByte(byte n)
    {
      BigInteger r = BigInteger.Zero;
      BigInteger _out22;
      _out22 = ((this).writer).WriteElements(Dafny.Sequence<byte>.FromElements(n));
      r = _out22;
      return r;
    }
    public BigInteger WriteBytes(Dafny.ISequence<byte> s)
    {
      BigInteger r = BigInteger.Zero;
      BigInteger _out23;
      _out23 = ((this).writer).WriteElements(s);
      r = _out23;
      return r;
    }
    public BigInteger WriteUInt16(ushort n)
    {
      BigInteger r = BigInteger.Zero;
      BigInteger _out24;
      _out24 = ((this).writer).WriteElements(StandardLibrary_mUInt_Compile.__default.UInt16ToSeq(n));
      r = _out24;
      return r;
    }
    public BigInteger WriteUInt32(uint n)
    {
      BigInteger r = BigInteger.Zero;
      BigInteger _out25;
      _out25 = ((this).writer).WriteElements(StandardLibrary_mUInt_Compile.__default.UInt32ToSeq(n));
      r = _out25;
      return r;
    }
    public Dafny.ISequence<byte> GetDataWritten() {
      return (this).writer.data;
    }
    public BigInteger GetSizeWritten() {
      return new BigInteger(((this).writer.data).Count);
    }
    public Streams_Compile.SeqWriter<byte> _writer;public Streams_Compile.SeqWriter<byte> writer { get {
      return this._writer;
    } }
  }

} // end of namespace Streams_Compile
namespace Deserialize_Compile {











  public class DeserializeHeaderResult {
    public readonly MessageHeader.Header header;
    public DeserializeHeaderResult(MessageHeader.Header header) {
      this.header = header;
    }
    public override bool Equals(object other) {
      var oth = other as Deserialize_Compile.DeserializeHeaderResult;
      return oth != null && object.Equals(this.header, oth.header);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.header));
      return (int) hash;
    }
    public override string ToString() {
      string s = "Deserialize_Compile.DeserializeHeaderResult.DeserializeHeaderResult";
      s += "(";
      s += Dafny.Helpers.ToString(this.header);
      s += ")";
      return s;
    }
    private static readonly DeserializeHeaderResult theDefault = create(MessageHeader.Header.Default());
    public static DeserializeHeaderResult Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<Deserialize_Compile.DeserializeHeaderResult> _TYPE = new Dafny.TypeDescriptor<Deserialize_Compile.DeserializeHeaderResult>(Deserialize_Compile.DeserializeHeaderResult.Default());
    public static Dafny.TypeDescriptor<Deserialize_Compile.DeserializeHeaderResult> _TypeDescriptor() {
      return _TYPE;
    }
    public static DeserializeHeaderResult create(MessageHeader.Header header) {
      return new DeserializeHeaderResult(header);
    }
    public bool is_DeserializeHeaderResult { get { return true; } }
    public MessageHeader.Header dtor_header {
      get {
        return this.header;
      }
    }
  }

  public partial class __default {
    public static Wrappers_Compile.Result<Deserialize_Compile.DeserializeHeaderResult, Dafny.ISequence<char>> DeserializeHeader(Streams_Compile.ByteReader rd)
    {
      Wrappers_Compile.Result<Deserialize_Compile.DeserializeHeaderResult, Dafny.ISequence<char>> res = Wrappers_Compile.Result<Deserialize_Compile.DeserializeHeaderResult, Dafny.ISequence<char>>.Default(Deserialize_Compile.DeserializeHeaderResult.Default());
      MessageHeader.HeaderBody _20871_hb = MessageHeader.HeaderBody.Default();
      Wrappers_Compile.Result<MessageHeader.HeaderBody, Dafny.ISequence<char>> _20872_valueOrError0 = Wrappers_Compile.Result<MessageHeader.HeaderBody, Dafny.ISequence<char>>.Default(MessageHeader.HeaderBody.Default());
      Wrappers_Compile.Result<MessageHeader.HeaderBody, Dafny.ISequence<char>> _out26;
      _out26 = Deserialize_Compile.__default.DeserializeHeaderBody(rd);
      _20872_valueOrError0 = _out26;
      if ((_20872_valueOrError0).IsFailure()) {
        res = (_20872_valueOrError0).PropagateFailure<Deserialize_Compile.DeserializeHeaderResult>();
        return res;
      }
      _20871_hb = (_20872_valueOrError0).Extract();
      MessageHeader.HeaderAuthentication _20873_auth = MessageHeader.HeaderAuthentication.Default();
      Wrappers_Compile.Result<MessageHeader.HeaderAuthentication, Dafny.ISequence<char>> _20874_valueOrError1 = Wrappers_Compile.Result<MessageHeader.HeaderAuthentication, Dafny.ISequence<char>>.Default(MessageHeader.HeaderAuthentication.Default());
      Wrappers_Compile.Result<MessageHeader.HeaderAuthentication, Dafny.ISequence<char>> _out27;
      _out27 = Deserialize_Compile.__default.DeserializeHeaderAuthentication(rd, (_20871_hb).dtor_algorithmSuiteID);
      _20874_valueOrError1 = _out27;
      if ((_20874_valueOrError1).IsFailure()) {
        res = (_20874_valueOrError1).PropagateFailure<Deserialize_Compile.DeserializeHeaderResult>();
        return res;
      }
      _20873_auth = (_20874_valueOrError1).Extract();
      res = @Wrappers_Compile.Result<Deserialize_Compile.DeserializeHeaderResult, Dafny.ISequence<char>>.create_Success(@Deserialize_Compile.DeserializeHeaderResult.create(@MessageHeader.Header.create(_20871_hb, _20873_auth)));
      return res;
      return res;
    }
    public static Wrappers_Compile.Result<MessageHeader.HeaderBody, Dafny.ISequence<char>> DeserializeHeaderBody(Streams_Compile.ByteReader rd)
    {
      Wrappers_Compile.Result<MessageHeader.HeaderBody, Dafny.ISequence<char>> ret = Wrappers_Compile.Result<MessageHeader.HeaderBody, Dafny.ISequence<char>>.Default(MessageHeader.HeaderBody.Default());
      byte _20875_version = MessageHeader.Version.Default();
      Wrappers_Compile.Result<byte, Dafny.ISequence<char>> _20876_valueOrError0 = Wrappers_Compile.Result<byte, Dafny.ISequence<char>>.Default(MessageHeader.Version.Default());
      Wrappers_Compile.Result<byte, Dafny.ISequence<char>> _out28;
      _out28 = Deserialize_Compile.__default.DeserializeVersion(rd);
      _20876_valueOrError0 = _out28;
      if ((_20876_valueOrError0).IsFailure()) {
        ret = (_20876_valueOrError0).PropagateFailure<MessageHeader.HeaderBody>();
        return ret;
      }
      _20875_version = (_20876_valueOrError0).Extract();
      byte _20877_typ = MessageHeader.Type.Default();
      Wrappers_Compile.Result<byte, Dafny.ISequence<char>> _20878_valueOrError1 = Wrappers_Compile.Result<byte, Dafny.ISequence<char>>.Default(MessageHeader.Type.Default());
      Wrappers_Compile.Result<byte, Dafny.ISequence<char>> _out29;
      _out29 = Deserialize_Compile.__default.DeserializeType(rd);
      _20878_valueOrError1 = _out29;
      if ((_20878_valueOrError1).IsFailure()) {
        ret = (_20878_valueOrError1).PropagateFailure<MessageHeader.HeaderBody>();
        return ret;
      }
      _20877_typ = (_20878_valueOrError1).Extract();
      ushort _20879_algorithmSuiteID = AlgorithmSuite.ID.Witness;
      Wrappers_Compile.Result<ushort, Dafny.ISequence<char>> _20880_valueOrError2 = Wrappers_Compile.Result<ushort, Dafny.ISequence<char>>.Default(AlgorithmSuite.ID.Witness);
      Wrappers_Compile.Result<ushort, Dafny.ISequence<char>> _out30;
      _out30 = Deserialize_Compile.__default.DeserializeAlgorithmSuiteID(rd);
      _20880_valueOrError2 = _out30;
      if ((_20880_valueOrError2).IsFailure()) {
        ret = (_20880_valueOrError2).PropagateFailure<MessageHeader.HeaderBody>();
        return ret;
      }
      _20879_algorithmSuiteID = (_20880_valueOrError2).Extract();
      Dafny.ISequence<byte> _20881_messageID = MessageHeader.MessageID.Default();
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _20882_valueOrError3 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(MessageHeader.MessageID.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out31;
      _out31 = Deserialize_Compile.__default.DeserializeMsgID(rd);
      _20882_valueOrError3 = _out31;
      if ((_20882_valueOrError3).IsFailure()) {
        ret = (_20882_valueOrError3).PropagateFailure<MessageHeader.HeaderBody>();
        return ret;
      }
      _20881_messageID = (_20882_valueOrError3).Extract();
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _20883_aad = Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Empty;
      Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, Dafny.ISequence<char>> _20884_valueOrError4 = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, Dafny.ISequence<char>>.Default(Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Empty);
      Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, Dafny.ISequence<char>> _out32;
      _out32 = Deserialize_Compile.__default.DeserializeAAD(rd);
      _20884_valueOrError4 = _out32;
      if ((_20884_valueOrError4).IsFailure()) {
        ret = (_20884_valueOrError4).PropagateFailure<MessageHeader.HeaderBody>();
        return ret;
      }
      _20883_aad = (_20884_valueOrError4).Extract();
      MessageHeader.EncryptedDataKeys _20885_encryptedDataKeys = MessageHeader.EncryptedDataKeys.Default();
      Wrappers_Compile.Result<MessageHeader.EncryptedDataKeys, Dafny.ISequence<char>> _20886_valueOrError5 = Wrappers_Compile.Result<MessageHeader.EncryptedDataKeys, Dafny.ISequence<char>>.Default(MessageHeader.EncryptedDataKeys.Default());
      Wrappers_Compile.Result<MessageHeader.EncryptedDataKeys, Dafny.ISequence<char>> _out33;
      _out33 = Deserialize_Compile.__default.DeserializeEncryptedDataKeys(rd);
      _20886_valueOrError5 = _out33;
      if ((_20886_valueOrError5).IsFailure()) {
        ret = (_20886_valueOrError5).PropagateFailure<MessageHeader.HeaderBody>();
        return ret;
      }
      _20885_encryptedDataKeys = (_20886_valueOrError5).Extract();
      MessageHeader.ContentType _20887_contentType = MessageHeader.ContentType.Default();
      Wrappers_Compile.Result<MessageHeader.ContentType, Dafny.ISequence<char>> _20888_valueOrError6 = Wrappers_Compile.Result<MessageHeader.ContentType, Dafny.ISequence<char>>.Default(MessageHeader.ContentType.Default());
      Wrappers_Compile.Result<MessageHeader.ContentType, Dafny.ISequence<char>> _out34;
      _out34 = Deserialize_Compile.__default.DeserializeContentType(rd);
      _20888_valueOrError6 = _out34;
      if ((_20888_valueOrError6).IsFailure()) {
        ret = (_20888_valueOrError6).PropagateFailure<MessageHeader.HeaderBody>();
        return ret;
      }
      _20887_contentType = (_20888_valueOrError6).Extract();
      Dafny.ISequence<byte> _20889___v2 = Dafny.Sequence<byte>.Empty;
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _20890_valueOrError7 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out35;
      _out35 = Deserialize_Compile.__default.DeserializeReserved(rd);
      _20890_valueOrError7 = _out35;
      if ((_20890_valueOrError7).IsFailure()) {
        ret = (_20890_valueOrError7).PropagateFailure<MessageHeader.HeaderBody>();
        return ret;
      }
      _20889___v2 = (_20890_valueOrError7).Extract();
      byte _20891_ivLength = 0;
      Wrappers_Compile.Result<byte, Dafny.ISequence<char>> _20892_valueOrError8 = Wrappers_Compile.Result<byte, Dafny.ISequence<char>>.Default(0);
      Wrappers_Compile.Result<byte, Dafny.ISequence<char>> _out36;
      _out36 = (rd).ReadByte();
      _20892_valueOrError8 = _out36;
      if ((_20892_valueOrError8).IsFailure()) {
        ret = (_20892_valueOrError8).PropagateFailure<MessageHeader.HeaderBody>();
        return ret;
      }
      _20891_ivLength = (_20892_valueOrError8).Extract();
      uint _20893_frameLength = 0;
      Wrappers_Compile.Result<uint, Dafny.ISequence<char>> _20894_valueOrError9 = Wrappers_Compile.Result<uint, Dafny.ISequence<char>>.Default(0);
      Wrappers_Compile.Result<uint, Dafny.ISequence<char>> _out37;
      _out37 = (rd).ReadUInt32();
      _20894_valueOrError9 = _out37;
      if ((_20894_valueOrError9).IsFailure()) {
        ret = (_20894_valueOrError9).PropagateFailure<MessageHeader.HeaderBody>();
        return ret;
      }
      _20893_frameLength = (_20894_valueOrError9).Extract();
      if ((new BigInteger(_20891_ivLength)) != (AlgorithmSuite.ID.IVLength(_20879_algorithmSuiteID))) {
        ret = @Wrappers_Compile.Result<MessageHeader.HeaderBody, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Deserialization Error: Incorrect IV length."));
        return ret;
      }
      if (((_20887_contentType).is_NonFramed) && ((_20893_frameLength) != (0U))) {
        ret = @Wrappers_Compile.Result<MessageHeader.HeaderBody, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Deserialization Error: Frame length must be 0 when content type is non-framed."));
        return ret;
      } else if (((_20887_contentType).is_Framed) && ((_20893_frameLength) == (0U))) {
        ret = @Wrappers_Compile.Result<MessageHeader.HeaderBody, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Deserialization Error: Frame length must be non-0 when content type is framed."));
        return ret;
      }
      MessageHeader.HeaderBody _20895_hb;
      _20895_hb = @MessageHeader.HeaderBody.create(_20875_version, _20877_typ, _20879_algorithmSuiteID, _20881_messageID, _20883_aad, _20885_encryptedDataKeys, _20887_contentType, _20891_ivLength, _20893_frameLength);
      ret = @Wrappers_Compile.Result<MessageHeader.HeaderBody, Dafny.ISequence<char>>.create_Success(_20895_hb);
      return ret;
      return ret;
    }
    public static Wrappers_Compile.Result<MessageHeader.HeaderAuthentication, Dafny.ISequence<char>> DeserializeHeaderAuthentication(Streams_Compile.ByteReader rd, ushort algorithmSuiteID)
    {
      Wrappers_Compile.Result<MessageHeader.HeaderAuthentication, Dafny.ISequence<char>> ret = Wrappers_Compile.Result<MessageHeader.HeaderAuthentication, Dafny.ISequence<char>>.Default(MessageHeader.HeaderAuthentication.Default());
      Dafny.ISequence<byte> _20896_iv = Dafny.Sequence<byte>.Empty;
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _20897_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out38;
      _out38 = (rd).ReadBytes(AlgorithmSuite.ID.IVLength(algorithmSuiteID));
      _20897_valueOrError0 = _out38;
      if ((_20897_valueOrError0).IsFailure()) {
        ret = (_20897_valueOrError0).PropagateFailure<MessageHeader.HeaderAuthentication>();
        return ret;
      }
      _20896_iv = (_20897_valueOrError0).Extract();
      Dafny.ISequence<byte> _20898_authenticationTag = Dafny.Sequence<byte>.Empty;
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _20899_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out39;
      _out39 = (rd).ReadBytes(AlgorithmSuite.ID.TagLength(algorithmSuiteID));
      _20899_valueOrError1 = _out39;
      if ((_20899_valueOrError1).IsFailure()) {
        ret = (_20899_valueOrError1).PropagateFailure<MessageHeader.HeaderAuthentication>();
        return ret;
      }
      _20898_authenticationTag = (_20899_valueOrError1).Extract();
      ret = @Wrappers_Compile.Result<MessageHeader.HeaderAuthentication, Dafny.ISequence<char>>.create_Success(@MessageHeader.HeaderAuthentication.create(_20896_iv, _20898_authenticationTag));
      return ret;
      return ret;
    }
    public static Wrappers_Compile.Result<byte, Dafny.ISequence<char>> DeserializeVersion(Streams_Compile.ByteReader rd)
    {
      Wrappers_Compile.Result<byte, Dafny.ISequence<char>> ret = Wrappers_Compile.Result<byte, Dafny.ISequence<char>>.Default(MessageHeader.Version.Default());
      byte _20900_version = 0;
      Wrappers_Compile.Result<byte, Dafny.ISequence<char>> _20901_valueOrError0 = Wrappers_Compile.Result<byte, Dafny.ISequence<char>>.Default(0);
      Wrappers_Compile.Result<byte, Dafny.ISequence<char>> _out40;
      _out40 = (rd).ReadByte();
      _20901_valueOrError0 = _out40;
      if ((_20901_valueOrError0).IsFailure()) {
        ret = (_20901_valueOrError0).PropagateFailure<byte>();
        return ret;
      }
      _20900_version = (_20901_valueOrError0).Extract();
      if ((_20900_version) == (MessageHeader.__default.VERSION__1)) {
        ret = @Wrappers_Compile.Result<byte, Dafny.ISequence<char>>.create_Success(_20900_version);
        return ret;
      } else {
        ret = @Wrappers_Compile.Result<byte, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Deserialization Error: Version not supported."));
        return ret;
      }
      return ret;
    }
    public static Wrappers_Compile.Result<byte, Dafny.ISequence<char>> DeserializeType(Streams_Compile.ByteReader rd)
    {
      Wrappers_Compile.Result<byte, Dafny.ISequence<char>> ret = Wrappers_Compile.Result<byte, Dafny.ISequence<char>>.Default(MessageHeader.Type.Default());
      byte _20902_typ = 0;
      Wrappers_Compile.Result<byte, Dafny.ISequence<char>> _20903_valueOrError0 = Wrappers_Compile.Result<byte, Dafny.ISequence<char>>.Default(0);
      Wrappers_Compile.Result<byte, Dafny.ISequence<char>> _out41;
      _out41 = (rd).ReadByte();
      _20903_valueOrError0 = _out41;
      if ((_20903_valueOrError0).IsFailure()) {
        ret = (_20903_valueOrError0).PropagateFailure<byte>();
        return ret;
      }
      _20902_typ = (_20903_valueOrError0).Extract();
      if ((_20902_typ) == (MessageHeader.__default.TYPE__CUSTOMER__AED)) {
        ret = @Wrappers_Compile.Result<byte, Dafny.ISequence<char>>.create_Success(_20902_typ);
        return ret;
      } else {
        ret = @Wrappers_Compile.Result<byte, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Deserialization Error: Type not supported."));
        return ret;
      }
      return ret;
    }
    public static Wrappers_Compile.Result<ushort, Dafny.ISequence<char>> DeserializeAlgorithmSuiteID(Streams_Compile.ByteReader rd)
    {
      Wrappers_Compile.Result<ushort, Dafny.ISequence<char>> ret = Wrappers_Compile.Result<ushort, Dafny.ISequence<char>>.Default(AlgorithmSuite.ID.Witness);
      ushort _20904_algorithmSuiteID = 0;
      Wrappers_Compile.Result<ushort, Dafny.ISequence<char>> _20905_valueOrError0 = Wrappers_Compile.Result<ushort, Dafny.ISequence<char>>.Default(0);
      Wrappers_Compile.Result<ushort, Dafny.ISequence<char>> _out42;
      _out42 = (rd).ReadUInt16();
      _20905_valueOrError0 = _out42;
      if ((_20905_valueOrError0).IsFailure()) {
        ret = (_20905_valueOrError0).PropagateFailure<ushort>();
        return ret;
      }
      _20904_algorithmSuiteID = (_20905_valueOrError0).Extract();
      if ((AlgorithmSuite.__default.VALID__IDS).Contains((_20904_algorithmSuiteID))) {
        ret = @Wrappers_Compile.Result<ushort, Dafny.ISequence<char>>.create_Success((ushort)(_20904_algorithmSuiteID));
        return ret;
      } else {
        ret = @Wrappers_Compile.Result<ushort, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Deserialization Error: Algorithm suite not supported."));
        return ret;
      }
      return ret;
    }
    public static Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> DeserializeMsgID(Streams_Compile.ByteReader rd)
    {
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> ret = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(MessageHeader.MessageID.Default());
      Dafny.ISequence<byte> _20906_msgID = Dafny.Sequence<byte>.Empty;
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _20907_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out43;
      _out43 = (rd).ReadBytes(MessageHeader.__default.MESSAGE__ID__LEN);
      _20907_valueOrError0 = _out43;
      if ((_20907_valueOrError0).IsFailure()) {
        ret = (_20907_valueOrError0).PropagateFailure<Dafny.ISequence<byte>>();
        return ret;
      }
      _20906_msgID = (_20907_valueOrError0).Extract();
      ret = @Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.create_Success(_20906_msgID);
      return ret;
      return ret;
    }
    public static Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> DeserializeUTF8(Streams_Compile.ByteReader rd, BigInteger n)
    {
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> ret = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Dafny.ISequence<byte> _20908_bytes = Dafny.Sequence<byte>.Empty;
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _20909_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out44;
      _out44 = (rd).ReadBytes(n);
      _20909_valueOrError0 = _out44;
      if ((_20909_valueOrError0).IsFailure()) {
        ret = (_20909_valueOrError0).PropagateFailure<Dafny.ISequence<byte>>();
        return ret;
      }
      _20908_bytes = (_20909_valueOrError0).Extract();
      if (UTF8.__default.ValidUTF8Seq(_20908_bytes)) {
        Dafny.ISequence<byte> _20910_utf8;
        _20910_utf8 = _20908_bytes;
        ret = @Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.create_Success(_20910_utf8);
        return ret;
      } else {
        ret = @Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Deserialization Error: Not a valid UTF8 string."));
        return ret;
      }
      return ret;
    }
    public static Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, Dafny.ISequence<char>> DeserializeAAD(Streams_Compile.ByteReader rd)
    {
      Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, Dafny.ISequence<char>> ret = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, Dafny.ISequence<char>>.Default(Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Empty);
      ushort _20911_kvPairsLength = 0;
      Wrappers_Compile.Result<ushort, Dafny.ISequence<char>> _20912_valueOrError0 = Wrappers_Compile.Result<ushort, Dafny.ISequence<char>>.Default(0);
      Wrappers_Compile.Result<ushort, Dafny.ISequence<char>> _out45;
      _out45 = (rd).ReadUInt16();
      _20912_valueOrError0 = _out45;
      if ((_20912_valueOrError0).IsFailure()) {
        ret = (_20912_valueOrError0).PropagateFailure<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>>();
        return ret;
      }
      _20911_kvPairsLength = (_20912_valueOrError0).Extract();
      if ((_20911_kvPairsLength) == (0)) {
        ret = @Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, Dafny.ISequence<char>>.create_Success(Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.FromElements());
        return ret;
      } else if ((_20911_kvPairsLength) < (2)) {
        ret = @Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Deserialization Error: The number of bytes in encryption context exceeds the given length."));
        return ret;
      }
      BigInteger _20913_totalBytesRead;
      _20913_totalBytesRead = BigInteger.Zero;
      ushort _20914_kvPairsCount = 0;
      Wrappers_Compile.Result<ushort, Dafny.ISequence<char>> _20915_valueOrError1 = Wrappers_Compile.Result<ushort, Dafny.ISequence<char>>.Default(0);
      Wrappers_Compile.Result<ushort, Dafny.ISequence<char>> _out46;
      _out46 = (rd).ReadUInt16();
      _20915_valueOrError1 = _out46;
      if ((_20915_valueOrError1).IsFailure()) {
        ret = (_20915_valueOrError1).PropagateFailure<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>>();
        return ret;
      }
      _20914_kvPairsCount = (_20915_valueOrError1).Extract();
      _20913_totalBytesRead = (_20913_totalBytesRead) + (new BigInteger(2));
      if ((_20914_kvPairsCount) == (0)) {
        ret = @Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Deserialization Error: Key value pairs count is 0."));
        return ret;
      }
      Dafny.ISequence<_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>> _20916_kvPairs;
      _20916_kvPairs = Dafny.Sequence<_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>>.FromElements();
      ushort _20917_i;
      _20917_i = 0;
      while ((_20917_i) < (_20914_kvPairsCount)) {
        ushort _20918_keyLength = 0;
        Wrappers_Compile.Result<ushort, Dafny.ISequence<char>> _20919_valueOrError2 = Wrappers_Compile.Result<ushort, Dafny.ISequence<char>>.Default(0);
        Wrappers_Compile.Result<ushort, Dafny.ISequence<char>> _out47;
        _out47 = (rd).ReadUInt16();
        _20919_valueOrError2 = _out47;
        if ((_20919_valueOrError2).IsFailure()) {
          ret = (_20919_valueOrError2).PropagateFailure<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>>();
          return ret;
        }
        _20918_keyLength = (_20919_valueOrError2).Extract();
        _20913_totalBytesRead = (_20913_totalBytesRead) + (new BigInteger(2));
        Dafny.ISequence<byte> _20920_key = UTF8.ValidUTF8Bytes.Default();
        Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _20921_valueOrError3 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
        Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out48;
        _out48 = Deserialize_Compile.__default.DeserializeUTF8(rd, new BigInteger(_20918_keyLength));
        _20921_valueOrError3 = _out48;
        if ((_20921_valueOrError3).IsFailure()) {
          ret = (_20921_valueOrError3).PropagateFailure<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>>();
          return ret;
        }
        _20920_key = (_20921_valueOrError3).Extract();
        _20913_totalBytesRead = (_20913_totalBytesRead) + (new BigInteger((_20920_key).Count));
        ushort _20922_valueLength = 0;
        Wrappers_Compile.Result<ushort, Dafny.ISequence<char>> _20923_valueOrError4 = Wrappers_Compile.Result<ushort, Dafny.ISequence<char>>.Default(0);
        Wrappers_Compile.Result<ushort, Dafny.ISequence<char>> _out49;
        _out49 = (rd).ReadUInt16();
        _20923_valueOrError4 = _out49;
        if ((_20923_valueOrError4).IsFailure()) {
          ret = (_20923_valueOrError4).PropagateFailure<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>>();
          return ret;
        }
        _20922_valueLength = (_20923_valueOrError4).Extract();
        _20913_totalBytesRead = (_20913_totalBytesRead) + (new BigInteger(2));
        if ((new BigInteger(_20911_kvPairsLength)) < ((_20913_totalBytesRead) + (new BigInteger(_20922_valueLength)))) {
          ret = @Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Deserialization Error: The number of bytes in encryption context exceeds the given length."));
          return ret;
        }
        Dafny.ISequence<byte> _20924_value = UTF8.ValidUTF8Bytes.Default();
        Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _20925_valueOrError5 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
        Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out50;
        _out50 = Deserialize_Compile.__default.DeserializeUTF8(rd, new BigInteger(_20922_valueLength));
        _20925_valueOrError5 = _out50;
        if ((_20925_valueOrError5).IsFailure()) {
          ret = (_20925_valueOrError5).PropagateFailure<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>>();
          return ret;
        }
        _20924_value = (_20925_valueOrError5).Extract();
        _20913_totalBytesRead = (_20913_totalBytesRead) + (new BigInteger((_20924_value).Count));
        Wrappers_Compile.Option<Dafny.ISequence<_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>>> _20926_opt;
        Wrappers_Compile.Option<Dafny.ISequence<_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>>> _out51;
        _out51 = Deserialize_Compile.__default.InsertNewEntry(_20916_kvPairs, _20920_key, _20924_value);
        _20926_opt = _out51;
        Wrappers_Compile.Option<Dafny.ISequence<_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>>> _source16 = _20926_opt;
        if (_source16.is_None) {
          {
            ret = @Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Deserialization Error: Duplicate key."));
            return ret;
          }
        } else {
          Dafny.ISequence<_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>> _20927___mcc_h2 = ((Wrappers_Compile.Option_Some<Dafny.ISequence<_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>>>)_source16).@value;
          {
            Dafny.ISequence<_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>> _20928_kvPairs__ = _20927___mcc_h2;
            _20916_kvPairs = _20928_kvPairs__;
          }
        }
        _20917_i = (ushort)((_20917_i) + (1));
      }
      if ((new BigInteger(_20911_kvPairsLength)) != (_20913_totalBytesRead)) {
        ret = @Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Deserialization Error: Bytes actually read differs from bytes supposed to be read."));
        return ret;
      }
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _20929_encryptionContext;
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _out52;
      _out52 = EncryptionContext.__default.LinearToMap(_20916_kvPairs);
      _20929_encryptionContext = _out52;
      bool _20930_isValid;
      bool _out53;
      _out53 = EncryptionContext.__default.CheckSerializable(_20929_encryptionContext);
      _20930_isValid = _out53;
      if ((!(_20930_isValid)) || ((new BigInteger((_20916_kvPairs).Count)) != (new BigInteger((_20929_encryptionContext).Count)))) {
        ret = @Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Deserialization Error: Failed to parse encryption context."));
        return ret;
      }
      ret = @Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, Dafny.ISequence<char>>.create_Success(_20929_encryptionContext);
      return ret;
      return ret;
    }
    public static Wrappers_Compile.Option<Dafny.ISequence<_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>>> InsertNewEntry(Dafny.ISequence<_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>> kvPairs, Dafny.ISequence<byte> key, Dafny.ISequence<byte> @value)
    {
      Wrappers_Compile.Option<Dafny.ISequence<_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>>> res = Wrappers_Compile.Option<Dafny.ISequence<_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>>>.Default();
      BigInteger _20931_n;
      _20931_n = new BigInteger((kvPairs).Count);
      while (((_20931_n).Sign == 1) && (StandardLibrary_Compile.__default.LexicographicLessOrEqual<byte>(key, ((kvPairs).Select((_20931_n) - (BigInteger.One))).dtor__0, StandardLibrary_mUInt_Compile.__default.UInt8Less))) {
        _20931_n = (_20931_n) - (BigInteger.One);
      }
      if (((!(kvPairs).Equals((Dafny.Sequence<_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>>.FromElements()))) && (StandardLibrary_Compile.__default.LexicographicLessOrEqual<byte>(key, ((kvPairs).Select((new BigInteger((kvPairs).Count)) - (BigInteger.One))).dtor__0, StandardLibrary_mUInt_Compile.__default.UInt8Less))) && ((((kvPairs).Select(_20931_n)).dtor__0).Equals((key)))) {
        Wrappers_Compile.Option<Dafny.ISequence<_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>>> _rhs0 = @Wrappers_Compile.Option<Dafny.ISequence<_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>>>.create_None();
        res = _rhs0;
        return res;
      } else {
        Dafny.ISequence<_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>> _20932_kvPairs_k;
        _20932_kvPairs_k = Dafny.Sequence<_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>>.Concat(Dafny.Sequence<_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>>.Concat((kvPairs).Take(_20931_n), Dafny.Sequence<_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>>.FromElements(@_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.create(key, @value))), (kvPairs).Drop(_20931_n));
        Wrappers_Compile.Option<Dafny.ISequence<_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>>> _rhs1 = @Wrappers_Compile.Option<Dafny.ISequence<_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>>>.create_Some(_20932_kvPairs_k);
        res = _rhs1;
        return res;
      }
      return res;
    }
    public static Wrappers_Compile.Result<MessageHeader.EncryptedDataKeys, Dafny.ISequence<char>> DeserializeEncryptedDataKeys(Streams_Compile.ByteReader rd)
    {
      Wrappers_Compile.Result<MessageHeader.EncryptedDataKeys, Dafny.ISequence<char>> ret = Wrappers_Compile.Result<MessageHeader.EncryptedDataKeys, Dafny.ISequence<char>>.Default(MessageHeader.EncryptedDataKeys.Default());
      ushort _20933_edkCount = 0;
      Wrappers_Compile.Result<ushort, Dafny.ISequence<char>> _20934_valueOrError0 = Wrappers_Compile.Result<ushort, Dafny.ISequence<char>>.Default(0);
      Wrappers_Compile.Result<ushort, Dafny.ISequence<char>> _out54;
      _out54 = (rd).ReadUInt16();
      _20934_valueOrError0 = _out54;
      if ((_20934_valueOrError0).IsFailure()) {
        ret = (_20934_valueOrError0).PropagateFailure<MessageHeader.EncryptedDataKeys>();
        return ret;
      }
      _20933_edkCount = (_20934_valueOrError0).Extract();
      if ((_20933_edkCount) == (0)) {
        ret = @Wrappers_Compile.Result<MessageHeader.EncryptedDataKeys, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Deserialization Error: Encrypted data key count is 0."));
        return ret;
      }
      Dafny.ISequence<Materials.EncryptedDataKey> _20935_edkEntries;
      _20935_edkEntries = Dafny.Sequence<Materials.EncryptedDataKey>.FromElements();
      ushort _20936_i;
      _20936_i = 0;
      while ((_20936_i) < (_20933_edkCount)) {
        ushort _20937_keyProviderIDLength = 0;
        Wrappers_Compile.Result<ushort, Dafny.ISequence<char>> _20938_valueOrError1 = Wrappers_Compile.Result<ushort, Dafny.ISequence<char>>.Default(0);
        Wrappers_Compile.Result<ushort, Dafny.ISequence<char>> _out55;
        _out55 = (rd).ReadUInt16();
        _20938_valueOrError1 = _out55;
        if ((_20938_valueOrError1).IsFailure()) {
          ret = (_20938_valueOrError1).PropagateFailure<MessageHeader.EncryptedDataKeys>();
          return ret;
        }
        _20937_keyProviderIDLength = (_20938_valueOrError1).Extract();
        Dafny.ISequence<byte> _20939_str = UTF8.ValidUTF8Bytes.Default();
        Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _20940_valueOrError2 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
        Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out56;
        _out56 = Deserialize_Compile.__default.DeserializeUTF8(rd, new BigInteger(_20937_keyProviderIDLength));
        _20940_valueOrError2 = _out56;
        if ((_20940_valueOrError2).IsFailure()) {
          ret = (_20940_valueOrError2).PropagateFailure<MessageHeader.EncryptedDataKeys>();
          return ret;
        }
        _20939_str = (_20940_valueOrError2).Extract();
        Dafny.ISequence<byte> _20941_keyProviderID;
        _20941_keyProviderID = _20939_str;
        ushort _20942_keyProviderInfoLength = 0;
        Wrappers_Compile.Result<ushort, Dafny.ISequence<char>> _20943_valueOrError3 = Wrappers_Compile.Result<ushort, Dafny.ISequence<char>>.Default(0);
        Wrappers_Compile.Result<ushort, Dafny.ISequence<char>> _out57;
        _out57 = (rd).ReadUInt16();
        _20943_valueOrError3 = _out57;
        if ((_20943_valueOrError3).IsFailure()) {
          ret = (_20943_valueOrError3).PropagateFailure<MessageHeader.EncryptedDataKeys>();
          return ret;
        }
        _20942_keyProviderInfoLength = (_20943_valueOrError3).Extract();
        Dafny.ISequence<byte> _20944_keyProviderInfo = Dafny.Sequence<byte>.Empty;
        Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _20945_valueOrError4 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
        Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out58;
        _out58 = (rd).ReadBytes(new BigInteger(_20942_keyProviderInfoLength));
        _20945_valueOrError4 = _out58;
        if ((_20945_valueOrError4).IsFailure()) {
          ret = (_20945_valueOrError4).PropagateFailure<MessageHeader.EncryptedDataKeys>();
          return ret;
        }
        _20944_keyProviderInfo = (_20945_valueOrError4).Extract();
        ushort _20946_edkLength = 0;
        Wrappers_Compile.Result<ushort, Dafny.ISequence<char>> _20947_valueOrError5 = Wrappers_Compile.Result<ushort, Dafny.ISequence<char>>.Default(0);
        Wrappers_Compile.Result<ushort, Dafny.ISequence<char>> _out59;
        _out59 = (rd).ReadUInt16();
        _20947_valueOrError5 = _out59;
        if ((_20947_valueOrError5).IsFailure()) {
          ret = (_20947_valueOrError5).PropagateFailure<MessageHeader.EncryptedDataKeys>();
          return ret;
        }
        _20946_edkLength = (_20947_valueOrError5).Extract();
        Dafny.ISequence<byte> _20948_edk = Dafny.Sequence<byte>.Empty;
        Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _20949_valueOrError6 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
        Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out60;
        _out60 = (rd).ReadBytes(new BigInteger(_20946_edkLength));
        _20949_valueOrError6 = _out60;
        if ((_20949_valueOrError6).IsFailure()) {
          ret = (_20949_valueOrError6).PropagateFailure<MessageHeader.EncryptedDataKeys>();
          return ret;
        }
        _20948_edk = (_20949_valueOrError6).Extract();
        _20935_edkEntries = Dafny.Sequence<Materials.EncryptedDataKey>.Concat(_20935_edkEntries, Dafny.Sequence<Materials.EncryptedDataKey>.FromElements(@Materials.EncryptedDataKey.create(_20941_keyProviderID, _20944_keyProviderInfo, _20948_edk)));
        _20936_i = (ushort)((_20936_i) + (1));
      }
      MessageHeader.EncryptedDataKeys _20950_edks;
      _20950_edks = @MessageHeader.EncryptedDataKeys.create(_20935_edkEntries);
      ret = @Wrappers_Compile.Result<MessageHeader.EncryptedDataKeys, Dafny.ISequence<char>>.create_Success(_20950_edks);
      return ret;
      return ret;
    }
    public static Wrappers_Compile.Result<MessageHeader.ContentType, Dafny.ISequence<char>> DeserializeContentType(Streams_Compile.ByteReader rd)
    {
      Wrappers_Compile.Result<MessageHeader.ContentType, Dafny.ISequence<char>> ret = Wrappers_Compile.Result<MessageHeader.ContentType, Dafny.ISequence<char>>.Default(MessageHeader.ContentType.Default());
      byte _20951_byte = 0;
      Wrappers_Compile.Result<byte, Dafny.ISequence<char>> _20952_valueOrError0 = Wrappers_Compile.Result<byte, Dafny.ISequence<char>>.Default(0);
      Wrappers_Compile.Result<byte, Dafny.ISequence<char>> _out61;
      _out61 = (rd).ReadByte();
      _20952_valueOrError0 = _out61;
      if ((_20952_valueOrError0).IsFailure()) {
        ret = (_20952_valueOrError0).PropagateFailure<MessageHeader.ContentType>();
        return ret;
      }
      _20951_byte = (_20952_valueOrError0).Extract();
      Wrappers_Compile.Option<MessageHeader.ContentType> _source17 = MessageHeader.__default.UInt8ToContentType(_20951_byte);
      if (_source17.is_None) {
        {
          ret = @Wrappers_Compile.Result<MessageHeader.ContentType, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Deserialization Error: Content type not supported."));
          return ret;
        }
      } else {
        MessageHeader.ContentType _20953___mcc_h2 = ((Wrappers_Compile.Option_Some<MessageHeader.ContentType>)_source17).@value;
        {
          MessageHeader.ContentType _20954_contentType = _20953___mcc_h2;
          ret = @Wrappers_Compile.Result<MessageHeader.ContentType, Dafny.ISequence<char>>.create_Success(_20954_contentType);
          return ret;
        }
      }
      return ret;
    }
    public static Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> DeserializeReserved(Streams_Compile.ByteReader rd)
    {
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> ret = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      Dafny.ISequence<byte> _20955_reserved = Dafny.Sequence<byte>.Empty;
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _20956_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out62;
      _out62 = (rd).ReadBytes(new BigInteger(4));
      _20956_valueOrError0 = _out62;
      if ((_20956_valueOrError0).IsFailure()) {
        ret = (_20956_valueOrError0).PropagateFailure<Dafny.ISequence<byte>>();
        return ret;
      }
      _20955_reserved = (_20956_valueOrError0).Extract();
      if ((_20955_reserved).Equals((MessageHeader.__default.Reserved))) {
        ret = @Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.create_Success(_20955_reserved);
        return ret;
      } else {
        ret = @Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Deserialization Error: Reserved fields must be 0."));
        return ret;
      }
      return ret;
    }
  }
} // end of namespace Deserialize_Compile
namespace DefaultCMMDef {













  public partial class DefaultCMM : CMMDefs.CMM {
    public DefaultCMM() {
      this._keyring = default(KeyringDefs.Keyring);
    }
    public void OfKeyring(KeyringDefs.Keyring k)
    {
      (this)._keyring = k;
    }
    public Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>> GetEncryptionMaterials(Materials.EncryptionMaterialsRequest materialsRequest)
    {
      Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>> res = Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>>.Default(Materials.ValidEncryptionMaterials.Default());
      Dafny.ISequence<byte> _20957_reservedField;
      _20957_reservedField = Materials.__default.EC__PUBLIC__KEY__FIELD;
      if ((((materialsRequest).dtor_encryptionContext).Keys).Contains((_20957_reservedField))) {
        res = @Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Reserved Field found in EncryptionContext keys."));
        return res;
      }
      ushort _20958_id;
      _20958_id = ((materialsRequest).dtor_algorithmSuiteID).UnwrapOr(AlgorithmSuite.__default.AES__256__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384);
      Wrappers_Compile.Option<Dafny.ISequence<byte>> _20959_enc__sk;
      _20959_enc__sk = @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_None();
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _20960_enc__ctx;
      _20960_enc__ctx = (materialsRequest).dtor_encryptionContext;
      Wrappers_Compile.Option<Signature.ECDSAParams> _source18 = AlgorithmSuite.ID.SignatureType(_20958_id);
      if (_source18.is_None) {
      } else {
        Signature.ECDSAParams _20961___mcc_h1 = ((Wrappers_Compile.Option_Some<Signature.ECDSAParams>)_source18).@value;
        {
          Signature.ECDSAParams _20962_param = _20961___mcc_h1;
          Signature.SignatureKeyPair _20963_signatureKeys = Signature.SignatureKeyPair.Default();
          Wrappers_Compile.Result<Signature.SignatureKeyPair, Dafny.ISequence<char>> _20964_valueOrError0 = Wrappers_Compile.Result<Signature.SignatureKeyPair, Dafny.ISequence<char>>.Default(Signature.SignatureKeyPair.Default());
          Wrappers_Compile.Result<Signature.SignatureKeyPair, Dafny.ISequence<char>> _out63;
          _out63 = Signature.__default.KeyGen(_20962_param);
          _20964_valueOrError0 = _out63;
          if ((_20964_valueOrError0).IsFailure()) {
            res = (_20964_valueOrError0).PropagateFailure<Materials.EncryptionMaterials>();
            return res;
          }
          _20963_signatureKeys = (_20964_valueOrError0).Extract();
          _20959_enc__sk = @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some((_20963_signatureKeys).dtor_signingKey);
          Dafny.ISequence<byte> _20965_enc__vk = UTF8.ValidUTF8Bytes.Default();
          Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _20966_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
          Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out64;
          _out64 = UTF8.__default.Encode(Base64_Compile.__default.Encode((_20963_signatureKeys).dtor_verificationKey));
          _20966_valueOrError1 = _out64;
          if ((_20966_valueOrError1).IsFailure()) {
            res = (_20966_valueOrError1).PropagateFailure<Materials.EncryptionMaterials>();
            return res;
          }
          _20965_enc__vk = (_20966_valueOrError1).Extract();
          _20960_enc__ctx = Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Update(_20960_enc__ctx,_20957_reservedField, _20965_enc__vk);
        }
      }
      bool _20967_validAAD;
      bool _out65;
      _out65 = EncryptionContext.__default.CheckSerializable(_20960_enc__ctx);
      _20967_validAAD = _out65;
      if (!(_20967_validAAD)) {
        res = @Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Invalid Encryption Context"));
        return res;
      }
      Materials.EncryptionMaterials _20968_materials;
      _20968_materials = Materials.EncryptionMaterials.WithoutDataKeys(_20960_enc__ctx, _20958_id, _20959_enc__sk);
      Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>> _20969_valueOrError2 = Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>>.Default(Materials.ValidEncryptionMaterials.Default());
      Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>> _out66;
      _out66 = ((this).keyring).OnEncrypt(_20968_materials);
      _20969_valueOrError2 = _out66;
      if ((_20969_valueOrError2).IsFailure()) {
        res = (_20969_valueOrError2).PropagateFailure<Materials.EncryptionMaterials>();
        return res;
      }
      _20968_materials = (_20969_valueOrError2).Extract();
      if ((((_20968_materials).dtor_plaintextDataKey).is_None) || ((new BigInteger(((_20968_materials).dtor_encryptedDataKeys).Count)).Sign == 0)) {
        res = @Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Could not retrieve materials required for encryption"));
        return res;
      }
      res = @Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>>.create_Success(_20968_materials);
      return res;
      return res;
    }
    public Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>> DecryptMaterials(Materials.DecryptionMaterialsRequest materialsRequest)
    {
      Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>> res = Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>.Default(Materials.ValidDecryptionMaterials.Default());
      Wrappers_Compile.Option<Dafny.ISequence<byte>> _20970_vkey;
      _20970_vkey = @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_None();
      ushort _20971_algID;
      _20971_algID = (materialsRequest).dtor_algorithmSuiteID;
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _20972_encCtx;
      _20972_encCtx = (materialsRequest).dtor_encryptionContext;
      if ((AlgorithmSuite.ID.SignatureType(_20971_algID)).is_Some) {
        Dafny.ISequence<byte> _20973_reservedField;
        _20973_reservedField = Materials.__default.EC__PUBLIC__KEY__FIELD;
        if (!(_20972_encCtx).Contains((_20973_reservedField))) {
          res = @Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Could not get materials required for decryption."));
          return res;
        }
        Dafny.ISequence<byte> _20974_encodedVKey;
        _20974_encodedVKey = Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Select(_20972_encCtx,_20973_reservedField);
        Dafny.ISequence<char> _20975_utf8Decoded = Dafny.Sequence<char>.Empty;
        Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>> _20976_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.Default(Dafny.Sequence<char>.Empty);
        Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>> _out67;
        _out67 = UTF8.__default.Decode(_20974_encodedVKey);
        _20976_valueOrError0 = _out67;
        if ((_20976_valueOrError0).IsFailure()) {
          res = (_20976_valueOrError0).PropagateFailure<Materials.DecryptionMaterials>();
          return res;
        }
        _20975_utf8Decoded = (_20976_valueOrError0).Extract();
        Dafny.ISequence<byte> _20977_base64Decoded = Dafny.Sequence<byte>.Empty;
        Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _20978_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
        _20978_valueOrError1 = Base64_Compile.__default.Decode(_20975_utf8Decoded);
        if ((_20978_valueOrError1).IsFailure()) {
          res = (_20978_valueOrError1).PropagateFailure<Materials.DecryptionMaterials>();
          return res;
        }
        _20977_base64Decoded = (_20978_valueOrError1).Extract();
        _20970_vkey = @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(_20977_base64Decoded);
      }
      Materials.DecryptionMaterials _20979_materials;
      _20979_materials = Materials.DecryptionMaterials.WithoutPlaintextDataKey(_20972_encCtx, _20971_algID, _20970_vkey);
      Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>> _20980_valueOrError2 = Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>.Default(Materials.ValidDecryptionMaterials.Default());
      Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>> _out68;
      _out68 = ((this).keyring).OnDecrypt(_20979_materials, (materialsRequest).dtor_encryptedDataKeys);
      _20980_valueOrError2 = _out68;
      if ((_20980_valueOrError2).IsFailure()) {
        res = (_20980_valueOrError2).PropagateFailure<Materials.DecryptionMaterials>();
        return res;
      }
      _20979_materials = (_20980_valueOrError2).Extract();
      if (((_20979_materials).dtor_plaintextDataKey).is_None) {
        res = @Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Keyring.OnDecrypt failed to decrypt the plaintext data key."));
        return res;
      }
      res = @Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>.create_Success(_20979_materials);
      return res;
      return res;
    }
    public KeyringDefs.Keyring _keyring;public KeyringDefs.Keyring keyring { get {
      return this._keyring;
    } }
  }

} // end of namespace DefaultCMMDef
namespace MessageBody_Compile {











  public abstract class BodyAADContent {
    public BodyAADContent() { }
    private static readonly BodyAADContent theDefault = create_AADRegularFrame();
    public static BodyAADContent Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<MessageBody_Compile.BodyAADContent> _TYPE = new Dafny.TypeDescriptor<MessageBody_Compile.BodyAADContent>(MessageBody_Compile.BodyAADContent.Default());
    public static Dafny.TypeDescriptor<MessageBody_Compile.BodyAADContent> _TypeDescriptor() {
      return _TYPE;
    }
    public static BodyAADContent create_AADRegularFrame() {
      return new BodyAADContent_AADRegularFrame();
    }
    public static BodyAADContent create_AADFinalFrame() {
      return new BodyAADContent_AADFinalFrame();
    }
    public static BodyAADContent create_AADSingleBlock() {
      return new BodyAADContent_AADSingleBlock();
    }
    public bool is_AADRegularFrame { get { return this is BodyAADContent_AADRegularFrame; } }
    public bool is_AADFinalFrame { get { return this is BodyAADContent_AADFinalFrame; } }
    public bool is_AADSingleBlock { get { return this is BodyAADContent_AADSingleBlock; } }
    public static System.Collections.Generic.IEnumerable<BodyAADContent> AllSingletonConstructors {
      get {
        yield return BodyAADContent.create_AADRegularFrame();
        yield return BodyAADContent.create_AADFinalFrame();
        yield return BodyAADContent.create_AADSingleBlock();
      }
    }
  }
  public class BodyAADContent_AADRegularFrame : BodyAADContent {
    public BodyAADContent_AADRegularFrame() {
    }
    public override bool Equals(object other) {
      var oth = other as MessageBody_Compile.BodyAADContent_AADRegularFrame;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      return (int) hash;
    }
    public override string ToString() {
      string s = "MessageBody_Compile.BodyAADContent.AADRegularFrame";
      return s;
    }
  }
  public class BodyAADContent_AADFinalFrame : BodyAADContent {
    public BodyAADContent_AADFinalFrame() {
    }
    public override bool Equals(object other) {
      var oth = other as MessageBody_Compile.BodyAADContent_AADFinalFrame;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      return (int) hash;
    }
    public override string ToString() {
      string s = "MessageBody_Compile.BodyAADContent.AADFinalFrame";
      return s;
    }
  }
  public class BodyAADContent_AADSingleBlock : BodyAADContent {
    public BodyAADContent_AADSingleBlock() {
    }
    public override bool Equals(object other) {
      var oth = other as MessageBody_Compile.BodyAADContent_AADSingleBlock;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 2;
      return (int) hash;
    }
    public override string ToString() {
      string s = "MessageBody_Compile.BodyAADContent.AADSingleBlock";
      return s;
    }
  }

  public abstract class Frame {
    public Frame() { }
    private static readonly Frame theDefault = create_RegularFrame(0, Dafny.Sequence<byte>.Empty, Dafny.Sequence<byte>.Empty, Dafny.Sequence<byte>.Empty);
    public static Frame Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<MessageBody_Compile.Frame> _TYPE = new Dafny.TypeDescriptor<MessageBody_Compile.Frame>(MessageBody_Compile.Frame.Default());
    public static Dafny.TypeDescriptor<MessageBody_Compile.Frame> _TypeDescriptor() {
      return _TYPE;
    }
    public static Frame create_RegularFrame(uint seqNum, Dafny.ISequence<byte> iv, Dafny.ISequence<byte> encContent, Dafny.ISequence<byte> authTag) {
      return new Frame_RegularFrame(seqNum, iv, encContent, authTag);
    }
    public static Frame create_FinalFrame(uint seqNum, Dafny.ISequence<byte> iv, Dafny.ISequence<byte> encContent, Dafny.ISequence<byte> authTag) {
      return new Frame_FinalFrame(seqNum, iv, encContent, authTag);
    }
    public bool is_RegularFrame { get { return this is Frame_RegularFrame; } }
    public bool is_FinalFrame { get { return this is Frame_FinalFrame; } }
    public uint dtor_seqNum {
      get {
        var d = this;
        if (d is Frame_RegularFrame) { return ((Frame_RegularFrame)d).seqNum; }
        return ((Frame_FinalFrame)d).seqNum; 
      }
    }
    public Dafny.ISequence<byte> dtor_iv {
      get {
        var d = this;
        if (d is Frame_RegularFrame) { return ((Frame_RegularFrame)d).iv; }
        return ((Frame_FinalFrame)d).iv; 
      }
    }
    public Dafny.ISequence<byte> dtor_encContent {
      get {
        var d = this;
        if (d is Frame_RegularFrame) { return ((Frame_RegularFrame)d).encContent; }
        return ((Frame_FinalFrame)d).encContent; 
      }
    }
    public Dafny.ISequence<byte> dtor_authTag {
      get {
        var d = this;
        if (d is Frame_RegularFrame) { return ((Frame_RegularFrame)d).authTag; }
        return ((Frame_FinalFrame)d).authTag; 
      }
    }
  }
  public class Frame_RegularFrame : Frame {
    public readonly uint seqNum;
    public readonly Dafny.ISequence<byte> iv;
    public readonly Dafny.ISequence<byte> encContent;
    public readonly Dafny.ISequence<byte> authTag;
    public Frame_RegularFrame(uint seqNum, Dafny.ISequence<byte> iv, Dafny.ISequence<byte> encContent, Dafny.ISequence<byte> authTag) {
      this.seqNum = seqNum;
      this.iv = iv;
      this.encContent = encContent;
      this.authTag = authTag;
    }
    public override bool Equals(object other) {
      var oth = other as MessageBody_Compile.Frame_RegularFrame;
      return oth != null && this.seqNum == oth.seqNum && object.Equals(this.iv, oth.iv) && object.Equals(this.encContent, oth.encContent) && object.Equals(this.authTag, oth.authTag);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.seqNum));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.iv));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.encContent));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.authTag));
      return (int) hash;
    }
    public override string ToString() {
      string s = "MessageBody_Compile.Frame.RegularFrame";
      s += "(";
      s += Dafny.Helpers.ToString(this.seqNum);
      s += ", ";
      s += Dafny.Helpers.ToString(this.iv);
      s += ", ";
      s += Dafny.Helpers.ToString(this.encContent);
      s += ", ";
      s += Dafny.Helpers.ToString(this.authTag);
      s += ")";
      return s;
    }
  }
  public class Frame_FinalFrame : Frame {
    public readonly uint seqNum;
    public readonly Dafny.ISequence<byte> iv;
    public readonly Dafny.ISequence<byte> encContent;
    public readonly Dafny.ISequence<byte> authTag;
    public Frame_FinalFrame(uint seqNum, Dafny.ISequence<byte> iv, Dafny.ISequence<byte> encContent, Dafny.ISequence<byte> authTag) {
      this.seqNum = seqNum;
      this.iv = iv;
      this.encContent = encContent;
      this.authTag = authTag;
    }
    public override bool Equals(object other) {
      var oth = other as MessageBody_Compile.Frame_FinalFrame;
      return oth != null && this.seqNum == oth.seqNum && object.Equals(this.iv, oth.iv) && object.Equals(this.encContent, oth.encContent) && object.Equals(this.authTag, oth.authTag);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.seqNum));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.iv));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.encContent));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.authTag));
      return (int) hash;
    }
    public override string ToString() {
      string s = "MessageBody_Compile.Frame.FinalFrame";
      s += "(";
      s += Dafny.Helpers.ToString(this.seqNum);
      s += ", ";
      s += Dafny.Helpers.ToString(this.iv);
      s += ", ";
      s += Dafny.Helpers.ToString(this.encContent);
      s += ", ";
      s += Dafny.Helpers.ToString(this.authTag);
      s += ")";
      return s;
    }
  }

  public class SeqWithGhostFrames {
    public readonly Dafny.ISequence<byte> sequence;
    public SeqWithGhostFrames(Dafny.ISequence<byte> sequence) {
      this.sequence = sequence;
    }
    public override bool Equals(object other) {
      var oth = other as MessageBody_Compile.SeqWithGhostFrames;
      return oth != null && object.Equals(this.sequence, oth.sequence);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.sequence));
      return (int) hash;
    }
    public override string ToString() {
      string s = "MessageBody_Compile.SeqWithGhostFrames.SeqWithGhostFrames";
      s += "(";
      s += Dafny.Helpers.ToString(this.sequence);
      s += ")";
      return s;
    }
    private static readonly SeqWithGhostFrames theDefault = create(Dafny.Sequence<byte>.Empty);
    public static SeqWithGhostFrames Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<MessageBody_Compile.SeqWithGhostFrames> _TYPE = new Dafny.TypeDescriptor<MessageBody_Compile.SeqWithGhostFrames>(MessageBody_Compile.SeqWithGhostFrames.Default());
    public static Dafny.TypeDescriptor<MessageBody_Compile.SeqWithGhostFrames> _TypeDescriptor() {
      return _TYPE;
    }
    public static SeqWithGhostFrames create(Dafny.ISequence<byte> sequence) {
      return new SeqWithGhostFrames(sequence);
    }
    public bool is_SeqWithGhostFrames { get { return true; } }
    public Dafny.ISequence<byte> dtor_sequence {
      get {
        return this.sequence;
      }
    }
  }

  public class FrameWithGhostSeq {
    public readonly MessageBody_Compile.Frame frame;
    public FrameWithGhostSeq(MessageBody_Compile.Frame frame) {
      this.frame = frame;
    }
    public override bool Equals(object other) {
      var oth = other as MessageBody_Compile.FrameWithGhostSeq;
      return oth != null && object.Equals(this.frame, oth.frame);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.frame));
      return (int) hash;
    }
    public override string ToString() {
      string s = "MessageBody_Compile.FrameWithGhostSeq.FrameWithGhostSeq";
      s += "(";
      s += Dafny.Helpers.ToString(this.frame);
      s += ")";
      return s;
    }
    private static readonly FrameWithGhostSeq theDefault = create(MessageBody_Compile.Frame.Default());
    public static FrameWithGhostSeq Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<MessageBody_Compile.FrameWithGhostSeq> _TYPE = new Dafny.TypeDescriptor<MessageBody_Compile.FrameWithGhostSeq>(MessageBody_Compile.FrameWithGhostSeq.Default());
    public static Dafny.TypeDescriptor<MessageBody_Compile.FrameWithGhostSeq> _TypeDescriptor() {
      return _TYPE;
    }
    public static FrameWithGhostSeq create(MessageBody_Compile.Frame frame) {
      return new FrameWithGhostSeq(frame);
    }
    public bool is_FrameWithGhostSeq { get { return true; } }
    public MessageBody_Compile.Frame dtor_frame {
      get {
        return this.frame;
      }
    }
  }

  public partial class __default {
    public static Dafny.ISequence<char> BodyAADContentTypeString(MessageBody_Compile.BodyAADContent bc) {
      MessageBody_Compile.BodyAADContent _source19 = bc;
      if (_source19.is_AADRegularFrame) {
        return MessageBody_Compile.__default.BODY__AAD__CONTENT__REGULAR__FRAME;
      } else if (_source19.is_AADFinalFrame) {
        return MessageBody_Compile.__default.BODY__AAD__CONTENT__FINAL__FRAME;
      } else {
        return MessageBody_Compile.__default.BODY__AAD__CONTENT__SINGLE__BLOCK;
      }
    }
    public static Dafny.ISequence<byte> IVSeq(ushort algorithmSuiteID, uint sequenceNumber)
    {
      return Dafny.Sequence<byte>.Concat(((System.Func<Dafny.ISequence<byte>>) (() => {
        BigInteger dim8 = (AlgorithmSuite.ID.IVLength(algorithmSuiteID)) - (new BigInteger(4));
        var arr8 = new byte[Dafny.Helpers.ToIntChecked(dim8,"C# array size must not be larger than max 32-bit int")];
        for (int i8 = 0; i8 < dim8; i8++) {
          var _20981___v0 = (BigInteger) i8;
          arr8[(int)(_20981___v0)] = 0;
        }
        return Dafny.Sequence<byte>.FromArray(arr8);
      }))(), StandardLibrary_mUInt_Compile.__default.UInt32ToSeq(sequenceNumber));
    }
    public static Wrappers_Compile.Result<MessageBody_Compile.SeqWithGhostFrames, Dafny.ISequence<char>> EncryptMessageBody(Dafny.ISequence<byte> plaintext, BigInteger frameLength, Dafny.ISequence<byte> messageID, Dafny.ISequence<byte> key, ushort algorithmSuiteID)
    {
      Wrappers_Compile.Result<MessageBody_Compile.SeqWithGhostFrames, Dafny.ISequence<char>> result = Wrappers_Compile.Result<MessageBody_Compile.SeqWithGhostFrames, Dafny.ISequence<char>>.Default(MessageBody_Compile.SeqWithGhostFrames.Default());
      Dafny.ISequence<byte> _20982_body;
      _20982_body = Dafny.Sequence<byte>.FromElements();
      BigInteger _20983_n;
      uint _20984_sequenceNumber;
      BigInteger _rhs2 = BigInteger.Zero;
      uint _rhs3 = MessageBody_Compile.__default.START__SEQUENCE__NUMBER;
      _20983_n = _rhs2;
      _20984_sequenceNumber = _rhs3;
      while (((_20983_n) + (frameLength)) < (new BigInteger((plaintext).Count))) {
        if ((_20984_sequenceNumber) == (MessageBody_Compile.__default.ENDFRAME__SEQUENCE__NUMBER)) {
          result = @Wrappers_Compile.Result<MessageBody_Compile.SeqWithGhostFrames, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("too many frames"));
          return result;
        }
        Dafny.ISequence<byte> _20985_plaintextFrame;
        _20985_plaintextFrame = (plaintext).Subsequence(_20983_n, (_20983_n) + (frameLength));
        Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _20986_regularFrame;
        Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out69;
        _out69 = MessageBody_Compile.__default.EncryptRegularFrame(algorithmSuiteID, key, messageID, _20985_plaintextFrame, _20984_sequenceNumber);
        _20986_regularFrame = _out69;
        if ((_20986_regularFrame).IsFailure()) {
          result = (_20986_regularFrame).PropagateFailure<MessageBody_Compile.SeqWithGhostFrames>();
          return result;
        }
        _20982_body = Dafny.Sequence<byte>.Concat(_20982_body, (_20986_regularFrame).Extract());
        BigInteger _rhs4 = (_20983_n) + (frameLength);
        uint _rhs5 = (_20984_sequenceNumber) + (1U);
        _20983_n = _rhs4;
        _20984_sequenceNumber = _rhs5;
      }
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _20987_finalFrameResult;
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out70;
      _out70 = MessageBody_Compile.__default.EncryptFinalFrame(algorithmSuiteID, key, frameLength, messageID, (plaintext).Drop(_20983_n), _20984_sequenceNumber);
      _20987_finalFrameResult = _out70;
      if ((_20987_finalFrameResult).IsFailure()) {
        result = (_20987_finalFrameResult).PropagateFailure<MessageBody_Compile.SeqWithGhostFrames>();
        return result;
      }
      Dafny.ISequence<byte> _20988_finalFrameSequence;
      _20988_finalFrameSequence = (_20987_finalFrameResult).Extract();
      _20982_body = Dafny.Sequence<byte>.Concat(_20982_body, _20988_finalFrameSequence);
      result = @Wrappers_Compile.Result<MessageBody_Compile.SeqWithGhostFrames, Dafny.ISequence<char>>.create_Success(@MessageBody_Compile.SeqWithGhostFrames.create(_20982_body));
      return result;
    }
    public static Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> EncryptRegularFrame(ushort algorithmSuiteID, Dafny.ISequence<byte> key, Dafny.ISequence<byte> messageID, Dafny.ISequence<byte> plaintext, uint sequenceNumber)
    {
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> res = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      Dafny.ISequence<byte> _20989_seqNumSeq;
      _20989_seqNumSeq = StandardLibrary_mUInt_Compile.__default.UInt32ToSeq(sequenceNumber);
      Dafny.ISequence<byte> _20990_unauthenticatedFrame;
      _20990_unauthenticatedFrame = _20989_seqNumSeq;
      Dafny.ISequence<byte> _20991_iv;
      _20991_iv = MessageBody_Compile.__default.IVSeq(algorithmSuiteID, sequenceNumber);
      Dafny.ISequence<byte> _20992_aad;
      Dafny.ISequence<byte> _out71;
      _out71 = MessageBody_Compile.__default.BodyAAD(messageID, @MessageBody_Compile.BodyAADContent.create_AADRegularFrame(), sequenceNumber, (ulong)(plaintext).LongCount);
      _20992_aad = _out71;
      Wrappers_Compile.Result<AESEncryption.EncryptionOutput, Dafny.ISequence<char>> _20993_encryptionOutputResult;
      Wrappers_Compile.Result<AESEncryption.EncryptionOutput, Dafny.ISequence<char>> _out72;
      _out72 = AESEncryption.__default.AESEncrypt(AlgorithmSuite.ID.EncryptionSuite(algorithmSuiteID), _20991_iv, key, plaintext, _20992_aad);
      _20993_encryptionOutputResult = _out72;
      if ((_20993_encryptionOutputResult).IsFailure()) {
        res = (_20993_encryptionOutputResult).PropagateFailure<Dafny.ISequence<byte>>();
        return res;
      }
      AESEncryption.EncryptionOutput _20994_encryptionOutput;
      _20994_encryptionOutput = (_20993_encryptionOutputResult).Extract();
      _20990_unauthenticatedFrame = Dafny.Sequence<byte>.Concat(_20990_unauthenticatedFrame, _20991_iv);
      _20990_unauthenticatedFrame = Dafny.Sequence<byte>.Concat(Dafny.Sequence<byte>.Concat(_20990_unauthenticatedFrame, (_20994_encryptionOutput).dtor_cipherText), (_20994_encryptionOutput).dtor_authTag);
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _rhs6 = @Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.create_Success(_20990_unauthenticatedFrame);
      res = _rhs6;
      return res;
      return res;
    }
    public static Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> EncryptFinalFrame(ushort algorithmSuiteID, Dafny.ISequence<byte> key, BigInteger frameLength, Dafny.ISequence<byte> messageID, Dafny.ISequence<byte> plaintext, uint sequenceNumber)
    {
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> res = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      Dafny.ISequence<byte> _20995_unauthenticatedFrame;
      _20995_unauthenticatedFrame = StandardLibrary_mUInt_Compile.__default.UInt32ToSeq(MessageBody_Compile.__default.ENDFRAME__SEQUENCE__NUMBER);
      Dafny.ISequence<byte> _20996_seqNumSeq;
      _20996_seqNumSeq = StandardLibrary_mUInt_Compile.__default.UInt32ToSeq(sequenceNumber);
      _20995_unauthenticatedFrame = Dafny.Sequence<byte>.Concat(_20995_unauthenticatedFrame, _20996_seqNumSeq);
      Dafny.ISequence<byte> _20997_iv;
      _20997_iv = MessageBody_Compile.__default.IVSeq(algorithmSuiteID, sequenceNumber);
      _20995_unauthenticatedFrame = Dafny.Sequence<byte>.Concat(_20995_unauthenticatedFrame, _20997_iv);
      _20995_unauthenticatedFrame = Dafny.Sequence<byte>.Concat(_20995_unauthenticatedFrame, StandardLibrary_mUInt_Compile.__default.UInt32ToSeq((uint)(plaintext).LongCount));
      Dafny.ISequence<byte> _20998_aad;
      Dafny.ISequence<byte> _out73;
      _out73 = MessageBody_Compile.__default.BodyAAD(messageID, @MessageBody_Compile.BodyAADContent.create_AADFinalFrame(), sequenceNumber, (ulong)(plaintext).LongCount);
      _20998_aad = _out73;
      Wrappers_Compile.Result<AESEncryption.EncryptionOutput, Dafny.ISequence<char>> _20999_encryptionOutputResult;
      Wrappers_Compile.Result<AESEncryption.EncryptionOutput, Dafny.ISequence<char>> _out74;
      _out74 = AESEncryption.__default.AESEncrypt(AlgorithmSuite.ID.EncryptionSuite(algorithmSuiteID), _20997_iv, key, plaintext, _20998_aad);
      _20999_encryptionOutputResult = _out74;
      if ((_20999_encryptionOutputResult).IsFailure()) {
        res = (_20999_encryptionOutputResult).PropagateFailure<Dafny.ISequence<byte>>();
        return res;
      }
      AESEncryption.EncryptionOutput _21000_encryptionOutput;
      _21000_encryptionOutput = (_20999_encryptionOutputResult).Extract();
      _20995_unauthenticatedFrame = Dafny.Sequence<byte>.Concat(Dafny.Sequence<byte>.Concat(_20995_unauthenticatedFrame, (_21000_encryptionOutput).dtor_cipherText), (_21000_encryptionOutput).dtor_authTag);
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _rhs7 = @Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.create_Success(_20995_unauthenticatedFrame);
      res = _rhs7;
      return res;
      return res;
    }
    public static Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> DecryptFramedMessageBody(Streams_Compile.ByteReader rd, ushort algorithmSuiteID, Dafny.ISequence<byte> key, BigInteger frameLength, Dafny.ISequence<byte> messageID)
    {
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> res = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      Dafny.ISequence<byte> _21001_plaintext;
      _21001_plaintext = Dafny.Sequence<byte>.FromElements();
      uint _21002_n;
      _21002_n = 1U;
      while (true) {
        MessageBody_Compile.FrameWithGhostSeq _21003_frameWithGhostSeq = MessageBody_Compile.FrameWithGhostSeq.Default();
        Wrappers_Compile.Result<MessageBody_Compile.FrameWithGhostSeq, Dafny.ISequence<char>> _21004_valueOrError0 = Wrappers_Compile.Result<MessageBody_Compile.FrameWithGhostSeq, Dafny.ISequence<char>>.Default(MessageBody_Compile.FrameWithGhostSeq.Default());
        Wrappers_Compile.Result<MessageBody_Compile.FrameWithGhostSeq, Dafny.ISequence<char>> _out75;
        _out75 = MessageBody_Compile.__default.DecryptFrame(rd, algorithmSuiteID, key, frameLength, messageID, _21002_n);
        _21004_valueOrError0 = _out75;
        if ((_21004_valueOrError0).IsFailure()) {
          res = (_21004_valueOrError0).PropagateFailure<Dafny.ISequence<byte>>();
          return res;
        }
        _21003_frameWithGhostSeq = (_21004_valueOrError0).Extract();
        MessageBody_Compile.Frame _21005_decryptedFrame;
        _21005_decryptedFrame = (_21003_frameWithGhostSeq).dtor_frame;
        _System.Tuple2<Dafny.ISequence<byte>, bool> _let_tmp_rhs1 = @_System.Tuple2<Dafny.ISequence<byte>, bool>.create((_21005_decryptedFrame).dtor_encContent, (_21005_decryptedFrame).is_FinalFrame);
        Dafny.ISequence<byte> _21006_decryptedFramePlaintext = ((_System.Tuple2<Dafny.ISequence<byte>, bool>)_let_tmp_rhs1)._0;
        bool _21007_final = ((_System.Tuple2<Dafny.ISequence<byte>, bool>)_let_tmp_rhs1)._1;
        _21001_plaintext = Dafny.Sequence<byte>.Concat(_21001_plaintext, _21006_decryptedFramePlaintext);
        if (_21007_final) {
          goto after_0;
        }
        _21002_n = (_21002_n) + (1U);
      }
    after_0: ;
      res = @Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.create_Success(_21001_plaintext);
      return res;
      return res;
    }
    public static Wrappers_Compile.Result<MessageBody_Compile.FrameWithGhostSeq, Dafny.ISequence<char>> DecryptFrame(Streams_Compile.ByteReader rd, ushort algorithmSuiteID, Dafny.ISequence<byte> key, BigInteger frameLength, Dafny.ISequence<byte> messageID, uint expectedSequenceNumber)
    {
      Wrappers_Compile.Result<MessageBody_Compile.FrameWithGhostSeq, Dafny.ISequence<char>> res = Wrappers_Compile.Result<MessageBody_Compile.FrameWithGhostSeq, Dafny.ISequence<char>>.Default(MessageBody_Compile.FrameWithGhostSeq.Default());
      bool _21008_final;
      _21008_final = false;
      uint _21009_sequenceNumber = 0;
      Wrappers_Compile.Result<uint, Dafny.ISequence<char>> _21010_valueOrError0 = Wrappers_Compile.Result<uint, Dafny.ISequence<char>>.Default(0);
      Wrappers_Compile.Result<uint, Dafny.ISequence<char>> _out76;
      _out76 = (rd).ReadUInt32();
      _21010_valueOrError0 = _out76;
      if ((_21010_valueOrError0).IsFailure()) {
        res = (_21010_valueOrError0).PropagateFailure<MessageBody_Compile.FrameWithGhostSeq>();
        return res;
      }
      _21009_sequenceNumber = (_21010_valueOrError0).Extract();
      if ((_21009_sequenceNumber) == (MessageBody_Compile.__default.ENDFRAME__SEQUENCE__NUMBER)) {
        _21008_final = true;
        Wrappers_Compile.Result<uint, Dafny.ISequence<char>> _21011_valueOrError1 = Wrappers_Compile.Result<uint, Dafny.ISequence<char>>.Default(0);
        Wrappers_Compile.Result<uint, Dafny.ISequence<char>> _out77;
        _out77 = (rd).ReadUInt32();
        _21011_valueOrError1 = _out77;
        if ((_21011_valueOrError1).IsFailure()) {
          res = (_21011_valueOrError1).PropagateFailure<MessageBody_Compile.FrameWithGhostSeq>();
          return res;
        }
        _21009_sequenceNumber = (_21011_valueOrError1).Extract();
      }
      if ((_21009_sequenceNumber) != (expectedSequenceNumber)) {
        res = @Wrappers_Compile.Result<MessageBody_Compile.FrameWithGhostSeq, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("unexpected frame sequence number"));
        return res;
      }
      Dafny.ISequence<byte> _21012_iv = Dafny.Sequence<byte>.Empty;
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _21013_valueOrError2 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out78;
      _out78 = (rd).ReadBytes(AlgorithmSuite.ID.IVLength(algorithmSuiteID));
      _21013_valueOrError2 = _out78;
      if ((_21013_valueOrError2).IsFailure()) {
        res = (_21013_valueOrError2).PropagateFailure<MessageBody_Compile.FrameWithGhostSeq>();
        return res;
      }
      _21012_iv = (_21013_valueOrError2).Extract();
      uint _21014_len;
      _21014_len = (uint)(frameLength);
      if (_21008_final) {
        Wrappers_Compile.Result<uint, Dafny.ISequence<char>> _21015_valueOrError3 = Wrappers_Compile.Result<uint, Dafny.ISequence<char>>.Default(0);
        Wrappers_Compile.Result<uint, Dafny.ISequence<char>> _out79;
        _out79 = (rd).ReadUInt32();
        _21015_valueOrError3 = _out79;
        if ((_21015_valueOrError3).IsFailure()) {
          res = (_21015_valueOrError3).PropagateFailure<MessageBody_Compile.FrameWithGhostSeq>();
          return res;
        }
        _21014_len = (_21015_valueOrError3).Extract();
        if ((_21014_len) > ((uint)(frameLength))) {
          res = @Wrappers_Compile.Result<MessageBody_Compile.FrameWithGhostSeq, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Final frame too long"));
          return res;
        }
      }
      Dafny.ISequence<byte> _21016_aad;
      Dafny.ISequence<byte> _out80;
      _out80 = MessageBody_Compile.__default.BodyAAD(messageID, ((_21008_final) ? (@MessageBody_Compile.BodyAADContent.create_AADFinalFrame()) : (@MessageBody_Compile.BodyAADContent.create_AADRegularFrame())), _21009_sequenceNumber, (ulong)(_21014_len));
      _21016_aad = _out80;
      Dafny.ISequence<byte> _21017_ciphertext = Dafny.Sequence<byte>.Empty;
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _21018_valueOrError4 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out81;
      _out81 = (rd).ReadBytes(new BigInteger(_21014_len));
      _21018_valueOrError4 = _out81;
      if ((_21018_valueOrError4).IsFailure()) {
        res = (_21018_valueOrError4).PropagateFailure<MessageBody_Compile.FrameWithGhostSeq>();
        return res;
      }
      _21017_ciphertext = (_21018_valueOrError4).Extract();
      Dafny.ISequence<byte> _21019_authTag = Dafny.Sequence<byte>.Empty;
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _21020_valueOrError5 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out82;
      _out82 = (rd).ReadBytes(AlgorithmSuite.ID.TagLength(algorithmSuiteID));
      _21020_valueOrError5 = _out82;
      if ((_21020_valueOrError5).IsFailure()) {
        res = (_21020_valueOrError5).PropagateFailure<MessageBody_Compile.FrameWithGhostSeq>();
        return res;
      }
      _21019_authTag = (_21020_valueOrError5).Extract();
      Dafny.ISequence<byte> _21021_plaintext = Dafny.Sequence<byte>.Empty;
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _21022_valueOrError6 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out83;
      _out83 = MessageBody_Compile.__default.Decrypt(_21017_ciphertext, _21019_authTag, algorithmSuiteID, _21012_iv, key, _21016_aad);
      _21022_valueOrError6 = _out83;
      if ((_21022_valueOrError6).IsFailure()) {
        res = (_21022_valueOrError6).PropagateFailure<MessageBody_Compile.FrameWithGhostSeq>();
        return res;
      }
      _21021_plaintext = (_21022_valueOrError6).Extract();
      MessageBody_Compile.Frame _21023_frame;
      _21023_frame = ((_21008_final) ? (@MessageBody_Compile.Frame.create_FinalFrame(_21009_sequenceNumber, _21012_iv, _21021_plaintext, _21019_authTag)) : (@MessageBody_Compile.Frame.create_RegularFrame(_21009_sequenceNumber, _21012_iv, _21021_plaintext, _21019_authTag)));
      res = @Wrappers_Compile.Result<MessageBody_Compile.FrameWithGhostSeq, Dafny.ISequence<char>>.create_Success(@MessageBody_Compile.FrameWithGhostSeq.create(_21023_frame));
      return res;
      return res;
    }
    public static Dafny.ISequence<byte> BodyAAD(Dafny.ISequence<byte> messageID, MessageBody_Compile.BodyAADContent bc, uint sequenceNumber, ulong length)
    {
      Dafny.ISequence<byte> aad = Dafny.Sequence<byte>.Empty;
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _21024_contentAAD;
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out84;
      _out84 = UTF8.__default.Encode(MessageBody_Compile.__default.BodyAADContentTypeString(bc));
      _21024_contentAAD = _out84;
      aad = Dafny.Sequence<byte>.Concat(Dafny.Sequence<byte>.Concat(Dafny.Sequence<byte>.Concat(messageID, (_21024_contentAAD).dtor_value), StandardLibrary_mUInt_Compile.__default.UInt32ToSeq(sequenceNumber)), StandardLibrary_mUInt_Compile.__default.UInt64ToSeq(length));
      return aad;
    }
    public static Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> Decrypt(Dafny.ISequence<byte> ciphertext, Dafny.ISequence<byte> authTag, ushort algorithmSuiteID, Dafny.ISequence<byte> iv, Dafny.ISequence<byte> key, Dafny.ISequence<byte> aad)
    {
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> res = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      EncryptionSuites.EncryptionSuite _21025_encAlg;
      _21025_encAlg = AlgorithmSuite.ID.EncryptionSuite(algorithmSuiteID);
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out85;
      _out85 = AESEncryption.__default.AESDecrypt(_21025_encAlg, key, ciphertext, authTag, iv, aad);
      res = _out85;
      return res;
    }
    public static Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> DecryptNonFramedMessageBody(Streams_Compile.ByteReader rd, ushort algorithmSuiteID, Dafny.ISequence<byte> key, Dafny.ISequence<byte> messageID)
    {
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> res = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      Dafny.ISequence<byte> _21026_iv = Dafny.Sequence<byte>.Empty;
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _21027_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out86;
      _out86 = (rd).ReadBytes(AlgorithmSuite.ID.IVLength(algorithmSuiteID));
      _21027_valueOrError0 = _out86;
      if ((_21027_valueOrError0).IsFailure()) {
        res = (_21027_valueOrError0).PropagateFailure<Dafny.ISequence<byte>>();
        return res;
      }
      _21026_iv = (_21027_valueOrError0).Extract();
      ulong _21028_contentLength = 0;
      Wrappers_Compile.Result<ulong, Dafny.ISequence<char>> _21029_valueOrError1 = Wrappers_Compile.Result<ulong, Dafny.ISequence<char>>.Default(0);
      Wrappers_Compile.Result<ulong, Dafny.ISequence<char>> _out87;
      _out87 = (rd).ReadUInt64();
      _21029_valueOrError1 = _out87;
      if ((_21029_valueOrError1).IsFailure()) {
        res = (_21029_valueOrError1).PropagateFailure<Dafny.ISequence<byte>>();
        return res;
      }
      _21028_contentLength = (_21029_valueOrError1).Extract();
      Dafny.ISequence<byte> _21030_ciphertext = Dafny.Sequence<byte>.Empty;
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _21031_valueOrError2 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out88;
      _out88 = (rd).ReadBytes(new BigInteger(_21028_contentLength));
      _21031_valueOrError2 = _out88;
      if ((_21031_valueOrError2).IsFailure()) {
        res = (_21031_valueOrError2).PropagateFailure<Dafny.ISequence<byte>>();
        return res;
      }
      _21030_ciphertext = (_21031_valueOrError2).Extract();
      Dafny.ISequence<byte> _21032_authTag = Dafny.Sequence<byte>.Empty;
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _21033_valueOrError3 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out89;
      _out89 = (rd).ReadBytes(AlgorithmSuite.ID.TagLength(algorithmSuiteID));
      _21033_valueOrError3 = _out89;
      if ((_21033_valueOrError3).IsFailure()) {
        res = (_21033_valueOrError3).PropagateFailure<Dafny.ISequence<byte>>();
        return res;
      }
      _21032_authTag = (_21033_valueOrError3).Extract();
      Dafny.ISequence<byte> _21034_aad;
      Dafny.ISequence<byte> _out90;
      _out90 = MessageBody_Compile.__default.BodyAAD(messageID, @MessageBody_Compile.BodyAADContent.create_AADSingleBlock(), MessageBody_Compile.__default.NONFRAMED__SEQUENCE__NUMBER, _21028_contentLength);
      _21034_aad = _out90;
      Dafny.ISequence<byte> _21035_plaintext = Dafny.Sequence<byte>.Empty;
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _21036_valueOrError4 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out91;
      _out91 = MessageBody_Compile.__default.Decrypt(_21030_ciphertext, _21032_authTag, algorithmSuiteID, _21026_iv, key, _21034_aad);
      _21036_valueOrError4 = _out91;
      if ((_21036_valueOrError4).IsFailure()) {
        res = (_21036_valueOrError4).PropagateFailure<Dafny.ISequence<byte>>();
        return res;
      }
      _21035_plaintext = (_21036_valueOrError4).Extract();
      res = @Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.create_Success(_21035_plaintext);
      return res;
      return res;
    }
    public static uint START__SEQUENCE__NUMBER { get {
      return 1U;
    } }
    public static Dafny.ISequence<char> BODY__AAD__CONTENT__REGULAR__FRAME { get {
      return Dafny.Sequence<char>.FromString("AWSKMSEncryptionClient Frame");
    } }
    public static Dafny.ISequence<char> BODY__AAD__CONTENT__FINAL__FRAME { get {
      return Dafny.Sequence<char>.FromString("AWSKMSEncryptionClient Final Frame");
    } }
    public static Dafny.ISequence<char> BODY__AAD__CONTENT__SINGLE__BLOCK { get {
      return Dafny.Sequence<char>.FromString("AWSKMSEncryptionClient Single Block");
    } }
    public static uint ENDFRAME__SEQUENCE__NUMBER { get {
      return 4294967295U;
    } }
    public static uint NONFRAMED__SEQUENCE__NUMBER { get {
      return 1U;
    } }
  }
} // end of namespace MessageBody_Compile
namespace Serialize_Compile {










  public partial class __default {
    public static Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>> SerializeHeaderBody(Streams_Compile.ByteWriter wr, MessageHeader.HeaderBody hb)
    {
      Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>> ret = Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>>.Default(BigInteger.Zero);
      BigInteger _21037_totalWritten;
      _21037_totalWritten = BigInteger.Zero;
      BigInteger _21038_len;
      BigInteger _out92;
      _out92 = (wr).WriteByte((byte)((hb).dtor_version));
      _21038_len = _out92;
      _21037_totalWritten = (_21037_totalWritten) + (_21038_len);
      BigInteger _out93;
      _out93 = (wr).WriteByte((byte)((hb).dtor_typ));
      _21038_len = _out93;
      _21037_totalWritten = (_21037_totalWritten) + (_21038_len);
      BigInteger _out94;
      _out94 = (wr).WriteUInt16((ushort)((hb).dtor_algorithmSuiteID));
      _21038_len = _out94;
      _21037_totalWritten = (_21037_totalWritten) + (_21038_len);
      BigInteger _out95;
      _out95 = (wr).WriteBytes((hb).dtor_messageID);
      _21038_len = _out95;
      _21037_totalWritten = (_21037_totalWritten) + (_21038_len);
      Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>> _21039_valueOrError0 = Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>>.Default(BigInteger.Zero);
      Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>> _out96;
      _out96 = Serialize_Compile.__default.SerializeAAD(wr, (hb).dtor_aad);
      _21039_valueOrError0 = _out96;
      if ((_21039_valueOrError0).IsFailure()) {
        ret = (_21039_valueOrError0).PropagateFailure<BigInteger>();
        return ret;
      }
      _21038_len = (_21039_valueOrError0).Extract();
      _21037_totalWritten = (_21037_totalWritten) + (_21038_len);
      BigInteger _out97;
      _out97 = Serialize_Compile.__default.SerializeEDKs(wr, (hb).dtor_encryptedDataKeys);
      _21038_len = _out97;
      _21037_totalWritten = (_21037_totalWritten) + (_21038_len);
      byte _21040_contentType;
      _21040_contentType = MessageHeader.__default.ContentTypeToUInt8((hb).dtor_contentType);
      BigInteger _out98;
      _out98 = (wr).WriteByte(_21040_contentType);
      _21038_len = _out98;
      _21037_totalWritten = (_21037_totalWritten) + (_21038_len);
      BigInteger _out99;
      _out99 = (wr).WriteBytes(MessageHeader.__default.Reserved);
      _21038_len = _out99;
      _21037_totalWritten = (_21037_totalWritten) + (_21038_len);
      BigInteger _out100;
      _out100 = (wr).WriteByte((hb).dtor_ivLength);
      _21038_len = _out100;
      _21037_totalWritten = (_21037_totalWritten) + (_21038_len);
      BigInteger _out101;
      _out101 = (wr).WriteUInt32((hb).dtor_frameLength);
      _21038_len = _out101;
      _21037_totalWritten = (_21037_totalWritten) + (_21038_len);
      ret = @Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>>.create_Success(_21037_totalWritten);
      return ret;
      return ret;
    }
    public static Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>> SerializeHeaderAuthentication(Streams_Compile.ByteWriter wr, MessageHeader.HeaderAuthentication ha)
    {
      Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>> ret = Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>>.Default(BigInteger.Zero);
      BigInteger _21041_m;
      BigInteger _out102;
      _out102 = (wr).WriteBytes((ha).dtor_iv);
      _21041_m = _out102;
      BigInteger _21042_n;
      BigInteger _out103;
      _out103 = (wr).WriteBytes((ha).dtor_authenticationTag);
      _21042_n = _out103;
      ret = @Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>>.create_Success((_21041_m) + (_21042_n));
      return ret;
      return ret;
    }
    public static Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>> SerializeAAD(Streams_Compile.ByteWriter wr, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> kvPairs)
    {
      Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>> ret = Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>>.Default(BigInteger.Zero);
      BigInteger _21043_totalWritten;
      _21043_totalWritten = BigInteger.Zero;
      BigInteger _21044_kvPairsLength;
      BigInteger _out104;
      _out104 = EncryptionContext.__default.ComputeLength(kvPairs);
      _21044_kvPairsLength = _out104;
      BigInteger _21045_len;
      BigInteger _out105;
      _out105 = (wr).WriteUInt16((ushort)(_21044_kvPairsLength));
      _21045_len = _out105;
      _21043_totalWritten = (_21043_totalWritten) + (_21045_len);
      Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>> _21046_valueOrError0 = Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>>.Default(BigInteger.Zero);
      Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>> _out106;
      _out106 = Serialize_Compile.__default.SerializeKVPairs(wr, kvPairs);
      _21046_valueOrError0 = _out106;
      if ((_21046_valueOrError0).IsFailure()) {
        ret = (_21046_valueOrError0).PropagateFailure<BigInteger>();
        return ret;
      }
      _21045_len = (_21046_valueOrError0).Extract();
      _21043_totalWritten = (_21043_totalWritten) + (_21045_len);
      ret = @Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>>.create_Success(_21043_totalWritten);
      return ret;
      return ret;
    }
    public static Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>> SerializeKVPairs(Streams_Compile.ByteWriter wr, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext)
    {
      Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>> ret = Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>>.Default(BigInteger.Zero);
      BigInteger _21047_newlyWritten;
      _21047_newlyWritten = BigInteger.Zero;
      if ((new BigInteger((encryptionContext).Count)).Sign == 0) {
        ret = @Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>>.create_Success(_21047_newlyWritten);
        return ret;
      }
      BigInteger _21048_len;
      BigInteger _out107;
      _out107 = (wr).WriteUInt16((ushort)(encryptionContext).Count);
      _21048_len = _out107;
      _21047_newlyWritten = (_21047_newlyWritten) + (_21048_len);
      Dafny.ISequence<Dafny.ISequence<byte>> _21049_keys;
      Dafny.ISequence<Dafny.ISequence<byte>> _out108;
      _out108 = Sets.__default.SetToOrderedSequence<byte>((encryptionContext).Keys, StandardLibrary_mUInt_Compile.__default.UInt8Less);
      _21049_keys = _out108;
      BigInteger _21050_j;
      _21050_j = BigInteger.Zero;
      while ((_21050_j) < (new BigInteger((_21049_keys).Count))) {
        Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>> _21051_valueOrError0 = Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>>.Default(BigInteger.Zero);
        Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>> _out109;
        _out109 = Serialize_Compile.__default.SerializeKVPair(wr, (_21049_keys).Select(_21050_j), Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Select(encryptionContext,(_21049_keys).Select(_21050_j)));
        _21051_valueOrError0 = _out109;
        if ((_21051_valueOrError0).IsFailure()) {
          ret = (_21051_valueOrError0).PropagateFailure<BigInteger>();
          return ret;
        }
        _21048_len = (_21051_valueOrError0).Extract();
        _21047_newlyWritten = (_21047_newlyWritten) + (_21048_len);
        _21050_j = (_21050_j) + (BigInteger.One);
      }
      ret = @Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>>.create_Success(_21047_newlyWritten);
      return ret;
      return ret;
    }
    public static Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>> SerializeKVPair(Streams_Compile.ByteWriter wr, Dafny.ISequence<byte> k, Dafny.ISequence<byte> v)
    {
      Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>> ret = Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>>.Default(BigInteger.Zero);
      BigInteger _21052_newlyWritten;
      _21052_newlyWritten = BigInteger.Zero;
      BigInteger _21053_len;
      BigInteger _out110;
      _out110 = (wr).WriteUInt16((ushort)(k).Count);
      _21053_len = _out110;
      _21052_newlyWritten = (_21052_newlyWritten) + (_21053_len);
      BigInteger _out111;
      _out111 = (wr).WriteBytes(k);
      _21053_len = _out111;
      _21052_newlyWritten = (_21052_newlyWritten) + (_21053_len);
      BigInteger _out112;
      _out112 = (wr).WriteUInt16((ushort)(v).Count);
      _21053_len = _out112;
      _21052_newlyWritten = (_21052_newlyWritten) + (_21053_len);
      BigInteger _out113;
      _out113 = (wr).WriteBytes(v);
      _21053_len = _out113;
      _21052_newlyWritten = (_21052_newlyWritten) + (_21053_len);
      ret = @Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>>.create_Success(_21052_newlyWritten);
      return ret;
      return ret;
    }
    public static BigInteger SerializeEDKs(Streams_Compile.ByteWriter wr, MessageHeader.EncryptedDataKeys encryptedDataKeys)
    {
      BigInteger ret = BigInteger.Zero;
      BigInteger _21054_totalWritten;
      _21054_totalWritten = BigInteger.Zero;
      BigInteger _21055_len;
      BigInteger _out114;
      _out114 = (wr).WriteUInt16((ushort)((encryptedDataKeys).dtor_entries).Count);
      _21055_len = _out114;
      _21054_totalWritten = (_21054_totalWritten) + (_21055_len);
      BigInteger _21056_j;
      _21056_j = BigInteger.Zero;
      while ((_21056_j) < (new BigInteger(((encryptedDataKeys).dtor_entries).Count))) {
        Materials.EncryptedDataKey _21057_entry;
        _21057_entry = ((encryptedDataKeys).dtor_entries).Select(_21056_j);
        BigInteger _out115;
        _out115 = (wr).WriteUInt16((ushort)((_21057_entry).dtor_providerID).Count);
        _21055_len = _out115;
        _21054_totalWritten = (_21054_totalWritten) + (_21055_len);
        BigInteger _out116;
        _out116 = (wr).WriteBytes((_21057_entry).dtor_providerID);
        _21055_len = _out116;
        _21054_totalWritten = (_21054_totalWritten) + (_21055_len);
        BigInteger _out117;
        _out117 = (wr).WriteUInt16((ushort)((_21057_entry).dtor_providerInfo).Count);
        _21055_len = _out117;
        _21054_totalWritten = (_21054_totalWritten) + (_21055_len);
        BigInteger _out118;
        _out118 = (wr).WriteBytes((_21057_entry).dtor_providerInfo);
        _21055_len = _out118;
        _21054_totalWritten = (_21054_totalWritten) + (_21055_len);
        BigInteger _out119;
        _out119 = (wr).WriteUInt16((ushort)((_21057_entry).dtor_ciphertext).Count);
        _21055_len = _out119;
        _21054_totalWritten = (_21054_totalWritten) + (_21055_len);
        BigInteger _out120;
        _out120 = (wr).WriteBytes((_21057_entry).dtor_ciphertext);
        _21055_len = _out120;
        _21054_totalWritten = (_21054_totalWritten) + (_21055_len);
        _21056_j = (_21056_j) + (BigInteger.One);
      }
      ret = _21054_totalWritten;
      return ret;
      return ret;
    }
  }
} // end of namespace Serialize_Compile
namespace ESDKClient {




















  public class EncryptRequest {
    public readonly Dafny.ISequence<byte> plaintext;
    public readonly CMMDefs.CMM cmm;
    public readonly KeyringDefs.Keyring keyring;
    public readonly BigInteger plaintextLength;
    public readonly Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext;
    public readonly Wrappers_Compile.Option<ushort> algorithmSuiteID;
    public readonly Wrappers_Compile.Option<uint> frameLength;
    public EncryptRequest(Dafny.ISequence<byte> plaintext, CMMDefs.CMM cmm, KeyringDefs.Keyring keyring, BigInteger plaintextLength, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext, Wrappers_Compile.Option<ushort> algorithmSuiteID, Wrappers_Compile.Option<uint> frameLength) {
      this.plaintext = plaintext;
      this.cmm = cmm;
      this.keyring = keyring;
      this.plaintextLength = plaintextLength;
      this.encryptionContext = encryptionContext;
      this.algorithmSuiteID = algorithmSuiteID;
      this.frameLength = frameLength;
    }
    public override bool Equals(object other) {
      var oth = other as ESDKClient.EncryptRequest;
      return oth != null && object.Equals(this.plaintext, oth.plaintext) && this.cmm == oth.cmm && this.keyring == oth.keyring && this.plaintextLength == oth.plaintextLength && object.Equals(this.encryptionContext, oth.encryptionContext) && object.Equals(this.algorithmSuiteID, oth.algorithmSuiteID) && object.Equals(this.frameLength, oth.frameLength);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.plaintext));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.cmm));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.keyring));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.plaintextLength));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.encryptionContext));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.algorithmSuiteID));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.frameLength));
      return (int) hash;
    }
    public override string ToString() {
      string s = "ESDKClient_Compile.EncryptRequest.EncryptRequest";
      s += "(";
      s += Dafny.Helpers.ToString(this.plaintext);
      s += ", ";
      s += Dafny.Helpers.ToString(this.cmm);
      s += ", ";
      s += Dafny.Helpers.ToString(this.keyring);
      s += ", ";
      s += Dafny.Helpers.ToString(this.plaintextLength);
      s += ", ";
      s += Dafny.Helpers.ToString(this.encryptionContext);
      s += ", ";
      s += Dafny.Helpers.ToString(this.algorithmSuiteID);
      s += ", ";
      s += Dafny.Helpers.ToString(this.frameLength);
      s += ")";
      return s;
    }
    private static readonly EncryptRequest theDefault = create(Dafny.Sequence<byte>.Empty, (CMMDefs.CMM)null, (KeyringDefs.Keyring)null, BigInteger.Zero, Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Empty, Wrappers_Compile.Option<ushort>.Default(), Wrappers_Compile.Option<uint>.Default());
    public static EncryptRequest Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<ESDKClient.EncryptRequest> _TYPE = new Dafny.TypeDescriptor<ESDKClient.EncryptRequest>(ESDKClient.EncryptRequest.Default());
    public static Dafny.TypeDescriptor<ESDKClient.EncryptRequest> _TypeDescriptor() {
      return _TYPE;
    }
    public static EncryptRequest create(Dafny.ISequence<byte> plaintext, CMMDefs.CMM cmm, KeyringDefs.Keyring keyring, BigInteger plaintextLength, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext, Wrappers_Compile.Option<ushort> algorithmSuiteID, Wrappers_Compile.Option<uint> frameLength) {
      return new EncryptRequest(plaintext, cmm, keyring, plaintextLength, encryptionContext, algorithmSuiteID, frameLength);
    }
    public bool is_EncryptRequest { get { return true; } }
    public Dafny.ISequence<byte> dtor_plaintext {
      get {
        return this.plaintext;
      }
    }
    public CMMDefs.CMM dtor_cmm {
      get {
        return this.cmm;
      }
    }
    public KeyringDefs.Keyring dtor_keyring {
      get {
        return this.keyring;
      }
    }
    public BigInteger dtor_plaintextLength {
      get {
        return this.plaintextLength;
      }
    }
    public Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> dtor_encryptionContext {
      get {
        return this.encryptionContext;
      }
    }
    public Wrappers_Compile.Option<ushort> dtor_algorithmSuiteID {
      get {
        return this.algorithmSuiteID;
      }
    }
    public Wrappers_Compile.Option<uint> dtor_frameLength {
      get {
        return this.frameLength;
      }
    }
    public static ESDKClient.EncryptRequest WithCMM(Dafny.ISequence<byte> plaintext, CMMDefs.CMM cmm)
    {
      return @ESDKClient.EncryptRequest.create(plaintext, cmm, (KeyringDefs.Keyring)null, new BigInteger((plaintext).Count), Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.FromElements(), @Wrappers_Compile.Option<ushort>.create_None(), @Wrappers_Compile.Option<uint>.create_None());
    }
    public static ESDKClient.EncryptRequest WithKeyring(Dafny.ISequence<byte> plaintext, KeyringDefs.Keyring keyring)
    {
      return @ESDKClient.EncryptRequest.create(plaintext, (CMMDefs.CMM)null, keyring, new BigInteger((plaintext).Count), Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.FromElements(), @Wrappers_Compile.Option<ushort>.create_None(), @Wrappers_Compile.Option<uint>.create_None());
    }
    public ESDKClient.EncryptRequest SetEncryptionContext(Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext) {
      ESDKClient.EncryptRequest _21058_dt__update__tmp_h0 = this;
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _21059_dt__update_hencryptionContext_h0 = encryptionContext;
      return @ESDKClient.EncryptRequest.create((_21058_dt__update__tmp_h0).dtor_plaintext, (_21058_dt__update__tmp_h0).dtor_cmm, (_21058_dt__update__tmp_h0).dtor_keyring, (_21058_dt__update__tmp_h0).dtor_plaintextLength, _21059_dt__update_hencryptionContext_h0, (_21058_dt__update__tmp_h0).dtor_algorithmSuiteID, (_21058_dt__update__tmp_h0).dtor_frameLength);
    }
    public ESDKClient.EncryptRequest SetAlgorithmSuiteID(ushort algorithmSuiteID) {
      ESDKClient.EncryptRequest _21060_dt__update__tmp_h0 = this;
      Wrappers_Compile.Option<ushort> _21061_dt__update_halgorithmSuiteID_h0 = @Wrappers_Compile.Option<ushort>.create_Some(algorithmSuiteID);
      return @ESDKClient.EncryptRequest.create((_21060_dt__update__tmp_h0).dtor_plaintext, (_21060_dt__update__tmp_h0).dtor_cmm, (_21060_dt__update__tmp_h0).dtor_keyring, (_21060_dt__update__tmp_h0).dtor_plaintextLength, (_21060_dt__update__tmp_h0).dtor_encryptionContext, _21061_dt__update_halgorithmSuiteID_h0, (_21060_dt__update__tmp_h0).dtor_frameLength);
    }
    public ESDKClient.EncryptRequest SetFrameLength(uint frameLength) {
      ESDKClient.EncryptRequest _21062_dt__update__tmp_h0 = this;
      Wrappers_Compile.Option<uint> _21063_dt__update_hframeLength_h0 = @Wrappers_Compile.Option<uint>.create_Some(frameLength);
      return @ESDKClient.EncryptRequest.create((_21062_dt__update__tmp_h0).dtor_plaintext, (_21062_dt__update__tmp_h0).dtor_cmm, (_21062_dt__update__tmp_h0).dtor_keyring, (_21062_dt__update__tmp_h0).dtor_plaintextLength, (_21062_dt__update__tmp_h0).dtor_encryptionContext, (_21062_dt__update__tmp_h0).dtor_algorithmSuiteID, _21063_dt__update_hframeLength_h0);
    }
  }

  public class DecryptRequest {
    public readonly Dafny.ISequence<byte> message;
    public readonly CMMDefs.CMM cmm;
    public readonly KeyringDefs.Keyring keyring;
    public DecryptRequest(Dafny.ISequence<byte> message, CMMDefs.CMM cmm, KeyringDefs.Keyring keyring) {
      this.message = message;
      this.cmm = cmm;
      this.keyring = keyring;
    }
    public override bool Equals(object other) {
      var oth = other as ESDKClient.DecryptRequest;
      return oth != null && object.Equals(this.message, oth.message) && this.cmm == oth.cmm && this.keyring == oth.keyring;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.message));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.cmm));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.keyring));
      return (int) hash;
    }
    public override string ToString() {
      string s = "ESDKClient_Compile.DecryptRequest.DecryptRequest";
      s += "(";
      s += Dafny.Helpers.ToString(this.message);
      s += ", ";
      s += Dafny.Helpers.ToString(this.cmm);
      s += ", ";
      s += Dafny.Helpers.ToString(this.keyring);
      s += ")";
      return s;
    }
    private static readonly DecryptRequest theDefault = create(Dafny.Sequence<byte>.Empty, (CMMDefs.CMM)null, (KeyringDefs.Keyring)null);
    public static DecryptRequest Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<ESDKClient.DecryptRequest> _TYPE = new Dafny.TypeDescriptor<ESDKClient.DecryptRequest>(ESDKClient.DecryptRequest.Default());
    public static Dafny.TypeDescriptor<ESDKClient.DecryptRequest> _TypeDescriptor() {
      return _TYPE;
    }
    public static DecryptRequest create(Dafny.ISequence<byte> message, CMMDefs.CMM cmm, KeyringDefs.Keyring keyring) {
      return new DecryptRequest(message, cmm, keyring);
    }
    public bool is_DecryptRequest { get { return true; } }
    public Dafny.ISequence<byte> dtor_message {
      get {
        return this.message;
      }
    }
    public CMMDefs.CMM dtor_cmm {
      get {
        return this.cmm;
      }
    }
    public KeyringDefs.Keyring dtor_keyring {
      get {
        return this.keyring;
      }
    }
    public static ESDKClient.DecryptRequest WithCMM(Dafny.ISequence<byte> message, CMMDefs.CMM cmm)
    {
      return @ESDKClient.DecryptRequest.create(message, cmm, (KeyringDefs.Keyring)null);
    }
    public static ESDKClient.DecryptRequest WithKeyring(Dafny.ISequence<byte> message, KeyringDefs.Keyring keyring)
    {
      return @ESDKClient.DecryptRequest.create(message, (CMMDefs.CMM)null, keyring);
    }
  }

  public class DecryptResultWithVerificationInfo {
    public readonly Dafny.ISequence<byte> plaintext;
    public DecryptResultWithVerificationInfo(Dafny.ISequence<byte> plaintext) {
      this.plaintext = plaintext;
    }
    public override bool Equals(object other) {
      var oth = other as ESDKClient.DecryptResultWithVerificationInfo;
      return oth != null && object.Equals(this.plaintext, oth.plaintext);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this.plaintext));
      return (int) hash;
    }
    public override string ToString() {
      string s = "ESDKClient_Compile.DecryptResultWithVerificationInfo.DecryptResultWithVerificationInfo";
      s += "(";
      s += Dafny.Helpers.ToString(this.plaintext);
      s += ")";
      return s;
    }
    private static readonly DecryptResultWithVerificationInfo theDefault = create(Dafny.Sequence<byte>.Empty);
    public static DecryptResultWithVerificationInfo Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<ESDKClient.DecryptResultWithVerificationInfo> _TYPE = new Dafny.TypeDescriptor<ESDKClient.DecryptResultWithVerificationInfo>(ESDKClient.DecryptResultWithVerificationInfo.Default());
    public static Dafny.TypeDescriptor<ESDKClient.DecryptResultWithVerificationInfo> _TypeDescriptor() {
      return _TYPE;
    }
    public static DecryptResultWithVerificationInfo create(Dafny.ISequence<byte> plaintext) {
      return new DecryptResultWithVerificationInfo(plaintext);
    }
    public bool is_DecryptResultWithVerificationInfo { get { return true; } }
    public Dafny.ISequence<byte> dtor_plaintext {
      get {
        return this.plaintext;
      }
    }
  }

  public partial class __default {
    public static Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> Encrypt(ESDKClient.EncryptRequest request)
    {
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> res = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      if ((((request).dtor_cmm) != (object) ((CMMDefs.CMM)null)) && (((request).dtor_keyring) != (object) ((KeyringDefs.Keyring)null))) {
        res = @Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("EncryptRequest.keyring OR EncryptRequest.cmm must be set (not both)."));
        return res;
      } else if ((((request).dtor_cmm) == (object) ((CMMDefs.CMM)null)) && (((request).dtor_keyring) == (object) ((KeyringDefs.Keyring)null))) {
        res = @Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("EncryptRequest.cmm and EncryptRequest.keyring cannot both be null."));
        return res;
      } else if ((((request).dtor_algorithmSuiteID).is_Some) && (!(AlgorithmSuite.__default.VALID__IDS).Contains((((request).dtor_algorithmSuiteID).dtor_value)))) {
        res = @Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Invalid algorithmSuiteID."));
        return res;
      } else if ((((request).dtor_frameLength).is_Some) && ((((request).dtor_frameLength).dtor_value) == (0U))) {
        res = @Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Request frameLength must be > 0"));
        return res;
      }
      CMMDefs.CMM _21064_cmm = default(CMMDefs.CMM);
      if (((request).dtor_keyring) == (object) ((KeyringDefs.Keyring)null)) {
        _21064_cmm = (request).dtor_cmm;
      } else {
        DefaultCMMDef.DefaultCMM _nw7 = new DefaultCMMDef.DefaultCMM();
        _nw7.OfKeyring((request).dtor_keyring);
        _21064_cmm = _nw7;
      }
      uint _21065_frameLength;
      _21065_frameLength = ((((request).dtor_frameLength).is_Some) ? (((request).dtor_frameLength).dtor_value) : (ESDKClient.__default.DEFAULT__FRAME__LENGTH));
      Wrappers_Compile.Option<ushort> _21066_algorithmSuiteID;
      _21066_algorithmSuiteID = ((((request).dtor_algorithmSuiteID).is_Some) ? (@Wrappers_Compile.Option<ushort>.create_Some((ushort)(((request).dtor_algorithmSuiteID).dtor_value))) : (@Wrappers_Compile.Option<ushort>.create_None()));
      Materials.EncryptionMaterialsRequest _21067_encMatRequest;
      _21067_encMatRequest = @Materials.EncryptionMaterialsRequest.create((request).dtor_encryptionContext, _21066_algorithmSuiteID, @Wrappers_Compile.Option<BigInteger>.create_Some((request).dtor_plaintextLength));
      Materials.EncryptionMaterials _21068_encMat = Materials.ValidEncryptionMaterials.Default();
      Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>> _21069_valueOrError0 = Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>>.Default(Materials.ValidEncryptionMaterials.Default());
      Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>> _out121;
      _out121 = (_21064_cmm).GetEncryptionMaterials(_21067_encMatRequest);
      _21069_valueOrError0 = _out121;
      if ((_21069_valueOrError0).IsFailure()) {
        res = (_21069_valueOrError0).PropagateFailure<Dafny.ISequence<byte>>();
        return res;
      }
      _21068_encMat = (_21069_valueOrError0).Extract();
      if ((StandardLibrary_mUInt_Compile.__default.UINT16__LIMIT) <= (new BigInteger(((_21068_encMat).dtor_encryptedDataKeys).Count))) {
        res = @Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Number of EDKs exceeds the allowed maximum."));
        return res;
      }
      Dafny.ISequence<byte> _21070_messageID = MessageHeader.MessageID.Default();
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _21071_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out122;
      _out122 = Random_Compile.__default.GenerateBytes((int)(MessageHeader.__default.MESSAGE__ID__LEN));
      _21071_valueOrError1 = _out122;
      if ((_21071_valueOrError1).IsFailure()) {
        res = (_21071_valueOrError1).PropagateFailure<Dafny.ISequence<byte>>();
        return res;
      }
      _21070_messageID = (_21071_valueOrError1).Extract();
      Dafny.ISequence<byte> _21072_derivedDataKey;
      Dafny.ISequence<byte> _out123;
      _out123 = ESDKClient.__default.DeriveKey(((_21068_encMat).dtor_plaintextDataKey).dtor_value, (_21068_encMat).dtor_algorithmSuiteID, _21070_messageID);
      _21072_derivedDataKey = _out123;
      MessageHeader.HeaderBody _21073_headerBody;
      _21073_headerBody = @MessageHeader.HeaderBody.create(MessageHeader.__default.VERSION__1, MessageHeader.__default.TYPE__CUSTOMER__AED, (_21068_encMat).dtor_algorithmSuiteID, _21070_messageID, (_21068_encMat).dtor_encryptionContext, @MessageHeader.EncryptedDataKeys.create((_21068_encMat).dtor_encryptedDataKeys), @MessageHeader.ContentType.create_Framed(), (byte)(AlgorithmSuite.ID.IVLength((_21068_encMat).dtor_algorithmSuiteID)), _21065_frameLength);
      Streams_Compile.ByteWriter _21074_wr;
      Streams_Compile.ByteWriter _nw8 = new Streams_Compile.ByteWriter();
      _nw8.__ctor();
      _21074_wr = _nw8;
      BigInteger _21075___v2 = BigInteger.Zero;
      Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>> _21076_valueOrError2 = Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>>.Default(BigInteger.Zero);
      Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>> _out124;
      _out124 = Serialize_Compile.__default.SerializeHeaderBody(_21074_wr, _21073_headerBody);
      _21076_valueOrError2 = _out124;
      if ((_21076_valueOrError2).IsFailure()) {
        res = (_21076_valueOrError2).PropagateFailure<Dafny.ISequence<byte>>();
        return res;
      }
      _21075___v2 = (_21076_valueOrError2).Extract();
      Dafny.ISequence<byte> _21077_unauthenticatedHeader;
      _21077_unauthenticatedHeader = (_21074_wr).GetDataWritten();
      Dafny.ISequence<byte> _21078_iv;
      _21078_iv = ((System.Func<Dafny.ISequence<byte>>) (() => {
        BigInteger dim9 = AlgorithmSuite.ID.IVLength((_21068_encMat).dtor_algorithmSuiteID);
        var arr9 = new byte[Dafny.Helpers.ToIntChecked(dim9,"C# array size must not be larger than max 32-bit int")];
        for (int i9 = 0; i9 < dim9; i9++) {
          var _21079___v3 = (BigInteger) i9;
          arr9[(int)(_21079___v3)] = 0;
        }
        return Dafny.Sequence<byte>.FromArray(arr9);
      }))();
      AESEncryption.EncryptionOutput _21080_encryptionOutput = AESEncryption.EncryptionOutput.Default();
      Wrappers_Compile.Result<AESEncryption.EncryptionOutput, Dafny.ISequence<char>> _21081_valueOrError3 = Wrappers_Compile.Result<AESEncryption.EncryptionOutput, Dafny.ISequence<char>>.Default(AESEncryption.EncryptionOutput.Default());
      Wrappers_Compile.Result<AESEncryption.EncryptionOutput, Dafny.ISequence<char>> _out125;
      _out125 = AESEncryption.AES_GCM.AESEncryptExtern(AlgorithmSuite.ID.EncryptionSuite((_21068_encMat).dtor_algorithmSuiteID), _21078_iv, _21072_derivedDataKey, Dafny.Sequence<byte>.FromElements(), _21077_unauthenticatedHeader);
      _21081_valueOrError3 = _out125;
      if ((_21081_valueOrError3).IsFailure()) {
        res = (_21081_valueOrError3).PropagateFailure<Dafny.ISequence<byte>>();
        return res;
      }
      _21080_encryptionOutput = (_21081_valueOrError3).Extract();
      MessageHeader.HeaderAuthentication _21082_headerAuthentication;
      _21082_headerAuthentication = @MessageHeader.HeaderAuthentication.create(_21078_iv, (_21080_encryptionOutput).dtor_authTag);
      BigInteger _21083___v5 = BigInteger.Zero;
      Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>> _21084_valueOrError4 = Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>>.Default(BigInteger.Zero);
      Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>> _out126;
      _out126 = Serialize_Compile.__default.SerializeHeaderAuthentication(_21074_wr, _21082_headerAuthentication);
      _21084_valueOrError4 = _out126;
      if ((_21084_valueOrError4).IsFailure()) {
        res = (_21084_valueOrError4).PropagateFailure<Dafny.ISequence<byte>>();
        return res;
      }
      _21083___v5 = (_21084_valueOrError4).Extract();
      MessageBody_Compile.SeqWithGhostFrames _21085_seqWithGhostFrames = MessageBody_Compile.SeqWithGhostFrames.Default();
      Wrappers_Compile.Result<MessageBody_Compile.SeqWithGhostFrames, Dafny.ISequence<char>> _21086_valueOrError5 = Wrappers_Compile.Result<MessageBody_Compile.SeqWithGhostFrames, Dafny.ISequence<char>>.Default(MessageBody_Compile.SeqWithGhostFrames.Default());
      Wrappers_Compile.Result<MessageBody_Compile.SeqWithGhostFrames, Dafny.ISequence<char>> _out127;
      _out127 = MessageBody_Compile.__default.EncryptMessageBody((request).dtor_plaintext, new BigInteger(_21065_frameLength), _21070_messageID, _21072_derivedDataKey, (_21068_encMat).dtor_algorithmSuiteID);
      _21086_valueOrError5 = _out127;
      if ((_21086_valueOrError5).IsFailure()) {
        res = (_21086_valueOrError5).PropagateFailure<Dafny.ISequence<byte>>();
        return res;
      }
      _21085_seqWithGhostFrames = (_21086_valueOrError5).Extract();
      Dafny.ISequence<byte> _21087_body;
      _21087_body = (_21085_seqWithGhostFrames).dtor_sequence;
      Dafny.ISequence<byte> _21088_msg;
      _21088_msg = Dafny.Sequence<byte>.Concat((_21074_wr).GetDataWritten(), _21087_body);
      if ((AlgorithmSuite.ID.SignatureType((_21068_encMat).dtor_algorithmSuiteID)).is_Some) {
        Signature.ECDSAParams _21089_ecdsaParams;
        _21089_ecdsaParams = (AlgorithmSuite.ID.SignatureType((_21068_encMat).dtor_algorithmSuiteID)).dtor_value;
        Dafny.ISequence<byte> _21090_bytes = Dafny.Sequence<byte>.Empty;
        Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _21091_valueOrError6 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
        Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out128;
        _out128 = Signature.ECDSA.Sign(_21089_ecdsaParams, ((_21068_encMat).dtor_signingKey).dtor_value, _21088_msg);
        _21091_valueOrError6 = _out128;
        if ((_21091_valueOrError6).IsFailure()) {
          res = (_21091_valueOrError6).PropagateFailure<Dafny.ISequence<byte>>();
          return res;
        }
        _21090_bytes = (_21091_valueOrError6).Extract();
        if ((new BigInteger((_21090_bytes).Count)) != (new BigInteger((_21089_ecdsaParams).SignatureLength()))) {
          res = @Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Malformed response from Sign()."));
          return res;
        }
        Dafny.ISequence<byte> _21092_signature;
        _21092_signature = Dafny.Sequence<byte>.Concat(StandardLibrary_mUInt_Compile.__default.UInt16ToSeq((ushort)(_21090_bytes).Count), _21090_bytes);
        _21088_msg = Dafny.Sequence<byte>.Concat(_21088_msg, _21092_signature);
        res = @Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.create_Success(_21088_msg);
        return res;
      } else {
        res = @Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.create_Success(_21088_msg);
        return res;
      }
      return res;
    }
    public static Dafny.ISequence<byte> DeriveKey(Dafny.ISequence<byte> plaintextDataKey, ushort algorithmSuiteID, Dafny.ISequence<byte> messageID)
    {
      Dafny.ISequence<byte> derivedDataKey = Dafny.Sequence<byte>.Empty;
      KeyDerivationAlgorithms.KeyDerivationAlgorithm _21093_algorithm;
      _21093_algorithm = (Dafny.Map<ushort, AlgorithmSuite.AlgSuite>.Select(AlgorithmSuite.__default.Suite,algorithmSuiteID)).dtor_hkdf;
      if (object.Equals(_21093_algorithm, @KeyDerivationAlgorithms.KeyDerivationAlgorithm.create_IDENTITY())) {
        derivedDataKey = plaintextDataKey;
        return derivedDataKey;
      }
      Dafny.ISequence<byte> _21094_infoSeq;
      _21094_infoSeq = Dafny.Sequence<byte>.Concat(StandardLibrary_mUInt_Compile.__default.UInt16ToSeq((ushort)(algorithmSuiteID)), messageID);
      BigInteger _21095_len;
      _21095_len = AlgorithmSuite.ID.KeyLength(algorithmSuiteID);
      Dafny.ISequence<byte> _21096_derivedKey;
      Dafny.ISequence<byte> _out129;
      _out129 = HKDF_Compile.__default.Hkdf(_21093_algorithm, @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_None(), plaintextDataKey, _21094_infoSeq, _21095_len);
      _21096_derivedKey = _out129;
      derivedDataKey = _21096_derivedKey;
      return derivedDataKey;
      return derivedDataKey;
    }
    public static Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> Decrypt(ESDKClient.DecryptRequest request)
    {
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> res = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      ESDKClient.DecryptResultWithVerificationInfo _21097_decryptWithVerificationInfo = ESDKClient.DecryptResultWithVerificationInfo.Default();
      Wrappers_Compile.Result<ESDKClient.DecryptResultWithVerificationInfo, Dafny.ISequence<char>> _21098_valueOrError0 = Wrappers_Compile.Result<ESDKClient.DecryptResultWithVerificationInfo, Dafny.ISequence<char>>.Default(ESDKClient.DecryptResultWithVerificationInfo.Default());
      Wrappers_Compile.Result<ESDKClient.DecryptResultWithVerificationInfo, Dafny.ISequence<char>> _out130;
      _out130 = ESDKClient.__default.DecryptWithVerificationInfo(request);
      _21098_valueOrError0 = _out130;
      if ((_21098_valueOrError0).IsFailure()) {
        res = (_21098_valueOrError0).PropagateFailure<Dafny.ISequence<byte>>();
        return res;
      }
      _21097_decryptWithVerificationInfo = (_21098_valueOrError0).Extract();
      res = @Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.create_Success((_21097_decryptWithVerificationInfo).dtor_plaintext);
      return res;
      return res;
    }
    public static Wrappers_Compile.Result<ESDKClient.DecryptResultWithVerificationInfo, Dafny.ISequence<char>> DecryptWithVerificationInfo(ESDKClient.DecryptRequest request)
    {
      Wrappers_Compile.Result<ESDKClient.DecryptResultWithVerificationInfo, Dafny.ISequence<char>> res = Wrappers_Compile.Result<ESDKClient.DecryptResultWithVerificationInfo, Dafny.ISequence<char>>.Default(ESDKClient.DecryptResultWithVerificationInfo.Default());
      if ((((request).dtor_cmm) != (object) ((CMMDefs.CMM)null)) && (((request).dtor_keyring) != (object) ((KeyringDefs.Keyring)null))) {
        res = @Wrappers_Compile.Result<ESDKClient.DecryptResultWithVerificationInfo, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("DecryptRequest.keyring OR DecryptRequest.cmm must be set (not both)."));
        return res;
      } else if ((((request).dtor_cmm) == (object) ((CMMDefs.CMM)null)) && (((request).dtor_keyring) == (object) ((KeyringDefs.Keyring)null))) {
        res = @Wrappers_Compile.Result<ESDKClient.DecryptResultWithVerificationInfo, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("DecryptRequest.cmm and DecryptRequest.keyring cannot both be null."));
        return res;
      }
      CMMDefs.CMM _21099_cmm = default(CMMDefs.CMM);
      if (((request).dtor_keyring) == (object) ((KeyringDefs.Keyring)null)) {
        _21099_cmm = (request).dtor_cmm;
      } else {
        DefaultCMMDef.DefaultCMM _nw9 = new DefaultCMMDef.DefaultCMM();
        _nw9.OfKeyring((request).dtor_keyring);
        _21099_cmm = _nw9;
      }
      Streams_Compile.ByteReader _21100_rd;
      Streams_Compile.ByteReader _nw10 = new Streams_Compile.ByteReader();
      _nw10.__ctor((request).dtor_message);
      _21100_rd = _nw10;
      Deserialize_Compile.DeserializeHeaderResult _21101_deserializeHeaderResult = Deserialize_Compile.DeserializeHeaderResult.Default();
      Wrappers_Compile.Result<Deserialize_Compile.DeserializeHeaderResult, Dafny.ISequence<char>> _21102_valueOrError0 = Wrappers_Compile.Result<Deserialize_Compile.DeserializeHeaderResult, Dafny.ISequence<char>>.Default(Deserialize_Compile.DeserializeHeaderResult.Default());
      Wrappers_Compile.Result<Deserialize_Compile.DeserializeHeaderResult, Dafny.ISequence<char>> _out131;
      _out131 = Deserialize_Compile.__default.DeserializeHeader(_21100_rd);
      _21102_valueOrError0 = _out131;
      if ((_21102_valueOrError0).IsFailure()) {
        res = (_21102_valueOrError0).PropagateFailure<ESDKClient.DecryptResultWithVerificationInfo>();
        return res;
      }
      _21101_deserializeHeaderResult = (_21102_valueOrError0).Extract();
      MessageHeader.Header _21103_header;
      _21103_header = (_21101_deserializeHeaderResult).dtor_header;
      Materials.DecryptionMaterialsRequest _21104_decMatRequest;
      _21104_decMatRequest = @Materials.DecryptionMaterialsRequest.create(((_21103_header).dtor_body).dtor_algorithmSuiteID, (((_21103_header).dtor_body).dtor_encryptedDataKeys).dtor_entries, ((_21103_header).dtor_body).dtor_aad);
      Materials.DecryptionMaterials _21105_decMat = Materials.ValidDecryptionMaterials.Default();
      Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>> _21106_valueOrError1 = Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>.Default(Materials.ValidDecryptionMaterials.Default());
      Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>> _out132;
      _out132 = (_21099_cmm).DecryptMaterials(_21104_decMatRequest);
      _21106_valueOrError1 = _out132;
      if ((_21106_valueOrError1).IsFailure()) {
        res = (_21106_valueOrError1).PropagateFailure<ESDKClient.DecryptResultWithVerificationInfo>();
        return res;
      }
      _21105_decMat = (_21106_valueOrError1).Extract();
      Dafny.ISequence<byte> _21107_decryptionKey;
      Dafny.ISequence<byte> _out133;
      _out133 = ESDKClient.__default.DeriveKey(((_21105_decMat).dtor_plaintextDataKey).dtor_value, (_21105_decMat).dtor_algorithmSuiteID, ((_21103_header).dtor_body).dtor_messageID);
      _21107_decryptionKey = _out133;
      Dafny.ISequence<byte> _21108_plaintext = Dafny.Sequence<byte>.Empty;
      MessageHeader.ContentType _source20 = ((_21103_header).dtor_body).dtor_contentType;
      if (_source20.is_NonFramed) {
        {
          Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _21109_valueOrError2 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
          Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out134;
          _out134 = MessageBody_Compile.__default.DecryptNonFramedMessageBody(_21100_rd, (_21105_decMat).dtor_algorithmSuiteID, _21107_decryptionKey, ((_21103_header).dtor_body).dtor_messageID);
          _21109_valueOrError2 = _out134;
          if ((_21109_valueOrError2).IsFailure()) {
            res = (_21109_valueOrError2).PropagateFailure<ESDKClient.DecryptResultWithVerificationInfo>();
            return res;
          }
          _21108_plaintext = (_21109_valueOrError2).Extract();
        }
      } else {
        {
          Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _21110_valueOrError3 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
          Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out135;
          _out135 = MessageBody_Compile.__default.DecryptFramedMessageBody(_21100_rd, (_21105_decMat).dtor_algorithmSuiteID, _21107_decryptionKey, new BigInteger(((_21103_header).dtor_body).dtor_frameLength), ((_21103_header).dtor_body).dtor_messageID);
          _21110_valueOrError3 = _out135;
          if ((_21110_valueOrError3).IsFailure()) {
            res = (_21110_valueOrError3).PropagateFailure<ESDKClient.DecryptResultWithVerificationInfo>();
            return res;
          }
          _21108_plaintext = (_21110_valueOrError3).Extract();
        }
      }
      if ((AlgorithmSuite.ID.SignatureType((_21105_decMat).dtor_algorithmSuiteID)).is_Some) {
        Wrappers_Compile.Result<_System.Tuple0, Dafny.ISequence<char>> _21111_verifyResult;
        Wrappers_Compile.Result<_System.Tuple0, Dafny.ISequence<char>> _out136;
        _out136 = ESDKClient.__default.VerifySignature(_21100_rd, _21105_decMat);
        _21111_verifyResult = _out136;
        if ((_21111_verifyResult).is_Failure) {
          res = @Wrappers_Compile.Result<ESDKClient.DecryptResultWithVerificationInfo, Dafny.ISequence<char>>.create_Failure((_21111_verifyResult).dtor_error);
          return res;
        }
      }
      bool _21112_isDone;
      bool _out137;
      _out137 = (_21100_rd).IsDoneReading();
      _21112_isDone = _out137;
      if (!(_21112_isDone)) {
        res = @Wrappers_Compile.Result<ESDKClient.DecryptResultWithVerificationInfo, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("message contains additional bytes at end"));
        return res;
      }
      ESDKClient.DecryptResultWithVerificationInfo _21113_decryptResultWithVerificationInfo;
      _21113_decryptResultWithVerificationInfo = @ESDKClient.DecryptResultWithVerificationInfo.create(_21108_plaintext);
      res = @Wrappers_Compile.Result<ESDKClient.DecryptResultWithVerificationInfo, Dafny.ISequence<char>>.create_Success(_21113_decryptResultWithVerificationInfo);
      return res;
      return res;
    }
    public static Wrappers_Compile.Result<_System.Tuple0, Dafny.ISequence<char>> VerifySignature(Streams_Compile.ByteReader rd, Materials.DecryptionMaterials decMat)
    {
      Wrappers_Compile.Result<_System.Tuple0, Dafny.ISequence<char>> res = Wrappers_Compile.Result<_System.Tuple0, Dafny.ISequence<char>>.Default(_System.Tuple0.Default());
      Signature.ECDSAParams _21114_ecdsaParams;
      _21114_ecdsaParams = (AlgorithmSuite.ID.SignatureType((decMat).dtor_algorithmSuiteID)).dtor_value;
      BigInteger _21115_usedCapacity;
      BigInteger _out138;
      _out138 = (rd).GetSizeRead();
      _21115_usedCapacity = _out138;
      Dafny.ISequence<byte> _21116_msg;
      _21116_msg = (((rd).reader).data).Take(_21115_usedCapacity);
      Wrappers_Compile.Result<ushort, Dafny.ISequence<char>> _21117_signatureLengthResult;
      Wrappers_Compile.Result<ushort, Dafny.ISequence<char>> _out139;
      _out139 = (rd).ReadUInt16();
      _21117_signatureLengthResult = _out139;
      if ((_21117_signatureLengthResult).is_Failure) {
        Wrappers_Compile.Result<_System.Tuple0, Dafny.ISequence<char>> _rhs8 = @Wrappers_Compile.Result<_System.Tuple0, Dafny.ISequence<char>>.create_Failure((_21117_signatureLengthResult).dtor_error);
        res = _rhs8;
        return res;
      }
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _21118_sigResult;
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out140;
      _out140 = (rd).ReadBytes(new BigInteger((_21117_signatureLengthResult).dtor_value));
      _21118_sigResult = _out140;
      if ((_21118_sigResult).is_Failure) {
        Wrappers_Compile.Result<_System.Tuple0, Dafny.ISequence<char>> _rhs9 = @Wrappers_Compile.Result<_System.Tuple0, Dafny.ISequence<char>>.create_Failure((_21118_sigResult).dtor_error);
        res = _rhs9;
        return res;
      }
      Wrappers_Compile.Result<bool, Dafny.ISequence<char>> _21119_signatureVerifiedResult;
      Wrappers_Compile.Result<bool, Dafny.ISequence<char>> _out141;
      _out141 = Signature.ECDSA.Verify(_21114_ecdsaParams, ((decMat).dtor_verificationKey).dtor_value, _21116_msg, (_21118_sigResult).dtor_value);
      _21119_signatureVerifiedResult = _out141;
      if ((_21119_signatureVerifiedResult).is_Failure) {
        Wrappers_Compile.Result<_System.Tuple0, Dafny.ISequence<char>> _rhs10 = @Wrappers_Compile.Result<_System.Tuple0, Dafny.ISequence<char>>.create_Failure((_21119_signatureVerifiedResult).dtor_error);
        res = _rhs10;
        return res;
      }
      if (!((_21119_signatureVerifiedResult).dtor_value)) {
        Wrappers_Compile.Result<_System.Tuple0, Dafny.ISequence<char>> _rhs11 = @Wrappers_Compile.Result<_System.Tuple0, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("signature not verified"));
        res = _rhs11;
        return res;
      }
      Wrappers_Compile.Result<_System.Tuple0, Dafny.ISequence<char>> _rhs12 = @Wrappers_Compile.Result<_System.Tuple0, Dafny.ISequence<char>>.create_Success(@_System.Tuple0.create());
      res = _rhs12;
      return res;
      return res;
    }
    public static uint DEFAULT__FRAME__LENGTH { get {
      return 4096U;
    } }
  }
} // end of namespace ESDKClient
namespace Time_Compile {



} // end of namespace Time_Compile
namespace Sorting_Compile {




  public partial class __default {
    public static bool LexicographicByteSeqBelow(Dafny.ISequence<byte> x, Dafny.ISequence<byte> y)
    {
      return Sorting_Compile.__default.LexicographicByteSeqBelowAux(x, y, BigInteger.Zero);
    }
    public static bool LexicographicByteSeqBelowAux(Dafny.ISequence<byte> x, Dafny.ISequence<byte> y, BigInteger n)
    {
      return (((n) == (new BigInteger((x).Count))) || (((n) != (new BigInteger((y).Count))) && (((x).Select(n)) < ((y).Select(n))))) || ((((n) != (new BigInteger((y).Count))) && (((x).Select(n)) == ((y).Select(n)))) && (Sorting_Compile.__default.LexicographicByteSeqBelowAux(x, y, (n) + (BigInteger.One))));
    }
    public static void SelectionSort<__Data>(__Data[] a, Func<__Data, __Data, bool> below)
    {
      BigInteger _21120_m;
      _21120_m = BigInteger.Zero;
      while ((_21120_m) < (new BigInteger((a).Length))) {
        BigInteger _21121_mindex;
        BigInteger _21122_n;
        BigInteger _rhs13 = _21120_m;
        BigInteger _rhs14 = (_21120_m) + (BigInteger.One);
        _21121_mindex = _rhs13;
        _21122_n = _rhs14;
        while ((_21122_n) < (new BigInteger((a).Length))) {
          if (!(Dafny.Helpers.Id<Func<__Data, __Data, bool>>(below)((a)[(int)(_21121_mindex)], (a)[(int)(_21122_n)]))) {
            _21121_mindex = _21122_n;
          }
          _21122_n = (_21122_n) + (BigInteger.One);
        }
        __Data _rhs15 = (a)[(int)(_21121_mindex)];
        __Data _rhs16 = (a)[(int)(_21120_m)];
        __Data[] _lhs0 = a;
        BigInteger _lhs1 = _21120_m;
        __Data[] _lhs2 = a;
        BigInteger _lhs3 = _21121_mindex;
        _lhs0[(int)(_lhs1)] = _rhs15;
        _lhs2[(int)(_lhs3)] = _rhs16;
        _21120_m = (_21120_m) + (BigInteger.One);
      }
    }
  }
} // end of namespace Sorting_Compile
namespace CachingCMMDef {















  public partial class CachingCMM : CMMDefs.CMM {
    public CachingCMM() {
      this._cmm = default(CMMDefs.CMM);
      this._cmc = default(CachingCMMDef.CryptographicMaterialsCache);
      this._secondsToLiveLimit = BigInteger.Zero;
      this._messageLimit = 0;
      this._byteLimit = 0;
    }
    public void __ctor(CMMDefs.CMM cmm, BigInteger secondsToLiveLimit)
    {
      (this)._secondsToLiveLimit = secondsToLiveLimit;
      (this)._messageLimit = CachingCMMDef.__default.DEFAULT__MESSAGE__USE__LIMIT__PER__CACHED__KEY;
      (this)._byteLimit = CachingCMMDef.__default.DEFAULT__BYTE__USE__LIMIT__PER__CACHED__KEY;
      (this)._cmm = cmm;
      CachingCMMDef.CryptographicMaterialsCache _21123_cmc;
      CachingCMMDef.CryptographicMaterialsCache _nw11 = new CachingCMMDef.CryptographicMaterialsCache();
      _nw11.__ctor();
      _21123_cmc = _nw11;
      (this)._cmc = _21123_cmc;
    }
    public void WithMessageLimit(CMMDefs.CMM cmm, BigInteger secondsToLiveLimit, ulong messageLimit)
    {
      (this)._secondsToLiveLimit = secondsToLiveLimit;
      (this)._messageLimit = messageLimit;
      (this)._byteLimit = CachingCMMDef.__default.DEFAULT__BYTE__USE__LIMIT__PER__CACHED__KEY;
      (this)._cmm = cmm;
      CachingCMMDef.CryptographicMaterialsCache _21124_cmc;
      CachingCMMDef.CryptographicMaterialsCache _nw12 = new CachingCMMDef.CryptographicMaterialsCache();
      _nw12.__ctor();
      _21124_cmc = _nw12;
      (this)._cmc = _21124_cmc;
    }
    public void WithLimits(CMMDefs.CMM cmm, BigInteger secondsToLiveLimit, ulong messageLimit, ulong byteLimit)
    {
      (this)._secondsToLiveLimit = secondsToLiveLimit;
      (this)._messageLimit = messageLimit;
      (this)._byteLimit = byteLimit;
      (this)._cmm = cmm;
      CachingCMMDef.CryptographicMaterialsCache _21125_cmc;
      CachingCMMDef.CryptographicMaterialsCache _nw13 = new CachingCMMDef.CryptographicMaterialsCache();
      _nw13.__ctor();
      _21125_cmc = _nw13;
      (this)._cmc = _21125_cmc;
    }
    public void ForTestingOnly__WithZeroTimeToLive(CMMDefs.CMM cmm)
    {
      (this)._secondsToLiveLimit = BigInteger.Zero;
      (this)._messageLimit = CachingCMMDef.__default.DEFAULT__MESSAGE__USE__LIMIT__PER__CACHED__KEY;
      (this)._byteLimit = CachingCMMDef.__default.DEFAULT__BYTE__USE__LIMIT__PER__CACHED__KEY;
      (this)._cmm = cmm;
      CachingCMMDef.CryptographicMaterialsCache _21126_cmc;
      CachingCMMDef.CryptographicMaterialsCache _nw14 = new CachingCMMDef.CryptographicMaterialsCache();
      _nw14.__ctor();
      _21126_cmc = _nw14;
      (this)._cmc = _21126_cmc;
    }
    public Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>> GetEncryptionMaterials(Materials.EncryptionMaterialsRequest materialsRequest)
    {
      Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>> res = Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>>.Default(Materials.ValidEncryptionMaterials.Default());
      if (((((materialsRequest).dtor_plaintextLength).is_None) || ((new BigInteger((this).byteLimit)) < (((materialsRequest).dtor_plaintextLength).dtor_value))) || ((((materialsRequest).dtor_algorithmSuiteID).is_Some) && (AlgorithmSuite.ID.ContainsIdentityKDF(((materialsRequest).dtor_algorithmSuiteID).dtor_value)))) {
        Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>> _out142;
        _out142 = ((this).cmm).GetEncryptionMaterials(materialsRequest);
        res = _out142;
        return res;
      }
      bool _21127_isSerializable;
      bool _out143;
      _out143 = EncryptionContext.__default.CheckSerializable((materialsRequest).dtor_encryptionContext);
      _21127_isSerializable = _out143;
      if (!(_21127_isSerializable)) {
        res = @Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Invalid Encryption Context"));
        return res;
      }
      Dafny.ISequence<byte> _21128_cacheID = Dafny.Sequence<byte>.Empty;
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _21129_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out144;
      _out144 = CachingCMMDef.__default.ComputeCacheIDForEncrypt((materialsRequest).dtor_algorithmSuiteID, (materialsRequest).dtor_encryptionContext);
      _21129_valueOrError0 = _out144;
      if ((_21129_valueOrError0).IsFailure()) {
        res = (_21129_valueOrError0).PropagateFailure<Materials.EncryptionMaterials>();
        return res;
      }
      _21128_cacheID = (_21129_valueOrError0).Extract();
      CachingCMMDef.CacheEntryEncrypt _21130_entry;
      _21130_entry = ((this).cmc).LookupEncrypt(_21128_cacheID);
      if ((_21130_entry) != (object) ((CachingCMMDef.CacheEntryEncrypt)null)) {
        (_21130_entry).IncrementUse(((materialsRequest).dtor_plaintextLength).dtor_value);
        ulong _21131_currentTime;
        ulong _out145;
        _out145 = TimeUtil.Time.CurrentRelativeTime();
        _21131_currentTime = _out145;
        if (((((_21130_entry).expiryTime) <= (new BigInteger(_21131_currentTime))) || ((new BigInteger((this).messageLimit)) <= (_21130_entry.messagesEncrypted))) || ((new BigInteger((this).byteLimit)) < (_21130_entry.bytesEncrypted))) {
          ((this).cmc).EvictEncrypt(_21128_cacheID);
        } else {
          res = @Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>>.create_Success((_21130_entry).encMat);
          return res;
        }
      }
      Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>> _out146;
      _out146 = ((this).cmm).GetEncryptionMaterials(Dafny.Helpers.Let<Materials.EncryptionMaterialsRequest, Materials.EncryptionMaterialsRequest>(materialsRequest, _pat_let6_0 => Dafny.Helpers.Let<Materials.EncryptionMaterialsRequest, Materials.EncryptionMaterialsRequest>(_pat_let6_0, _21132_dt__update__tmp_h0 => Dafny.Helpers.Let<Wrappers_Compile.Option<BigInteger>, Materials.EncryptionMaterialsRequest>(@Wrappers_Compile.Option<BigInteger>.create_Some(new BigInteger((this).byteLimit)), _pat_let7_0 => Dafny.Helpers.Let<Wrappers_Compile.Option<BigInteger>, Materials.EncryptionMaterialsRequest>(_pat_let7_0, _21133_dt__update_hplaintextLength_h0 => @Materials.EncryptionMaterialsRequest.create((_21132_dt__update__tmp_h0).dtor_encryptionContext, (_21132_dt__update__tmp_h0).dtor_algorithmSuiteID, _21133_dt__update_hplaintextLength_h0))))));
      res = _out146;
      Materials.EncryptionMaterials _21134_encMat = Materials.ValidEncryptionMaterials.Default();
      Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>> _21135_valueOrError1 = Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>>.Default(Materials.ValidEncryptionMaterials.Default());
      _21135_valueOrError1 = res;
      if ((_21135_valueOrError1).IsFailure()) {
        res = (_21135_valueOrError1).PropagateFailure<Materials.EncryptionMaterials>();
        return res;
      }
      _21134_encMat = (_21135_valueOrError1).Extract();
      CachingCMMDef.CacheEntryEncrypt _out147;
      _out147 = ((this).cmc).AddEncrypt(_21128_cacheID, _21134_encMat, (this).secondsToLiveLimit);
      _21130_entry = _out147;
      (_21130_entry).IncrementUse(((materialsRequest).dtor_plaintextLength).dtor_value);
      res = @Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>>.create_Success(_21134_encMat);
      return res;
      return res;
    }
    public Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>> DecryptMaterials(Materials.DecryptionMaterialsRequest materialsRequest)
    {
      Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>> res = Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>.Default(Materials.ValidDecryptionMaterials.Default());
      bool _21136_isSerializable;
      bool _out148;
      _out148 = EncryptionContext.__default.CheckSerializable((materialsRequest).dtor_encryptionContext);
      _21136_isSerializable = _out148;
      if (!(_21136_isSerializable)) {
        res = @Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Invalid Encryption Context"));
        return res;
      }
      Dafny.ISequence<byte> _21137_cacheID = Dafny.Sequence<byte>.Empty;
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _21138_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out149;
      _out149 = CachingCMMDef.__default.ComputeCacheIDForDecrypt(materialsRequest);
      _21138_valueOrError0 = _out149;
      if ((_21138_valueOrError0).IsFailure()) {
        res = (_21138_valueOrError0).PropagateFailure<Materials.DecryptionMaterials>();
        return res;
      }
      _21137_cacheID = (_21138_valueOrError0).Extract();
      CachingCMMDef.CacheEntryDecrypt _21139_entry;
      _21139_entry = ((this).cmc).LookupDecrypt(_21137_cacheID);
      if ((_21139_entry) != (object) ((CachingCMMDef.CacheEntryDecrypt)null)) {
        ulong _21140_currentTime;
        ulong _out150;
        _out150 = TimeUtil.Time.CurrentRelativeTime();
        _21140_currentTime = _out150;
        if (((_21139_entry).expiryTime) <= (new BigInteger(_21140_currentTime))) {
          ((this).cmc).EvictDecrypt(_21137_cacheID);
        } else {
          res = @Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>.create_Success((_21139_entry).decMat);
          return res;
        }
      }
      Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>> _out151;
      _out151 = ((this).cmm).DecryptMaterials(materialsRequest);
      res = _out151;
      Materials.DecryptionMaterials _21141_decMat = Materials.ValidDecryptionMaterials.Default();
      Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>> _21142_valueOrError1 = Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>.Default(Materials.ValidDecryptionMaterials.Default());
      _21142_valueOrError1 = res;
      if ((_21142_valueOrError1).IsFailure()) {
        res = (_21142_valueOrError1).PropagateFailure<Materials.DecryptionMaterials>();
        return res;
      }
      _21141_decMat = (_21142_valueOrError1).Extract();
      CachingCMMDef.CacheEntryDecrypt _out152;
      _out152 = ((this).cmc).AddDecrypt(_21137_cacheID, _21141_decMat, (this).secondsToLiveLimit);
      _21139_entry = _out152;
      res = @Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>.create_Success(_21141_decMat);
      return res;
      return res;
    }
    public CMMDefs.CMM _cmm;public CMMDefs.CMM cmm { get {
      return this._cmm;
    } }
    public CachingCMMDef.CryptographicMaterialsCache _cmc;public CachingCMMDef.CryptographicMaterialsCache cmc { get {
      return this._cmc;
    } }
    public BigInteger _secondsToLiveLimit;public BigInteger secondsToLiveLimit { get {
      return this._secondsToLiveLimit;
    } }
    public ulong _messageLimit;public ulong messageLimit { get {
      return this._messageLimit;
    } }
    public ulong _byteLimit;public ulong byteLimit { get {
      return this._byteLimit;
    } }
  }

  public partial class CryptographicMaterialsCache {
    public CryptographicMaterialsCache() {
      this.EncryptMap = Dafny.Map<Dafny.ISequence<byte>, CachingCMMDef.CacheEntryEncrypt>.Empty;
      this.DecryptMap = Dafny.Map<Dafny.ISequence<byte>, CachingCMMDef.CacheEntryDecrypt>.Empty;
    }
    public Dafny.IMap<Dafny.ISequence<byte>,CachingCMMDef.CacheEntryEncrypt> EncryptMap;public Dafny.IMap<Dafny.ISequence<byte>,CachingCMMDef.CacheEntryDecrypt> DecryptMap;public void __ctor()
    {
      Dafny.IMap<Dafny.ISequence<byte>,CachingCMMDef.CacheEntryEncrypt> _rhs17 = Dafny.Map<Dafny.ISequence<byte>, CachingCMMDef.CacheEntryEncrypt>.FromElements();
      Dafny.IMap<Dafny.ISequence<byte>,CachingCMMDef.CacheEntryDecrypt> _rhs18 = Dafny.Map<Dafny.ISequence<byte>, CachingCMMDef.CacheEntryDecrypt>.FromElements();
      CachingCMMDef.CryptographicMaterialsCache _lhs4 = this;
      CachingCMMDef.CryptographicMaterialsCache _lhs5 = this;
      _lhs4.EncryptMap = _rhs17;
      _lhs5.DecryptMap = _rhs18;
    }
    public CachingCMMDef.CacheEntryEncrypt LookupEncrypt(Dafny.ISequence<byte> cacheID) {
      if (((this.EncryptMap).Keys).Contains((cacheID))) {
        return Dafny.Map<Dafny.ISequence<byte>, CachingCMMDef.CacheEntryEncrypt>.Select(this.EncryptMap,cacheID);
      } else {
        return (CachingCMMDef.CacheEntryEncrypt)null;
      }
    }
    public CachingCMMDef.CacheEntryDecrypt LookupDecrypt(Dafny.ISequence<byte> cacheID) {
      if (((this.DecryptMap).Keys).Contains((cacheID))) {
        return Dafny.Map<Dafny.ISequence<byte>, CachingCMMDef.CacheEntryDecrypt>.Select(this.DecryptMap,cacheID);
      } else {
        return (CachingCMMDef.CacheEntryDecrypt)null;
      }
    }
    public CachingCMMDef.CacheEntryEncrypt AddEncrypt(Dafny.ISequence<byte> cacheID, Materials.EncryptionMaterials encMat, BigInteger secondsToLiveLimit)
    {
      CachingCMMDef.CacheEntryEncrypt entry = default(CachingCMMDef.CacheEntryEncrypt);
      CachingCMMDef.CacheEntryEncrypt _nw15 = new CachingCMMDef.CacheEntryEncrypt();
      _nw15.__ctor(encMat, secondsToLiveLimit);
      entry = _nw15;
      (this).EncryptMap = Dafny.Map<Dafny.ISequence<byte>, CachingCMMDef.CacheEntryEncrypt>.Update(this.EncryptMap,cacheID, entry);
      return entry;
    }
    public CachingCMMDef.CacheEntryDecrypt AddDecrypt(Dafny.ISequence<byte> cacheID, Materials.DecryptionMaterials decMat, BigInteger secondsToLiveLimit)
    {
      CachingCMMDef.CacheEntryDecrypt entry = default(CachingCMMDef.CacheEntryDecrypt);
      CachingCMMDef.CacheEntryDecrypt _nw16 = new CachingCMMDef.CacheEntryDecrypt();
      _nw16.__ctor(decMat, secondsToLiveLimit);
      entry = _nw16;
      (this).DecryptMap = Dafny.Map<Dafny.ISequence<byte>, CachingCMMDef.CacheEntryDecrypt>.Update(this.DecryptMap,cacheID, entry);
      return entry;
    }
    public void EvictEncrypt(Dafny.ISequence<byte> cacheID)
    {
      (this).EncryptMap = Dafny.Helpers.Id<Func<Dafny.ISequence<byte>, Dafny.IMap<Dafny.ISequence<byte>,CachingCMMDef.CacheEntryEncrypt>>>((_21143_cacheID) => ((System.Func<Dafny.IMap<Dafny.ISequence<byte>,CachingCMMDef.CacheEntryEncrypt>>)(() => {
        var _coll1 = new System.Collections.Generic.List<Dafny.Pair<Dafny.ISequence<byte>,CachingCMMDef.CacheEntryEncrypt>>();
        foreach (Dafny.ISequence<byte> _compr_1 in ((this.EncryptMap).Keys).Elements) {
          Dafny.ISequence<byte> _21144_id = (Dafny.ISequence<byte>)_compr_1;
          if ((((this.EncryptMap).Keys).Contains((_21144_id))) && (!(_21144_id).Equals((_21143_cacheID)))) {
            _coll1.Add(new Dafny.Pair<Dafny.ISequence<byte>,CachingCMMDef.CacheEntryEncrypt>(_21144_id,Dafny.Map<Dafny.ISequence<byte>, CachingCMMDef.CacheEntryEncrypt>.Select(this.EncryptMap,_21144_id)));
          }
        }
        return Dafny.Map<Dafny.ISequence<byte>,CachingCMMDef.CacheEntryEncrypt>.FromCollection(_coll1);
      }))())(cacheID);
    }
    public void EvictDecrypt(Dafny.ISequence<byte> cacheID)
    {
      (this).DecryptMap = Dafny.Helpers.Id<Func<Dafny.ISequence<byte>, Dafny.IMap<Dafny.ISequence<byte>,CachingCMMDef.CacheEntryDecrypt>>>((_21145_cacheID) => ((System.Func<Dafny.IMap<Dafny.ISequence<byte>,CachingCMMDef.CacheEntryDecrypt>>)(() => {
        var _coll2 = new System.Collections.Generic.List<Dafny.Pair<Dafny.ISequence<byte>,CachingCMMDef.CacheEntryDecrypt>>();
        foreach (Dafny.ISequence<byte> _compr_2 in ((this.DecryptMap).Keys).Elements) {
          Dafny.ISequence<byte> _21146_id = (Dafny.ISequence<byte>)_compr_2;
          if ((((this.DecryptMap).Keys).Contains((_21146_id))) && (!(_21146_id).Equals((_21145_cacheID)))) {
            _coll2.Add(new Dafny.Pair<Dafny.ISequence<byte>,CachingCMMDef.CacheEntryDecrypt>(_21146_id,Dafny.Map<Dafny.ISequence<byte>, CachingCMMDef.CacheEntryDecrypt>.Select(this.DecryptMap,_21146_id)));
          }
        }
        return Dafny.Map<Dafny.ISequence<byte>,CachingCMMDef.CacheEntryDecrypt>.FromCollection(_coll2);
      }))())(cacheID);
    }
  }

  public partial class CacheEntryEncrypt {
    public CacheEntryEncrypt() {
      this.messagesEncrypted = BigInteger.Zero;
      this.bytesEncrypted = BigInteger.Zero;
      this._encMat = Materials.ValidEncryptionMaterials.Default();
      this._expiryTime = BigInteger.Zero;
    }
    public BigInteger messagesEncrypted;public BigInteger bytesEncrypted;public void __ctor(Materials.EncryptionMaterials encMat, BigInteger secondsToLiveLimit)
    {
      (this)._encMat = encMat;
      ulong _21147_currentTime;
      ulong _out153;
      _out153 = TimeUtil.Time.CurrentRelativeTime();
      _21147_currentTime = _out153;
      (this)._expiryTime = (new BigInteger(_21147_currentTime)) + (secondsToLiveLimit);
      BigInteger _rhs19 = BigInteger.Zero;
      BigInteger _rhs20 = BigInteger.Zero;
      CachingCMMDef.CacheEntryEncrypt _lhs6 = this;
      CachingCMMDef.CacheEntryEncrypt _lhs7 = this;
      _lhs6.messagesEncrypted = _rhs19;
      _lhs7.bytesEncrypted = _rhs20;
    }
    public void IncrementUse(BigInteger byteCount)
    {
      (this).messagesEncrypted = (this.messagesEncrypted) + (BigInteger.One);
      (this).bytesEncrypted = (this.bytesEncrypted) + (byteCount);
    }
    public Materials.EncryptionMaterials _encMat;public Materials.EncryptionMaterials encMat { get {
      return this._encMat;
    } }
    public BigInteger _expiryTime;public BigInteger expiryTime { get {
      return this._expiryTime;
    } }
  }

  public partial class CacheEntryDecrypt {
    public CacheEntryDecrypt() {
      this._decMat = Materials.ValidDecryptionMaterials.Default();
      this._expiryTime = BigInteger.Zero;
    }
    public void __ctor(Materials.DecryptionMaterials decMat, BigInteger secondsToLiveLimit)
    {
      (this)._decMat = decMat;
      ulong _21148_currentTime;
      ulong _out154;
      _out154 = TimeUtil.Time.CurrentRelativeTime();
      _21148_currentTime = _out154;
      (this)._expiryTime = (new BigInteger(_21148_currentTime)) + (secondsToLiveLimit);
    }
    public Materials.DecryptionMaterials _decMat;public Materials.DecryptionMaterials decMat { get {
      return this._decMat;
    } }
    public BigInteger _expiryTime;public BigInteger expiryTime { get {
      return this._expiryTime;
    } }
  }

  public partial class __default {
    public static Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> ComputeCacheIDForEncrypt(Wrappers_Compile.Option<ushort> algSuiteID, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encCtx)
    {
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> res = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      Streams_Compile.ByteWriter _21149_wr;
      Streams_Compile.ByteWriter _nw17 = new Streams_Compile.ByteWriter();
      _nw17.__ctor();
      _21149_wr = _nw17;
      Wrappers_Compile.Option<ushort> _source21 = algSuiteID;
      if (_source21.is_None) {
        {
          BigInteger _21150___v0;
          BigInteger _out155;
          _out155 = (_21149_wr).WriteByte(0);
          _21150___v0 = _out155;
        }
      } else {
        ushort _21151___mcc_h0 = ((Wrappers_Compile.Option_Some<ushort>)_source21).@value;
        {
          ushort _21152_algID = _21151___mcc_h0;
          BigInteger _21153___v1;
          BigInteger _out156;
          _out156 = (_21149_wr).WriteByte(1);
          _21153___v1 = _out156;
          BigInteger _21154___v2;
          BigInteger _out157;
          _out157 = (_21149_wr).WriteUInt16((ushort)(_21152_algID));
          _21154___v2 = _out157;
        }
      }
      Streams_Compile.ByteWriter _21155_encCtxWr;
      Streams_Compile.ByteWriter _nw18 = new Streams_Compile.ByteWriter();
      _nw18.__ctor();
      _21155_encCtxWr = _nw18;
      BigInteger _21156___v3 = BigInteger.Zero;
      Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>> _21157_valueOrError0 = Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>>.Default(BigInteger.Zero);
      Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>> _out158;
      _out158 = Serialize_Compile.__default.SerializeAAD(_21155_encCtxWr, encCtx);
      _21157_valueOrError0 = _out158;
      if ((_21157_valueOrError0).IsFailure()) {
        res = (_21157_valueOrError0).PropagateFailure<Dafny.ISequence<byte>>();
        return res;
      }
      _21156___v3 = (_21157_valueOrError0).Extract();
      Dafny.ISequence<byte> _21158_encCtxEncoding = Dafny.Sequence<byte>.Empty;
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _21159_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out159;
      _out159 = Digest_Compile.__default.Digest(CachingCMMDef.__default.CACHE__ID__HASH__ALGORITHM, (_21155_encCtxWr).GetDataWritten());
      _21159_valueOrError1 = _out159;
      if ((_21159_valueOrError1).IsFailure()) {
        res = (_21159_valueOrError1).PropagateFailure<Dafny.ISequence<byte>>();
        return res;
      }
      _21158_encCtxEncoding = (_21159_valueOrError1).Extract();
      BigInteger _21160___v4;
      BigInteger _out160;
      _out160 = (_21149_wr).WriteBytes(_21158_encCtxEncoding);
      _21160___v4 = _out160;
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out161;
      _out161 = Digest_Compile.__default.Digest(CachingCMMDef.__default.CACHE__ID__HASH__ALGORITHM, (_21149_wr).GetDataWritten());
      res = _out161;
      return res;
    }
    public static Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> ComputeCacheIDForDecrypt(Materials.DecryptionMaterialsRequest materialsRequest)
    {
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> res = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      BigInteger _21161_i;
      _21161_i = BigInteger.Zero;
      Dafny.ISequence<byte>[] _21162_edkHashes;
      Dafny.ISequence<byte>[] _nw19 = new Dafny.ISequence<byte>[Dafny.Helpers.ToIntChecked(Dafny.Helpers.ToIntChecked(new BigInteger(((materialsRequest).dtor_encryptedDataKeys).Count), "C# arrays may not be larger than the max 32-bit integer"),"C# array size must not be larger than max 32-bit int")];
      Func<BigInteger, Dafny.ISequence<byte>> _arrayinit2 = ((System.Func<BigInteger, Dafny.ISequence<byte>>)((_21163___v5) => {
        return Dafny.Sequence<byte>.FromElements();
      }));
      for (var _arrayinit_02 = 0; _arrayinit_02 < new BigInteger(_nw19.Length); _arrayinit_02++) {
        _nw19[(int)(_arrayinit_02)] = _arrayinit2(_arrayinit_02);
      }
      _21162_edkHashes = _nw19;
      while ((_21161_i) < (new BigInteger(((materialsRequest).dtor_encryptedDataKeys).Count))) {
        Materials.EncryptedDataKey _21164_edk;
        _21164_edk = ((materialsRequest).dtor_encryptedDataKeys).Select(_21161_i);
        Dafny.ISequence<byte>[] _21165_recv0;
        _21165_recv0 = _21162_edkHashes;
        BigInteger _21166_idx0;
        _21166_idx0 = _21161_i;
        Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _21167_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
        Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out162;
        _out162 = Digest_Compile.__default.Digest(CachingCMMDef.__default.CACHE__ID__HASH__ALGORITHM, MessageHeader.__default.EDKEntryToSeq(_21164_edk));
        _21167_valueOrError0 = _out162;
        if ((_21167_valueOrError0).IsFailure()) {
          res = (_21167_valueOrError0).PropagateFailure<Dafny.ISequence<byte>>();
          return res;
        }
        (_21165_recv0)[(int)((_21166_idx0))] = (_21167_valueOrError0).Extract();
        _21161_i = (_21161_i) + (BigInteger.One);
      }
      Sorting_Compile.__default.SelectionSort<Dafny.ISequence<byte>>(_21162_edkHashes, Sorting_Compile.__default.LexicographicByteSeqBelow);
      Streams_Compile.ByteWriter _21168_wr;
      Streams_Compile.ByteWriter _nw20 = new Streams_Compile.ByteWriter();
      _nw20.__ctor();
      _21168_wr = _nw20;
      BigInteger _21169___v6;
      BigInteger _out163;
      _out163 = (_21168_wr).WriteUInt16((ushort)((materialsRequest).dtor_algorithmSuiteID));
      _21169___v6 = _out163;
      _21161_i = BigInteger.Zero;
      while ((_21161_i) < (new BigInteger((_21162_edkHashes).Length))) {
        BigInteger _21170___v7;
        BigInteger _out164;
        _out164 = (_21168_wr).WriteBytes((_21162_edkHashes)[(int)(_21161_i)]);
        _21170___v7 = _out164;
        _21161_i = (_21161_i) + (BigInteger.One);
      }
      Dafny.ISequence<byte> _21171_zeros;
      _21171_zeros = ((System.Func<Dafny.ISequence<byte>>) (() => {
        BigInteger dim10 = Digest_Compile.__default.Length(CachingCMMDef.__default.CACHE__ID__HASH__ALGORITHM);
        var arr10 = new byte[Dafny.Helpers.ToIntChecked(dim10,"C# array size must not be larger than max 32-bit int")];
        for (int i10 = 0; i10 < dim10; i10++) {
          var _21172___v8 = (BigInteger) i10;
          arr10[(int)(_21172___v8)] = 0;
        }
        return Dafny.Sequence<byte>.FromArray(arr10);
      }))();
      BigInteger _21173___v9;
      BigInteger _out165;
      _out165 = (_21168_wr).WriteBytes(_21171_zeros);
      _21173___v9 = _out165;
      Streams_Compile.ByteWriter _21174_encCtxWr;
      Streams_Compile.ByteWriter _nw21 = new Streams_Compile.ByteWriter();
      _nw21.__ctor();
      _21174_encCtxWr = _nw21;
      BigInteger _21175___v10 = BigInteger.Zero;
      Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>> _21176_valueOrError1 = Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>>.Default(BigInteger.Zero);
      Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>> _out166;
      _out166 = Serialize_Compile.__default.SerializeAAD(_21174_encCtxWr, (materialsRequest).dtor_encryptionContext);
      _21176_valueOrError1 = _out166;
      if ((_21176_valueOrError1).IsFailure()) {
        res = (_21176_valueOrError1).PropagateFailure<Dafny.ISequence<byte>>();
        return res;
      }
      _21175___v10 = (_21176_valueOrError1).Extract();
      Dafny.ISequence<byte> _21177_encCtxEncoding = Dafny.Sequence<byte>.Empty;
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _21178_valueOrError2 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out167;
      _out167 = Digest_Compile.__default.Digest(CachingCMMDef.__default.CACHE__ID__HASH__ALGORITHM, (_21174_encCtxWr).GetDataWritten());
      _21178_valueOrError2 = _out167;
      if ((_21178_valueOrError2).IsFailure()) {
        res = (_21178_valueOrError2).PropagateFailure<Dafny.ISequence<byte>>();
        return res;
      }
      _21177_encCtxEncoding = (_21178_valueOrError2).Extract();
      BigInteger _21179___v11;
      BigInteger _out168;
      _out168 = (_21168_wr).WriteBytes(_21177_encCtxEncoding);
      _21179___v11 = _out168;
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out169;
      _out169 = Digest_Compile.__default.Digest(CachingCMMDef.__default.CACHE__ID__HASH__ALGORITHM, (_21168_wr).GetDataWritten());
      res = _out169;
      return res;
    }
    public static ulong DEFAULT__MESSAGE__USE__LIMIT__PER__CACHED__KEY { get {
      return 4294967296UL;
    } }
    public static ulong DEFAULT__BYTE__USE__LIMIT__PER__CACHED__KEY { get {
      return 9223372036854775807UL;
    } }
    public static CryptoDatatypes_Compile.DigestAlgorithm CACHE__ID__HASH__ALGORITHM { get {
      return @CryptoDatatypes_Compile.DigestAlgorithm.create();
    } }
  }
} // end of namespace CachingCMMDef
namespace AwsKmsMrkAreUnique_Compile {





  public partial class __default {
    public static Wrappers_Compile.Result<_System.Tuple0, Dafny.ISequence<char>> AwsKmsMrkAreUnique(Dafny.ISequence<AwsKmsArnParsing_Compile.AwsKmsIdentifier> identifiers) {
      Dafny.ISequence<AwsKmsArnParsing_Compile.AwsKmsIdentifier> _21180_mrks = Seq_Compile.__default.Filter<AwsKmsArnParsing_Compile.AwsKmsIdentifier>(AwsKmsArnParsing_Compile.__default.IsMultiRegionAwsKmsIdentifier, identifiers);
      if ((new BigInteger((_21180_mrks).Count)).Sign == 0) {
        return @Wrappers_Compile.Result<_System.Tuple0, Dafny.ISequence<char>>.create_Success(@_System.Tuple0.create());
      } else {
        Dafny.ISequence<Dafny.ISequence<char>> _21181_mrkKeyIds = Seq_Compile.__default.Map<AwsKmsArnParsing_Compile.AwsKmsIdentifier, Dafny.ISequence<char>>(AwsKmsMrkAreUnique_Compile.__default.GetKeyId, _21180_mrks);
        Dafny.ISet<Dafny.ISequence<char>> _21182_setMrks = Seq_Compile.__default.ToSet<Dafny.ISequence<char>>(_21181_mrkKeyIds);
        if ((new BigInteger((_21181_mrkKeyIds).Count)) == (new BigInteger((_21182_setMrks).Count))) {
          return @Wrappers_Compile.Result<_System.Tuple0, Dafny.ISequence<char>>.create_Success(@_System.Tuple0.create());
        } else {
          Dafny.ISet<Dafny.ISequence<char>> _21183_duplicateMrkIds = Dafny.Helpers.Id<Func<Dafny.ISequence<Dafny.ISequence<char>>, Dafny.ISet<Dafny.ISequence<char>>>>((_21184_mrkKeyIds) => ((System.Func<Dafny.ISet<Dafny.ISequence<char>>>)(() => {
            var _coll3 = new System.Collections.Generic.List<Dafny.ISequence<char>>();
            foreach (Dafny.ISequence<char> _compr_3 in (_21184_mrkKeyIds).Elements) {
              Dafny.ISequence<char> _21185_x = (Dafny.ISequence<char>)_compr_3;
              if (((_21184_mrkKeyIds).Contains((_21185_x))) && (((Dafny.MultiSet<Dafny.ISequence<char>>.FromSeq(_21184_mrkKeyIds)).Select(_21185_x)) >= (BigInteger.One))) {
                _coll3.Add(_21185_x);
              }
            }
            return Dafny.Set<Dafny.ISequence<char>>.FromCollection(_coll3);
          }))())(_21181_mrkKeyIds);
          Func<AwsKmsArnParsing_Compile.AwsKmsIdentifier, bool> _21186_isDuplicate = Dafny.Helpers.Id<Func<Dafny.ISet<Dafny.ISequence<char>>, Func<AwsKmsArnParsing_Compile.AwsKmsIdentifier, bool>>>((_21187_duplicateMrkIds) => ((System.Func<AwsKmsArnParsing_Compile.AwsKmsIdentifier, bool>)((_21188_identifier) => {
            return (_21187_duplicateMrkIds).Contains((AwsKmsMrkAreUnique_Compile.__default.GetKeyId(_21188_identifier)));
          })))(_21183_duplicateMrkIds);
          Func<AwsKmsArnParsing_Compile.AwsKmsIdentifier, Dafny.ISequence<char>> _21189_identifierToString = ((System.Func<AwsKmsArnParsing_Compile.AwsKmsIdentifier, Dafny.ISequence<char>>)((_21190_i) => {
            return (_21190_i)._ToString();
          }));
          Dafny.ISequence<AwsKmsArnParsing_Compile.AwsKmsIdentifier> _21191_duplicateIdentifiers = Seq_Compile.__default.Filter<AwsKmsArnParsing_Compile.AwsKmsIdentifier>(_21186_isDuplicate, identifiers);
          Dafny.ISequence<Dafny.ISequence<char>> _21192_duplicates = Seq_Compile.__default.Map<AwsKmsArnParsing_Compile.AwsKmsIdentifier, Dafny.ISequence<char>>(_21189_identifierToString, _21191_duplicateIdentifiers);
          Wrappers_Compile.Outcome<Dafny.ISequence<char>> _21193_valueOrError0 = Wrappers_Compile.__default.Need<Dafny.ISequence<char>>((new BigInteger((_21192_duplicates).Count)).Sign == 1, Dafny.Sequence<char>.FromString("Impossible"));
          if ((_21193_valueOrError0).IsFailure()) {
            return (_21193_valueOrError0).PropagateFailure<_System.Tuple0>();
          } else {
            return @Wrappers_Compile.Result<_System.Tuple0, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Related multi-Region keys: "), StandardLibrary_Compile.__default.Join<char>(_21192_duplicates, Dafny.Sequence<char>.FromString(","))), Dafny.Sequence<char>.FromString("are not allowed.")));
          }
        }
      }
    }
    public static Dafny.ISequence<char> GetKeyId(AwsKmsArnParsing_Compile.AwsKmsIdentifier identifier) {
      AwsKmsArnParsing_Compile.AwsKmsIdentifier _source22 = identifier;
      if (_source22.is_AwsKmsArnIdentifier) {
        AwsKmsArnParsing_Compile.AwsArn _21194___mcc_h0 = ((AwsKmsArnParsing_Compile.AwsKmsIdentifier_AwsKmsArnIdentifier)_source22).a;
        AwsKmsArnParsing_Compile.AwsArn _21195_a = _21194___mcc_h0;
        return ((_21195_a).dtor_resource).dtor_value;
      } else {
        AwsKmsArnParsing_Compile.AwsResource _21196___mcc_h1 = ((AwsKmsArnParsing_Compile.AwsKmsIdentifier_AwsKmsRawResourceIdentifier)_source22).r;
        AwsKmsArnParsing_Compile.AwsResource _21197_i = _21196___mcc_h1;
        return (_21197_i).dtor_value;
      }
    }
  }
} // end of namespace AwsKmsMrkAreUnique_Compile
namespace Actions_Compile {


  public interface Action<A, R> {
    R Invoke(A a);
  }
  public class _Companion_Action<A, R> {
  }

  public interface ActionWithResult<A, R, E> : Actions_Compile.Action<A, Wrappers_Compile.Result<R, E>> {
  }
  public class _Companion_ActionWithResult<A, R, E> {
  }

  public partial class __default {
    public static Dafny.ISequence<__R> Map<__A, __R>(Actions_Compile.Action<__A, __R> action, Dafny.ISequence<__A> s)
    {
      Dafny.ISequence<__R> res = Dafny.Sequence<__R>.Empty;
      Dafny.ISequence<__R> _21198_rs;
      _21198_rs = Dafny.Sequence<__R>.FromElements();
      BigInteger _hi0 = new BigInteger((s).Count);
      for (BigInteger _21199_i = BigInteger.Zero; _21199_i < _hi0; _21199_i++) {
        __R _21200_r;
        __R _out170;
        _out170 = (action).Invoke((s).Select(_21199_i));
        _21200_r = _out170;
        _21198_rs = Dafny.Sequence<__R>.Concat(_21198_rs, Dafny.Sequence<__R>.FromElements(_21200_r));
      }
      res = _21198_rs;
      return res;
      return res;
    }
    public static Wrappers_Compile.Result<Dafny.ISequence<__R>, __E> MapWithResult<__A, __R, __E>(Actions_Compile.ActionWithResult<__A, __R, __E> action, Dafny.ISequence<__A> s)
    {
      Wrappers_Compile.Result<Dafny.ISequence<__R>, __E> res = Wrappers_Compile.Result<Dafny.ISequence<__R>, __E>.Default(Dafny.Sequence<__R>.Empty);
      Dafny.ISequence<__R> _21201_rs;
      _21201_rs = Dafny.Sequence<__R>.FromElements();
      BigInteger _hi1 = new BigInteger((s).Count);
      for (BigInteger _21202_i = BigInteger.Zero; _21202_i < _hi1; _21202_i++) {
        __R _21203_r = _td___R.Default();
        Wrappers_Compile.Result<__R, __E> _21204_valueOrError0 = Wrappers_Compile.Result<__R, __E>.Default(_td___R.Default());
        Wrappers_Compile.Result<__R, __E> _out171;
        _out171 = (action).Invoke((s).Select(_21202_i));
        _21204_valueOrError0 = _out171;
        if ((_21204_valueOrError0).IsFailure()) {
          res = (_21204_valueOrError0).PropagateFailure<Dafny.ISequence<__R>>();
          return res;
        }
        _21203_r = (_21204_valueOrError0).Extract();
        _21201_rs = Dafny.Sequence<__R>.Concat(_21201_rs, Dafny.Sequence<__R>.FromElements(_21203_r));
      }
      res = @Wrappers_Compile.Result<Dafny.ISequence<__R>, __E>.create_Success(_21201_rs);
      return res;
      return res;
    }
    public static Dafny.ISequence<__A> Filter<__A>(Actions_Compile.Action<__A, bool> action, Dafny.ISequence<__A> s)
    {
      Dafny.ISequence<__A> res = Dafny.Sequence<__A>.Empty;
      Dafny.ISequence<__A> _21205_rs;
      _21205_rs = Dafny.Sequence<__A>.FromElements();
      BigInteger _hi2 = new BigInteger((s).Count);
      for (BigInteger _21206_i = BigInteger.Zero; _21206_i < _hi2; _21206_i++) {
        bool _21207_r;
        bool _out172;
        _out172 = (action).Invoke((s).Select(_21206_i));
        _21207_r = _out172;
        if (_21207_r) {
          _21205_rs = Dafny.Sequence<__A>.Concat(_21205_rs, Dafny.Sequence<__A>.FromElements((s).Select(_21206_i)));
        }
      }
      res = _21205_rs;
      return res;
      return res;
    }
    public static Wrappers_Compile.Result<Dafny.ISequence<__A>, __E> FilterWithResult<__A, __E>(Actions_Compile.ActionWithResult<__A, bool, __E> action, Dafny.ISequence<__A> s)
    {
      Wrappers_Compile.Result<Dafny.ISequence<__A>, __E> res = Wrappers_Compile.Result<Dafny.ISequence<__A>, __E>.Default(Dafny.Sequence<__A>.Empty);
      Dafny.ISequence<__A> _21208_rs;
      _21208_rs = Dafny.Sequence<__A>.FromElements();
      BigInteger _hi3 = new BigInteger((s).Count);
      for (BigInteger _21209_i = BigInteger.Zero; _21209_i < _hi3; _21209_i++) {
        bool _21210_r = false;
        Wrappers_Compile.Result<bool, __E> _21211_valueOrError0 = Wrappers_Compile.Result<bool, __E>.Default(false);
        Wrappers_Compile.Result<bool, __E> _out173;
        _out173 = (action).Invoke((s).Select(_21209_i));
        _21211_valueOrError0 = _out173;
        if ((_21211_valueOrError0).IsFailure()) {
          res = (_21211_valueOrError0).PropagateFailure<Dafny.ISequence<__A>>();
          return res;
        }
        _21210_r = (_21211_valueOrError0).Extract();
        if (_21210_r) {
          _21208_rs = Dafny.Sequence<__A>.Concat(_21208_rs, Dafny.Sequence<__A>.FromElements((s).Select(_21209_i)));
        }
      }
      res = @Wrappers_Compile.Result<Dafny.ISequence<__A>, __E>.create_Success(_21208_rs);
      return res;
      return res;
    }
    public static Wrappers_Compile.Result<__B, Dafny.ISequence<__E>> ReduceToSuccess<__A, __B, __E>(Actions_Compile.ActionWithResult<__A, __B, __E> action, Dafny.ISequence<__A> s)
    {
      Wrappers_Compile.Result<__B, Dafny.ISequence<__E>> res = default(Wrappers_Compile.Result<__B, Dafny.ISequence<__E>>);
      Dafny.ISequence<__E> _21212_errors;
      _21212_errors = Dafny.Sequence<__E>.FromElements();
      BigInteger _hi4 = new BigInteger((s).Count);
      for (BigInteger _21213_i = BigInteger.Zero; _21213_i < _hi4; _21213_i++) {
        Wrappers_Compile.Result<__B, __E> _21214_attempt;
        Wrappers_Compile.Result<__B, __E> _out174;
        _out174 = (action).Invoke((s).Select(_21213_i));
        _21214_attempt = _out174;
        if ((_21214_attempt).is_Success) {
          res = @Wrappers_Compile.Result<__B, Dafny.ISequence<__E>>.create_Success((_21214_attempt).dtor_value);
          return res;
        } else {
          _21212_errors = Dafny.Sequence<__E>.Concat(_21212_errors, Dafny.Sequence<__E>.FromElements((_21214_attempt).dtor_error));
        }
      }
      res = @Wrappers_Compile.Result<__B, Dafny.ISequence<__E>>.create_Failure(_21212_errors);
      return res;
      return res;
    }
  }
} // end of namespace Actions_Compile
namespace Constants_Compile {


  public partial class __default {
    public static Dafny.ISequence<byte> PROVIDER__ID { get {
      Dafny.ISequence<byte> _21215_s = Dafny.Sequence<byte>.FromElements(97, 119, 115, 45, 107, 109, 115);
      return _21215_s;
    } }
  }
} // end of namespace Constants_Compile
namespace AwsKmsMrkMatchForDecrypt_Compile {





  public partial class __default {
    public static bool AwsKmsMrkMatchForDecrypt(AwsKmsArnParsing_Compile.AwsKmsIdentifier configuredAwsKmsIdentifier, AwsKmsArnParsing_Compile.AwsKmsIdentifier messageAwsKmsIdentifer)
    {
      if (object.Equals(configuredAwsKmsIdentifier, messageAwsKmsIdentifer)) {
        return true;
      } else {
        _System.Tuple2<AwsKmsArnParsing_Compile.AwsKmsIdentifier, AwsKmsArnParsing_Compile.AwsKmsIdentifier> _source23 = @_System.Tuple2<AwsKmsArnParsing_Compile.AwsKmsIdentifier, AwsKmsArnParsing_Compile.AwsKmsIdentifier>.create(messageAwsKmsIdentifer, configuredAwsKmsIdentifier);
        {
          AwsKmsArnParsing_Compile.AwsKmsIdentifier _21216___mcc_h0 = ((_System.Tuple2<AwsKmsArnParsing_Compile.AwsKmsIdentifier, AwsKmsArnParsing_Compile.AwsKmsIdentifier>)_source23)._0;
          AwsKmsArnParsing_Compile.AwsKmsIdentifier _21217___mcc_h1 = ((_System.Tuple2<AwsKmsArnParsing_Compile.AwsKmsIdentifier, AwsKmsArnParsing_Compile.AwsKmsIdentifier>)_source23)._1;
          AwsKmsArnParsing_Compile.AwsKmsIdentifier _source24 = _21216___mcc_h0;
          if (_source24.is_AwsKmsArnIdentifier) {
            AwsKmsArnParsing_Compile.AwsArn _21218___mcc_h2 = ((AwsKmsArnParsing_Compile.AwsKmsIdentifier_AwsKmsArnIdentifier)_source24).a;
            AwsKmsArnParsing_Compile.AwsKmsIdentifier _source25 = _21217___mcc_h1;
            if (_source25.is_AwsKmsArnIdentifier) {
              AwsKmsArnParsing_Compile.AwsArn _21219___mcc_h4 = ((AwsKmsArnParsing_Compile.AwsKmsIdentifier_AwsKmsArnIdentifier)_source25).a;
              AwsKmsArnParsing_Compile.AwsArn _21220_messageAwsKmsArn = _21219___mcc_h4;
              AwsKmsArnParsing_Compile.AwsArn _21221_configuredAwsKmsArn = _21218___mcc_h2;
              if ((!(AwsKmsArnParsing_Compile.__default.IsMultiRegionAwsKmsArn(_21221_configuredAwsKmsArn))) || (!(AwsKmsArnParsing_Compile.__default.IsMultiRegionAwsKmsArn(_21220_messageAwsKmsArn)))) {
                return false;
              } else {
                return (((((_21220_messageAwsKmsArn).dtor_partition).Equals(((_21221_configuredAwsKmsArn).dtor_partition))) && (((_21220_messageAwsKmsArn).dtor_service).Equals(((_21221_configuredAwsKmsArn).dtor_service)))) && (((_21220_messageAwsKmsArn).dtor_account).Equals(((_21221_configuredAwsKmsArn).dtor_account)))) && (object.Equals((_21220_messageAwsKmsArn).dtor_resource, (_21221_configuredAwsKmsArn).dtor_resource));
              }
            } else {
              AwsKmsArnParsing_Compile.AwsResource _21222___mcc_h6 = ((AwsKmsArnParsing_Compile.AwsKmsIdentifier_AwsKmsRawResourceIdentifier)_source25).r;
              return false;
            }
          } else {
            AwsKmsArnParsing_Compile.AwsResource _21223___mcc_h8 = ((AwsKmsArnParsing_Compile.AwsKmsIdentifier_AwsKmsRawResourceIdentifier)_source24).r;
            return false;
          }
        }
      }
    }
  }
} // end of namespace AwsKmsMrkMatchForDecrypt_Compile
namespace AwsKmsMrkAwareSymmetricKeyring {














  public partial class AwsKmsMrkAwareSymmetricKeyring : KeyringDefs.Keyring {
    public AwsKmsMrkAwareSymmetricKeyring() {
      this._client = default(Amazon.KeyManagementService.IAmazonKeyManagementService);
      this._awsKmsKey = default(Dafny.ISequence<char>);
      this._awsKmsArn = default(AwsKmsArnParsing_Compile.AwsKmsIdentifier);
      this._grantTokens = Dafny.Sequence<Dafny.ISequence<char>>.Empty;
    }
    public void __ctor(Amazon.KeyManagementService.IAmazonKeyManagementService client, Dafny.ISequence<char> awsKmsKey, Dafny.ISequence<Dafny.ISequence<char>> grantTokens)
    {
      Wrappers_Compile.Result<AwsKmsArnParsing_Compile.AwsKmsIdentifier, Dafny.ISequence<char>> _21224_parsedAwsKmsId;
      _21224_parsedAwsKmsId = AwsKmsArnParsing_Compile.__default.ParseAwsKmsIdentifier(awsKmsKey);
      (this)._client = client;
      (this)._awsKmsKey = awsKmsKey;
      (this)._awsKmsArn = (_21224_parsedAwsKmsId).dtor_value;
      (this)._grantTokens = grantTokens;
    }
    public Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>> OnEncrypt(Materials.EncryptionMaterials materials)
    {
      Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>> res = Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>>.Default(Materials.ValidEncryptionMaterials.Default());
      if (((materials).dtor_plaintextDataKey).is_None) {
        KMSUtils.GenerateDataKeyRequest _21225_generatorRequest;
        _21225_generatorRequest = @KMSUtils.GenerateDataKeyRequest.create((materials).dtor_encryptionContext, (this).grantTokens, (this).awsKmsKey, (int)(AlgorithmSuite.ID.KDFInputKeyLength((materials).dtor_algorithmSuiteID)));
        Wrappers_Compile.Result<KMSUtils.GenerateDataKeyResponse, Dafny.ISequence<char>> _21226_maybeGenerateResponse;
        Wrappers_Compile.Result<KMSUtils.GenerateDataKeyResponse, Dafny.ISequence<char>> _out175;
        _out175 = KMSUtils.ClientHelper.GenerateDataKey((this).client, _21225_generatorRequest);
        _21226_maybeGenerateResponse = _out175;
        if ((_21226_maybeGenerateResponse).is_Failure) {
          res = @Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>>.create_Failure((_21226_maybeGenerateResponse).dtor_error);
          return res;
        }
        KMSUtils.GenerateDataKeyResponse _21227_generateResponse;
        _21227_generateResponse = (_21226_maybeGenerateResponse).dtor_value;
        Wrappers_Compile.Outcome<Dafny.ISequence<char>> _21228_valueOrError0 = Wrappers_Compile.Outcome<Dafny.ISequence<char>>.Default();
        _21228_valueOrError0 = Wrappers_Compile.__default.Need<Dafny.ISequence<char>>((_21227_generateResponse).IsWellFormed(), Dafny.Sequence<char>.FromString("Invalid response from KMS GenerateDataKey"));
        if ((_21228_valueOrError0).IsFailure()) {
          res = (_21228_valueOrError0).PropagateFailure<Materials.EncryptionMaterials>();
          return res;
        }
        Wrappers_Compile.Outcome<Dafny.ISequence<char>> _21229_valueOrError1 = Wrappers_Compile.Outcome<Dafny.ISequence<char>>.Default();
        _21229_valueOrError1 = Wrappers_Compile.__default.Need<Dafny.ISequence<char>>((AwsKmsArnParsing_Compile.__default.ParseAwsKmsIdentifier((_21227_generateResponse).dtor_keyID)).is_Success, Dafny.Sequence<char>.FromString("Invalid response from KMS GenerateDataKey:: Invalid Key Id"));
        if ((_21229_valueOrError1).IsFailure()) {
          res = (_21229_valueOrError1).PropagateFailure<Materials.EncryptionMaterials>();
          return res;
        }
        Wrappers_Compile.Outcome<Dafny.ISequence<char>> _21230_valueOrError2 = Wrappers_Compile.Outcome<Dafny.ISequence<char>>.Default();
        _21230_valueOrError2 = Wrappers_Compile.__default.Need<Dafny.ISequence<char>>(AlgorithmSuite.ID.ValidPlaintextDataKey((materials).dtor_algorithmSuiteID, (_21227_generateResponse).dtor_plaintext), Dafny.Sequence<char>.FromString("Invalid response from AWS KMS GenerateDataKey: Invalid data key"));
        if ((_21230_valueOrError2).IsFailure()) {
          res = (_21230_valueOrError2).PropagateFailure<Materials.EncryptionMaterials>();
          return res;
        }
        Dafny.ISequence<byte> _21231_providerInfo = UTF8.ValidUTF8Bytes.Default();
        Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _21232_valueOrError3 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
        Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out176;
        _out176 = UTF8.__default.Encode((_21227_generateResponse).dtor_keyID);
        _21232_valueOrError3 = _out176;
        if ((_21232_valueOrError3).IsFailure()) {
          res = (_21232_valueOrError3).PropagateFailure<Materials.EncryptionMaterials>();
          return res;
        }
        _21231_providerInfo = (_21232_valueOrError3).Extract();
        Wrappers_Compile.Outcome<Dafny.ISequence<char>> _21233_valueOrError4 = Wrappers_Compile.Outcome<Dafny.ISequence<char>>.Default();
        _21233_valueOrError4 = Wrappers_Compile.__default.Need<Dafny.ISequence<char>>((new BigInteger((_21231_providerInfo).Count)) < (StandardLibrary_mUInt_Compile.__default.UINT16__LIMIT), Dafny.Sequence<char>.FromString("AWS KMS Key ID too long."));
        if ((_21233_valueOrError4).IsFailure()) {
          res = (_21233_valueOrError4).PropagateFailure<Materials.EncryptionMaterials>();
          return res;
        }
        Materials.EncryptedDataKey _21234_edk;
        _21234_edk = @Materials.EncryptedDataKey.create(Constants_Compile.__default.PROVIDER__ID, _21231_providerInfo, (_21227_generateResponse).dtor_ciphertextBlob);
        Dafny.ISequence<byte> _21235_plaintextDataKey;
        _21235_plaintextDataKey = (_21227_generateResponse).dtor_plaintext;
        Materials.EncryptionMaterials _21236_result;
        _21236_result = (materials).WithKeys(@Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(_21235_plaintextDataKey), Dafny.Sequence<Materials.EncryptedDataKey>.FromElements(_21234_edk));
        res = @Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>>.create_Success(_21236_result);
        return res;
      } else {
        KMSUtils.EncryptRequest _21237_encryptRequest;
        _21237_encryptRequest = @KMSUtils.EncryptRequest.create((materials).dtor_encryptionContext, (this).grantTokens, (this).awsKmsKey, ((materials).dtor_plaintextDataKey).dtor_value);
        Wrappers_Compile.Result<KMSUtils.EncryptResponse, Dafny.ISequence<char>> _21238_maybeEncryptResponse;
        Wrappers_Compile.Result<KMSUtils.EncryptResponse, Dafny.ISequence<char>> _out177;
        _out177 = KMSUtils.ClientHelper.Encrypt((this).client, _21237_encryptRequest);
        _21238_maybeEncryptResponse = _out177;
        if ((_21238_maybeEncryptResponse).is_Failure) {
          res = @Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>>.create_Failure((_21238_maybeEncryptResponse).dtor_error);
          return res;
        }
        KMSUtils.EncryptResponse _21239_encryptResponse;
        _21239_encryptResponse = (_21238_maybeEncryptResponse).dtor_value;
        Wrappers_Compile.Outcome<Dafny.ISequence<char>> _21240_valueOrError5 = Wrappers_Compile.Outcome<Dafny.ISequence<char>>.Default();
        _21240_valueOrError5 = Wrappers_Compile.__default.Need<Dafny.ISequence<char>>((_21239_encryptResponse).IsWellFormed(), Dafny.Sequence<char>.FromString("Invalid response from KMS Encrypt"));
        if ((_21240_valueOrError5).IsFailure()) {
          res = (_21240_valueOrError5).PropagateFailure<Materials.EncryptionMaterials>();
          return res;
        }
        Wrappers_Compile.Outcome<Dafny.ISequence<char>> _21241_valueOrError6 = Wrappers_Compile.Outcome<Dafny.ISequence<char>>.Default();
        _21241_valueOrError6 = Wrappers_Compile.__default.Need<Dafny.ISequence<char>>((AwsKmsArnParsing_Compile.__default.ParseAwsKmsIdentifier((_21239_encryptResponse).dtor_keyID)).is_Success, Dafny.Sequence<char>.FromString("Invalid response from AWS KMS Encrypt:: Invalid Key Id"));
        if ((_21241_valueOrError6).IsFailure()) {
          res = (_21241_valueOrError6).PropagateFailure<Materials.EncryptionMaterials>();
          return res;
        }
        Dafny.ISequence<byte> _21242_providerInfo = UTF8.ValidUTF8Bytes.Default();
        Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _21243_valueOrError7 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
        Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out178;
        _out178 = UTF8.__default.Encode((_21239_encryptResponse).dtor_keyID);
        _21243_valueOrError7 = _out178;
        if ((_21243_valueOrError7).IsFailure()) {
          res = (_21243_valueOrError7).PropagateFailure<Materials.EncryptionMaterials>();
          return res;
        }
        _21242_providerInfo = (_21243_valueOrError7).Extract();
        Wrappers_Compile.Outcome<Dafny.ISequence<char>> _21244_valueOrError8 = Wrappers_Compile.Outcome<Dafny.ISequence<char>>.Default();
        _21244_valueOrError8 = Wrappers_Compile.__default.Need<Dafny.ISequence<char>>((new BigInteger((_21242_providerInfo).Count)) < (StandardLibrary_mUInt_Compile.__default.UINT16__LIMIT), Dafny.Sequence<char>.FromString("AWS KMS Key ID too long."));
        if ((_21244_valueOrError8).IsFailure()) {
          res = (_21244_valueOrError8).PropagateFailure<Materials.EncryptionMaterials>();
          return res;
        }
        Materials.EncryptedDataKey _21245_edk;
        _21245_edk = @Materials.EncryptedDataKey.create(Constants_Compile.__default.PROVIDER__ID, _21242_providerInfo, (_21239_encryptResponse).dtor_ciphertextBlob);
        Materials.EncryptionMaterials _21246_result;
        _21246_result = (materials).WithKeys((materials).dtor_plaintextDataKey, Dafny.Sequence<Materials.EncryptedDataKey>.FromElements(_21245_edk));
        res = @Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>>.create_Success(_21246_result);
        return res;
      }
      return res;
    }
    public Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>> OnDecrypt(Materials.DecryptionMaterials materials, Dafny.ISequence<Materials.EncryptedDataKey> encryptedDataKeys)
    {
      Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>> res = Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>.Default(Materials.ValidDecryptionMaterials.Default());
      if (((materials).dtor_plaintextDataKey).is_Some) {
        res = @Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>.create_Success(materials);
        return res;
      }
      AwsKmsMrkAwareSymmetricKeyring.OnDecryptEncryptedDataKeyFilter _21247_filter;
      AwsKmsMrkAwareSymmetricKeyring.OnDecryptEncryptedDataKeyFilter _nw22 = new AwsKmsMrkAwareSymmetricKeyring.OnDecryptEncryptedDataKeyFilter();
      _nw22.__ctor((this).awsKmsArn);
      _21247_filter = _nw22;
      Dafny.ISequence<Materials.EncryptedDataKey> _21248_edksToAttempt = Dafny.Sequence<Materials.EncryptedDataKey>.Empty;
      Wrappers_Compile.Result<Dafny.ISequence<Materials.EncryptedDataKey>, Dafny.ISequence<char>> _21249_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<Materials.EncryptedDataKey>, Dafny.ISequence<char>>.Default(Dafny.Sequence<Materials.EncryptedDataKey>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<Materials.EncryptedDataKey>, Dafny.ISequence<char>> _out179;
      _out179 = Actions_Compile.__default.FilterWithResult<Materials.EncryptedDataKey, Dafny.ISequence<char>>(_21247_filter, encryptedDataKeys);
      _21249_valueOrError0 = _out179;
      if ((_21249_valueOrError0).IsFailure()) {
        res = (_21249_valueOrError0).PropagateFailure<Materials.DecryptionMaterials>();
        return res;
      }
      _21248_edksToAttempt = (_21249_valueOrError0).Extract();
      AwsKmsMrkAwareSymmetricKeyring.DecryptSingleEncryptedDataKey _21250_decryptClosure;
      AwsKmsMrkAwareSymmetricKeyring.DecryptSingleEncryptedDataKey _nw23 = new AwsKmsMrkAwareSymmetricKeyring.DecryptSingleEncryptedDataKey();
      _nw23.__ctor(materials, (this).client, (this).awsKmsKey, (this).grantTokens);
      _21250_decryptClosure = _nw23;
      Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<Dafny.ISequence<char>>> _21251_outcome;
      Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<Dafny.ISequence<char>>> _out180;
      _out180 = Actions_Compile.__default.ReduceToSuccess<Materials.EncryptedDataKey, Materials.DecryptionMaterials, Dafny.ISequence<char>>(_21250_decryptClosure, _21248_edksToAttempt);
      _21251_outcome = _out180;
      res = ((System.Func<Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<Dafny.ISequence<char>>>, Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>>)((_source26) => {
        if (_source26.is_Success) {
          Materials.DecryptionMaterials _21252___mcc_h0 = ((Wrappers_Compile.Result_Success<Materials.DecryptionMaterials, Dafny.ISequence<Dafny.ISequence<char>>>)_source26).@value;
          return Dafny.Helpers.Let<Materials.DecryptionMaterials, Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>>(_21252___mcc_h0, _pat_let8_0 => Dafny.Helpers.Let<Materials.DecryptionMaterials, Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>>(_pat_let8_0, _21253_mat => @Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>.create_Success(_21253_mat)));
        } else {
          Dafny.ISequence<Dafny.ISequence<char>> _21254___mcc_h1 = ((Wrappers_Compile.Result_Failure<Materials.DecryptionMaterials, Dafny.ISequence<Dafny.ISequence<char>>>)_source26).error;
          return Dafny.Helpers.Let<Dafny.ISequence<Dafny.ISequence<char>>, Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>>(_21254___mcc_h1, _pat_let9_0 => Dafny.Helpers.Let<Dafny.ISequence<Dafny.ISequence<char>>, Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>>(_pat_let9_0, _21255_errors => (((new BigInteger((_21255_errors).Count)).Sign == 0) ? (@Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Unable to decrypt data key: No Encrypted Data Keys found to match."))) : (Dafny.Helpers.Let<Func<Dafny.ISequence<char>, Dafny.ISequence<char>, Dafny.ISequence<char>>, Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>>(((System.Func<Dafny.ISequence<char>, Dafny.ISequence<char>, Dafny.ISequence<char>>)((_21256_s, _21257_a) => {
            return Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(_21257_a, Dafny.Sequence<char>.FromString("\n")), _21256_s);
          })), _pat_let10_0 => Dafny.Helpers.Let<Func<Dafny.ISequence<char>, Dafny.ISequence<char>, Dafny.ISequence<char>>, Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>>(_pat_let10_0, _21258_concatString => Dafny.Helpers.Let<Dafny.ISequence<char>, Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>>(Seq_Compile.__default.FoldRight<Dafny.ISequence<char>, Dafny.ISequence<char>>(_21258_concatString, _21255_errors, Dafny.Sequence<char>.FromString("Unable to decrypt data key:\n")), _pat_let11_0 => Dafny.Helpers.Let<Dafny.ISequence<char>, Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>>(_pat_let11_0, _21259_error => @Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>.create_Failure(_21259_error)))))))));
        }
      }))(_21251_outcome);
      return res;
      return res;
    }
    public Amazon.KeyManagementService.IAmazonKeyManagementService _client;public Amazon.KeyManagementService.IAmazonKeyManagementService client { get {
      return this._client;
    } }
    public Dafny.ISequence<char> _awsKmsKey;public Dafny.ISequence<char> awsKmsKey { get {
      return this._awsKmsKey;
    } }
    public AwsKmsArnParsing_Compile.AwsKmsIdentifier _awsKmsArn;public AwsKmsArnParsing_Compile.AwsKmsIdentifier awsKmsArn { get {
      return this._awsKmsArn;
    } }
    public Dafny.ISequence<Dafny.ISequence<char>> _grantTokens;public Dafny.ISequence<Dafny.ISequence<char>> grantTokens { get {
      return this._grantTokens;
    } }
  }

  public partial class OnDecryptEncryptedDataKeyFilter : Actions_Compile.ActionWithResult<Materials.EncryptedDataKey, bool, Dafny.ISequence<char>>, Actions_Compile.Action<Materials.EncryptedDataKey, Wrappers_Compile.Result<bool, Dafny.ISequence<char>>> {
    public OnDecryptEncryptedDataKeyFilter() {
      this._awsKmsKey = default(AwsKmsArnParsing_Compile.AwsKmsIdentifier);
    }
    public void __ctor(AwsKmsArnParsing_Compile.AwsKmsIdentifier awsKmsKey)
    {
      (this)._awsKmsKey = awsKmsKey;
    }
    public Wrappers_Compile.Result<bool, Dafny.ISequence<char>> Invoke(Materials.EncryptedDataKey edk)
    {
      Wrappers_Compile.Result<bool, Dafny.ISequence<char>> res = Wrappers_Compile.Result<bool, Dafny.ISequence<char>>.Default(false);
      if (!((edk).dtor_providerID).Equals((Constants_Compile.__default.PROVIDER__ID))) {
        res = @Wrappers_Compile.Result<bool, Dafny.ISequence<char>>.create_Success(false);
        return res;
      }
      if (!(UTF8.__default.ValidUTF8Seq((edk).dtor_providerInfo))) {
        res = @Wrappers_Compile.Result<bool, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Invalid AWS KMS encoding, provider info is not UTF8."));
        return res;
      }
      Dafny.ISequence<char> _21260_keyId = Dafny.Sequence<char>.Empty;
      Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>> _21261_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.Default(Dafny.Sequence<char>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>> _out181;
      _out181 = UTF8.__default.Decode((edk).dtor_providerInfo);
      _21261_valueOrError0 = _out181;
      if ((_21261_valueOrError0).IsFailure()) {
        res = (_21261_valueOrError0).PropagateFailure<bool>();
        return res;
      }
      _21260_keyId = (_21261_valueOrError0).Extract();
      AwsKmsArnParsing_Compile.AwsArn _21262_arn = AwsKmsArnParsing_Compile.AwsArn.Default();
      Wrappers_Compile.Result<AwsKmsArnParsing_Compile.AwsArn, Dafny.ISequence<char>> _21263_valueOrError1 = Wrappers_Compile.Result<AwsKmsArnParsing_Compile.AwsArn, Dafny.ISequence<char>>.Default(AwsKmsArnParsing_Compile.AwsArn.Default());
      _21263_valueOrError1 = AwsKmsArnParsing_Compile.__default.ParseAwsKmsArn(_21260_keyId);
      if ((_21263_valueOrError1).IsFailure()) {
        res = (_21263_valueOrError1).PropagateFailure<bool>();
        return res;
      }
      _21262_arn = (_21263_valueOrError1).Extract();
      res = @Wrappers_Compile.Result<bool, Dafny.ISequence<char>>.create_Success(AwsKmsMrkMatchForDecrypt_Compile.__default.AwsKmsMrkMatchForDecrypt((this).awsKmsKey, @AwsKmsArnParsing_Compile.AwsKmsIdentifier.create_AwsKmsArnIdentifier(_21262_arn)));
      return res;
      return res;
    }
    public AwsKmsArnParsing_Compile.AwsKmsIdentifier _awsKmsKey;public AwsKmsArnParsing_Compile.AwsKmsIdentifier awsKmsKey { get {
      return this._awsKmsKey;
    } }
  }

  public partial class DecryptSingleEncryptedDataKey : Actions_Compile.ActionWithResult<Materials.EncryptedDataKey, Materials.DecryptionMaterials, Dafny.ISequence<char>>, Actions_Compile.Action<Materials.EncryptedDataKey, Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>> {
    public DecryptSingleEncryptedDataKey() {
      this._materials = default(Materials.DecryptionMaterials);
      this._client = default(Amazon.KeyManagementService.IAmazonKeyManagementService);
      this._awsKmsKey = default(Dafny.ISequence<char>);
      this._grantTokens = Dafny.Sequence<Dafny.ISequence<char>>.Empty;
    }
    public void __ctor(Materials.DecryptionMaterials materials, Amazon.KeyManagementService.IAmazonKeyManagementService client, Dafny.ISequence<char> awsKmsKey, Dafny.ISequence<Dafny.ISequence<char>> grantTokens)
    {
      (this)._materials = materials;
      (this)._client = client;
      (this)._awsKmsKey = awsKmsKey;
      (this)._grantTokens = grantTokens;
    }
    public Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>> Invoke(Materials.EncryptedDataKey edk)
    {
      Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>> res = default(Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>);
      KMSUtils.DecryptRequest _21264_decryptRequest;
      _21264_decryptRequest = @KMSUtils.DecryptRequest.create((this).awsKmsKey, (edk).dtor_ciphertext, ((this).materials).dtor_encryptionContext, (this).grantTokens);
      KMSUtils.DecryptResponse _21265_decryptResponse = KMSUtils.DecryptResponse.Default();
      Wrappers_Compile.Result<KMSUtils.DecryptResponse, Dafny.ISequence<char>> _21266_valueOrError0 = Wrappers_Compile.Result<KMSUtils.DecryptResponse, Dafny.ISequence<char>>.Default(KMSUtils.DecryptResponse.Default());
      Wrappers_Compile.Result<KMSUtils.DecryptResponse, Dafny.ISequence<char>> _out182;
      _out182 = KMSUtils.ClientHelper.Decrypt((this).client, _21264_decryptRequest);
      _21266_valueOrError0 = _out182;
      if ((_21266_valueOrError0).IsFailure()) {
        res = (_21266_valueOrError0).PropagateFailure<Materials.DecryptionMaterials>();
        return res;
      }
      _21265_decryptResponse = (_21266_valueOrError0).Extract();
      Wrappers_Compile.Outcome<Dafny.ISequence<char>> _21267_valueOrError1 = Wrappers_Compile.Outcome<Dafny.ISequence<char>>.Default();
      _21267_valueOrError1 = Wrappers_Compile.__default.Need<Dafny.ISequence<char>>((((_21265_decryptResponse).dtor_keyID).Equals(((this).awsKmsKey))) && (AlgorithmSuite.ID.ValidPlaintextDataKey(((this).materials).dtor_algorithmSuiteID, (_21265_decryptResponse).dtor_plaintext)), Dafny.Sequence<char>.FromString("Invalid response from KMS Decrypt"));
      if ((_21267_valueOrError1).IsFailure()) {
        res = (_21267_valueOrError1).PropagateFailure<Materials.DecryptionMaterials>();
        return res;
      }
      Materials.DecryptionMaterials _21268_result;
      _21268_result = ((this).materials).WithPlaintextDataKey((_21265_decryptResponse).dtor_plaintext);
      res = @Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>.create_Success(_21268_result);
      return res;
      return res;
    }
    public Materials.DecryptionMaterials _materials;public Materials.DecryptionMaterials materials { get {
      return this._materials;
    } }
    public Amazon.KeyManagementService.IAmazonKeyManagementService _client;public Amazon.KeyManagementService.IAmazonKeyManagementService client { get {
      return this._client;
    } }
    public Dafny.ISequence<char> _awsKmsKey;public Dafny.ISequence<char> awsKmsKey { get {
      return this._awsKmsKey;
    } }
    public Dafny.ISequence<Dafny.ISequence<char>> _grantTokens;public Dafny.ISequence<Dafny.ISequence<char>> grantTokens { get {
      return this._grantTokens;
    } }
  }

} // end of namespace AwsKmsMrkAwareSymmetricKeyring
namespace MultiKeyringDef {






  public partial class MultiKeyring : KeyringDefs.Keyring {
    public MultiKeyring() {
      this._children = Dafny.Sequence<KeyringDefs.Keyring>.Empty;
      this._generator = (KeyringDefs.Keyring)null;
    }
    public void __ctor(KeyringDefs.Keyring g, Dafny.ISequence<KeyringDefs.Keyring> c)
    {
      (this)._generator = g;
      (this)._children = c;
    }
    public Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>> OnEncrypt(Materials.EncryptionMaterials materials)
    {
      Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>> res = Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>>.Default(Materials.ValidEncryptionMaterials.Default());
      Materials.EncryptionMaterials _21269_resultMaterials;
      _21269_resultMaterials = materials;
      if (((this).generator) != (object) ((KeyringDefs.Keyring)null)) {
        Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>> _21270_valueOrError0 = Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>>.Default(Materials.ValidEncryptionMaterials.Default());
        Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>> _out183;
        _out183 = ((this).generator).OnEncrypt(_21269_resultMaterials);
        _21270_valueOrError0 = _out183;
        if ((_21270_valueOrError0).IsFailure()) {
          res = (_21270_valueOrError0).PropagateFailure<Materials.EncryptionMaterials>();
          return res;
        }
        _21269_resultMaterials = (_21270_valueOrError0).Extract();
      }
      if (((_21269_resultMaterials).dtor_plaintextDataKey).is_None) {
        res = @Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Bad state: data key not found"));
        return res;
      }
      BigInteger _21271_i;
      _21271_i = BigInteger.Zero;
      while ((_21271_i) < (new BigInteger(((this).children).Count))) {
        Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>> _21272_valueOrError1 = Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>>.Default(Materials.ValidEncryptionMaterials.Default());
        Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>> _out184;
        _out184 = (((this).children).Select(_21271_i)).OnEncrypt(_21269_resultMaterials);
        _21272_valueOrError1 = _out184;
        if ((_21272_valueOrError1).IsFailure()) {
          res = (_21272_valueOrError1).PropagateFailure<Materials.EncryptionMaterials>();
          return res;
        }
        _21269_resultMaterials = (_21272_valueOrError1).Extract();
        _21271_i = (_21271_i) + (BigInteger.One);
      }
      res = @Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>>.create_Success(_21269_resultMaterials);
      return res;
    }
    public Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>> OnDecrypt(Materials.DecryptionMaterials materials, Dafny.ISequence<Materials.EncryptedDataKey> edks)
    {
      Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>> res = Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>.Default(Materials.ValidDecryptionMaterials.Default());
      if (((materials).dtor_plaintextDataKey).is_Some) {
        res = @Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>.create_Success(materials);
        return res;
      }
      if (((this).generator) != (object) ((KeyringDefs.Keyring)null)) {
        Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>> _21273_onDecryptResult;
        Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>> _out185;
        _out185 = ((this).generator).OnDecrypt(materials, edks);
        _21273_onDecryptResult = _out185;
        if ((_21273_onDecryptResult).is_Success) {
          res = _21273_onDecryptResult;
          return res;
        }
      }
      BigInteger _21274_i;
      _21274_i = BigInteger.Zero;
      res = @Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>.create_Success(materials);
      while ((_21274_i) < (new BigInteger(((this).children).Count))) {
        Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>> _21275_onDecryptResult;
        Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>> _out186;
        _out186 = (((this).children).Select(_21274_i)).OnDecrypt(materials, edks);
        _21275_onDecryptResult = _out186;
        if ((_21275_onDecryptResult).is_Success) {
          res = _21275_onDecryptResult;
          return res;
        }
        _21274_i = (_21274_i) + (BigInteger.One);
      }
      res = @Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Unable to decrypt."));
      return res;
      return res;
    }
    public Dafny.ISequence<KeyringDefs.Keyring> _children;public Dafny.ISequence<KeyringDefs.Keyring> children { get {
      return this._children;
    } }
    public KeyringDefs.Keyring _generator;public KeyringDefs.Keyring generator { get {
      return this._generator;
    } }
  }

} // end of namespace MultiKeyringDef
namespace RawAESKeyringDef {















  public partial class RawAESKeyring : KeyringDefs.Keyring {
    public RawAESKeyring() {
      this._keyNamespace = UTF8.ValidUTF8Bytes.Default();
      this._keyName = UTF8.ValidUTF8Bytes.Default();
      this._wrappingKey = Dafny.Sequence<byte>.Empty;
      this._wrappingAlgorithm = EncryptionSuites.EncryptionSuite.Default();
    }
    public void __ctor(Dafny.ISequence<byte> @namespace, Dafny.ISequence<byte> name, Dafny.ISequence<byte> key, EncryptionSuites.EncryptionSuite wrappingAlg)
    {
      (this)._keyNamespace = @namespace;
      (this)._keyName = name;
      (this)._wrappingKey = key;
      (this)._wrappingAlgorithm = wrappingAlg;
    }
    public Dafny.ISequence<byte> SerializeProviderInfo(Dafny.ISequence<byte> iv) {
      return Dafny.Sequence<byte>.Concat(Dafny.Sequence<byte>.Concat(Dafny.Sequence<byte>.Concat((this).keyName, Dafny.Sequence<byte>.FromElements(0, 0, 0, (byte)((((this).wrappingAlgorithm).dtor_tagLen) * (8)))), Dafny.Sequence<byte>.FromElements(0, 0, 0, ((this).wrappingAlgorithm).dtor_ivLen)), iv);
    }
    public Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>> OnEncrypt(Materials.EncryptionMaterials materials)
    {
      Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>> res = Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>>.Default(Materials.ValidEncryptionMaterials.Default());
      bool _21276_valid;
      bool _out187;
      _out187 = EncryptionContext.__default.CheckSerializable((materials).dtor_encryptionContext);
      _21276_valid = _out187;
      if (!(_21276_valid)) {
        res = @Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Unable to serialize encryption context"));
        return res;
      }
      Materials.EncryptionMaterials _21277_materialsWithDataKey;
      _21277_materialsWithDataKey = materials;
      if (((_21277_materialsWithDataKey).dtor_plaintextDataKey).is_None) {
        Dafny.ISequence<byte> _21278_k = Dafny.Sequence<byte>.Empty;
        Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _21279_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
        Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out188;
        _out188 = Random_Compile.__default.GenerateBytes((int)(AlgorithmSuite.ID.KeyLength((materials).dtor_algorithmSuiteID)));
        _21279_valueOrError0 = _out188;
        if ((_21279_valueOrError0).IsFailure()) {
          res = (_21279_valueOrError0).PropagateFailure<Materials.EncryptionMaterials>();
          return res;
        }
        _21278_k = (_21279_valueOrError0).Extract();
        _21277_materialsWithDataKey = (_21277_materialsWithDataKey).WithKeys(@Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(_21278_k), Dafny.Sequence<Materials.EncryptedDataKey>.FromElements());
      }
      Dafny.ISequence<byte> _21280_iv = Dafny.Sequence<byte>.Empty;
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _21281_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out189;
      _out189 = Random_Compile.__default.GenerateBytes((int)(((this).wrappingAlgorithm).dtor_ivLen));
      _21281_valueOrError1 = _out189;
      if ((_21281_valueOrError1).IsFailure()) {
        res = (_21281_valueOrError1).PropagateFailure<Materials.EncryptionMaterials>();
        return res;
      }
      _21280_iv = (_21281_valueOrError1).Extract();
      Dafny.ISequence<byte> _21282_providerInfo;
      _21282_providerInfo = (this).SerializeProviderInfo(_21280_iv);
      Streams_Compile.ByteWriter _21283_wr;
      Streams_Compile.ByteWriter _nw24 = new Streams_Compile.ByteWriter();
      _nw24.__ctor();
      _21283_wr = _nw24;
      BigInteger _21284___v0 = BigInteger.Zero;
      Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>> _21285_valueOrError2 = Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>>.Default(BigInteger.Zero);
      Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>> _out190;
      _out190 = Serialize_Compile.__default.SerializeKVPairs(_21283_wr, (materials).dtor_encryptionContext);
      _21285_valueOrError2 = _out190;
      if ((_21285_valueOrError2).IsFailure()) {
        res = (_21285_valueOrError2).PropagateFailure<Materials.EncryptionMaterials>();
        return res;
      }
      _21284___v0 = (_21285_valueOrError2).Extract();
      Dafny.ISequence<byte> _21286_aad;
      _21286_aad = (_21283_wr).GetDataWritten();
      AESEncryption.EncryptionOutput _21287_encryptResult = AESEncryption.EncryptionOutput.Default();
      Wrappers_Compile.Result<AESEncryption.EncryptionOutput, Dafny.ISequence<char>> _21288_valueOrError3 = Wrappers_Compile.Result<AESEncryption.EncryptionOutput, Dafny.ISequence<char>>.Default(AESEncryption.EncryptionOutput.Default());
      Wrappers_Compile.Result<AESEncryption.EncryptionOutput, Dafny.ISequence<char>> _out191;
      _out191 = AESEncryption.__default.AESEncrypt((this).wrappingAlgorithm, _21280_iv, (this).wrappingKey, ((_21277_materialsWithDataKey).dtor_plaintextDataKey).dtor_value, _21286_aad);
      _21288_valueOrError3 = _out191;
      if ((_21288_valueOrError3).IsFailure()) {
        res = (_21288_valueOrError3).PropagateFailure<Materials.EncryptionMaterials>();
        return res;
      }
      _21287_encryptResult = (_21288_valueOrError3).Extract();
      Dafny.ISequence<byte> _21289_encryptedKey;
      _21289_encryptedKey = RawAESKeyringDef.__default.SerializeEDKCiphertext(_21287_encryptResult);
      if ((StandardLibrary_mUInt_Compile.__default.UINT16__LIMIT) <= (new BigInteger((_21282_providerInfo).Count))) {
        res = @Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Serialized provider info too long."));
        return res;
      }
      if ((StandardLibrary_mUInt_Compile.__default.UINT16__LIMIT) <= (new BigInteger((_21289_encryptedKey).Count))) {
        res = @Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Encrypted data key too long."));
        return res;
      }
      Materials.EncryptedDataKey _21290_edk;
      _21290_edk = @Materials.EncryptedDataKey.create((this).keyNamespace, _21282_providerInfo, _21289_encryptedKey);
      res = @Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>>.create_Success((_21277_materialsWithDataKey).WithKeys((_21277_materialsWithDataKey).dtor_plaintextDataKey, Dafny.Sequence<Materials.EncryptedDataKey>.FromElements(_21290_edk)));
      return res;
    }
    public Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>> OnDecrypt(Materials.DecryptionMaterials materials, Dafny.ISequence<Materials.EncryptedDataKey> edks)
    {
      Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>> res = Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>.Default(Materials.ValidDecryptionMaterials.Default());
      if (((materials).dtor_plaintextDataKey).is_Some) {
        res = @Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>.create_Success(materials);
        return res;
      }
      BigInteger _21291_i;
      _21291_i = BigInteger.Zero;
      while ((_21291_i) < (new BigInteger((edks).Count))) {
        if ((this).ShouldDecryptEDK((edks).Select(_21291_i))) {
          bool _21292_valid;
          bool _out192;
          _out192 = EncryptionContext.__default.CheckSerializable((materials).dtor_encryptionContext);
          _21292_valid = _out192;
          if (!(_21292_valid)) {
            res = @Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Unable to serialize encryption context"));
            return res;
          }
          Streams_Compile.ByteWriter _21293_wr;
          Streams_Compile.ByteWriter _nw25 = new Streams_Compile.ByteWriter();
          _nw25.__ctor();
          _21293_wr = _nw25;
          BigInteger _21294___v1 = BigInteger.Zero;
          Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>> _21295_valueOrError0 = Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>>.Default(BigInteger.Zero);
          Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>> _out193;
          _out193 = Serialize_Compile.__default.SerializeKVPairs(_21293_wr, (materials).dtor_encryptionContext);
          _21295_valueOrError0 = _out193;
          if ((_21295_valueOrError0).IsFailure()) {
            res = (_21295_valueOrError0).PropagateFailure<Materials.DecryptionMaterials>();
            return res;
          }
          _21294___v1 = (_21295_valueOrError0).Extract();
          Dafny.ISequence<byte> _21296_aad;
          _21296_aad = (_21293_wr).GetDataWritten();
          Dafny.ISequence<byte> _21297_iv;
          _21297_iv = (this).GetIvFromProvInfo(((edks).Select(_21291_i)).dtor_providerInfo);
          AESEncryption.EncryptionOutput _21298_encryptionOutput;
          _21298_encryptionOutput = RawAESKeyringDef.__default.DeserializeEDKCiphertext(((edks).Select(_21291_i)).dtor_ciphertext, new BigInteger(((this).wrappingAlgorithm).dtor_tagLen));
          Dafny.ISequence<byte> _21299_ptKey = Dafny.Sequence<byte>.Empty;
          Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _21300_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
          Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out194;
          _out194 = AESEncryption.__default.AESDecrypt((this).wrappingAlgorithm, (this).wrappingKey, (_21298_encryptionOutput).dtor_cipherText, (_21298_encryptionOutput).dtor_authTag, _21297_iv, _21296_aad);
          _21300_valueOrError1 = _out194;
          if ((_21300_valueOrError1).IsFailure()) {
            res = (_21300_valueOrError1).PropagateFailure<Materials.DecryptionMaterials>();
            return res;
          }
          _21299_ptKey = (_21300_valueOrError1).Extract();
          if (AlgorithmSuite.ID.ValidPlaintextDataKey((materials).dtor_algorithmSuiteID, _21299_ptKey)) {
            res = @Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>.create_Success((materials).WithPlaintextDataKey(_21299_ptKey));
            return res;
          } else {
            res = @Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Decryption failed: bad datakey length."));
            return res;
          }
        }
        _21291_i = (_21291_i) + (BigInteger.One);
      }
      res = @Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Unable to decrypt."));
      return res;
      return res;
    }
    public bool ShouldDecryptEDK(Materials.EncryptedDataKey edk) {
      return ((((edk).dtor_providerID).Equals(((this).keyNamespace))) && ((this).ValidProviderInfo((edk).dtor_providerInfo))) && ((new BigInteger(((this).wrappingAlgorithm).dtor_tagLen)) <= (new BigInteger(((edk).dtor_ciphertext).Count)));
    }
    public bool ValidProviderInfo(Dafny.ISequence<byte> info) {
      return ((((new BigInteger((info).Count)) == ((((new BigInteger(((this).keyName).Count)) + (RawAESKeyringDef.__default.AUTH__TAG__LEN__LEN)) + (RawAESKeyringDef.__default.IV__LEN__LEN)) + (new BigInteger(((this).wrappingAlgorithm).dtor_ivLen)))) && (((info).Subsequence(BigInteger.Zero, new BigInteger(((this).keyName).Count))).Equals(((this).keyName)))) && ((StandardLibrary_mUInt_Compile.__default.SeqToUInt32((info).Subsequence(new BigInteger(((this).keyName).Count), (new BigInteger(((this).keyName).Count)) + (RawAESKeyringDef.__default.AUTH__TAG__LEN__LEN)))) == (((uint)(((this).wrappingAlgorithm).dtor_tagLen)) * (8U)))) && ((StandardLibrary_mUInt_Compile.__default.SeqToUInt32((info).Subsequence((new BigInteger(((this).keyName).Count)) + (RawAESKeyringDef.__default.AUTH__TAG__LEN__LEN), ((new BigInteger(((this).keyName).Count)) + (RawAESKeyringDef.__default.AUTH__TAG__LEN__LEN)) + (RawAESKeyringDef.__default.IV__LEN__LEN)))) == ((uint)(((this).wrappingAlgorithm).dtor_ivLen)));
    }
    public Dafny.ISequence<byte> GetIvFromProvInfo(Dafny.ISequence<byte> info) {
      return (info).Drop(((new BigInteger(((this).keyName).Count)) + (RawAESKeyringDef.__default.AUTH__TAG__LEN__LEN)) + (RawAESKeyringDef.__default.IV__LEN__LEN));
    }
    public Dafny.ISequence<byte> _keyNamespace;public Dafny.ISequence<byte> keyNamespace { get {
      return this._keyNamespace;
    } }
    public Dafny.ISequence<byte> _keyName;public Dafny.ISequence<byte> keyName { get {
      return this._keyName;
    } }
    public Dafny.ISequence<byte> _wrappingKey;public Dafny.ISequence<byte> wrappingKey { get {
      return this._wrappingKey;
    } }
    public EncryptionSuites.EncryptionSuite _wrappingAlgorithm;public EncryptionSuites.EncryptionSuite wrappingAlgorithm { get {
      return this._wrappingAlgorithm;
    } }
  }

  public partial class __default {
    public static AESEncryption.EncryptionOutput DeserializeEDKCiphertext(Dafny.ISequence<byte> ciphertext, BigInteger tagLen)
    {
      BigInteger _21301_encryptedKeyLength = (new BigInteger((ciphertext).Count)) - (tagLen);
      return @AESEncryption.EncryptionOutput.create((ciphertext).Take(_21301_encryptedKeyLength), (ciphertext).Drop(_21301_encryptedKeyLength));
    }
    public static Dafny.ISequence<byte> SerializeEDKCiphertext(AESEncryption.EncryptionOutput encOutput) {
      return Dafny.Sequence<byte>.Concat((encOutput).dtor_cipherText, (encOutput).dtor_authTag);
    }
    public static Dafny.ISet<EncryptionSuites.EncryptionSuite> VALID__ALGORITHMS { get {
      return Dafny.Set<EncryptionSuites.EncryptionSuite>.FromElements(EncryptionSuites.__default.AES__GCM__128, EncryptionSuites.__default.AES__GCM__192, EncryptionSuites.__default.AES__GCM__256);
    } }
    public static BigInteger AUTH__TAG__LEN__LEN { get {
      return new BigInteger(4);
    } }
    public static BigInteger IV__LEN__LEN { get {
      return new BigInteger(4);
    } }
  }
} // end of namespace RawAESKeyringDef
namespace RawRSAKeyringDef {










  public partial class RawRSAKeyring : KeyringDefs.Keyring {
    public RawRSAKeyring() {
      this._keyNamespace = UTF8.ValidUTF8Bytes.Default();
      this._keyName = UTF8.ValidUTF8Bytes.Default();
      this._paddingMode = RSAEncryption.PaddingMode.Default();
      this._publicKey = Wrappers_Compile.Option<RSAEncryption.PublicKey>.Default();
      this._privateKey = Wrappers_Compile.Option<RSAEncryption.PrivateKey>.Default();
    }
    public void __ctor(Dafny.ISequence<byte> @namespace, Dafny.ISequence<byte> name, RSAEncryption.PaddingMode padding, Wrappers_Compile.Option<RSAEncryption.PublicKey> publicKey, Wrappers_Compile.Option<RSAEncryption.PrivateKey> privateKey)
    {
      (this)._keyNamespace = @namespace;
      (this)._keyName = name;
      (this)._paddingMode = padding;
      (this)._publicKey = publicKey;
      (this)._privateKey = privateKey;
    }
    public Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>> OnEncrypt(Materials.EncryptionMaterials materials)
    {
      Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>> res = Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>>.Default(Materials.ValidEncryptionMaterials.Default());
      if (((this).publicKey).is_None) {
        res = @Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Encryption key undefined"));
        return res;
      }
      Materials.EncryptionMaterials _21302_materialsWithDataKey;
      _21302_materialsWithDataKey = materials;
      if (((materials).dtor_plaintextDataKey).is_None) {
        Dafny.ISequence<byte> _21303_k = Dafny.Sequence<byte>.Empty;
        Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _21304_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
        Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out195;
        _out195 = Random_Compile.__default.GenerateBytes((int)(AlgorithmSuite.ID.KDFInputKeyLength((_21302_materialsWithDataKey).dtor_algorithmSuiteID)));
        _21304_valueOrError0 = _out195;
        if ((_21304_valueOrError0).IsFailure()) {
          res = (_21304_valueOrError0).PropagateFailure<Materials.EncryptionMaterials>();
          return res;
        }
        _21303_k = (_21304_valueOrError0).Extract();
        _21302_materialsWithDataKey = (materials).WithKeys(@Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(_21303_k), Dafny.Sequence<Materials.EncryptedDataKey>.FromElements());
      }
      Dafny.ISequence<byte> _21305_encryptedCiphertext = Dafny.Sequence<byte>.Empty;
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _21306_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out196;
      _out196 = RSAEncryption.__default.Encrypt((this).paddingMode, ((this).publicKey).dtor_value, ((_21302_materialsWithDataKey).dtor_plaintextDataKey).dtor_value);
      _21306_valueOrError1 = _out196;
      if ((_21306_valueOrError1).IsFailure()) {
        res = (_21306_valueOrError1).PropagateFailure<Materials.EncryptionMaterials>();
        return res;
      }
      _21305_encryptedCiphertext = (_21306_valueOrError1).Extract();
      if ((StandardLibrary_mUInt_Compile.__default.UINT16__LIMIT) <= (new BigInteger((_21305_encryptedCiphertext).Count))) {
        res = @Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Encrypted data key too long."));
        return res;
      }
      Materials.EncryptedDataKey _21307_encryptedDataKey;
      _21307_encryptedDataKey = @Materials.EncryptedDataKey.create((this).keyNamespace, (this).keyName, _21305_encryptedCiphertext);
      Materials.EncryptionMaterials _21308_materials;
      _21308_materials = (_21302_materialsWithDataKey).WithKeys((_21302_materialsWithDataKey).dtor_plaintextDataKey, Dafny.Sequence<Materials.EncryptedDataKey>.FromElements(_21307_encryptedDataKey));
      res = @Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>>.create_Success(_21308_materials);
      return res;
      return res;
    }
    public Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>> OnDecrypt(Materials.DecryptionMaterials materials, Dafny.ISequence<Materials.EncryptedDataKey> encryptedDataKeys)
    {
      Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>> res = Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>.Default(Materials.ValidDecryptionMaterials.Default());
      if (((materials).dtor_plaintextDataKey).is_Some) {
        res = @Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>.create_Success(materials);
        return res;
      } else if (((this).privateKey).is_None) {
        res = @Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Decryption key undefined"));
        return res;
      }
      BigInteger _21309_i;
      _21309_i = BigInteger.Zero;
      while ((_21309_i) < (new BigInteger((encryptedDataKeys).Count))) {
        Materials.EncryptedDataKey _21310_encryptedDataKey;
        _21310_encryptedDataKey = (encryptedDataKeys).Select(_21309_i);
        if (((((_21310_encryptedDataKey).dtor_providerID).Equals(((this).keyNamespace))) && (((_21310_encryptedDataKey).dtor_providerInfo).Equals(((this).keyName)))) && ((new BigInteger(((_21310_encryptedDataKey).dtor_ciphertext).Count)).Sign == 1)) {
          Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _21311_potentialPlaintextDataKey;
          Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out197;
          _out197 = RSAEncryption.__default.Decrypt((this).paddingMode, ((this).privateKey).dtor_value, (_21310_encryptedDataKey).dtor_ciphertext);
          _21311_potentialPlaintextDataKey = _out197;
          Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _source27 = _21311_potentialPlaintextDataKey;
          if (_source27.is_Success) {
            Dafny.ISequence<byte> _21312___mcc_h0 = ((Wrappers_Compile.Result_Success<Dafny.ISequence<byte>, Dafny.ISequence<char>>)_source27).@value;
            {
              Dafny.ISequence<byte> _21313_plaintextDataKey = _21312___mcc_h0;
              if (AlgorithmSuite.ID.ValidPlaintextDataKey((materials).dtor_algorithmSuiteID, _21313_plaintextDataKey)) {
                res = @Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>.create_Success((materials).WithPlaintextDataKey(_21313_plaintextDataKey));
                return res;
              } else {
                res = @Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Bad key length!"));
                return res;
              }
            }
          } else {
            Dafny.ISequence<char> _21314___mcc_h1 = ((Wrappers_Compile.Result_Failure<Dafny.ISequence<byte>, Dafny.ISequence<char>>)_source27).error;
          }
        }
        _21309_i = (_21309_i) + (BigInteger.One);
      }
      res = @Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Unable to decrypt."));
      return res;
      return res;
    }
    public Dafny.ISequence<byte> _keyNamespace;public Dafny.ISequence<byte> keyNamespace { get {
      return this._keyNamespace;
    } }
    public Dafny.ISequence<byte> _keyName;public Dafny.ISequence<byte> keyName { get {
      return this._keyName;
    } }
    public RSAEncryption.PaddingMode _paddingMode;public RSAEncryption.PaddingMode paddingMode { get {
      return this._paddingMode;
    } }
    public Wrappers_Compile.Option<RSAEncryption.PublicKey> _publicKey;public Wrappers_Compile.Option<RSAEncryption.PublicKey> publicKey { get {
      return this._publicKey;
    } }
    public Wrappers_Compile.Option<RSAEncryption.PrivateKey> _privateKey;public Wrappers_Compile.Option<RSAEncryption.PrivateKey> privateKey { get {
      return this._privateKey;
    } }
  }

} // end of namespace RawRSAKeyringDef
namespace Base64Lemmas_Compile {





} // end of namespace Base64Lemmas_Compile
namespace TestDigest_mHelpers_Compile {





  public partial class __default {
    public static BigInteger ToInt(Dafny.ISequence<byte> bytes)
    {
      BigInteger n = BigInteger.Zero;
      n = BigInteger.Zero;
      BigInteger _21315_i;
      _21315_i = BigInteger.Zero;
      while ((_21315_i) < (new BigInteger((bytes).Count))) {
        n = ((new BigInteger(256)) * (n)) + (new BigInteger((bytes).Select(_21315_i)));
        _21315_i = (_21315_i) + (BigInteger.One);
      }
      return n;
    }
    public static void TestDigest(Dafny.ISequence<char> s, CryptoDatatypes_Compile.DigestAlgorithm alg, BigInteger expected)
    {
      if (!(Dafny.Helpers.Id<Func<Dafny.ISequence<char>, bool>>((_21316_s) => Dafny.Helpers.Quantifier<BigInteger>(Dafny.Helpers.IntegerRange(BigInteger.Zero, new BigInteger((_21316_s).Count)), true, (((_21317_i) => {
        return !(((_21317_i).Sign != -1) && ((_21317_i) < (new BigInteger((_21316_s).Count)))) || ((('a') <= ((_21316_s).Select(_21317_i))) && (((_21316_s).Select(_21317_i)) <= ('z')));
      }))))(s))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Crypto/Digest.dfy(30,6): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      Dafny.ISequence<byte> _21318_msg;
      _21318_msg = ((System.Func<Dafny.ISequence<byte>>) (() => {
        BigInteger dim11 = new BigInteger((s).Count);
        var arr11 = new byte[Dafny.Helpers.ToIntChecked(dim11,"C# array size must not be larger than max 32-bit int")];
        for (int i11 = 0; i11 < dim11; i11++) {
          var _21319_i = (BigInteger) i11;
          arr11[(int)(_21319_i)] = (byte)((s).Select(_21319_i));
        }
        return Dafny.Sequence<byte>.FromArray(arr11);
      }))();
      Dafny.ISequence<byte> _21320_digest = Dafny.Sequence<byte>.Empty;
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _21321_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out198;
      _out198 = Digest_Compile.__default.Digest(alg, _21318_msg);
      _21321_valueOrError0 = _out198;
      if (!(!((_21321_valueOrError0).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Crypto/Digest.dfy(32,17): " + _21321_valueOrError0);
      }
      _21320_digest = (_21321_valueOrError0).Extract();
      if (!((new BigInteger((_21320_digest).Count)) == (Digest_Compile.__default.Length(alg)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Crypto/Digest.dfy(33,6): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      BigInteger _21322_actual;
      BigInteger _out199;
      _out199 = TestDigest_mHelpers_Compile.__default.ToInt(_21320_digest);
      _21322_actual = _out199;
      if (!((_21322_actual) == (expected))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Crypto/Digest.dfy(35,6): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
  }
} // end of namespace TestDigest_mHelpers_Compile
namespace TestDigest_Compile {




  public partial class __default {
    [Xunit.Fact]
    public static void DigestTestVectors()
    {
      Dafny.ISequence<char> _21323_s;
      _21323_s = Dafny.Sequence<char>.FromString("abc");
      TestDigest_mHelpers_Compile.__default.TestDigest(_21323_s, @CryptoDatatypes_Compile.DigestAlgorithm.create(), BigInteger.Parse("11610554759577678887058616627522426787358414133166247019097754655123425531747192578669846860198531688061507751898313498051436198428987376028989280584770719"));
      _21323_s = Dafny.Sequence<char>.FromString("");
      TestDigest_mHelpers_Compile.__default.TestDigest(_21323_s, @CryptoDatatypes_Compile.DigestAlgorithm.create(), BigInteger.Parse("10868450558671247443152026947160338505683745266658651051718065983487878962987857602829315249215796444208488632888003673539585986066311769564391053988452926"));
      _21323_s = Dafny.Sequence<char>.FromString("abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu");
      TestDigest_mHelpers_Compile.__default.TestDigest(_21323_s, @CryptoDatatypes_Compile.DigestAlgorithm.create(), BigInteger.Parse("7467751150072304710748607053756525574443640673541183129594735496433453152253989885323496399866777464427478124519714519652484878749913622135027995536779529"));
    }
  }
} // end of namespace TestDigest_Compile
namespace TestSignature_mHelpers_Compile {





  public partial class __default {
    public static void RequireGoodKeyLengths(Signature.ECDSAParams s, Signature.SignatureKeyPair sigKeyPair)
    {
      if (!((new BigInteger(((sigKeyPair).dtor_verificationKey).Count)) == ((s).FieldSize()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Crypto/Signature.dfy(20,6): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    public static void YCompression(Signature.ECDSAParams s, BigInteger fieldSize)
    {
      Signature.SignatureKeyPair _21324_res = Signature.SignatureKeyPair.Default();
      Wrappers_Compile.Result<Signature.SignatureKeyPair, Dafny.ISequence<char>> _21325_valueOrError0 = Wrappers_Compile.Result<Signature.SignatureKeyPair, Dafny.ISequence<char>>.Default(Signature.SignatureKeyPair.Default());
      Wrappers_Compile.Result<Signature.SignatureKeyPair, Dafny.ISequence<char>> _out200;
      _out200 = Signature.__default.KeyGen(s);
      _21325_valueOrError0 = _out200;
      if (!(!((_21325_valueOrError0).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Crypto/Signature.dfy(24,14): " + _21325_valueOrError0);
      }
      _21324_res = (_21325_valueOrError0).Extract();
      TestSignature_mHelpers_Compile.__default.RequireGoodKeyLengths(s, _21324_res);
      Dafny.ISequence<byte> _21326_public;
      Dafny.ISequence<byte> _21327_secret;
      Dafny.ISequence<byte> _rhs21 = (_21324_res).dtor_verificationKey;
      Dafny.ISequence<byte> _rhs22 = (_21324_res).dtor_signingKey;
      _21326_public = _rhs21;
      _21327_secret = _rhs22;
      if (!((new BigInteger((_21327_secret).Count)).Sign == 1)) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Crypto/Signature.dfy(29,6): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!((new BigInteger((_21326_public).Count)) == ((BigInteger.One) + (Dafny.Helpers.EuclideanDivision((fieldSize) + (new BigInteger(7)), new BigInteger(8)))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Crypto/Signature.dfy(30,6): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!((((_21326_public).Select(BigInteger.Zero)) == (2)) || (((_21326_public).Select(BigInteger.Zero)) == (3)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Crypto/Signature.dfy(31,6): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    public static void VerifyMessage(Signature.ECDSAParams @params)
    {
      Dafny.ISequence<byte> _21328_message = UTF8.ValidUTF8Bytes.Default();
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _21329_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out201;
      _out201 = UTF8.__default.Encode(Dafny.Sequence<char>.FromString("Hello, World!"));
      _21329_valueOrError0 = _out201;
      if (!(!((_21329_valueOrError0).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Crypto/Signature.dfy(35,18): " + _21329_valueOrError0);
      }
      _21328_message = (_21329_valueOrError0).Extract();
      Signature.SignatureKeyPair _21330_keys = Signature.SignatureKeyPair.Default();
      Wrappers_Compile.Result<Signature.SignatureKeyPair, Dafny.ISequence<char>> _21331_valueOrError1 = Wrappers_Compile.Result<Signature.SignatureKeyPair, Dafny.ISequence<char>>.Default(Signature.SignatureKeyPair.Default());
      Wrappers_Compile.Result<Signature.SignatureKeyPair, Dafny.ISequence<char>> _out202;
      _out202 = Signature.__default.KeyGen(@params);
      _21331_valueOrError1 = _out202;
      if (!(!((_21331_valueOrError1).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Crypto/Signature.dfy(36,15): " + _21331_valueOrError1);
      }
      _21330_keys = (_21331_valueOrError1).Extract();
      TestSignature_mHelpers_Compile.__default.RequireGoodKeyLengths(@params, _21330_keys);
      Dafny.ISequence<byte> _21332_signature = Dafny.Sequence<byte>.Empty;
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _21333_valueOrError2 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out203;
      _out203 = Signature.ECDSA.Sign(@params, (_21330_keys).dtor_signingKey, _21328_message);
      _21333_valueOrError2 = _out203;
      if (!(!((_21333_valueOrError2).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Crypto/Signature.dfy(39,20): " + _21333_valueOrError2);
      }
      _21332_signature = (_21333_valueOrError2).Extract();
      bool _21334_shouldBeTrue = false;
      Wrappers_Compile.Result<bool, Dafny.ISequence<char>> _21335_valueOrError3 = Wrappers_Compile.Result<bool, Dafny.ISequence<char>>.Default(false);
      Wrappers_Compile.Result<bool, Dafny.ISequence<char>> _out204;
      _out204 = Signature.ECDSA.Verify(@params, (_21330_keys).dtor_verificationKey, _21328_message, _21332_signature);
      _21335_valueOrError3 = _out204;
      if (!(!((_21335_valueOrError3).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Crypto/Signature.dfy(40,23): " + _21335_valueOrError3);
      }
      _21334_shouldBeTrue = (_21335_valueOrError3).Extract();
      if (!(_21334_shouldBeTrue)) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Crypto/Signature.dfy(41,6): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      bool _21336_shouldBeFalse = false;
      Wrappers_Compile.Result<bool, Dafny.ISequence<char>> _21337_valueOrError4 = Wrappers_Compile.Result<bool, Dafny.ISequence<char>>.Default(false);
      Wrappers_Compile.Result<bool, Dafny.ISequence<char>> _out205;
      _out205 = Signature.ECDSA.Verify(@params, (_21330_keys).dtor_verificationKey, Dafny.Sequence<byte>.Concat(_21328_message, Dafny.Sequence<byte>.FromElements(1)), _21332_signature);
      _21337_valueOrError4 = _out205;
      if (!(!((_21337_valueOrError4).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Crypto/Signature.dfy(43,24): " + _21337_valueOrError4);
      }
      _21336_shouldBeFalse = (_21337_valueOrError4).Extract();
      if (!(!(_21336_shouldBeFalse))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Crypto/Signature.dfy(44,6): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
  }
} // end of namespace TestSignature_mHelpers_Compile
namespace TestSignature_Compile {



  public partial class __default {
    [Xunit.Fact]
    public static void YCompression384()
    {
      TestSignature_mHelpers_Compile.__default.YCompression(@Signature.ECDSAParams.create_ECDSA__P384(), new BigInteger(384));
    }
    [Xunit.Fact]
    public static void YCompression256()
    {
      TestSignature_mHelpers_Compile.__default.YCompression(@Signature.ECDSAParams.create_ECDSA__P256(), new BigInteger(256));
    }
    [Xunit.Fact]
    public static void VerifyMessage384()
    {
      TestSignature_mHelpers_Compile.__default.VerifyMessage(@Signature.ECDSAParams.create_ECDSA__P384());
    }
    [Xunit.Fact]
    public static void VerifyMessage256()
    {
      TestSignature_mHelpers_Compile.__default.VerifyMessage(@Signature.ECDSAParams.create_ECDSA__P256());
    }
  }
} // end of namespace TestSignature_Compile
namespace TestHKDF {




  public partial class __default {
    [Xunit.Fact]
    public static void Test0()
    {
      byte[] _21338_tv__ikm;
      byte[] _nw26 = new byte[Dafny.Helpers.ToIntChecked(Dafny.Helpers.ToIntChecked(new BigInteger(22), "C# arrays may not be larger than the max 32-bit integer"),"C# array size must not be larger than max 32-bit int")];
      _nw26[(int)(0)] = 11;
      _nw26[(int)(1)] = 11;
      _nw26[(int)(2)] = 11;
      _nw26[(int)(3)] = 11;
      _nw26[(int)(4)] = 11;
      _nw26[(int)(5)] = 11;
      _nw26[(int)(6)] = 11;
      _nw26[(int)(7)] = 11;
      _nw26[(int)(8)] = 11;
      _nw26[(int)(9)] = 11;
      _nw26[(int)(10)] = 11;
      _nw26[(int)(11)] = 11;
      _nw26[(int)(12)] = 11;
      _nw26[(int)(13)] = 11;
      _nw26[(int)(14)] = 11;
      _nw26[(int)(15)] = 11;
      _nw26[(int)(16)] = 11;
      _nw26[(int)(17)] = 11;
      _nw26[(int)(18)] = 11;
      _nw26[(int)(19)] = 11;
      _nw26[(int)(20)] = 11;
      _nw26[(int)(21)] = 11;
      _21338_tv__ikm = _nw26;
      byte[] _21339_tv__salt;
      byte[] _nw27 = new byte[Dafny.Helpers.ToIntChecked(Dafny.Helpers.ToIntChecked(new BigInteger(13), "C# arrays may not be larger than the max 32-bit integer"),"C# array size must not be larger than max 32-bit int")];
      _nw27[(int)(0)] = 0;
      _nw27[(int)(1)] = 1;
      _nw27[(int)(2)] = 2;
      _nw27[(int)(3)] = 3;
      _nw27[(int)(4)] = 4;
      _nw27[(int)(5)] = 5;
      _nw27[(int)(6)] = 6;
      _nw27[(int)(7)] = 7;
      _nw27[(int)(8)] = 8;
      _nw27[(int)(9)] = 9;
      _nw27[(int)(10)] = 10;
      _nw27[(int)(11)] = 11;
      _nw27[(int)(12)] = 12;
      _21339_tv__salt = _nw27;
      byte[] _21340_tv__info;
      byte[] _nw28 = new byte[Dafny.Helpers.ToIntChecked(Dafny.Helpers.ToIntChecked(new BigInteger(10), "C# arrays may not be larger than the max 32-bit integer"),"C# array size must not be larger than max 32-bit int")];
      _nw28[(int)(0)] = 240;
      _nw28[(int)(1)] = 241;
      _nw28[(int)(2)] = 242;
      _nw28[(int)(3)] = 243;
      _nw28[(int)(4)] = 244;
      _nw28[(int)(5)] = 245;
      _nw28[(int)(6)] = 246;
      _nw28[(int)(7)] = 247;
      _nw28[(int)(8)] = 248;
      _nw28[(int)(9)] = 249;
      _21340_tv__info = _nw28;
      byte[] _21341_tv__okm__desired;
      byte[] _nw29 = new byte[Dafny.Helpers.ToIntChecked(Dafny.Helpers.ToIntChecked(new BigInteger(42), "C# arrays may not be larger than the max 32-bit integer"),"C# array size must not be larger than max 32-bit int")];
      _nw29[(int)(0)] = 60;
      _nw29[(int)(1)] = 178;
      _nw29[(int)(2)] = 95;
      _nw29[(int)(3)] = 37;
      _nw29[(int)(4)] = 250;
      _nw29[(int)(5)] = 172;
      _nw29[(int)(6)] = 213;
      _nw29[(int)(7)] = 122;
      _nw29[(int)(8)] = 144;
      _nw29[(int)(9)] = 67;
      _nw29[(int)(10)] = 79;
      _nw29[(int)(11)] = 100;
      _nw29[(int)(12)] = 208;
      _nw29[(int)(13)] = 54;
      _nw29[(int)(14)] = 47;
      _nw29[(int)(15)] = 42;
      _nw29[(int)(16)] = 45;
      _nw29[(int)(17)] = 45;
      _nw29[(int)(18)] = 10;
      _nw29[(int)(19)] = 144;
      _nw29[(int)(20)] = 207;
      _nw29[(int)(21)] = 26;
      _nw29[(int)(22)] = 90;
      _nw29[(int)(23)] = 76;
      _nw29[(int)(24)] = 93;
      _nw29[(int)(25)] = 176;
      _nw29[(int)(26)] = 45;
      _nw29[(int)(27)] = 86;
      _nw29[(int)(28)] = 236;
      _nw29[(int)(29)] = 196;
      _nw29[(int)(30)] = 197;
      _nw29[(int)(31)] = 191;
      _nw29[(int)(32)] = 52;
      _nw29[(int)(33)] = 0;
      _nw29[(int)(34)] = 114;
      _nw29[(int)(35)] = 8;
      _nw29[(int)(36)] = 213;
      _nw29[(int)(37)] = 184;
      _nw29[(int)(38)] = 135;
      _nw29[(int)(39)] = 24;
      _nw29[(int)(40)] = 88;
      _nw29[(int)(41)] = 101;
      _21341_tv__okm__desired = _nw29;
      Dafny.ISequence<byte> _21342_okm;
      Dafny.ISequence<byte> _out206;
      _out206 = HKDF_Compile.__default.Hkdf(@KeyDerivationAlgorithms.KeyDerivationAlgorithm.create_HKDF__WITH__SHA__256(), @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(Dafny.Helpers.SeqFromArray(_21339_tv__salt)), Dafny.Helpers.SeqFromArray(_21338_tv__ikm), Dafny.Helpers.SeqFromArray(_21340_tv__info), new BigInteger(42));
      _21342_okm = _out206;
      if (!((Dafny.Helpers.SeqFromArray(_21341_tv__okm__desired)).Equals((_21342_okm)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/hkdf/HKDF.dfy(31,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void Test1()
    {
      byte[] _21343_tv__ikm;
      byte[] _nw30 = new byte[Dafny.Helpers.ToIntChecked(Dafny.Helpers.ToIntChecked(new BigInteger(80), "C# arrays may not be larger than the max 32-bit integer"),"C# array size must not be larger than max 32-bit int")];
      _nw30[(int)(0)] = 0;
      _nw30[(int)(1)] = 1;
      _nw30[(int)(2)] = 2;
      _nw30[(int)(3)] = 3;
      _nw30[(int)(4)] = 4;
      _nw30[(int)(5)] = 5;
      _nw30[(int)(6)] = 6;
      _nw30[(int)(7)] = 7;
      _nw30[(int)(8)] = 8;
      _nw30[(int)(9)] = 9;
      _nw30[(int)(10)] = 10;
      _nw30[(int)(11)] = 11;
      _nw30[(int)(12)] = 12;
      _nw30[(int)(13)] = 13;
      _nw30[(int)(14)] = 14;
      _nw30[(int)(15)] = 15;
      _nw30[(int)(16)] = 16;
      _nw30[(int)(17)] = 17;
      _nw30[(int)(18)] = 18;
      _nw30[(int)(19)] = 19;
      _nw30[(int)(20)] = 20;
      _nw30[(int)(21)] = 21;
      _nw30[(int)(22)] = 22;
      _nw30[(int)(23)] = 23;
      _nw30[(int)(24)] = 24;
      _nw30[(int)(25)] = 25;
      _nw30[(int)(26)] = 26;
      _nw30[(int)(27)] = 27;
      _nw30[(int)(28)] = 28;
      _nw30[(int)(29)] = 29;
      _nw30[(int)(30)] = 30;
      _nw30[(int)(31)] = 31;
      _nw30[(int)(32)] = 32;
      _nw30[(int)(33)] = 33;
      _nw30[(int)(34)] = 34;
      _nw30[(int)(35)] = 35;
      _nw30[(int)(36)] = 36;
      _nw30[(int)(37)] = 37;
      _nw30[(int)(38)] = 38;
      _nw30[(int)(39)] = 39;
      _nw30[(int)(40)] = 40;
      _nw30[(int)(41)] = 41;
      _nw30[(int)(42)] = 42;
      _nw30[(int)(43)] = 43;
      _nw30[(int)(44)] = 44;
      _nw30[(int)(45)] = 45;
      _nw30[(int)(46)] = 46;
      _nw30[(int)(47)] = 47;
      _nw30[(int)(48)] = 48;
      _nw30[(int)(49)] = 49;
      _nw30[(int)(50)] = 50;
      _nw30[(int)(51)] = 51;
      _nw30[(int)(52)] = 52;
      _nw30[(int)(53)] = 53;
      _nw30[(int)(54)] = 54;
      _nw30[(int)(55)] = 55;
      _nw30[(int)(56)] = 56;
      _nw30[(int)(57)] = 57;
      _nw30[(int)(58)] = 58;
      _nw30[(int)(59)] = 59;
      _nw30[(int)(60)] = 60;
      _nw30[(int)(61)] = 61;
      _nw30[(int)(62)] = 62;
      _nw30[(int)(63)] = 63;
      _nw30[(int)(64)] = 64;
      _nw30[(int)(65)] = 65;
      _nw30[(int)(66)] = 66;
      _nw30[(int)(67)] = 67;
      _nw30[(int)(68)] = 68;
      _nw30[(int)(69)] = 69;
      _nw30[(int)(70)] = 70;
      _nw30[(int)(71)] = 71;
      _nw30[(int)(72)] = 72;
      _nw30[(int)(73)] = 73;
      _nw30[(int)(74)] = 74;
      _nw30[(int)(75)] = 75;
      _nw30[(int)(76)] = 76;
      _nw30[(int)(77)] = 77;
      _nw30[(int)(78)] = 78;
      _nw30[(int)(79)] = 79;
      _21343_tv__ikm = _nw30;
      byte[] _21344_tv__salt;
      byte[] _nw31 = new byte[Dafny.Helpers.ToIntChecked(Dafny.Helpers.ToIntChecked(new BigInteger(80), "C# arrays may not be larger than the max 32-bit integer"),"C# array size must not be larger than max 32-bit int")];
      _nw31[(int)(0)] = 96;
      _nw31[(int)(1)] = 97;
      _nw31[(int)(2)] = 98;
      _nw31[(int)(3)] = 99;
      _nw31[(int)(4)] = 100;
      _nw31[(int)(5)] = 101;
      _nw31[(int)(6)] = 102;
      _nw31[(int)(7)] = 103;
      _nw31[(int)(8)] = 104;
      _nw31[(int)(9)] = 105;
      _nw31[(int)(10)] = 106;
      _nw31[(int)(11)] = 107;
      _nw31[(int)(12)] = 108;
      _nw31[(int)(13)] = 109;
      _nw31[(int)(14)] = 110;
      _nw31[(int)(15)] = 111;
      _nw31[(int)(16)] = 112;
      _nw31[(int)(17)] = 113;
      _nw31[(int)(18)] = 114;
      _nw31[(int)(19)] = 115;
      _nw31[(int)(20)] = 116;
      _nw31[(int)(21)] = 117;
      _nw31[(int)(22)] = 118;
      _nw31[(int)(23)] = 119;
      _nw31[(int)(24)] = 120;
      _nw31[(int)(25)] = 121;
      _nw31[(int)(26)] = 122;
      _nw31[(int)(27)] = 123;
      _nw31[(int)(28)] = 124;
      _nw31[(int)(29)] = 125;
      _nw31[(int)(30)] = 126;
      _nw31[(int)(31)] = 127;
      _nw31[(int)(32)] = 128;
      _nw31[(int)(33)] = 129;
      _nw31[(int)(34)] = 130;
      _nw31[(int)(35)] = 130;
      _nw31[(int)(36)] = 86;
      _nw31[(int)(37)] = 133;
      _nw31[(int)(38)] = 134;
      _nw31[(int)(39)] = 135;
      _nw31[(int)(40)] = 136;
      _nw31[(int)(41)] = 137;
      _nw31[(int)(42)] = 138;
      _nw31[(int)(43)] = 139;
      _nw31[(int)(44)] = 140;
      _nw31[(int)(45)] = 141;
      _nw31[(int)(46)] = 142;
      _nw31[(int)(47)] = 143;
      _nw31[(int)(48)] = 144;
      _nw31[(int)(49)] = 145;
      _nw31[(int)(50)] = 146;
      _nw31[(int)(51)] = 147;
      _nw31[(int)(52)] = 148;
      _nw31[(int)(53)] = 149;
      _nw31[(int)(54)] = 150;
      _nw31[(int)(55)] = 151;
      _nw31[(int)(56)] = 152;
      _nw31[(int)(57)] = 153;
      _nw31[(int)(58)] = 154;
      _nw31[(int)(59)] = 155;
      _nw31[(int)(60)] = 156;
      _nw31[(int)(61)] = 157;
      _nw31[(int)(62)] = 158;
      _nw31[(int)(63)] = 159;
      _nw31[(int)(64)] = 160;
      _nw31[(int)(65)] = 161;
      _nw31[(int)(66)] = 162;
      _nw31[(int)(67)] = 163;
      _nw31[(int)(68)] = 164;
      _nw31[(int)(69)] = 165;
      _nw31[(int)(70)] = 166;
      _nw31[(int)(71)] = 167;
      _nw31[(int)(72)] = 168;
      _nw31[(int)(73)] = 169;
      _nw31[(int)(74)] = 170;
      _nw31[(int)(75)] = 171;
      _nw31[(int)(76)] = 172;
      _nw31[(int)(77)] = 173;
      _nw31[(int)(78)] = 174;
      _nw31[(int)(79)] = 175;
      _21344_tv__salt = _nw31;
      byte[] _21345_tv__info;
      byte[] _nw32 = new byte[Dafny.Helpers.ToIntChecked(Dafny.Helpers.ToIntChecked(new BigInteger(80), "C# arrays may not be larger than the max 32-bit integer"),"C# array size must not be larger than max 32-bit int")];
      _nw32[(int)(0)] = 176;
      _nw32[(int)(1)] = 177;
      _nw32[(int)(2)] = 178;
      _nw32[(int)(3)] = 179;
      _nw32[(int)(4)] = 180;
      _nw32[(int)(5)] = 181;
      _nw32[(int)(6)] = 182;
      _nw32[(int)(7)] = 183;
      _nw32[(int)(8)] = 184;
      _nw32[(int)(9)] = 185;
      _nw32[(int)(10)] = 186;
      _nw32[(int)(11)] = 187;
      _nw32[(int)(12)] = 188;
      _nw32[(int)(13)] = 189;
      _nw32[(int)(14)] = 190;
      _nw32[(int)(15)] = 191;
      _nw32[(int)(16)] = 192;
      _nw32[(int)(17)] = 193;
      _nw32[(int)(18)] = 194;
      _nw32[(int)(19)] = 195;
      _nw32[(int)(20)] = 196;
      _nw32[(int)(21)] = 197;
      _nw32[(int)(22)] = 198;
      _nw32[(int)(23)] = 199;
      _nw32[(int)(24)] = 200;
      _nw32[(int)(25)] = 201;
      _nw32[(int)(26)] = 202;
      _nw32[(int)(27)] = 203;
      _nw32[(int)(28)] = 204;
      _nw32[(int)(29)] = 205;
      _nw32[(int)(30)] = 206;
      _nw32[(int)(31)] = 207;
      _nw32[(int)(32)] = 208;
      _nw32[(int)(33)] = 209;
      _nw32[(int)(34)] = 210;
      _nw32[(int)(35)] = 211;
      _nw32[(int)(36)] = 212;
      _nw32[(int)(37)] = 213;
      _nw32[(int)(38)] = 214;
      _nw32[(int)(39)] = 215;
      _nw32[(int)(40)] = 216;
      _nw32[(int)(41)] = 217;
      _nw32[(int)(42)] = 218;
      _nw32[(int)(43)] = 219;
      _nw32[(int)(44)] = 220;
      _nw32[(int)(45)] = 221;
      _nw32[(int)(46)] = 222;
      _nw32[(int)(47)] = 223;
      _nw32[(int)(48)] = 224;
      _nw32[(int)(49)] = 225;
      _nw32[(int)(50)] = 226;
      _nw32[(int)(51)] = 227;
      _nw32[(int)(52)] = 228;
      _nw32[(int)(53)] = 229;
      _nw32[(int)(54)] = 230;
      _nw32[(int)(55)] = 231;
      _nw32[(int)(56)] = 232;
      _nw32[(int)(57)] = 233;
      _nw32[(int)(58)] = 234;
      _nw32[(int)(59)] = 235;
      _nw32[(int)(60)] = 236;
      _nw32[(int)(61)] = 237;
      _nw32[(int)(62)] = 238;
      _nw32[(int)(63)] = 239;
      _nw32[(int)(64)] = 240;
      _nw32[(int)(65)] = 241;
      _nw32[(int)(66)] = 242;
      _nw32[(int)(67)] = 243;
      _nw32[(int)(68)] = 244;
      _nw32[(int)(69)] = 245;
      _nw32[(int)(70)] = 246;
      _nw32[(int)(71)] = 247;
      _nw32[(int)(72)] = 248;
      _nw32[(int)(73)] = 249;
      _nw32[(int)(74)] = 250;
      _nw32[(int)(75)] = 251;
      _nw32[(int)(76)] = 252;
      _nw32[(int)(77)] = 253;
      _nw32[(int)(78)] = 254;
      _nw32[(int)(79)] = 255;
      _21345_tv__info = _nw32;
      byte[] _21346_tv__okm__desired;
      byte[] _nw33 = new byte[Dafny.Helpers.ToIntChecked(Dafny.Helpers.ToIntChecked(new BigInteger(82), "C# arrays may not be larger than the max 32-bit integer"),"C# array size must not be larger than max 32-bit int")];
      _nw33[(int)(0)] = 86;
      _nw33[(int)(1)] = 160;
      _nw33[(int)(2)] = 84;
      _nw33[(int)(3)] = 52;
      _nw33[(int)(4)] = 29;
      _nw33[(int)(5)] = 13;
      _nw33[(int)(6)] = 71;
      _nw33[(int)(7)] = 250;
      _nw33[(int)(8)] = 11;
      _nw33[(int)(9)] = 73;
      _nw33[(int)(10)] = 208;
      _nw33[(int)(11)] = 29;
      _nw33[(int)(12)] = 1;
      _nw33[(int)(13)] = 53;
      _nw33[(int)(14)] = 45;
      _nw33[(int)(15)] = 194;
      _nw33[(int)(16)] = 17;
      _nw33[(int)(17)] = 12;
      _nw33[(int)(18)] = 253;
      _nw33[(int)(19)] = 117;
      _nw33[(int)(20)] = 16;
      _nw33[(int)(21)] = 251;
      _nw33[(int)(22)] = 6;
      _nw33[(int)(23)] = 124;
      _nw33[(int)(24)] = 155;
      _nw33[(int)(25)] = 90;
      _nw33[(int)(26)] = 233;
      _nw33[(int)(27)] = 105;
      _nw33[(int)(28)] = 148;
      _nw33[(int)(29)] = 86;
      _nw33[(int)(30)] = 41;
      _nw33[(int)(31)] = 99;
      _nw33[(int)(32)] = 67;
      _nw33[(int)(33)] = 199;
      _nw33[(int)(34)] = 253;
      _nw33[(int)(35)] = 213;
      _nw33[(int)(36)] = 169;
      _nw33[(int)(37)] = 254;
      _nw33[(int)(38)] = 226;
      _nw33[(int)(39)] = 104;
      _nw33[(int)(40)] = 215;
      _nw33[(int)(41)] = 158;
      _nw33[(int)(42)] = 234;
      _nw33[(int)(43)] = 250;
      _nw33[(int)(44)] = 134;
      _nw33[(int)(45)] = 60;
      _nw33[(int)(46)] = 241;
      _nw33[(int)(47)] = 23;
      _nw33[(int)(48)] = 88;
      _nw33[(int)(49)] = 218;
      _nw33[(int)(50)] = 24;
      _nw33[(int)(51)] = 176;
      _nw33[(int)(52)] = 71;
      _nw33[(int)(53)] = 136;
      _nw33[(int)(54)] = 160;
      _nw33[(int)(55)] = 210;
      _nw33[(int)(56)] = 197;
      _nw33[(int)(57)] = 159;
      _nw33[(int)(58)] = 59;
      _nw33[(int)(59)] = 3;
      _nw33[(int)(60)] = 66;
      _nw33[(int)(61)] = 163;
      _nw33[(int)(62)] = 130;
      _nw33[(int)(63)] = 46;
      _nw33[(int)(64)] = 215;
      _nw33[(int)(65)] = 166;
      _nw33[(int)(66)] = 223;
      _nw33[(int)(67)] = 241;
      _nw33[(int)(68)] = 108;
      _nw33[(int)(69)] = 59;
      _nw33[(int)(70)] = 97;
      _nw33[(int)(71)] = 59;
      _nw33[(int)(72)] = 88;
      _nw33[(int)(73)] = 158;
      _nw33[(int)(74)] = 207;
      _nw33[(int)(75)] = 15;
      _nw33[(int)(76)] = 113;
      _nw33[(int)(77)] = 11;
      _nw33[(int)(78)] = 223;
      _nw33[(int)(79)] = 43;
      _nw33[(int)(80)] = 21;
      _nw33[(int)(81)] = 57;
      _21346_tv__okm__desired = _nw33;
      Dafny.ISequence<byte> _21347_okm;
      Dafny.ISequence<byte> _out207;
      _out207 = HKDF_Compile.__default.Hkdf(@KeyDerivationAlgorithms.KeyDerivationAlgorithm.create_HKDF__WITH__SHA__256(), @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(Dafny.Helpers.SeqFromArray(_21344_tv__salt)), Dafny.Helpers.SeqFromArray(_21343_tv__ikm), Dafny.Helpers.SeqFromArray(_21345_tv__info), new BigInteger(82));
      _21347_okm = _out207;
      if (!((Dafny.Helpers.SeqFromArray(_21346_tv__okm__desired)).Equals((_21347_okm)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/hkdf/HKDF.dfy(66,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void Test2()
    {
      Wrappers_Compile.Option<Dafny.ISequence<byte>> _21348_tv__salt;
      _21348_tv__salt = @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_None();
      byte[] _21349_tv__ikm;
      byte[] _nw34 = new byte[Dafny.Helpers.ToIntChecked(Dafny.Helpers.ToIntChecked(new BigInteger(22), "C# arrays may not be larger than the max 32-bit integer"),"C# array size must not be larger than max 32-bit int")];
      _nw34[(int)(0)] = 11;
      _nw34[(int)(1)] = 11;
      _nw34[(int)(2)] = 11;
      _nw34[(int)(3)] = 11;
      _nw34[(int)(4)] = 11;
      _nw34[(int)(5)] = 11;
      _nw34[(int)(6)] = 11;
      _nw34[(int)(7)] = 11;
      _nw34[(int)(8)] = 11;
      _nw34[(int)(9)] = 11;
      _nw34[(int)(10)] = 11;
      _nw34[(int)(11)] = 11;
      _nw34[(int)(12)] = 11;
      _nw34[(int)(13)] = 11;
      _nw34[(int)(14)] = 11;
      _nw34[(int)(15)] = 11;
      _nw34[(int)(16)] = 11;
      _nw34[(int)(17)] = 11;
      _nw34[(int)(18)] = 11;
      _nw34[(int)(19)] = 11;
      _nw34[(int)(20)] = 11;
      _nw34[(int)(21)] = 11;
      _21349_tv__ikm = _nw34;
      Dafny.ISequence<byte> _21350_tv__info;
      _21350_tv__info = Dafny.Sequence<byte>.FromElements();
      byte[] _21351_tv__okm__desired;
      byte[] _nw35 = new byte[Dafny.Helpers.ToIntChecked(Dafny.Helpers.ToIntChecked(new BigInteger(42), "C# arrays may not be larger than the max 32-bit integer"),"C# array size must not be larger than max 32-bit int")];
      _nw35[(int)(0)] = 141;
      _nw35[(int)(1)] = 164;
      _nw35[(int)(2)] = 231;
      _nw35[(int)(3)] = 117;
      _nw35[(int)(4)] = 165;
      _nw35[(int)(5)] = 99;
      _nw35[(int)(6)] = 193;
      _nw35[(int)(7)] = 143;
      _nw35[(int)(8)] = 113;
      _nw35[(int)(9)] = 95;
      _nw35[(int)(10)] = 128;
      _nw35[(int)(11)] = 42;
      _nw35[(int)(12)] = 6;
      _nw35[(int)(13)] = 60;
      _nw35[(int)(14)] = 90;
      _nw35[(int)(15)] = 49;
      _nw35[(int)(16)] = 184;
      _nw35[(int)(17)] = 161;
      _nw35[(int)(18)] = 31;
      _nw35[(int)(19)] = 92;
      _nw35[(int)(20)] = 94;
      _nw35[(int)(21)] = 225;
      _nw35[(int)(22)] = 135;
      _nw35[(int)(23)] = 158;
      _nw35[(int)(24)] = 195;
      _nw35[(int)(25)] = 69;
      _nw35[(int)(26)] = 78;
      _nw35[(int)(27)] = 95;
      _nw35[(int)(28)] = 60;
      _nw35[(int)(29)] = 115;
      _nw35[(int)(30)] = 141;
      _nw35[(int)(31)] = 45;
      _nw35[(int)(32)] = 157;
      _nw35[(int)(33)] = 32;
      _nw35[(int)(34)] = 19;
      _nw35[(int)(35)] = 149;
      _nw35[(int)(36)] = 250;
      _nw35[(int)(37)] = 164;
      _nw35[(int)(38)] = 182;
      _nw35[(int)(39)] = 26;
      _nw35[(int)(40)] = 150;
      _nw35[(int)(41)] = 200;
      _21351_tv__okm__desired = _nw35;
      Dafny.ISequence<byte> _21352_okm;
      Dafny.ISequence<byte> _out208;
      _out208 = HKDF_Compile.__default.Hkdf(@KeyDerivationAlgorithms.KeyDerivationAlgorithm.create_HKDF__WITH__SHA__256(), _21348_tv__salt, Dafny.Helpers.SeqFromArray(_21349_tv__ikm), (_21350_tv__info), new BigInteger(42));
      _21352_okm = _out208;
      if (!((Dafny.Helpers.SeqFromArray(_21351_tv__okm__desired)).Equals((_21352_okm)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/hkdf/HKDF.dfy(84,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void Test3()
    {
      byte[] _21353_tv__salt;
      byte[] _nw36 = new byte[Dafny.Helpers.ToIntChecked(Dafny.Helpers.ToIntChecked(new BigInteger(13), "C# arrays may not be larger than the max 32-bit integer"),"C# array size must not be larger than max 32-bit int")];
      _nw36[(int)(0)] = 0;
      _nw36[(int)(1)] = 1;
      _nw36[(int)(2)] = 2;
      _nw36[(int)(3)] = 3;
      _nw36[(int)(4)] = 4;
      _nw36[(int)(5)] = 5;
      _nw36[(int)(6)] = 6;
      _nw36[(int)(7)] = 7;
      _nw36[(int)(8)] = 8;
      _nw36[(int)(9)] = 9;
      _nw36[(int)(10)] = 10;
      _nw36[(int)(11)] = 11;
      _nw36[(int)(12)] = 12;
      _21353_tv__salt = _nw36;
      byte[] _21354_tv__ikm;
      byte[] _nw37 = new byte[Dafny.Helpers.ToIntChecked(Dafny.Helpers.ToIntChecked(new BigInteger(22), "C# arrays may not be larger than the max 32-bit integer"),"C# array size must not be larger than max 32-bit int")];
      _nw37[(int)(0)] = 11;
      _nw37[(int)(1)] = 11;
      _nw37[(int)(2)] = 11;
      _nw37[(int)(3)] = 11;
      _nw37[(int)(4)] = 11;
      _nw37[(int)(5)] = 11;
      _nw37[(int)(6)] = 11;
      _nw37[(int)(7)] = 11;
      _nw37[(int)(8)] = 11;
      _nw37[(int)(9)] = 11;
      _nw37[(int)(10)] = 11;
      _nw37[(int)(11)] = 11;
      _nw37[(int)(12)] = 11;
      _nw37[(int)(13)] = 11;
      _nw37[(int)(14)] = 11;
      _nw37[(int)(15)] = 11;
      _nw37[(int)(16)] = 11;
      _nw37[(int)(17)] = 11;
      _nw37[(int)(18)] = 11;
      _nw37[(int)(19)] = 11;
      _nw37[(int)(20)] = 11;
      _nw37[(int)(21)] = 11;
      _21354_tv__ikm = _nw37;
      byte[] _21355_tv__info;
      byte[] _nw38 = new byte[Dafny.Helpers.ToIntChecked(Dafny.Helpers.ToIntChecked(new BigInteger(10), "C# arrays may not be larger than the max 32-bit integer"),"C# array size must not be larger than max 32-bit int")];
      _nw38[(int)(0)] = 240;
      _nw38[(int)(1)] = 241;
      _nw38[(int)(2)] = 242;
      _nw38[(int)(3)] = 243;
      _nw38[(int)(4)] = 244;
      _nw38[(int)(5)] = 245;
      _nw38[(int)(6)] = 246;
      _nw38[(int)(7)] = 247;
      _nw38[(int)(8)] = 248;
      _nw38[(int)(9)] = 249;
      _21355_tv__info = _nw38;
      byte[] _21356_tv__okm__desired;
      byte[] _nw39 = new byte[Dafny.Helpers.ToIntChecked(Dafny.Helpers.ToIntChecked(new BigInteger(42), "C# arrays may not be larger than the max 32-bit integer"),"C# array size must not be larger than max 32-bit int")];
      _nw39[(int)(0)] = 155;
      _nw39[(int)(1)] = 80;
      _nw39[(int)(2)] = 151;
      _nw39[(int)(3)] = 168;
      _nw39[(int)(4)] = 96;
      _nw39[(int)(5)] = 56;
      _nw39[(int)(6)] = 184;
      _nw39[(int)(7)] = 5;
      _nw39[(int)(8)] = 48;
      _nw39[(int)(9)] = 144;
      _nw39[(int)(10)] = 118;
      _nw39[(int)(11)] = 164;
      _nw39[(int)(12)] = 75;
      _nw39[(int)(13)] = 58;
      _nw39[(int)(14)] = 159;
      _nw39[(int)(15)] = 56;
      _nw39[(int)(16)] = 6;
      _nw39[(int)(17)] = 62;
      _nw39[(int)(18)] = 37;
      _nw39[(int)(19)] = 181;
      _nw39[(int)(20)] = 22;
      _nw39[(int)(21)] = 220;
      _nw39[(int)(22)] = 191;
      _nw39[(int)(23)] = 54;
      _nw39[(int)(24)] = 159;
      _nw39[(int)(25)] = 57;
      _nw39[(int)(26)] = 76;
      _nw39[(int)(27)] = 250;
      _nw39[(int)(28)] = 180;
      _nw39[(int)(29)] = 54;
      _nw39[(int)(30)] = 133;
      _nw39[(int)(31)] = 247;
      _nw39[(int)(32)] = 72;
      _nw39[(int)(33)] = 182;
      _nw39[(int)(34)] = 69;
      _nw39[(int)(35)] = 119;
      _nw39[(int)(36)] = 99;
      _nw39[(int)(37)] = 228;
      _nw39[(int)(38)] = 240;
      _nw39[(int)(39)] = 32;
      _nw39[(int)(40)] = 79;
      _nw39[(int)(41)] = 197;
      _21356_tv__okm__desired = _nw39;
      Dafny.ISequence<byte> _21357_okm;
      Dafny.ISequence<byte> _out209;
      _out209 = HKDF_Compile.__default.Hkdf(@KeyDerivationAlgorithms.KeyDerivationAlgorithm.create_HKDF__WITH__SHA__384(), @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(Dafny.Helpers.SeqFromArray(_21353_tv__salt)), Dafny.Helpers.SeqFromArray(_21354_tv__ikm), Dafny.Helpers.SeqFromArray(_21355_tv__info), new BigInteger(42));
      _21357_okm = _out209;
      if (!((Dafny.Helpers.SeqFromArray(_21356_tv__okm__desired)).Equals((_21357_okm)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/hkdf/HKDF.dfy(102,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void Test4()
    {
      byte[] _21358_tv__salt;
      byte[] _nw40 = new byte[Dafny.Helpers.ToIntChecked(Dafny.Helpers.ToIntChecked(new BigInteger(80), "C# arrays may not be larger than the max 32-bit integer"),"C# array size must not be larger than max 32-bit int")];
      _nw40[(int)(0)] = 96;
      _nw40[(int)(1)] = 97;
      _nw40[(int)(2)] = 98;
      _nw40[(int)(3)] = 99;
      _nw40[(int)(4)] = 100;
      _nw40[(int)(5)] = 101;
      _nw40[(int)(6)] = 102;
      _nw40[(int)(7)] = 103;
      _nw40[(int)(8)] = 104;
      _nw40[(int)(9)] = 105;
      _nw40[(int)(10)] = 106;
      _nw40[(int)(11)] = 107;
      _nw40[(int)(12)] = 108;
      _nw40[(int)(13)] = 109;
      _nw40[(int)(14)] = 110;
      _nw40[(int)(15)] = 111;
      _nw40[(int)(16)] = 112;
      _nw40[(int)(17)] = 113;
      _nw40[(int)(18)] = 114;
      _nw40[(int)(19)] = 115;
      _nw40[(int)(20)] = 116;
      _nw40[(int)(21)] = 117;
      _nw40[(int)(22)] = 118;
      _nw40[(int)(23)] = 119;
      _nw40[(int)(24)] = 120;
      _nw40[(int)(25)] = 121;
      _nw40[(int)(26)] = 122;
      _nw40[(int)(27)] = 123;
      _nw40[(int)(28)] = 124;
      _nw40[(int)(29)] = 125;
      _nw40[(int)(30)] = 126;
      _nw40[(int)(31)] = 127;
      _nw40[(int)(32)] = 128;
      _nw40[(int)(33)] = 129;
      _nw40[(int)(34)] = 130;
      _nw40[(int)(35)] = 131;
      _nw40[(int)(36)] = 132;
      _nw40[(int)(37)] = 133;
      _nw40[(int)(38)] = 134;
      _nw40[(int)(39)] = 135;
      _nw40[(int)(40)] = 136;
      _nw40[(int)(41)] = 137;
      _nw40[(int)(42)] = 138;
      _nw40[(int)(43)] = 139;
      _nw40[(int)(44)] = 140;
      _nw40[(int)(45)] = 141;
      _nw40[(int)(46)] = 142;
      _nw40[(int)(47)] = 143;
      _nw40[(int)(48)] = 144;
      _nw40[(int)(49)] = 145;
      _nw40[(int)(50)] = 146;
      _nw40[(int)(51)] = 147;
      _nw40[(int)(52)] = 148;
      _nw40[(int)(53)] = 149;
      _nw40[(int)(54)] = 150;
      _nw40[(int)(55)] = 151;
      _nw40[(int)(56)] = 152;
      _nw40[(int)(57)] = 153;
      _nw40[(int)(58)] = 154;
      _nw40[(int)(59)] = 155;
      _nw40[(int)(60)] = 156;
      _nw40[(int)(61)] = 157;
      _nw40[(int)(62)] = 158;
      _nw40[(int)(63)] = 159;
      _nw40[(int)(64)] = 160;
      _nw40[(int)(65)] = 161;
      _nw40[(int)(66)] = 162;
      _nw40[(int)(67)] = 163;
      _nw40[(int)(68)] = 164;
      _nw40[(int)(69)] = 165;
      _nw40[(int)(70)] = 166;
      _nw40[(int)(71)] = 167;
      _nw40[(int)(72)] = 168;
      _nw40[(int)(73)] = 169;
      _nw40[(int)(74)] = 170;
      _nw40[(int)(75)] = 171;
      _nw40[(int)(76)] = 172;
      _nw40[(int)(77)] = 173;
      _nw40[(int)(78)] = 174;
      _nw40[(int)(79)] = 175;
      _21358_tv__salt = _nw40;
      byte[] _21359_tv__ikm;
      byte[] _nw41 = new byte[Dafny.Helpers.ToIntChecked(Dafny.Helpers.ToIntChecked(new BigInteger(80), "C# arrays may not be larger than the max 32-bit integer"),"C# array size must not be larger than max 32-bit int")];
      _nw41[(int)(0)] = 0;
      _nw41[(int)(1)] = 1;
      _nw41[(int)(2)] = 2;
      _nw41[(int)(3)] = 3;
      _nw41[(int)(4)] = 4;
      _nw41[(int)(5)] = 5;
      _nw41[(int)(6)] = 6;
      _nw41[(int)(7)] = 7;
      _nw41[(int)(8)] = 8;
      _nw41[(int)(9)] = 9;
      _nw41[(int)(10)] = 10;
      _nw41[(int)(11)] = 11;
      _nw41[(int)(12)] = 12;
      _nw41[(int)(13)] = 13;
      _nw41[(int)(14)] = 14;
      _nw41[(int)(15)] = 15;
      _nw41[(int)(16)] = 16;
      _nw41[(int)(17)] = 17;
      _nw41[(int)(18)] = 18;
      _nw41[(int)(19)] = 19;
      _nw41[(int)(20)] = 20;
      _nw41[(int)(21)] = 21;
      _nw41[(int)(22)] = 22;
      _nw41[(int)(23)] = 23;
      _nw41[(int)(24)] = 24;
      _nw41[(int)(25)] = 25;
      _nw41[(int)(26)] = 26;
      _nw41[(int)(27)] = 27;
      _nw41[(int)(28)] = 28;
      _nw41[(int)(29)] = 29;
      _nw41[(int)(30)] = 30;
      _nw41[(int)(31)] = 31;
      _nw41[(int)(32)] = 32;
      _nw41[(int)(33)] = 33;
      _nw41[(int)(34)] = 34;
      _nw41[(int)(35)] = 35;
      _nw41[(int)(36)] = 36;
      _nw41[(int)(37)] = 37;
      _nw41[(int)(38)] = 38;
      _nw41[(int)(39)] = 39;
      _nw41[(int)(40)] = 40;
      _nw41[(int)(41)] = 41;
      _nw41[(int)(42)] = 42;
      _nw41[(int)(43)] = 43;
      _nw41[(int)(44)] = 44;
      _nw41[(int)(45)] = 45;
      _nw41[(int)(46)] = 46;
      _nw41[(int)(47)] = 47;
      _nw41[(int)(48)] = 48;
      _nw41[(int)(49)] = 49;
      _nw41[(int)(50)] = 50;
      _nw41[(int)(51)] = 51;
      _nw41[(int)(52)] = 52;
      _nw41[(int)(53)] = 53;
      _nw41[(int)(54)] = 54;
      _nw41[(int)(55)] = 55;
      _nw41[(int)(56)] = 56;
      _nw41[(int)(57)] = 57;
      _nw41[(int)(58)] = 58;
      _nw41[(int)(59)] = 59;
      _nw41[(int)(60)] = 60;
      _nw41[(int)(61)] = 61;
      _nw41[(int)(62)] = 62;
      _nw41[(int)(63)] = 63;
      _nw41[(int)(64)] = 64;
      _nw41[(int)(65)] = 65;
      _nw41[(int)(66)] = 66;
      _nw41[(int)(67)] = 67;
      _nw41[(int)(68)] = 68;
      _nw41[(int)(69)] = 69;
      _nw41[(int)(70)] = 70;
      _nw41[(int)(71)] = 71;
      _nw41[(int)(72)] = 72;
      _nw41[(int)(73)] = 73;
      _nw41[(int)(74)] = 74;
      _nw41[(int)(75)] = 75;
      _nw41[(int)(76)] = 76;
      _nw41[(int)(77)] = 77;
      _nw41[(int)(78)] = 78;
      _nw41[(int)(79)] = 79;
      _21359_tv__ikm = _nw41;
      byte[] _21360_tv__info;
      byte[] _nw42 = new byte[Dafny.Helpers.ToIntChecked(Dafny.Helpers.ToIntChecked(new BigInteger(80), "C# arrays may not be larger than the max 32-bit integer"),"C# array size must not be larger than max 32-bit int")];
      _nw42[(int)(0)] = 176;
      _nw42[(int)(1)] = 177;
      _nw42[(int)(2)] = 178;
      _nw42[(int)(3)] = 179;
      _nw42[(int)(4)] = 180;
      _nw42[(int)(5)] = 181;
      _nw42[(int)(6)] = 182;
      _nw42[(int)(7)] = 183;
      _nw42[(int)(8)] = 184;
      _nw42[(int)(9)] = 185;
      _nw42[(int)(10)] = 186;
      _nw42[(int)(11)] = 187;
      _nw42[(int)(12)] = 188;
      _nw42[(int)(13)] = 189;
      _nw42[(int)(14)] = 190;
      _nw42[(int)(15)] = 191;
      _nw42[(int)(16)] = 192;
      _nw42[(int)(17)] = 193;
      _nw42[(int)(18)] = 194;
      _nw42[(int)(19)] = 195;
      _nw42[(int)(20)] = 196;
      _nw42[(int)(21)] = 197;
      _nw42[(int)(22)] = 198;
      _nw42[(int)(23)] = 199;
      _nw42[(int)(24)] = 200;
      _nw42[(int)(25)] = 201;
      _nw42[(int)(26)] = 202;
      _nw42[(int)(27)] = 203;
      _nw42[(int)(28)] = 204;
      _nw42[(int)(29)] = 205;
      _nw42[(int)(30)] = 206;
      _nw42[(int)(31)] = 207;
      _nw42[(int)(32)] = 208;
      _nw42[(int)(33)] = 209;
      _nw42[(int)(34)] = 210;
      _nw42[(int)(35)] = 211;
      _nw42[(int)(36)] = 212;
      _nw42[(int)(37)] = 213;
      _nw42[(int)(38)] = 214;
      _nw42[(int)(39)] = 215;
      _nw42[(int)(40)] = 216;
      _nw42[(int)(41)] = 217;
      _nw42[(int)(42)] = 218;
      _nw42[(int)(43)] = 219;
      _nw42[(int)(44)] = 220;
      _nw42[(int)(45)] = 221;
      _nw42[(int)(46)] = 222;
      _nw42[(int)(47)] = 223;
      _nw42[(int)(48)] = 224;
      _nw42[(int)(49)] = 225;
      _nw42[(int)(50)] = 226;
      _nw42[(int)(51)] = 227;
      _nw42[(int)(52)] = 228;
      _nw42[(int)(53)] = 229;
      _nw42[(int)(54)] = 230;
      _nw42[(int)(55)] = 231;
      _nw42[(int)(56)] = 232;
      _nw42[(int)(57)] = 233;
      _nw42[(int)(58)] = 234;
      _nw42[(int)(59)] = 235;
      _nw42[(int)(60)] = 236;
      _nw42[(int)(61)] = 237;
      _nw42[(int)(62)] = 238;
      _nw42[(int)(63)] = 239;
      _nw42[(int)(64)] = 240;
      _nw42[(int)(65)] = 241;
      _nw42[(int)(66)] = 242;
      _nw42[(int)(67)] = 243;
      _nw42[(int)(68)] = 244;
      _nw42[(int)(69)] = 245;
      _nw42[(int)(70)] = 246;
      _nw42[(int)(71)] = 247;
      _nw42[(int)(72)] = 248;
      _nw42[(int)(73)] = 249;
      _nw42[(int)(74)] = 250;
      _nw42[(int)(75)] = 251;
      _nw42[(int)(76)] = 252;
      _nw42[(int)(77)] = 253;
      _nw42[(int)(78)] = 254;
      _nw42[(int)(79)] = 255;
      _21360_tv__info = _nw42;
      byte[] _21361_tv__okm__desired;
      byte[] _nw43 = new byte[Dafny.Helpers.ToIntChecked(Dafny.Helpers.ToIntChecked(new BigInteger(82), "C# arrays may not be larger than the max 32-bit integer"),"C# array size must not be larger than max 32-bit int")];
      _nw43[(int)(0)] = 72;
      _nw43[(int)(1)] = 76;
      _nw43[(int)(2)] = 160;
      _nw43[(int)(3)] = 82;
      _nw43[(int)(4)] = 184;
      _nw43[(int)(5)] = 204;
      _nw43[(int)(6)] = 114;
      _nw43[(int)(7)] = 79;
      _nw43[(int)(8)] = 209;
      _nw43[(int)(9)] = 196;
      _nw43[(int)(10)] = 236;
      _nw43[(int)(11)] = 100;
      _nw43[(int)(12)] = 213;
      _nw43[(int)(13)] = 123;
      _nw43[(int)(14)] = 78;
      _nw43[(int)(15)] = 129;
      _nw43[(int)(16)] = 140;
      _nw43[(int)(17)] = 126;
      _nw43[(int)(18)] = 37;
      _nw43[(int)(19)] = 168;
      _nw43[(int)(20)] = 224;
      _nw43[(int)(21)] = 244;
      _nw43[(int)(22)] = 86;
      _nw43[(int)(23)] = 158;
      _nw43[(int)(24)] = 215;
      _nw43[(int)(25)] = 42;
      _nw43[(int)(26)] = 106;
      _nw43[(int)(27)] = 5;
      _nw43[(int)(28)] = 254;
      _nw43[(int)(29)] = 6;
      _nw43[(int)(30)] = 73;
      _nw43[(int)(31)] = 238;
      _nw43[(int)(32)] = 191;
      _nw43[(int)(33)] = 105;
      _nw43[(int)(34)] = 248;
      _nw43[(int)(35)] = 213;
      _nw43[(int)(36)] = 200;
      _nw43[(int)(37)] = 50;
      _nw43[(int)(38)] = 133;
      _nw43[(int)(39)] = 107;
      _nw43[(int)(40)] = 244;
      _nw43[(int)(41)] = 228;
      _nw43[(int)(42)] = 251;
      _nw43[(int)(43)] = 193;
      _nw43[(int)(44)] = 121;
      _nw43[(int)(45)] = 103;
      _nw43[(int)(46)] = 213;
      _nw43[(int)(47)] = 73;
      _nw43[(int)(48)] = 117;
      _nw43[(int)(49)] = 50;
      _nw43[(int)(50)] = 74;
      _nw43[(int)(51)] = 148;
      _nw43[(int)(52)] = 152;
      _nw43[(int)(53)] = 127;
      _nw43[(int)(54)] = 127;
      _nw43[(int)(55)] = 65;
      _nw43[(int)(56)] = 131;
      _nw43[(int)(57)] = 88;
      _nw43[(int)(58)] = 23;
      _nw43[(int)(59)] = 216;
      _nw43[(int)(60)] = 153;
      _nw43[(int)(61)] = 79;
      _nw43[(int)(62)] = 219;
      _nw43[(int)(63)] = 214;
      _nw43[(int)(64)] = 244;
      _nw43[(int)(65)] = 192;
      _nw43[(int)(66)] = 156;
      _nw43[(int)(67)] = 85;
      _nw43[(int)(68)] = 0;
      _nw43[(int)(69)] = 220;
      _nw43[(int)(70)] = 162;
      _nw43[(int)(71)] = 74;
      _nw43[(int)(72)] = 86;
      _nw43[(int)(73)] = 34;
      _nw43[(int)(74)] = 47;
      _nw43[(int)(75)] = 234;
      _nw43[(int)(76)] = 83;
      _nw43[(int)(77)] = 216;
      _nw43[(int)(78)] = 150;
      _nw43[(int)(79)] = 122;
      _nw43[(int)(80)] = 139;
      _nw43[(int)(81)] = 46;
      _21361_tv__okm__desired = _nw43;
      Dafny.ISequence<byte> _21362_okm;
      Dafny.ISequence<byte> _out210;
      _out210 = HKDF_Compile.__default.Hkdf(@KeyDerivationAlgorithms.KeyDerivationAlgorithm.create_HKDF__WITH__SHA__384(), @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(Dafny.Helpers.SeqFromArray(_21358_tv__salt)), Dafny.Helpers.SeqFromArray(_21359_tv__ikm), Dafny.Helpers.SeqFromArray(_21360_tv__info), new BigInteger(82));
      _21362_okm = _out210;
      if (!((Dafny.Helpers.SeqFromArray(_21361_tv__okm__desired)).Equals((_21362_okm)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/hkdf/HKDF.dfy(137,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void Test5()
    {
      Wrappers_Compile.Option<Dafny.ISequence<byte>> _21363_tv__salt;
      _21363_tv__salt = @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_None();
      byte[] _21364_tv__ikm;
      byte[] _nw44 = new byte[Dafny.Helpers.ToIntChecked(Dafny.Helpers.ToIntChecked(new BigInteger(22), "C# arrays may not be larger than the max 32-bit integer"),"C# array size must not be larger than max 32-bit int")];
      _nw44[(int)(0)] = 11;
      _nw44[(int)(1)] = 11;
      _nw44[(int)(2)] = 11;
      _nw44[(int)(3)] = 11;
      _nw44[(int)(4)] = 11;
      _nw44[(int)(5)] = 11;
      _nw44[(int)(6)] = 11;
      _nw44[(int)(7)] = 11;
      _nw44[(int)(8)] = 11;
      _nw44[(int)(9)] = 11;
      _nw44[(int)(10)] = 11;
      _nw44[(int)(11)] = 11;
      _nw44[(int)(12)] = 11;
      _nw44[(int)(13)] = 11;
      _nw44[(int)(14)] = 11;
      _nw44[(int)(15)] = 11;
      _nw44[(int)(16)] = 11;
      _nw44[(int)(17)] = 11;
      _nw44[(int)(18)] = 11;
      _nw44[(int)(19)] = 11;
      _nw44[(int)(20)] = 11;
      _nw44[(int)(21)] = 11;
      _21364_tv__ikm = _nw44;
      Dafny.ISequence<byte> _21365_tv__info;
      _21365_tv__info = Dafny.Sequence<byte>.FromElements();
      byte[] _21366_tv__okm__desired;
      byte[] _nw45 = new byte[Dafny.Helpers.ToIntChecked(Dafny.Helpers.ToIntChecked(new BigInteger(42), "C# arrays may not be larger than the max 32-bit integer"),"C# array size must not be larger than max 32-bit int")];
      _nw45[(int)(0)] = 200;
      _nw45[(int)(1)] = 201;
      _nw45[(int)(2)] = 110;
      _nw45[(int)(3)] = 113;
      _nw45[(int)(4)] = 15;
      _nw45[(int)(5)] = 137;
      _nw45[(int)(6)] = 176;
      _nw45[(int)(7)] = 215;
      _nw45[(int)(8)] = 153;
      _nw45[(int)(9)] = 11;
      _nw45[(int)(10)] = 202;
      _nw45[(int)(11)] = 104;
      _nw45[(int)(12)] = 188;
      _nw45[(int)(13)] = 222;
      _nw45[(int)(14)] = 200;
      _nw45[(int)(15)] = 207;
      _nw45[(int)(16)] = 133;
      _nw45[(int)(17)] = 64;
      _nw45[(int)(18)] = 98;
      _nw45[(int)(19)] = 229;
      _nw45[(int)(20)] = 76;
      _nw45[(int)(21)] = 115;
      _nw45[(int)(22)] = 167;
      _nw45[(int)(23)] = 171;
      _nw45[(int)(24)] = 199;
      _nw45[(int)(25)] = 67;
      _nw45[(int)(26)] = 250;
      _nw45[(int)(27)] = 222;
      _nw45[(int)(28)] = 155;
      _nw45[(int)(29)] = 36;
      _nw45[(int)(30)] = 45;
      _nw45[(int)(31)] = 170;
      _nw45[(int)(32)] = 204;
      _nw45[(int)(33)] = 28;
      _nw45[(int)(34)] = 234;
      _nw45[(int)(35)] = 86;
      _nw45[(int)(36)] = 112;
      _nw45[(int)(37)] = 65;
      _nw45[(int)(38)] = 91;
      _nw45[(int)(39)] = 82;
      _nw45[(int)(40)] = 132;
      _nw45[(int)(41)] = 156;
      _21366_tv__okm__desired = _nw45;
      Dafny.ISequence<byte> _21367_okm;
      Dafny.ISequence<byte> _out211;
      _out211 = HKDF_Compile.__default.Hkdf(@KeyDerivationAlgorithms.KeyDerivationAlgorithm.create_HKDF__WITH__SHA__384(), _21363_tv__salt, Dafny.Helpers.SeqFromArray(_21364_tv__ikm), (_21365_tv__info), new BigInteger(42));
      _21367_okm = _out211;
      if (!((Dafny.Helpers.SeqFromArray(_21366_tv__okm__desired)).Equals((_21367_okm)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/hkdf/HKDF.dfy(155,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void Test7()
    {
      byte[] _21368_tv__ikm;
      byte[] _nw46 = new byte[Dafny.Helpers.ToIntChecked(Dafny.Helpers.ToIntChecked(new BigInteger(22), "C# arrays may not be larger than the max 32-bit integer"),"C# array size must not be larger than max 32-bit int")];
      _nw46[(int)(0)] = 11;
      _nw46[(int)(1)] = 11;
      _nw46[(int)(2)] = 11;
      _nw46[(int)(3)] = 11;
      _nw46[(int)(4)] = 11;
      _nw46[(int)(5)] = 11;
      _nw46[(int)(6)] = 11;
      _nw46[(int)(7)] = 11;
      _nw46[(int)(8)] = 11;
      _nw46[(int)(9)] = 11;
      _nw46[(int)(10)] = 11;
      _nw46[(int)(11)] = 11;
      _nw46[(int)(12)] = 11;
      _nw46[(int)(13)] = 11;
      _nw46[(int)(14)] = 11;
      _nw46[(int)(15)] = 11;
      _nw46[(int)(16)] = 11;
      _nw46[(int)(17)] = 11;
      _nw46[(int)(18)] = 11;
      _nw46[(int)(19)] = 11;
      _nw46[(int)(20)] = 11;
      _nw46[(int)(21)] = 11;
      _21368_tv__ikm = _nw46;
      byte[] _21369_tv__salt;
      byte[] _nw47 = new byte[Dafny.Helpers.ToIntChecked(Dafny.Helpers.ToIntChecked(new BigInteger(13), "C# arrays may not be larger than the max 32-bit integer"),"C# array size must not be larger than max 32-bit int")];
      _nw47[(int)(0)] = 0;
      _nw47[(int)(1)] = 1;
      _nw47[(int)(2)] = 2;
      _nw47[(int)(3)] = 3;
      _nw47[(int)(4)] = 4;
      _nw47[(int)(5)] = 5;
      _nw47[(int)(6)] = 6;
      _nw47[(int)(7)] = 7;
      _nw47[(int)(8)] = 8;
      _nw47[(int)(9)] = 9;
      _nw47[(int)(10)] = 10;
      _nw47[(int)(11)] = 11;
      _nw47[(int)(12)] = 12;
      _21369_tv__salt = _nw47;
      byte[] _21370_tv__info;
      byte[] _nw48 = new byte[Dafny.Helpers.ToIntChecked(Dafny.Helpers.ToIntChecked(new BigInteger(10), "C# arrays may not be larger than the max 32-bit integer"),"C# array size must not be larger than max 32-bit int")];
      _nw48[(int)(0)] = 240;
      _nw48[(int)(1)] = 241;
      _nw48[(int)(2)] = 242;
      _nw48[(int)(3)] = 243;
      _nw48[(int)(4)] = 244;
      _nw48[(int)(5)] = 245;
      _nw48[(int)(6)] = 246;
      _nw48[(int)(7)] = 247;
      _nw48[(int)(8)] = 248;
      _nw48[(int)(9)] = 249;
      _21370_tv__info = _nw48;
      byte[] _21371_tv__okm__desired;
      byte[] _nw49 = new byte[Dafny.Helpers.ToIntChecked(Dafny.Helpers.ToIntChecked(new BigInteger(8129), "C# arrays may not be larger than the max 32-bit integer"),"C# array size must not be larger than max 32-bit int")];
      _nw49[(int)(0)] = 60;
      _nw49[(int)(1)] = 178;
      _nw49[(int)(2)] = 95;
      _nw49[(int)(3)] = 37;
      _nw49[(int)(4)] = 250;
      _nw49[(int)(5)] = 172;
      _nw49[(int)(6)] = 213;
      _nw49[(int)(7)] = 122;
      _nw49[(int)(8)] = 144;
      _nw49[(int)(9)] = 67;
      _nw49[(int)(10)] = 79;
      _nw49[(int)(11)] = 100;
      _nw49[(int)(12)] = 208;
      _nw49[(int)(13)] = 54;
      _nw49[(int)(14)] = 47;
      _nw49[(int)(15)] = 42;
      _nw49[(int)(16)] = 45;
      _nw49[(int)(17)] = 45;
      _nw49[(int)(18)] = 10;
      _nw49[(int)(19)] = 144;
      _nw49[(int)(20)] = 207;
      _nw49[(int)(21)] = 26;
      _nw49[(int)(22)] = 90;
      _nw49[(int)(23)] = 76;
      _nw49[(int)(24)] = 93;
      _nw49[(int)(25)] = 176;
      _nw49[(int)(26)] = 45;
      _nw49[(int)(27)] = 86;
      _nw49[(int)(28)] = 236;
      _nw49[(int)(29)] = 196;
      _nw49[(int)(30)] = 197;
      _nw49[(int)(31)] = 191;
      _nw49[(int)(32)] = 52;
      _nw49[(int)(33)] = 0;
      _nw49[(int)(34)] = 114;
      _nw49[(int)(35)] = 8;
      _nw49[(int)(36)] = 213;
      _nw49[(int)(37)] = 184;
      _nw49[(int)(38)] = 135;
      _nw49[(int)(39)] = 24;
      _nw49[(int)(40)] = 88;
      _nw49[(int)(41)] = 101;
      _nw49[(int)(42)] = 180;
      _nw49[(int)(43)] = 176;
      _nw49[(int)(44)] = 168;
      _nw49[(int)(45)] = 90;
      _nw49[(int)(46)] = 153;
      _nw49[(int)(47)] = 59;
      _nw49[(int)(48)] = 137;
      _nw49[(int)(49)] = 185;
      _nw49[(int)(50)] = 182;
      _nw49[(int)(51)] = 86;
      _nw49[(int)(52)] = 131;
      _nw49[(int)(53)] = 214;
      _nw49[(int)(54)] = 15;
      _nw49[(int)(55)] = 1;
      _nw49[(int)(56)] = 6;
      _nw49[(int)(57)] = 210;
      _nw49[(int)(58)] = 143;
      _nw49[(int)(59)] = 255;
      _nw49[(int)(60)] = 3;
      _nw49[(int)(61)] = 157;
      _nw49[(int)(62)] = 11;
      _nw49[(int)(63)] = 111;
      _nw49[(int)(64)] = 52;
      _nw49[(int)(65)] = 8;
      _nw49[(int)(66)] = 144;
      _nw49[(int)(67)] = 12;
      _nw49[(int)(68)] = 15;
      _nw49[(int)(69)] = 42;
      _nw49[(int)(70)] = 157;
      _nw49[(int)(71)] = 68;
      _nw49[(int)(72)] = 99;
      _nw49[(int)(73)] = 222;
      _nw49[(int)(74)] = 131;
      _nw49[(int)(75)] = 98;
      _nw49[(int)(76)] = 32;
      _nw49[(int)(77)] = 86;
      _nw49[(int)(78)] = 190;
      _nw49[(int)(79)] = 80;
      _nw49[(int)(80)] = 168;
      _nw49[(int)(81)] = 129;
      _nw49[(int)(82)] = 190;
      _nw49[(int)(83)] = 191;
      _nw49[(int)(84)] = 43;
      _nw49[(int)(85)] = 152;
      _nw49[(int)(86)] = 58;
      _nw49[(int)(87)] = 180;
      _nw49[(int)(88)] = 62;
      _nw49[(int)(89)] = 6;
      _nw49[(int)(90)] = 153;
      _nw49[(int)(91)] = 18;
      _nw49[(int)(92)] = 240;
      _nw49[(int)(93)] = 165;
      _nw49[(int)(94)] = 117;
      _nw49[(int)(95)] = 130;
      _nw49[(int)(96)] = 252;
      _nw49[(int)(97)] = 177;
      _nw49[(int)(98)] = 140;
      _nw49[(int)(99)] = 167;
      _nw49[(int)(100)] = 167;
      _nw49[(int)(101)] = 254;
      _nw49[(int)(102)] = 64;
      _nw49[(int)(103)] = 163;
      _nw49[(int)(104)] = 60;
      _nw49[(int)(105)] = 118;
      _nw49[(int)(106)] = 108;
      _nw49[(int)(107)] = 130;
      _nw49[(int)(108)] = 152;
      _nw49[(int)(109)] = 18;
      _nw49[(int)(110)] = 175;
      _nw49[(int)(111)] = 50;
      _nw49[(int)(112)] = 124;
      _nw49[(int)(113)] = 50;
      _nw49[(int)(114)] = 225;
      _nw49[(int)(115)] = 38;
      _nw49[(int)(116)] = 88;
      _nw49[(int)(117)] = 157;
      _nw49[(int)(118)] = 60;
      _nw49[(int)(119)] = 100;
      _nw49[(int)(120)] = 244;
      _nw49[(int)(121)] = 25;
      _nw49[(int)(122)] = 221;
      _nw49[(int)(123)] = 255;
      _nw49[(int)(124)] = 249;
      _nw49[(int)(125)] = 216;
      _nw49[(int)(126)] = 199;
      _nw49[(int)(127)] = 135;
      _nw49[(int)(128)] = 246;
      _nw49[(int)(129)] = 149;
      _nw49[(int)(130)] = 207;
      _nw49[(int)(131)] = 234;
      _nw49[(int)(132)] = 118;
      _nw49[(int)(133)] = 150;
      _nw49[(int)(134)] = 129;
      _nw49[(int)(135)] = 103;
      _nw49[(int)(136)] = 37;
      _nw49[(int)(137)] = 227;
      _nw49[(int)(138)] = 146;
      _nw49[(int)(139)] = 198;
      _nw49[(int)(140)] = 59;
      _nw49[(int)(141)] = 83;
      _nw49[(int)(142)] = 126;
      _nw49[(int)(143)] = 102;
      _nw49[(int)(144)] = 90;
      _nw49[(int)(145)] = 107;
      _nw49[(int)(146)] = 21;
      _nw49[(int)(147)] = 225;
      _nw49[(int)(148)] = 228;
      _nw49[(int)(149)] = 90;
      _nw49[(int)(150)] = 45;
      _nw49[(int)(151)] = 248;
      _nw49[(int)(152)] = 14;
      _nw49[(int)(153)] = 98;
      _nw49[(int)(154)] = 84;
      _nw49[(int)(155)] = 167;
      _nw49[(int)(156)] = 163;
      _nw49[(int)(157)] = 237;
      _nw49[(int)(158)] = 200;
      _nw49[(int)(159)] = 67;
      _nw49[(int)(160)] = 222;
      _nw49[(int)(161)] = 25;
      _nw49[(int)(162)] = 229;
      _nw49[(int)(163)] = 176;
      _nw49[(int)(164)] = 216;
      _nw49[(int)(165)] = 151;
      _nw49[(int)(166)] = 232;
      _nw49[(int)(167)] = 4;
      _nw49[(int)(168)] = 130;
      _nw49[(int)(169)] = 158;
      _nw49[(int)(170)] = 243;
      _nw49[(int)(171)] = 237;
      _nw49[(int)(172)] = 237;
      _nw49[(int)(173)] = 162;
      _nw49[(int)(174)] = 11;
      _nw49[(int)(175)] = 188;
      _nw49[(int)(176)] = 218;
      _nw49[(int)(177)] = 124;
      _nw49[(int)(178)] = 241;
      _nw49[(int)(179)] = 49;
      _nw49[(int)(180)] = 98;
      _nw49[(int)(181)] = 22;
      _nw49[(int)(182)] = 42;
      _nw49[(int)(183)] = 29;
      _nw49[(int)(184)] = 168;
      _nw49[(int)(185)] = 134;
      _nw49[(int)(186)] = 149;
      _nw49[(int)(187)] = 243;
      _nw49[(int)(188)] = 227;
      _nw49[(int)(189)] = 161;
      _nw49[(int)(190)] = 181;
      _nw49[(int)(191)] = 245;
      _nw49[(int)(192)] = 36;
      _nw49[(int)(193)] = 229;
      _nw49[(int)(194)] = 187;
      _nw49[(int)(195)] = 152;
      _nw49[(int)(196)] = 95;
      _nw49[(int)(197)] = 115;
      _nw49[(int)(198)] = 198;
      _nw49[(int)(199)] = 109;
      _nw49[(int)(200)] = 102;
      _nw49[(int)(201)] = 223;
      _nw49[(int)(202)] = 146;
      _nw49[(int)(203)] = 112;
      _nw49[(int)(204)] = 87;
      _nw49[(int)(205)] = 79;
      _nw49[(int)(206)] = 144;
      _nw49[(int)(207)] = 183;
      _nw49[(int)(208)] = 52;
      _nw49[(int)(209)] = 142;
      _nw49[(int)(210)] = 201;
      _nw49[(int)(211)] = 101;
      _nw49[(int)(212)] = 253;
      _nw49[(int)(213)] = 81;
      _nw49[(int)(214)] = 69;
      _nw49[(int)(215)] = 117;
      _nw49[(int)(216)] = 40;
      _nw49[(int)(217)] = 253;
      _nw49[(int)(218)] = 114;
      _nw49[(int)(219)] = 172;
      _nw49[(int)(220)] = 71;
      _nw49[(int)(221)] = 88;
      _nw49[(int)(222)] = 190;
      _nw49[(int)(223)] = 87;
      _nw49[(int)(224)] = 60;
      _nw49[(int)(225)] = 109;
      _nw49[(int)(226)] = 141;
      _nw49[(int)(227)] = 2;
      _nw49[(int)(228)] = 148;
      _nw49[(int)(229)] = 225;
      _nw49[(int)(230)] = 123;
      _nw49[(int)(231)] = 201;
      _nw49[(int)(232)] = 242;
      _nw49[(int)(233)] = 103;
      _nw49[(int)(234)] = 191;
      _nw49[(int)(235)] = 159;
      _nw49[(int)(236)] = 28;
      _nw49[(int)(237)] = 170;
      _nw49[(int)(238)] = 141;
      _nw49[(int)(239)] = 56;
      _nw49[(int)(240)] = 72;
      _nw49[(int)(241)] = 103;
      _nw49[(int)(242)] = 124;
      _nw49[(int)(243)] = 185;
      _nw49[(int)(244)] = 176;
      _nw49[(int)(245)] = 250;
      _nw49[(int)(246)] = 237;
      _nw49[(int)(247)] = 138;
      _nw49[(int)(248)] = 81;
      _nw49[(int)(249)] = 242;
      _nw49[(int)(250)] = 65;
      _nw49[(int)(251)] = 80;
      _nw49[(int)(252)] = 253;
      _nw49[(int)(253)] = 200;
      _nw49[(int)(254)] = 96;
      _nw49[(int)(255)] = 58;
      _nw49[(int)(256)] = 250;
      _nw49[(int)(257)] = 130;
      _nw49[(int)(258)] = 232;
      _nw49[(int)(259)] = 213;
      _nw49[(int)(260)] = 213;
      _nw49[(int)(261)] = 130;
      _nw49[(int)(262)] = 74;
      _nw49[(int)(263)] = 113;
      _nw49[(int)(264)] = 110;
      _nw49[(int)(265)] = 63;
      _nw49[(int)(266)] = 185;
      _nw49[(int)(267)] = 91;
      _nw49[(int)(268)] = 10;
      _nw49[(int)(269)] = 204;
      _nw49[(int)(270)] = 233;
      _nw49[(int)(271)] = 167;
      _nw49[(int)(272)] = 86;
      _nw49[(int)(273)] = 6;
      _nw49[(int)(274)] = 208;
      _nw49[(int)(275)] = 111;
      _nw49[(int)(276)] = 227;
      _nw49[(int)(277)] = 88;
      _nw49[(int)(278)] = 137;
      _nw49[(int)(279)] = 239;
      _nw49[(int)(280)] = 170;
      _nw49[(int)(281)] = 109;
      _nw49[(int)(282)] = 78;
      _nw49[(int)(283)] = 12;
      _nw49[(int)(284)] = 75;
      _nw49[(int)(285)] = 61;
      _nw49[(int)(286)] = 210;
      _nw49[(int)(287)] = 223;
      _nw49[(int)(288)] = 222;
      _nw49[(int)(289)] = 0;
      _nw49[(int)(290)] = 237;
      _nw49[(int)(291)] = 155;
      _nw49[(int)(292)] = 18;
      _nw49[(int)(293)] = 211;
      _nw49[(int)(294)] = 225;
      _nw49[(int)(295)] = 243;
      _nw49[(int)(296)] = 64;
      _nw49[(int)(297)] = 167;
      _nw49[(int)(298)] = 174;
      _nw49[(int)(299)] = 78;
      _nw49[(int)(300)] = 73;
      _nw49[(int)(301)] = 81;
      _nw49[(int)(302)] = 189;
      _nw49[(int)(303)] = 103;
      _nw49[(int)(304)] = 255;
      _nw49[(int)(305)] = 251;
      _nw49[(int)(306)] = 45;
      _nw49[(int)(307)] = 179;
      _nw49[(int)(308)] = 147;
      _nw49[(int)(309)] = 160;
      _nw49[(int)(310)] = 62;
      _nw49[(int)(311)] = 62;
      _nw49[(int)(312)] = 249;
      _nw49[(int)(313)] = 44;
      _nw49[(int)(314)] = 144;
      _nw49[(int)(315)] = 191;
      _nw49[(int)(316)] = 223;
      _nw49[(int)(317)] = 222;
      _nw49[(int)(318)] = 179;
      _nw49[(int)(319)] = 16;
      _nw49[(int)(320)] = 183;
      _nw49[(int)(321)] = 82;
      _nw49[(int)(322)] = 187;
      _nw49[(int)(323)] = 134;
      _nw49[(int)(324)] = 56;
      _nw49[(int)(325)] = 26;
      _nw49[(int)(326)] = 217;
      _nw49[(int)(327)] = 2;
      _nw49[(int)(328)] = 30;
      _nw49[(int)(329)] = 238;
      _nw49[(int)(330)] = 21;
      _nw49[(int)(331)] = 21;
      _nw49[(int)(332)] = 94;
      _nw49[(int)(333)] = 187;
      _nw49[(int)(334)] = 62;
      _nw49[(int)(335)] = 191;
      _nw49[(int)(336)] = 84;
      _nw49[(int)(337)] = 102;
      _nw49[(int)(338)] = 68;
      _nw49[(int)(339)] = 46;
      _nw49[(int)(340)] = 103;
      _nw49[(int)(341)] = 223;
      _nw49[(int)(342)] = 180;
      _nw49[(int)(343)] = 126;
      _nw49[(int)(344)] = 241;
      _nw49[(int)(345)] = 243;
      _nw49[(int)(346)] = 184;
      _nw49[(int)(347)] = 47;
      _nw49[(int)(348)] = 89;
      _nw49[(int)(349)] = 14;
      _nw49[(int)(350)] = 194;
      _nw49[(int)(351)] = 202;
      _nw49[(int)(352)] = 153;
      _nw49[(int)(353)] = 104;
      _nw49[(int)(354)] = 194;
      _nw49[(int)(355)] = 211;
      _nw49[(int)(356)] = 90;
      _nw49[(int)(357)] = 50;
      _nw49[(int)(358)] = 95;
      _nw49[(int)(359)] = 39;
      _nw49[(int)(360)] = 183;
      _nw49[(int)(361)] = 97;
      _nw49[(int)(362)] = 114;
      _nw49[(int)(363)] = 86;
      _nw49[(int)(364)] = 3;
      _nw49[(int)(365)] = 247;
      _nw49[(int)(366)] = 64;
      _nw49[(int)(367)] = 201;
      _nw49[(int)(368)] = 205;
      _nw49[(int)(369)] = 16;
      _nw49[(int)(370)] = 150;
      _nw49[(int)(371)] = 21;
      _nw49[(int)(372)] = 136;
      _nw49[(int)(373)] = 241;
      _nw49[(int)(374)] = 136;
      _nw49[(int)(375)] = 156;
      _nw49[(int)(376)] = 210;
      _nw49[(int)(377)] = 108;
      _nw49[(int)(378)] = 166;
      _nw49[(int)(379)] = 202;
      _nw49[(int)(380)] = 172;
      _nw49[(int)(381)] = 112;
      _nw49[(int)(382)] = 51;
      _nw49[(int)(383)] = 87;
      _nw49[(int)(384)] = 249;
      _nw49[(int)(385)] = 137;
      _nw49[(int)(386)] = 188;
      _nw49[(int)(387)] = 79;
      _nw49[(int)(388)] = 91;
      _nw49[(int)(389)] = 72;
      _nw49[(int)(390)] = 59;
      _nw49[(int)(391)] = 83;
      _nw49[(int)(392)] = 142;
      _nw49[(int)(393)] = 174;
      _nw49[(int)(394)] = 82;
      _nw49[(int)(395)] = 191;
      _nw49[(int)(396)] = 136;
      _nw49[(int)(397)] = 136;
      _nw49[(int)(398)] = 220;
      _nw49[(int)(399)] = 225;
      _nw49[(int)(400)] = 196;
      _nw49[(int)(401)] = 19;
      _nw49[(int)(402)] = 181;
      _nw49[(int)(403)] = 156;
      _nw49[(int)(404)] = 36;
      _nw49[(int)(405)] = 162;
      _nw49[(int)(406)] = 139;
      _nw49[(int)(407)] = 193;
      _nw49[(int)(408)] = 252;
      _nw49[(int)(409)] = 133;
      _nw49[(int)(410)] = 57;
      _nw49[(int)(411)] = 121;
      _nw49[(int)(412)] = 219;
      _nw49[(int)(413)] = 84;
      _nw49[(int)(414)] = 221;
      _nw49[(int)(415)] = 138;
      _nw49[(int)(416)] = 192;
      _nw49[(int)(417)] = 207;
      _nw49[(int)(418)] = 174;
      _nw49[(int)(419)] = 114;
      _nw49[(int)(420)] = 157;
      _nw49[(int)(421)] = 155;
      _nw49[(int)(422)] = 211;
      _nw49[(int)(423)] = 168;
      _nw49[(int)(424)] = 233;
      _nw49[(int)(425)] = 161;
      _nw49[(int)(426)] = 192;
      _nw49[(int)(427)] = 111;
      _nw49[(int)(428)] = 7;
      _nw49[(int)(429)] = 246;
      _nw49[(int)(430)] = 241;
      _nw49[(int)(431)] = 194;
      _nw49[(int)(432)] = 185;
      _nw49[(int)(433)] = 215;
      _nw49[(int)(434)] = 122;
      _nw49[(int)(435)] = 109;
      _nw49[(int)(436)] = 15;
      _nw49[(int)(437)] = 33;
      _nw49[(int)(438)] = 43;
      _nw49[(int)(439)] = 36;
      _nw49[(int)(440)] = 164;
      _nw49[(int)(441)] = 60;
      _nw49[(int)(442)] = 200;
      _nw49[(int)(443)] = 16;
      _nw49[(int)(444)] = 153;
      _nw49[(int)(445)] = 192;
      _nw49[(int)(446)] = 192;
      _nw49[(int)(447)] = 101;
      _nw49[(int)(448)] = 143;
      _nw49[(int)(449)] = 158;
      _nw49[(int)(450)] = 36;
      _nw49[(int)(451)] = 103;
      _nw49[(int)(452)] = 167;
      _nw49[(int)(453)] = 14;
      _nw49[(int)(454)] = 70;
      _nw49[(int)(455)] = 61;
      _nw49[(int)(456)] = 158;
      _nw49[(int)(457)] = 247;
      _nw49[(int)(458)] = 108;
      _nw49[(int)(459)] = 239;
      _nw49[(int)(460)] = 14;
      _nw49[(int)(461)] = 107;
      _nw49[(int)(462)] = 242;
      _nw49[(int)(463)] = 202;
      _nw49[(int)(464)] = 227;
      _nw49[(int)(465)] = 215;
      _nw49[(int)(466)] = 132;
      _nw49[(int)(467)] = 113;
      _nw49[(int)(468)] = 84;
      _nw49[(int)(469)] = 115;
      _nw49[(int)(470)] = 219;
      _nw49[(int)(471)] = 65;
      _nw49[(int)(472)] = 39;
      _nw49[(int)(473)] = 98;
      _nw49[(int)(474)] = 209;
      _nw49[(int)(475)] = 9;
      _nw49[(int)(476)] = 135;
      _nw49[(int)(477)] = 36;
      _nw49[(int)(478)] = 133;
      _nw49[(int)(479)] = 249;
      _nw49[(int)(480)] = 155;
      _nw49[(int)(481)] = 44;
      _nw49[(int)(482)] = 144;
      _nw49[(int)(483)] = 20;
      _nw49[(int)(484)] = 97;
      _nw49[(int)(485)] = 14;
      _nw49[(int)(486)] = 214;
      _nw49[(int)(487)] = 18;
      _nw49[(int)(488)] = 230;
      _nw49[(int)(489)] = 95;
      _nw49[(int)(490)] = 15;
      _nw49[(int)(491)] = 21;
      _nw49[(int)(492)] = 99;
      _nw49[(int)(493)] = 94;
      _nw49[(int)(494)] = 0;
      _nw49[(int)(495)] = 11;
      _nw49[(int)(496)] = 62;
      _nw49[(int)(497)] = 21;
      _nw49[(int)(498)] = 61;
      _nw49[(int)(499)] = 136;
      _nw49[(int)(500)] = 0;
      _nw49[(int)(501)] = 186;
      _nw49[(int)(502)] = 9;
      _nw49[(int)(503)] = 39;
      _nw49[(int)(504)] = 49;
      _nw49[(int)(505)] = 155;
      _nw49[(int)(506)] = 149;
      _nw49[(int)(507)] = 71;
      _nw49[(int)(508)] = 61;
      _nw49[(int)(509)] = 46;
      _nw49[(int)(510)] = 223;
      _nw49[(int)(511)] = 150;
      _nw49[(int)(512)] = 199;
      _nw49[(int)(513)] = 57;
      _nw49[(int)(514)] = 58;
      _nw49[(int)(515)] = 97;
      _nw49[(int)(516)] = 162;
      _nw49[(int)(517)] = 166;
      _nw49[(int)(518)] = 183;
      _nw49[(int)(519)] = 124;
      _nw49[(int)(520)] = 217;
      _nw49[(int)(521)] = 53;
      _nw49[(int)(522)] = 28;
      _nw49[(int)(523)] = 111;
      _nw49[(int)(524)] = 128;
      _nw49[(int)(525)] = 77;
      _nw49[(int)(526)] = 137;
      _nw49[(int)(527)] = 141;
      _nw49[(int)(528)] = 232;
      _nw49[(int)(529)] = 98;
      _nw49[(int)(530)] = 251;
      _nw49[(int)(531)] = 94;
      _nw49[(int)(532)] = 155;
      _nw49[(int)(533)] = 48;
      _nw49[(int)(534)] = 31;
      _nw49[(int)(535)] = 243;
      _nw49[(int)(536)] = 99;
      _nw49[(int)(537)] = 245;
      _nw49[(int)(538)] = 161;
      _nw49[(int)(539)] = 143;
      _nw49[(int)(540)] = 142;
      _nw49[(int)(541)] = 162;
      _nw49[(int)(542)] = 234;
      _nw49[(int)(543)] = 35;
      _nw49[(int)(544)] = 31;
      _nw49[(int)(545)] = 244;
      _nw49[(int)(546)] = 132;
      _nw49[(int)(547)] = 119;
      _nw49[(int)(548)] = 49;
      _nw49[(int)(549)] = 20;
      _nw49[(int)(550)] = 215;
      _nw49[(int)(551)] = 56;
      _nw49[(int)(552)] = 202;
      _nw49[(int)(553)] = 171;
      _nw49[(int)(554)] = 183;
      _nw49[(int)(555)] = 125;
      _nw49[(int)(556)] = 230;
      _nw49[(int)(557)] = 11;
      _nw49[(int)(558)] = 56;
      _nw49[(int)(559)] = 34;
      _nw49[(int)(560)] = 188;
      _nw49[(int)(561)] = 136;
      _nw49[(int)(562)] = 185;
      _nw49[(int)(563)] = 143;
      _nw49[(int)(564)] = 49;
      _nw49[(int)(565)] = 223;
      _nw49[(int)(566)] = 164;
      _nw49[(int)(567)] = 229;
      _nw49[(int)(568)] = 203;
      _nw49[(int)(569)] = 154;
      _nw49[(int)(570)] = 177;
      _nw49[(int)(571)] = 235;
      _nw49[(int)(572)] = 9;
      _nw49[(int)(573)] = 180;
      _nw49[(int)(574)] = 209;
      _nw49[(int)(575)] = 212;
      _nw49[(int)(576)] = 250;
      _nw49[(int)(577)] = 238;
      _nw49[(int)(578)] = 99;
      _nw49[(int)(579)] = 63;
      _nw49[(int)(580)] = 187;
      _nw49[(int)(581)] = 87;
      _nw49[(int)(582)] = 77;
      _nw49[(int)(583)] = 58;
      _nw49[(int)(584)] = 178;
      _nw49[(int)(585)] = 253;
      _nw49[(int)(586)] = 184;
      _nw49[(int)(587)] = 161;
      _nw49[(int)(588)] = 161;
      _nw49[(int)(589)] = 91;
      _nw49[(int)(590)] = 1;
      _nw49[(int)(591)] = 55;
      _nw49[(int)(592)] = 115;
      _nw49[(int)(593)] = 181;
      _nw49[(int)(594)] = 3;
      _nw49[(int)(595)] = 199;
      _nw49[(int)(596)] = 250;
      _nw49[(int)(597)] = 153;
      _nw49[(int)(598)] = 157;
      _nw49[(int)(599)] = 237;
      _nw49[(int)(600)] = 115;
      _nw49[(int)(601)] = 129;
      _nw49[(int)(602)] = 140;
      _nw49[(int)(603)] = 114;
      _nw49[(int)(604)] = 180;
      _nw49[(int)(605)] = 103;
      _nw49[(int)(606)] = 51;
      _nw49[(int)(607)] = 189;
      _nw49[(int)(608)] = 163;
      _nw49[(int)(609)] = 117;
      _nw49[(int)(610)] = 157;
      _nw49[(int)(611)] = 213;
      _nw49[(int)(612)] = 184;
      _nw49[(int)(613)] = 112;
      _nw49[(int)(614)] = 209;
      _nw49[(int)(615)] = 197;
      _nw49[(int)(616)] = 219;
      _nw49[(int)(617)] = 110;
      _nw49[(int)(618)] = 115;
      _nw49[(int)(619)] = 209;
      _nw49[(int)(620)] = 18;
      _nw49[(int)(621)] = 232;
      _nw49[(int)(622)] = 84;
      _nw49[(int)(623)] = 137;
      _nw49[(int)(624)] = 206;
      _nw49[(int)(625)] = 135;
      _nw49[(int)(626)] = 107;
      _nw49[(int)(627)] = 179;
      _nw49[(int)(628)] = 163;
      _nw49[(int)(629)] = 225;
      _nw49[(int)(630)] = 20;
      _nw49[(int)(631)] = 167;
      _nw49[(int)(632)] = 204;
      _nw49[(int)(633)] = 7;
      _nw49[(int)(634)] = 249;
      _nw49[(int)(635)] = 212;
      _nw49[(int)(636)] = 154;
      _nw49[(int)(637)] = 181;
      _nw49[(int)(638)] = 227;
      _nw49[(int)(639)] = 51;
      _nw49[(int)(640)] = 32;
      _nw49[(int)(641)] = 181;
      _nw49[(int)(642)] = 170;
      _nw49[(int)(643)] = 69;
      _nw49[(int)(644)] = 137;
      _nw49[(int)(645)] = 160;
      _nw49[(int)(646)] = 191;
      _nw49[(int)(647)] = 95;
      _nw49[(int)(648)] = 116;
      _nw49[(int)(649)] = 50;
      _nw49[(int)(650)] = 2;
      _nw49[(int)(651)] = 37;
      _nw49[(int)(652)] = 144;
      _nw49[(int)(653)] = 160;
      _nw49[(int)(654)] = 38;
      _nw49[(int)(655)] = 25;
      _nw49[(int)(656)] = 206;
      _nw49[(int)(657)] = 172;
      _nw49[(int)(658)] = 238;
      _nw49[(int)(659)] = 151;
      _nw49[(int)(660)] = 85;
      _nw49[(int)(661)] = 102;
      _nw49[(int)(662)] = 121;
      _nw49[(int)(663)] = 250;
      _nw49[(int)(664)] = 211;
      _nw49[(int)(665)] = 201;
      _nw49[(int)(666)] = 252;
      _nw49[(int)(667)] = 220;
      _nw49[(int)(668)] = 201;
      _nw49[(int)(669)] = 151;
      _nw49[(int)(670)] = 68;
      _nw49[(int)(671)] = 221;
      _nw49[(int)(672)] = 11;
      _nw49[(int)(673)] = 182;
      _nw49[(int)(674)] = 130;
      _nw49[(int)(675)] = 43;
      _nw49[(int)(676)] = 191;
      _nw49[(int)(677)] = 131;
      _nw49[(int)(678)] = 124;
      _nw49[(int)(679)] = 182;
      _nw49[(int)(680)] = 138;
      _nw49[(int)(681)] = 11;
      _nw49[(int)(682)] = 227;
      _nw49[(int)(683)] = 47;
      _nw49[(int)(684)] = 66;
      _nw49[(int)(685)] = 7;
      _nw49[(int)(686)] = 189;
      _nw49[(int)(687)] = 240;
      _nw49[(int)(688)] = 151;
      _nw49[(int)(689)] = 101;
      _nw49[(int)(690)] = 22;
      _nw49[(int)(691)] = 218;
      _nw49[(int)(692)] = 70;
      _nw49[(int)(693)] = 88;
      _nw49[(int)(694)] = 39;
      _nw49[(int)(695)] = 63;
      _nw49[(int)(696)] = 115;
      _nw49[(int)(697)] = 194;
      _nw49[(int)(698)] = 93;
      _nw49[(int)(699)] = 61;
      _nw49[(int)(700)] = 66;
      _nw49[(int)(701)] = 14;
      _nw49[(int)(702)] = 126;
      _nw49[(int)(703)] = 114;
      _nw49[(int)(704)] = 142;
      _nw49[(int)(705)] = 142;
      _nw49[(int)(706)] = 164;
      _nw49[(int)(707)] = 133;
      _nw49[(int)(708)] = 22;
      _nw49[(int)(709)] = 2;
      _nw49[(int)(710)] = 128;
      _nw49[(int)(711)] = 230;
      _nw49[(int)(712)] = 81;
      _nw49[(int)(713)] = 1;
      _nw49[(int)(714)] = 228;
      _nw49[(int)(715)] = 21;
      _nw49[(int)(716)] = 18;
      _nw49[(int)(717)] = 76;
      _nw49[(int)(718)] = 249;
      _nw49[(int)(719)] = 211;
      _nw49[(int)(720)] = 133;
      _nw49[(int)(721)] = 47;
      _nw49[(int)(722)] = 158;
      _nw49[(int)(723)] = 108;
      _nw49[(int)(724)] = 34;
      _nw49[(int)(725)] = 166;
      _nw49[(int)(726)] = 218;
      _nw49[(int)(727)] = 138;
      _nw49[(int)(728)] = 91;
      _nw49[(int)(729)] = 48;
      _nw49[(int)(730)] = 251;
      _nw49[(int)(731)] = 193;
      _nw49[(int)(732)] = 222;
      _nw49[(int)(733)] = 98;
      _nw49[(int)(734)] = 90;
      _nw49[(int)(735)] = 162;
      _nw49[(int)(736)] = 82;
      _nw49[(int)(737)] = 198;
      _nw49[(int)(738)] = 180;
      _nw49[(int)(739)] = 7;
      _nw49[(int)(740)] = 135;
      _nw49[(int)(741)] = 9;
      _nw49[(int)(742)] = 102;
      _nw49[(int)(743)] = 154;
      _nw49[(int)(744)] = 20;
      _nw49[(int)(745)] = 118;
      _nw49[(int)(746)] = 246;
      _nw49[(int)(747)] = 85;
      _nw49[(int)(748)] = 1;
      _nw49[(int)(749)] = 172;
      _nw49[(int)(750)] = 216;
      _nw49[(int)(751)] = 97;
      _nw49[(int)(752)] = 255;
      _nw49[(int)(753)] = 186;
      _nw49[(int)(754)] = 108;
      _nw49[(int)(755)] = 208;
      _nw49[(int)(756)] = 195;
      _nw49[(int)(757)] = 158;
      _nw49[(int)(758)] = 6;
      _nw49[(int)(759)] = 77;
      _nw49[(int)(760)] = 233;
      _nw49[(int)(761)] = 221;
      _nw49[(int)(762)] = 203;
      _nw49[(int)(763)] = 242;
      _nw49[(int)(764)] = 82;
      _nw49[(int)(765)] = 156;
      _nw49[(int)(766)] = 176;
      _nw49[(int)(767)] = 66;
      _nw49[(int)(768)] = 129;
      _nw49[(int)(769)] = 211;
      _nw49[(int)(770)] = 34;
      _nw49[(int)(771)] = 218;
      _nw49[(int)(772)] = 220;
      _nw49[(int)(773)] = 166;
      _nw49[(int)(774)] = 181;
      _nw49[(int)(775)] = 122;
      _nw49[(int)(776)] = 101;
      _nw49[(int)(777)] = 191;
      _nw49[(int)(778)] = 169;
      _nw49[(int)(779)] = 212;
      _nw49[(int)(780)] = 62;
      _nw49[(int)(781)] = 127;
      _nw49[(int)(782)] = 126;
      _nw49[(int)(783)] = 132;
      _nw49[(int)(784)] = 111;
      _nw49[(int)(785)] = 111;
      _nw49[(int)(786)] = 226;
      _nw49[(int)(787)] = 3;
      _nw49[(int)(788)] = 147;
      _nw49[(int)(789)] = 235;
      _nw49[(int)(790)] = 216;
      _nw49[(int)(791)] = 61;
      _nw49[(int)(792)] = 152;
      _nw49[(int)(793)] = 119;
      _nw49[(int)(794)] = 255;
      _nw49[(int)(795)] = 34;
      _nw49[(int)(796)] = 116;
      _nw49[(int)(797)] = 176;
      _nw49[(int)(798)] = 247;
      _nw49[(int)(799)] = 117;
      _nw49[(int)(800)] = 49;
      _nw49[(int)(801)] = 19;
      _nw49[(int)(802)] = 33;
      _nw49[(int)(803)] = 92;
      _nw49[(int)(804)] = 245;
      _nw49[(int)(805)] = 180;
      _nw49[(int)(806)] = 74;
      _nw49[(int)(807)] = 230;
      _nw49[(int)(808)] = 170;
      _nw49[(int)(809)] = 150;
      _nw49[(int)(810)] = 31;
      _nw49[(int)(811)] = 148;
      _nw49[(int)(812)] = 25;
      _nw49[(int)(813)] = 108;
      _nw49[(int)(814)] = 77;
      _nw49[(int)(815)] = 125;
      _nw49[(int)(816)] = 68;
      _nw49[(int)(817)] = 107;
      _nw49[(int)(818)] = 25;
      _nw49[(int)(819)] = 146;
      _nw49[(int)(820)] = 49;
      _nw49[(int)(821)] = 207;
      _nw49[(int)(822)] = 109;
      _nw49[(int)(823)] = 159;
      _nw49[(int)(824)] = 163;
      _nw49[(int)(825)] = 168;
      _nw49[(int)(826)] = 29;
      _nw49[(int)(827)] = 39;
      _nw49[(int)(828)] = 220;
      _nw49[(int)(829)] = 213;
      _nw49[(int)(830)] = 59;
      _nw49[(int)(831)] = 23;
      _nw49[(int)(832)] = 1;
      _nw49[(int)(833)] = 123;
      _nw49[(int)(834)] = 249;
      _nw49[(int)(835)] = 79;
      _nw49[(int)(836)] = 187;
      _nw49[(int)(837)] = 190;
      _nw49[(int)(838)] = 180;
      _nw49[(int)(839)] = 179;
      _nw49[(int)(840)] = 53;
      _nw49[(int)(841)] = 60;
      _nw49[(int)(842)] = 142;
      _nw49[(int)(843)] = 251;
      _nw49[(int)(844)] = 103;
      _nw49[(int)(845)] = 92;
      _nw49[(int)(846)] = 57;
      _nw49[(int)(847)] = 48;
      _nw49[(int)(848)] = 110;
      _nw49[(int)(849)] = 221;
      _nw49[(int)(850)] = 143;
      _nw49[(int)(851)] = 205;
      _nw49[(int)(852)] = 126;
      _nw49[(int)(853)] = 2;
      _nw49[(int)(854)] = 192;
      _nw49[(int)(855)] = 163;
      _nw49[(int)(856)] = 210;
      _nw49[(int)(857)] = 79;
      _nw49[(int)(858)] = 121;
      _nw49[(int)(859)] = 82;
      _nw49[(int)(860)] = 175;
      _nw49[(int)(861)] = 187;
      _nw49[(int)(862)] = 63;
      _nw49[(int)(863)] = 56;
      _nw49[(int)(864)] = 6;
      _nw49[(int)(865)] = 201;
      _nw49[(int)(866)] = 42;
      _nw49[(int)(867)] = 240;
      _nw49[(int)(868)] = 26;
      _nw49[(int)(869)] = 194;
      _nw49[(int)(870)] = 163;
      _nw49[(int)(871)] = 183;
      _nw49[(int)(872)] = 133;
      _nw49[(int)(873)] = 88;
      _nw49[(int)(874)] = 38;
      _nw49[(int)(875)] = 151;
      _nw49[(int)(876)] = 246;
      _nw49[(int)(877)] = 100;
      _nw49[(int)(878)] = 194;
      _nw49[(int)(879)] = 212;
      _nw49[(int)(880)] = 222;
      _nw49[(int)(881)] = 18;
      _nw49[(int)(882)] = 7;
      _nw49[(int)(883)] = 168;
      _nw49[(int)(884)] = 1;
      _nw49[(int)(885)] = 155;
      _nw49[(int)(886)] = 73;
      _nw49[(int)(887)] = 59;
      _nw49[(int)(888)] = 155;
      _nw49[(int)(889)] = 255;
      _nw49[(int)(890)] = 10;
      _nw49[(int)(891)] = 211;
      _nw49[(int)(892)] = 102;
      _nw49[(int)(893)] = 116;
      _nw49[(int)(894)] = 200;
      _nw49[(int)(895)] = 89;
      _nw49[(int)(896)] = 247;
      _nw49[(int)(897)] = 127;
      _nw49[(int)(898)] = 230;
      _nw49[(int)(899)] = 59;
      _nw49[(int)(900)] = 202;
      _nw49[(int)(901)] = 238;
      _nw49[(int)(902)] = 243;
      _nw49[(int)(903)] = 179;
      _nw49[(int)(904)] = 135;
      _nw49[(int)(905)] = 230;
      _nw49[(int)(906)] = 245;
      _nw49[(int)(907)] = 66;
      _nw49[(int)(908)] = 8;
      _nw49[(int)(909)] = 136;
      _nw49[(int)(910)] = 200;
      _nw49[(int)(911)] = 53;
      _nw49[(int)(912)] = 3;
      _nw49[(int)(913)] = 249;
      _nw49[(int)(914)] = 103;
      _nw49[(int)(915)] = 7;
      _nw49[(int)(916)] = 212;
      _nw49[(int)(917)] = 65;
      _nw49[(int)(918)] = 95;
      _nw49[(int)(919)] = 171;
      _nw49[(int)(920)] = 118;
      _nw49[(int)(921)] = 51;
      _nw49[(int)(922)] = 81;
      _nw49[(int)(923)] = 90;
      _nw49[(int)(924)] = 231;
      _nw49[(int)(925)] = 91;
      _nw49[(int)(926)] = 189;
      _nw49[(int)(927)] = 60;
      _nw49[(int)(928)] = 55;
      _nw49[(int)(929)] = 113;
      _nw49[(int)(930)] = 119;
      _nw49[(int)(931)] = 6;
      _nw49[(int)(932)] = 159;
      _nw49[(int)(933)] = 59;
      _nw49[(int)(934)] = 142;
      _nw49[(int)(935)] = 108;
      _nw49[(int)(936)] = 227;
      _nw49[(int)(937)] = 192;
      _nw49[(int)(938)] = 208;
      _nw49[(int)(939)] = 122;
      _nw49[(int)(940)] = 251;
      _nw49[(int)(941)] = 73;
      _nw49[(int)(942)] = 199;
      _nw49[(int)(943)] = 107;
      _nw49[(int)(944)] = 194;
      _nw49[(int)(945)] = 202;
      _nw49[(int)(946)] = 17;
      _nw49[(int)(947)] = 94;
      _nw49[(int)(948)] = 84;
      _nw49[(int)(949)] = 155;
      _nw49[(int)(950)] = 20;
      _nw49[(int)(951)] = 13;
      _nw49[(int)(952)] = 223;
      _nw49[(int)(953)] = 43;
      _nw49[(int)(954)] = 163;
      _nw49[(int)(955)] = 75;
      _nw49[(int)(956)] = 193;
      _nw49[(int)(957)] = 247;
      _nw49[(int)(958)] = 4;
      _nw49[(int)(959)] = 109;
      _nw49[(int)(960)] = 171;
      _nw49[(int)(961)] = 46;
      _nw49[(int)(962)] = 170;
      _nw49[(int)(963)] = 86;
      _nw49[(int)(964)] = 1;
      _nw49[(int)(965)] = 166;
      _nw49[(int)(966)] = 211;
      _nw49[(int)(967)] = 203;
      _nw49[(int)(968)] = 22;
      _nw49[(int)(969)] = 158;
      _nw49[(int)(970)] = 33;
      _nw49[(int)(971)] = 170;
      _nw49[(int)(972)] = 161;
      _nw49[(int)(973)] = 171;
      _nw49[(int)(974)] = 69;
      _nw49[(int)(975)] = 149;
      _nw49[(int)(976)] = 149;
      _nw49[(int)(977)] = 145;
      _nw49[(int)(978)] = 154;
      _nw49[(int)(979)] = 9;
      _nw49[(int)(980)] = 38;
      _nw49[(int)(981)] = 31;
      _nw49[(int)(982)] = 132;
      _nw49[(int)(983)] = 171;
      _nw49[(int)(984)] = 211;
      _nw49[(int)(985)] = 170;
      _nw49[(int)(986)] = 105;
      _nw49[(int)(987)] = 153;
      _nw49[(int)(988)] = 209;
      _nw49[(int)(989)] = 96;
      _nw49[(int)(990)] = 135;
      _nw49[(int)(991)] = 243;
      _nw49[(int)(992)] = 54;
      _nw49[(int)(993)] = 18;
      _nw49[(int)(994)] = 145;
      _nw49[(int)(995)] = 127;
      _nw49[(int)(996)] = 73;
      _nw49[(int)(997)] = 102;
      _nw49[(int)(998)] = 230;
      _nw49[(int)(999)] = 74;
      _nw49[(int)(1000)] = 53;
      _nw49[(int)(1001)] = 187;
      _nw49[(int)(1002)] = 227;
      _nw49[(int)(1003)] = 65;
      _nw49[(int)(1004)] = 149;
      _nw49[(int)(1005)] = 81;
      _nw49[(int)(1006)] = 31;
      _nw49[(int)(1007)] = 110;
      _nw49[(int)(1008)] = 43;
      _nw49[(int)(1009)] = 74;
      _nw49[(int)(1010)] = 73;
      _nw49[(int)(1011)] = 97;
      _nw49[(int)(1012)] = 22;
      _nw49[(int)(1013)] = 231;
      _nw49[(int)(1014)] = 119;
      _nw49[(int)(1015)] = 212;
      _nw49[(int)(1016)] = 154;
      _nw49[(int)(1017)] = 64;
      _nw49[(int)(1018)] = 247;
      _nw49[(int)(1019)] = 221;
      _nw49[(int)(1020)] = 255;
      _nw49[(int)(1021)] = 219;
      _nw49[(int)(1022)] = 208;
      _nw49[(int)(1023)] = 65;
      _nw49[(int)(1024)] = 79;
      _nw49[(int)(1025)] = 188;
      _nw49[(int)(1026)] = 120;
      _nw49[(int)(1027)] = 186;
      _nw49[(int)(1028)] = 8;
      _nw49[(int)(1029)] = 43;
      _nw49[(int)(1030)] = 82;
      _nw49[(int)(1031)] = 232;
      _nw49[(int)(1032)] = 103;
      _nw49[(int)(1033)] = 117;
      _nw49[(int)(1034)] = 11;
      _nw49[(int)(1035)] = 163;
      _nw49[(int)(1036)] = 137;
      _nw49[(int)(1037)] = 174;
      _nw49[(int)(1038)] = 172;
      _nw49[(int)(1039)] = 124;
      _nw49[(int)(1040)] = 188;
      _nw49[(int)(1041)] = 38;
      _nw49[(int)(1042)] = 104;
      _nw49[(int)(1043)] = 166;
      _nw49[(int)(1044)] = 171;
      _nw49[(int)(1045)] = 146;
      _nw49[(int)(1046)] = 129;
      _nw49[(int)(1047)] = 107;
      _nw49[(int)(1048)] = 212;
      _nw49[(int)(1049)] = 237;
      _nw49[(int)(1050)] = 11;
      _nw49[(int)(1051)] = 113;
      _nw49[(int)(1052)] = 190;
      _nw49[(int)(1053)] = 12;
      _nw49[(int)(1054)] = 66;
      _nw49[(int)(1055)] = 223;
      _nw49[(int)(1056)] = 234;
      _nw49[(int)(1057)] = 97;
      _nw49[(int)(1058)] = 98;
      _nw49[(int)(1059)] = 17;
      _nw49[(int)(1060)] = 32;
      _nw49[(int)(1061)] = 106;
      _nw49[(int)(1062)] = 6;
      _nw49[(int)(1063)] = 228;
      _nw49[(int)(1064)] = 86;
      _nw49[(int)(1065)] = 25;
      _nw49[(int)(1066)] = 164;
      _nw49[(int)(1067)] = 82;
      _nw49[(int)(1068)] = 82;
      _nw49[(int)(1069)] = 67;
      _nw49[(int)(1070)] = 151;
      _nw49[(int)(1071)] = 149;
      _nw49[(int)(1072)] = 65;
      _nw49[(int)(1073)] = 172;
      _nw49[(int)(1074)] = 26;
      _nw49[(int)(1075)] = 144;
      _nw49[(int)(1076)] = 69;
      _nw49[(int)(1077)] = 142;
      _nw49[(int)(1078)] = 214;
      _nw49[(int)(1079)] = 240;
      _nw49[(int)(1080)] = 84;
      _nw49[(int)(1081)] = 144;
      _nw49[(int)(1082)] = 163;
      _nw49[(int)(1083)] = 171;
      _nw49[(int)(1084)] = 234;
      _nw49[(int)(1085)] = 192;
      _nw49[(int)(1086)] = 90;
      _nw49[(int)(1087)] = 248;
      _nw49[(int)(1088)] = 20;
      _nw49[(int)(1089)] = 196;
      _nw49[(int)(1090)] = 139;
      _nw49[(int)(1091)] = 108;
      _nw49[(int)(1092)] = 68;
      _nw49[(int)(1093)] = 246;
      _nw49[(int)(1094)] = 126;
      _nw49[(int)(1095)] = 186;
      _nw49[(int)(1096)] = 88;
      _nw49[(int)(1097)] = 55;
      _nw49[(int)(1098)] = 138;
      _nw49[(int)(1099)] = 248;
      _nw49[(int)(1100)] = 10;
      _nw49[(int)(1101)] = 38;
      _nw49[(int)(1102)] = 73;
      _nw49[(int)(1103)] = 84;
      _nw49[(int)(1104)] = 230;
      _nw49[(int)(1105)] = 144;
      _nw49[(int)(1106)] = 169;
      _nw49[(int)(1107)] = 243;
      _nw49[(int)(1108)] = 106;
      _nw49[(int)(1109)] = 220;
      _nw49[(int)(1110)] = 201;
      _nw49[(int)(1111)] = 67;
      _nw49[(int)(1112)] = 147;
      _nw49[(int)(1113)] = 156;
      _nw49[(int)(1114)] = 252;
      _nw49[(int)(1115)] = 140;
      _nw49[(int)(1116)] = 111;
      _nw49[(int)(1117)] = 127;
      _nw49[(int)(1118)] = 185;
      _nw49[(int)(1119)] = 107;
      _nw49[(int)(1120)] = 9;
      _nw49[(int)(1121)] = 30;
      _nw49[(int)(1122)] = 254;
      _nw49[(int)(1123)] = 186;
      _nw49[(int)(1124)] = 199;
      _nw49[(int)(1125)] = 233;
      _nw49[(int)(1126)] = 202;
      _nw49[(int)(1127)] = 65;
      _nw49[(int)(1128)] = 19;
      _nw49[(int)(1129)] = 187;
      _nw49[(int)(1130)] = 103;
      _nw49[(int)(1131)] = 157;
      _nw49[(int)(1132)] = 118;
      _nw49[(int)(1133)] = 224;
      _nw49[(int)(1134)] = 147;
      _nw49[(int)(1135)] = 206;
      _nw49[(int)(1136)] = 221;
      _nw49[(int)(1137)] = 216;
      _nw49[(int)(1138)] = 129;
      _nw49[(int)(1139)] = 102;
      _nw49[(int)(1140)] = 199;
      _nw49[(int)(1141)] = 50;
      _nw49[(int)(1142)] = 156;
      _nw49[(int)(1143)] = 28;
      _nw49[(int)(1144)] = 196;
      _nw49[(int)(1145)] = 49;
      _nw49[(int)(1146)] = 89;
      _nw49[(int)(1147)] = 129;
      _nw49[(int)(1148)] = 160;
      _nw49[(int)(1149)] = 199;
      _nw49[(int)(1150)] = 97;
      _nw49[(int)(1151)] = 30;
      _nw49[(int)(1152)] = 93;
      _nw49[(int)(1153)] = 100;
      _nw49[(int)(1154)] = 230;
      _nw49[(int)(1155)] = 20;
      _nw49[(int)(1156)] = 129;
      _nw49[(int)(1157)] = 215;
      _nw49[(int)(1158)] = 66;
      _nw49[(int)(1159)] = 136;
      _nw49[(int)(1160)] = 58;
      _nw49[(int)(1161)] = 192;
      _nw49[(int)(1162)] = 17;
      _nw49[(int)(1163)] = 199;
      _nw49[(int)(1164)] = 168;
      _nw49[(int)(1165)] = 169;
      _nw49[(int)(1166)] = 154;
      _nw49[(int)(1167)] = 217;
      _nw49[(int)(1168)] = 63;
      _nw49[(int)(1169)] = 33;
      _nw49[(int)(1170)] = 65;
      _nw49[(int)(1171)] = 220;
      _nw49[(int)(1172)] = 43;
      _nw49[(int)(1173)] = 69;
      _nw49[(int)(1174)] = 10;
      _nw49[(int)(1175)] = 246;
      _nw49[(int)(1176)] = 162;
      _nw49[(int)(1177)] = 183;
      _nw49[(int)(1178)] = 182;
      _nw49[(int)(1179)] = 5;
      _nw49[(int)(1180)] = 82;
      _nw49[(int)(1181)] = 97;
      _nw49[(int)(1182)] = 123;
      _nw49[(int)(1183)] = 134;
      _nw49[(int)(1184)] = 208;
      _nw49[(int)(1185)] = 8;
      _nw49[(int)(1186)] = 115;
      _nw49[(int)(1187)] = 104;
      _nw49[(int)(1188)] = 109;
      _nw49[(int)(1189)] = 24;
      _nw49[(int)(1190)] = 217;
      _nw49[(int)(1191)] = 242;
      _nw49[(int)(1192)] = 129;
      _nw49[(int)(1193)] = 125;
      _nw49[(int)(1194)] = 18;
      _nw49[(int)(1195)] = 8;
      _nw49[(int)(1196)] = 116;
      _nw49[(int)(1197)] = 77;
      _nw49[(int)(1198)] = 45;
      _nw49[(int)(1199)] = 154;
      _nw49[(int)(1200)] = 245;
      _nw49[(int)(1201)] = 201;
      _nw49[(int)(1202)] = 77;
      _nw49[(int)(1203)] = 71;
      _nw49[(int)(1204)] = 181;
      _nw49[(int)(1205)] = 72;
      _nw49[(int)(1206)] = 79;
      _nw49[(int)(1207)] = 20;
      _nw49[(int)(1208)] = 77;
      _nw49[(int)(1209)] = 178;
      _nw49[(int)(1210)] = 134;
      _nw49[(int)(1211)] = 186;
      _nw49[(int)(1212)] = 159;
      _nw49[(int)(1213)] = 167;
      _nw49[(int)(1214)] = 237;
      _nw49[(int)(1215)] = 32;
      _nw49[(int)(1216)] = 50;
      _nw49[(int)(1217)] = 124;
      _nw49[(int)(1218)] = 205;
      _nw49[(int)(1219)] = 236;
      _nw49[(int)(1220)] = 112;
      _nw49[(int)(1221)] = 92;
      _nw49[(int)(1222)] = 244;
      _nw49[(int)(1223)] = 164;
      _nw49[(int)(1224)] = 239;
      _nw49[(int)(1225)] = 31;
      _nw49[(int)(1226)] = 109;
      _nw49[(int)(1227)] = 33;
      _nw49[(int)(1228)] = 223;
      _nw49[(int)(1229)] = 93;
      _nw49[(int)(1230)] = 22;
      _nw49[(int)(1231)] = 222;
      _nw49[(int)(1232)] = 166;
      _nw49[(int)(1233)] = 62;
      _nw49[(int)(1234)] = 30;
      _nw49[(int)(1235)] = 214;
      _nw49[(int)(1236)] = 132;
      _nw49[(int)(1237)] = 206;
      _nw49[(int)(1238)] = 151;
      _nw49[(int)(1239)] = 53;
      _nw49[(int)(1240)] = 178;
      _nw49[(int)(1241)] = 250;
      _nw49[(int)(1242)] = 208;
      _nw49[(int)(1243)] = 52;
      _nw49[(int)(1244)] = 66;
      _nw49[(int)(1245)] = 153;
      _nw49[(int)(1246)] = 248;
      _nw49[(int)(1247)] = 63;
      _nw49[(int)(1248)] = 2;
      _nw49[(int)(1249)] = 12;
      _nw49[(int)(1250)] = 178;
      _nw49[(int)(1251)] = 117;
      _nw49[(int)(1252)] = 241;
      _nw49[(int)(1253)] = 24;
      _nw49[(int)(1254)] = 113;
      _nw49[(int)(1255)] = 47;
      _nw49[(int)(1256)] = 34;
      _nw49[(int)(1257)] = 235;
      _nw49[(int)(1258)] = 149;
      _nw49[(int)(1259)] = 40;
      _nw49[(int)(1260)] = 66;
      _nw49[(int)(1261)] = 229;
      _nw49[(int)(1262)] = 127;
      _nw49[(int)(1263)] = 204;
      _nw49[(int)(1264)] = 29;
      _nw49[(int)(1265)] = 163;
      _nw49[(int)(1266)] = 90;
      _nw49[(int)(1267)] = 35;
      _nw49[(int)(1268)] = 151;
      _nw49[(int)(1269)] = 244;
      _nw49[(int)(1270)] = 28;
      _nw49[(int)(1271)] = 249;
      _nw49[(int)(1272)] = 70;
      _nw49[(int)(1273)] = 91;
      _nw49[(int)(1274)] = 74;
      _nw49[(int)(1275)] = 205;
      _nw49[(int)(1276)] = 46;
      _nw49[(int)(1277)] = 235;
      _nw49[(int)(1278)] = 100;
      _nw49[(int)(1279)] = 194;
      _nw49[(int)(1280)] = 188;
      _nw49[(int)(1281)] = 97;
      _nw49[(int)(1282)] = 51;
      _nw49[(int)(1283)] = 164;
      _nw49[(int)(1284)] = 241;
      _nw49[(int)(1285)] = 35;
      _nw49[(int)(1286)] = 176;
      _nw49[(int)(1287)] = 8;
      _nw49[(int)(1288)] = 91;
      _nw49[(int)(1289)] = 67;
      _nw49[(int)(1290)] = 204;
      _nw49[(int)(1291)] = 51;
      _nw49[(int)(1292)] = 133;
      _nw49[(int)(1293)] = 157;
      _nw49[(int)(1294)] = 28;
      _nw49[(int)(1295)] = 237;
      _nw49[(int)(1296)] = 234;
      _nw49[(int)(1297)] = 135;
      _nw49[(int)(1298)] = 140;
      _nw49[(int)(1299)] = 68;
      _nw49[(int)(1300)] = 248;
      _nw49[(int)(1301)] = 195;
      _nw49[(int)(1302)] = 168;
      _nw49[(int)(1303)] = 48;
      _nw49[(int)(1304)] = 152;
      _nw49[(int)(1305)] = 86;
      _nw49[(int)(1306)] = 41;
      _nw49[(int)(1307)] = 176;
      _nw49[(int)(1308)] = 53;
      _nw49[(int)(1309)] = 39;
      _nw49[(int)(1310)] = 199;
      _nw49[(int)(1311)] = 99;
      _nw49[(int)(1312)] = 122;
      _nw49[(int)(1313)] = 86;
      _nw49[(int)(1314)] = 70;
      _nw49[(int)(1315)] = 225;
      _nw49[(int)(1316)] = 87;
      _nw49[(int)(1317)] = 225;
      _nw49[(int)(1318)] = 139;
      _nw49[(int)(1319)] = 57;
      _nw49[(int)(1320)] = 93;
      _nw49[(int)(1321)] = 93;
      _nw49[(int)(1322)] = 161;
      _nw49[(int)(1323)] = 228;
      _nw49[(int)(1324)] = 186;
      _nw49[(int)(1325)] = 192;
      _nw49[(int)(1326)] = 84;
      _nw49[(int)(1327)] = 229;
      _nw49[(int)(1328)] = 185;
      _nw49[(int)(1329)] = 3;
      _nw49[(int)(1330)] = 73;
      _nw49[(int)(1331)] = 196;
      _nw49[(int)(1332)] = 133;
      _nw49[(int)(1333)] = 137;
      _nw49[(int)(1334)] = 215;
      _nw49[(int)(1335)] = 192;
      _nw49[(int)(1336)] = 41;
      _nw49[(int)(1337)] = 30;
      _nw49[(int)(1338)] = 84;
      _nw49[(int)(1339)] = 160;
      _nw49[(int)(1340)] = 75;
      _nw49[(int)(1341)] = 206;
      _nw49[(int)(1342)] = 4;
      _nw49[(int)(1343)] = 245;
      _nw49[(int)(1344)] = 53;
      _nw49[(int)(1345)] = 52;
      _nw49[(int)(1346)] = 32;
      _nw49[(int)(1347)] = 182;
      _nw49[(int)(1348)] = 141;
      _nw49[(int)(1349)] = 66;
      _nw49[(int)(1350)] = 50;
      _nw49[(int)(1351)] = 238;
      _nw49[(int)(1352)] = 90;
      _nw49[(int)(1353)] = 81;
      _nw49[(int)(1354)] = 50;
      _nw49[(int)(1355)] = 55;
      _nw49[(int)(1356)] = 132;
      _nw49[(int)(1357)] = 3;
      _nw49[(int)(1358)] = 238;
      _nw49[(int)(1359)] = 68;
      _nw49[(int)(1360)] = 207;
      _nw49[(int)(1361)] = 144;
      _nw49[(int)(1362)] = 15;
      _nw49[(int)(1363)] = 12;
      _nw49[(int)(1364)] = 127;
      _nw49[(int)(1365)] = 195;
      _nw49[(int)(1366)] = 85;
      _nw49[(int)(1367)] = 18;
      _nw49[(int)(1368)] = 67;
      _nw49[(int)(1369)] = 55;
      _nw49[(int)(1370)] = 4;
      _nw49[(int)(1371)] = 249;
      _nw49[(int)(1372)] = 232;
      _nw49[(int)(1373)] = 170;
      _nw49[(int)(1374)] = 189;
      _nw49[(int)(1375)] = 205;
      _nw49[(int)(1376)] = 197;
      _nw49[(int)(1377)] = 169;
      _nw49[(int)(1378)] = 128;
      _nw49[(int)(1379)] = 156;
      _nw49[(int)(1380)] = 103;
      _nw49[(int)(1381)] = 221;
      _nw49[(int)(1382)] = 172;
      _nw49[(int)(1383)] = 213;
      _nw49[(int)(1384)] = 46;
      _nw49[(int)(1385)] = 143;
      _nw49[(int)(1386)] = 218;
      _nw49[(int)(1387)] = 107;
      _nw49[(int)(1388)] = 253;
      _nw49[(int)(1389)] = 77;
      _nw49[(int)(1390)] = 76;
      _nw49[(int)(1391)] = 190;
      _nw49[(int)(1392)] = 63;
      _nw49[(int)(1393)] = 151;
      _nw49[(int)(1394)] = 44;
      _nw49[(int)(1395)] = 57;
      _nw49[(int)(1396)] = 37;
      _nw49[(int)(1397)] = 225;
      _nw49[(int)(1398)] = 135;
      _nw49[(int)(1399)] = 125;
      _nw49[(int)(1400)] = 21;
      _nw49[(int)(1401)] = 217;
      _nw49[(int)(1402)] = 0;
      _nw49[(int)(1403)] = 62;
      _nw49[(int)(1404)] = 83;
      _nw49[(int)(1405)] = 50;
      _nw49[(int)(1406)] = 51;
      _nw49[(int)(1407)] = 2;
      _nw49[(int)(1408)] = 176;
      _nw49[(int)(1409)] = 160;
      _nw49[(int)(1410)] = 161;
      _nw49[(int)(1411)] = 82;
      _nw49[(int)(1412)] = 112;
      _nw49[(int)(1413)] = 198;
      _nw49[(int)(1414)] = 128;
      _nw49[(int)(1415)] = 235;
      _nw49[(int)(1416)] = 40;
      _nw49[(int)(1417)] = 101;
      _nw49[(int)(1418)] = 151;
      _nw49[(int)(1419)] = 189;
      _nw49[(int)(1420)] = 86;
      _nw49[(int)(1421)] = 46;
      _nw49[(int)(1422)] = 206;
      _nw49[(int)(1423)] = 202;
      _nw49[(int)(1424)] = 90;
      _nw49[(int)(1425)] = 229;
      _nw49[(int)(1426)] = 188;
      _nw49[(int)(1427)] = 108;
      _nw49[(int)(1428)] = 235;
      _nw49[(int)(1429)] = 245;
      _nw49[(int)(1430)] = 52;
      _nw49[(int)(1431)] = 22;
      _nw49[(int)(1432)] = 48;
      _nw49[(int)(1433)] = 189;
      _nw49[(int)(1434)] = 88;
      _nw49[(int)(1435)] = 192;
      _nw49[(int)(1436)] = 95;
      _nw49[(int)(1437)] = 153;
      _nw49[(int)(1438)] = 109;
      _nw49[(int)(1439)] = 92;
      _nw49[(int)(1440)] = 74;
      _nw49[(int)(1441)] = 146;
      _nw49[(int)(1442)] = 135;
      _nw49[(int)(1443)] = 44;
      _nw49[(int)(1444)] = 130;
      _nw49[(int)(1445)] = 221;
      _nw49[(int)(1446)] = 91;
      _nw49[(int)(1447)] = 17;
      _nw49[(int)(1448)] = 46;
      _nw49[(int)(1449)] = 49;
      _nw49[(int)(1450)] = 24;
      _nw49[(int)(1451)] = 97;
      _nw49[(int)(1452)] = 221;
      _nw49[(int)(1453)] = 22;
      _nw49[(int)(1454)] = 174;
      _nw49[(int)(1455)] = 32;
      _nw49[(int)(1456)] = 12;
      _nw49[(int)(1457)] = 189;
      _nw49[(int)(1458)] = 52;
      _nw49[(int)(1459)] = 252;
      _nw49[(int)(1460)] = 204;
      _nw49[(int)(1461)] = 133;
      _nw49[(int)(1462)] = 19;
      _nw49[(int)(1463)] = 122;
      _nw49[(int)(1464)] = 242;
      _nw49[(int)(1465)] = 26;
      _nw49[(int)(1466)] = 106;
      _nw49[(int)(1467)] = 233;
      _nw49[(int)(1468)] = 218;
      _nw49[(int)(1469)] = 176;
      _nw49[(int)(1470)] = 88;
      _nw49[(int)(1471)] = 71;
      _nw49[(int)(1472)] = 169;
      _nw49[(int)(1473)] = 76;
      _nw49[(int)(1474)] = 77;
      _nw49[(int)(1475)] = 71;
      _nw49[(int)(1476)] = 32;
      _nw49[(int)(1477)] = 235;
      _nw49[(int)(1478)] = 0;
      _nw49[(int)(1479)] = 204;
      _nw49[(int)(1480)] = 37;
      _nw49[(int)(1481)] = 71;
      _nw49[(int)(1482)] = 18;
      _nw49[(int)(1483)] = 175;
      _nw49[(int)(1484)] = 99;
      _nw49[(int)(1485)] = 202;
      _nw49[(int)(1486)] = 141;
      _nw49[(int)(1487)] = 95;
      _nw49[(int)(1488)] = 73;
      _nw49[(int)(1489)] = 81;
      _nw49[(int)(1490)] = 102;
      _nw49[(int)(1491)] = 224;
      _nw49[(int)(1492)] = 83;
      _nw49[(int)(1493)] = 97;
      _nw49[(int)(1494)] = 121;
      _nw49[(int)(1495)] = 41;
      _nw49[(int)(1496)] = 56;
      _nw49[(int)(1497)] = 4;
      _nw49[(int)(1498)] = 168;
      _nw49[(int)(1499)] = 25;
      _nw49[(int)(1500)] = 161;
      _nw49[(int)(1501)] = 181;
      _nw49[(int)(1502)] = 109;
      _nw49[(int)(1503)] = 109;
      _nw49[(int)(1504)] = 32;
      _nw49[(int)(1505)] = 119;
      _nw49[(int)(1506)] = 50;
      _nw49[(int)(1507)] = 239;
      _nw49[(int)(1508)] = 157;
      _nw49[(int)(1509)] = 76;
      _nw49[(int)(1510)] = 87;
      _nw49[(int)(1511)] = 131;
      _nw49[(int)(1512)] = 49;
      _nw49[(int)(1513)] = 194;
      _nw49[(int)(1514)] = 143;
      _nw49[(int)(1515)] = 60;
      _nw49[(int)(1516)] = 252;
      _nw49[(int)(1517)] = 204;
      _nw49[(int)(1518)] = 151;
      _nw49[(int)(1519)] = 84;
      _nw49[(int)(1520)] = 138;
      _nw49[(int)(1521)] = 227;
      _nw49[(int)(1522)] = 161;
      _nw49[(int)(1523)] = 25;
      _nw49[(int)(1524)] = 224;
      _nw49[(int)(1525)] = 185;
      _nw49[(int)(1526)] = 11;
      _nw49[(int)(1527)] = 244;
      _nw49[(int)(1528)] = 243;
      _nw49[(int)(1529)] = 71;
      _nw49[(int)(1530)] = 100;
      _nw49[(int)(1531)] = 58;
      _nw49[(int)(1532)] = 187;
      _nw49[(int)(1533)] = 100;
      _nw49[(int)(1534)] = 10;
      _nw49[(int)(1535)] = 114;
      _nw49[(int)(1536)] = 9;
      _nw49[(int)(1537)] = 150;
      _nw49[(int)(1538)] = 49;
      _nw49[(int)(1539)] = 55;
      _nw49[(int)(1540)] = 88;
      _nw49[(int)(1541)] = 50;
      _nw49[(int)(1542)] = 236;
      _nw49[(int)(1543)] = 54;
      _nw49[(int)(1544)] = 134;
      _nw49[(int)(1545)] = 117;
      _nw49[(int)(1546)] = 225;
      _nw49[(int)(1547)] = 138;
      _nw49[(int)(1548)] = 112;
      _nw49[(int)(1549)] = 54;
      _nw49[(int)(1550)] = 231;
      _nw49[(int)(1551)] = 10;
      _nw49[(int)(1552)] = 172;
      _nw49[(int)(1553)] = 222;
      _nw49[(int)(1554)] = 40;
      _nw49[(int)(1555)] = 134;
      _nw49[(int)(1556)] = 247;
      _nw49[(int)(1557)] = 223;
      _nw49[(int)(1558)] = 22;
      _nw49[(int)(1559)] = 127;
      _nw49[(int)(1560)] = 174;
      _nw49[(int)(1561)] = 217;
      _nw49[(int)(1562)] = 89;
      _nw49[(int)(1563)] = 228;
      _nw49[(int)(1564)] = 121;
      _nw49[(int)(1565)] = 213;
      _nw49[(int)(1566)] = 171;
      _nw49[(int)(1567)] = 117;
      _nw49[(int)(1568)] = 38;
      _nw49[(int)(1569)] = 115;
      _nw49[(int)(1570)] = 184;
      _nw49[(int)(1571)] = 151;
      _nw49[(int)(1572)] = 65;
      _nw49[(int)(1573)] = 116;
      _nw49[(int)(1574)] = 80;
      _nw49[(int)(1575)] = 180;
      _nw49[(int)(1576)] = 6;
      _nw49[(int)(1577)] = 44;
      _nw49[(int)(1578)] = 68;
      _nw49[(int)(1579)] = 100;
      _nw49[(int)(1580)] = 103;
      _nw49[(int)(1581)] = 62;
      _nw49[(int)(1582)] = 45;
      _nw49[(int)(1583)] = 161;
      _nw49[(int)(1584)] = 105;
      _nw49[(int)(1585)] = 91;
      _nw49[(int)(1586)] = 205;
      _nw49[(int)(1587)] = 163;
      _nw49[(int)(1588)] = 170;
      _nw49[(int)(1589)] = 194;
      _nw49[(int)(1590)] = 69;
      _nw49[(int)(1591)] = 7;
      _nw49[(int)(1592)] = 110;
      _nw49[(int)(1593)] = 85;
      _nw49[(int)(1594)] = 9;
      _nw49[(int)(1595)] = 1;
      _nw49[(int)(1596)] = 75;
      _nw49[(int)(1597)] = 138;
      _nw49[(int)(1598)] = 93;
      _nw49[(int)(1599)] = 63;
      _nw49[(int)(1600)] = 223;
      _nw49[(int)(1601)] = 224;
      _nw49[(int)(1602)] = 35;
      _nw49[(int)(1603)] = 41;
      _nw49[(int)(1604)] = 87;
      _nw49[(int)(1605)] = 86;
      _nw49[(int)(1606)] = 162;
      _nw49[(int)(1607)] = 251;
      _nw49[(int)(1608)] = 222;
      _nw49[(int)(1609)] = 96;
      _nw49[(int)(1610)] = 116;
      _nw49[(int)(1611)] = 144;
      _nw49[(int)(1612)] = 226;
      _nw49[(int)(1613)] = 203;
      _nw49[(int)(1614)] = 220;
      _nw49[(int)(1615)] = 53;
      _nw49[(int)(1616)] = 58;
      _nw49[(int)(1617)] = 173;
      _nw49[(int)(1618)] = 189;
      _nw49[(int)(1619)] = 251;
      _nw49[(int)(1620)] = 66;
      _nw49[(int)(1621)] = 48;
      _nw49[(int)(1622)] = 70;
      _nw49[(int)(1623)] = 179;
      _nw49[(int)(1624)] = 124;
      _nw49[(int)(1625)] = 43;
      _nw49[(int)(1626)] = 199;
      _nw49[(int)(1627)] = 97;
      _nw49[(int)(1628)] = 140;
      _nw49[(int)(1629)] = 17;
      _nw49[(int)(1630)] = 72;
      _nw49[(int)(1631)] = 95;
      _nw49[(int)(1632)] = 156;
      _nw49[(int)(1633)] = 86;
      _nw49[(int)(1634)] = 49;
      _nw49[(int)(1635)] = 121;
      _nw49[(int)(1636)] = 101;
      _nw49[(int)(1637)] = 171;
      _nw49[(int)(1638)] = 191;
      _nw49[(int)(1639)] = 239;
      _nw49[(int)(1640)] = 131;
      _nw49[(int)(1641)] = 88;
      _nw49[(int)(1642)] = 82;
      _nw49[(int)(1643)] = 87;
      _nw49[(int)(1644)] = 5;
      _nw49[(int)(1645)] = 137;
      _nw49[(int)(1646)] = 132;
      _nw49[(int)(1647)] = 94;
      _nw49[(int)(1648)] = 50;
      _nw49[(int)(1649)] = 170;
      _nw49[(int)(1650)] = 154;
      _nw49[(int)(1651)] = 151;
      _nw49[(int)(1652)] = 92;
      _nw49[(int)(1653)] = 140;
      _nw49[(int)(1654)] = 85;
      _nw49[(int)(1655)] = 46;
      _nw49[(int)(1656)] = 61;
      _nw49[(int)(1657)] = 153;
      _nw49[(int)(1658)] = 222;
      _nw49[(int)(1659)] = 231;
      _nw49[(int)(1660)] = 189;
      _nw49[(int)(1661)] = 141;
      _nw49[(int)(1662)] = 109;
      _nw49[(int)(1663)] = 1;
      _nw49[(int)(1664)] = 214;
      _nw49[(int)(1665)] = 204;
      _nw49[(int)(1666)] = 195;
      _nw49[(int)(1667)] = 222;
      _nw49[(int)(1668)] = 189;
      _nw49[(int)(1669)] = 125;
      _nw49[(int)(1670)] = 161;
      _nw49[(int)(1671)] = 123;
      _nw49[(int)(1672)] = 134;
      _nw49[(int)(1673)] = 161;
      _nw49[(int)(1674)] = 81;
      _nw49[(int)(1675)] = 225;
      _nw49[(int)(1676)] = 165;
      _nw49[(int)(1677)] = 244;
      _nw49[(int)(1678)] = 58;
      _nw49[(int)(1679)] = 102;
      _nw49[(int)(1680)] = 39;
      _nw49[(int)(1681)] = 171;
      _nw49[(int)(1682)] = 183;
      _nw49[(int)(1683)] = 233;
      _nw49[(int)(1684)] = 66;
      _nw49[(int)(1685)] = 194;
      _nw49[(int)(1686)] = 210;
      _nw49[(int)(1687)] = 8;
      _nw49[(int)(1688)] = 90;
      _nw49[(int)(1689)] = 115;
      _nw49[(int)(1690)] = 202;
      _nw49[(int)(1691)] = 198;
      _nw49[(int)(1692)] = 68;
      _nw49[(int)(1693)] = 59;
      _nw49[(int)(1694)] = 247;
      _nw49[(int)(1695)] = 136;
      _nw49[(int)(1696)] = 21;
      _nw49[(int)(1697)] = 62;
      _nw49[(int)(1698)] = 34;
      _nw49[(int)(1699)] = 166;
      _nw49[(int)(1700)] = 149;
      _nw49[(int)(1701)] = 125;
      _nw49[(int)(1702)] = 2;
      _nw49[(int)(1703)] = 212;
      _nw49[(int)(1704)] = 34;
      _nw49[(int)(1705)] = 115;
      _nw49[(int)(1706)] = 239;
      _nw49[(int)(1707)] = 145;
      _nw49[(int)(1708)] = 25;
      _nw49[(int)(1709)] = 222;
      _nw49[(int)(1710)] = 220;
      _nw49[(int)(1711)] = 251;
      _nw49[(int)(1712)] = 117;
      _nw49[(int)(1713)] = 200;
      _nw49[(int)(1714)] = 88;
      _nw49[(int)(1715)] = 153;
      _nw49[(int)(1716)] = 4;
      _nw49[(int)(1717)] = 20;
      _nw49[(int)(1718)] = 110;
      _nw49[(int)(1719)] = 231;
      _nw49[(int)(1720)] = 168;
      _nw49[(int)(1721)] = 237;
      _nw49[(int)(1722)] = 102;
      _nw49[(int)(1723)] = 7;
      _nw49[(int)(1724)] = 133;
      _nw49[(int)(1725)] = 51;
      _nw49[(int)(1726)] = 6;
      _nw49[(int)(1727)] = 252;
      _nw49[(int)(1728)] = 181;
      _nw49[(int)(1729)] = 67;
      _nw49[(int)(1730)] = 83;
      _nw49[(int)(1731)] = 9;
      _nw49[(int)(1732)] = 243;
      _nw49[(int)(1733)] = 79;
      _nw49[(int)(1734)] = 230;
      _nw49[(int)(1735)] = 204;
      _nw49[(int)(1736)] = 58;
      _nw49[(int)(1737)] = 25;
      _nw49[(int)(1738)] = 37;
      _nw49[(int)(1739)] = 34;
      _nw49[(int)(1740)] = 165;
      _nw49[(int)(1741)] = 145;
      _nw49[(int)(1742)] = 76;
      _nw49[(int)(1743)] = 56;
      _nw49[(int)(1744)] = 220;
      _nw49[(int)(1745)] = 68;
      _nw49[(int)(1746)] = 180;
      _nw49[(int)(1747)] = 28;
      _nw49[(int)(1748)] = 60;
      _nw49[(int)(1749)] = 57;
      _nw49[(int)(1750)] = 110;
      _nw49[(int)(1751)] = 148;
      _nw49[(int)(1752)] = 225;
      _nw49[(int)(1753)] = 37;
      _nw49[(int)(1754)] = 201;
      _nw49[(int)(1755)] = 201;
      _nw49[(int)(1756)] = 186;
      _nw49[(int)(1757)] = 93;
      _nw49[(int)(1758)] = 224;
      _nw49[(int)(1759)] = 191;
      _nw49[(int)(1760)] = 197;
      _nw49[(int)(1761)] = 48;
      _nw49[(int)(1762)] = 172;
      _nw49[(int)(1763)] = 144;
      _nw49[(int)(1764)] = 118;
      _nw49[(int)(1765)] = 103;
      _nw49[(int)(1766)] = 206;
      _nw49[(int)(1767)] = 71;
      _nw49[(int)(1768)] = 103;
      _nw49[(int)(1769)] = 245;
      _nw49[(int)(1770)] = 203;
      _nw49[(int)(1771)] = 38;
      _nw49[(int)(1772)] = 98;
      _nw49[(int)(1773)] = 67;
      _nw49[(int)(1774)] = 253;
      _nw49[(int)(1775)] = 80;
      _nw49[(int)(1776)] = 48;
      _nw49[(int)(1777)] = 241;
      _nw49[(int)(1778)] = 24;
      _nw49[(int)(1779)] = 231;
      _nw49[(int)(1780)] = 26;
      _nw49[(int)(1781)] = 198;
      _nw49[(int)(1782)] = 150;
      _nw49[(int)(1783)] = 104;
      _nw49[(int)(1784)] = 188;
      _nw49[(int)(1785)] = 33;
      _nw49[(int)(1786)] = 85;
      _nw49[(int)(1787)] = 73;
      _nw49[(int)(1788)] = 225;
      _nw49[(int)(1789)] = 23;
      _nw49[(int)(1790)] = 44;
      _nw49[(int)(1791)] = 218;
      _nw49[(int)(1792)] = 131;
      _nw49[(int)(1793)] = 130;
      _nw49[(int)(1794)] = 222;
      _nw49[(int)(1795)] = 148;
      _nw49[(int)(1796)] = 35;
      _nw49[(int)(1797)] = 181;
      _nw49[(int)(1798)] = 67;
      _nw49[(int)(1799)] = 134;
      _nw49[(int)(1800)] = 111;
      _nw49[(int)(1801)] = 17;
      _nw49[(int)(1802)] = 108;
      _nw49[(int)(1803)] = 57;
      _nw49[(int)(1804)] = 109;
      _nw49[(int)(1805)] = 17;
      _nw49[(int)(1806)] = 44;
      _nw49[(int)(1807)] = 54;
      _nw49[(int)(1808)] = 234;
      _nw49[(int)(1809)] = 175;
      _nw49[(int)(1810)] = 230;
      _nw49[(int)(1811)] = 8;
      _nw49[(int)(1812)] = 84;
      _nw49[(int)(1813)] = 2;
      _nw49[(int)(1814)] = 106;
      _nw49[(int)(1815)] = 19;
      _nw49[(int)(1816)] = 71;
      _nw49[(int)(1817)] = 72;
      _nw49[(int)(1818)] = 22;
      _nw49[(int)(1819)] = 234;
      _nw49[(int)(1820)] = 118;
      _nw49[(int)(1821)] = 91;
      _nw49[(int)(1822)] = 128;
      _nw49[(int)(1823)] = 235;
      _nw49[(int)(1824)] = 146;
      _nw49[(int)(1825)] = 29;
      _nw49[(int)(1826)] = 244;
      _nw49[(int)(1827)] = 202;
      _nw49[(int)(1828)] = 237;
      _nw49[(int)(1829)] = 109;
      _nw49[(int)(1830)] = 230;
      _nw49[(int)(1831)] = 223;
      _nw49[(int)(1832)] = 43;
      _nw49[(int)(1833)] = 43;
      _nw49[(int)(1834)] = 187;
      _nw49[(int)(1835)] = 38;
      _nw49[(int)(1836)] = 137;
      _nw49[(int)(1837)] = 179;
      _nw49[(int)(1838)] = 227;
      _nw49[(int)(1839)] = 187;
      _nw49[(int)(1840)] = 104;
      _nw49[(int)(1841)] = 153;
      _nw49[(int)(1842)] = 77;
      _nw49[(int)(1843)] = 132;
      _nw49[(int)(1844)] = 126;
      _nw49[(int)(1845)] = 162;
      _nw49[(int)(1846)] = 151;
      _nw49[(int)(1847)] = 245;
      _nw49[(int)(1848)] = 248;
      _nw49[(int)(1849)] = 148;
      _nw49[(int)(1850)] = 8;
      _nw49[(int)(1851)] = 231;
      _nw49[(int)(1852)] = 198;
      _nw49[(int)(1853)] = 191;
      _nw49[(int)(1854)] = 131;
      _nw49[(int)(1855)] = 96;
      _nw49[(int)(1856)] = 157;
      _nw49[(int)(1857)] = 29;
      _nw49[(int)(1858)] = 218;
      _nw49[(int)(1859)] = 183;
      _nw49[(int)(1860)] = 37;
      _nw49[(int)(1861)] = 69;
      _nw49[(int)(1862)] = 61;
      _nw49[(int)(1863)] = 57;
      _nw49[(int)(1864)] = 227;
      _nw49[(int)(1865)] = 83;
      _nw49[(int)(1866)] = 237;
      _nw49[(int)(1867)] = 142;
      _nw49[(int)(1868)] = 46;
      _nw49[(int)(1869)] = 42;
      _nw49[(int)(1870)] = 198;
      _nw49[(int)(1871)] = 142;
      _nw49[(int)(1872)] = 158;
      _nw49[(int)(1873)] = 216;
      _nw49[(int)(1874)] = 217;
      _nw49[(int)(1875)] = 53;
      _nw49[(int)(1876)] = 186;
      _nw49[(int)(1877)] = 250;
      _nw49[(int)(1878)] = 53;
      _nw49[(int)(1879)] = 123;
      _nw49[(int)(1880)] = 64;
      _nw49[(int)(1881)] = 11;
      _nw49[(int)(1882)] = 106;
      _nw49[(int)(1883)] = 130;
      _nw49[(int)(1884)] = 156;
      _nw49[(int)(1885)] = 194;
      _nw49[(int)(1886)] = 217;
      _nw49[(int)(1887)] = 209;
      _nw49[(int)(1888)] = 56;
      _nw49[(int)(1889)] = 208;
      _nw49[(int)(1890)] = 80;
      _nw49[(int)(1891)] = 182;
      _nw49[(int)(1892)] = 162;
      _nw49[(int)(1893)] = 138;
      _nw49[(int)(1894)] = 236;
      _nw49[(int)(1895)] = 151;
      _nw49[(int)(1896)] = 145;
      _nw49[(int)(1897)] = 17;
      _nw49[(int)(1898)] = 125;
      _nw49[(int)(1899)] = 140;
      _nw49[(int)(1900)] = 251;
      _nw49[(int)(1901)] = 244;
      _nw49[(int)(1902)] = 172;
      _nw49[(int)(1903)] = 223;
      _nw49[(int)(1904)] = 226;
      _nw49[(int)(1905)] = 175;
      _nw49[(int)(1906)] = 26;
      _nw49[(int)(1907)] = 116;
      _nw49[(int)(1908)] = 251;
      _nw49[(int)(1909)] = 58;
      _nw49[(int)(1910)] = 194;
      _nw49[(int)(1911)] = 248;
      _nw49[(int)(1912)] = 228;
      _nw49[(int)(1913)] = 122;
      _nw49[(int)(1914)] = 80;
      _nw49[(int)(1915)] = 247;
      _nw49[(int)(1916)] = 17;
      _nw49[(int)(1917)] = 37;
      _nw49[(int)(1918)] = 168;
      _nw49[(int)(1919)] = 248;
      _nw49[(int)(1920)] = 153;
      _nw49[(int)(1921)] = 56;
      _nw49[(int)(1922)] = 148;
      _nw49[(int)(1923)] = 12;
      _nw49[(int)(1924)] = 114;
      _nw49[(int)(1925)] = 220;
      _nw49[(int)(1926)] = 234;
      _nw49[(int)(1927)] = 74;
      _nw49[(int)(1928)] = 80;
      _nw49[(int)(1929)] = 5;
      _nw49[(int)(1930)] = 208;
      _nw49[(int)(1931)] = 238;
      _nw49[(int)(1932)] = 164;
      _nw49[(int)(1933)] = 208;
      _nw49[(int)(1934)] = 108;
      _nw49[(int)(1935)] = 198;
      _nw49[(int)(1936)] = 92;
      _nw49[(int)(1937)] = 55;
      _nw49[(int)(1938)] = 46;
      _nw49[(int)(1939)] = 20;
      _nw49[(int)(1940)] = 111;
      _nw49[(int)(1941)] = 58;
      _nw49[(int)(1942)] = 32;
      _nw49[(int)(1943)] = 17;
      _nw49[(int)(1944)] = 11;
      _nw49[(int)(1945)] = 43;
      _nw49[(int)(1946)] = 217;
      _nw49[(int)(1947)] = 241;
      _nw49[(int)(1948)] = 119;
      _nw49[(int)(1949)] = 90;
      _nw49[(int)(1950)] = 87;
      _nw49[(int)(1951)] = 225;
      _nw49[(int)(1952)] = 136;
      _nw49[(int)(1953)] = 59;
      _nw49[(int)(1954)] = 127;
      _nw49[(int)(1955)] = 102;
      _nw49[(int)(1956)] = 158;
      _nw49[(int)(1957)] = 69;
      _nw49[(int)(1958)] = 0;
      _nw49[(int)(1959)] = 149;
      _nw49[(int)(1960)] = 226;
      _nw49[(int)(1961)] = 106;
      _nw49[(int)(1962)] = 89;
      _nw49[(int)(1963)] = 223;
      _nw49[(int)(1964)] = 134;
      _nw49[(int)(1965)] = 165;
      _nw49[(int)(1966)] = 34;
      _nw49[(int)(1967)] = 41;
      _nw49[(int)(1968)] = 16;
      _nw49[(int)(1969)] = 59;
      _nw49[(int)(1970)] = 218;
      _nw49[(int)(1971)] = 188;
      _nw49[(int)(1972)] = 24;
      _nw49[(int)(1973)] = 149;
      _nw49[(int)(1974)] = 145;
      _nw49[(int)(1975)] = 2;
      _nw49[(int)(1976)] = 121;
      _nw49[(int)(1977)] = 66;
      _nw49[(int)(1978)] = 128;
      _nw49[(int)(1979)] = 186;
      _nw49[(int)(1980)] = 252;
      _nw49[(int)(1981)] = 168;
      _nw49[(int)(1982)] = 233;
      _nw49[(int)(1983)] = 102;
      _nw49[(int)(1984)] = 248;
      _nw49[(int)(1985)] = 102;
      _nw49[(int)(1986)] = 126;
      _nw49[(int)(1987)] = 49;
      _nw49[(int)(1988)] = 90;
      _nw49[(int)(1989)] = 212;
      _nw49[(int)(1990)] = 102;
      _nw49[(int)(1991)] = 202;
      _nw49[(int)(1992)] = 116;
      _nw49[(int)(1993)] = 97;
      _nw49[(int)(1994)] = 147;
      _nw49[(int)(1995)] = 94;
      _nw49[(int)(1996)] = 39;
      _nw49[(int)(1997)] = 245;
      _nw49[(int)(1998)] = 233;
      _nw49[(int)(1999)] = 34;
      _nw49[(int)(2000)] = 77;
      _nw49[(int)(2001)] = 7;
      _nw49[(int)(2002)] = 113;
      _nw49[(int)(2003)] = 237;
      _nw49[(int)(2004)] = 89;
      _nw49[(int)(2005)] = 14;
      _nw49[(int)(2006)] = 246;
      _nw49[(int)(2007)] = 156;
      _nw49[(int)(2008)] = 61;
      _nw49[(int)(2009)] = 30;
      _nw49[(int)(2010)] = 173;
      _nw49[(int)(2011)] = 163;
      _nw49[(int)(2012)] = 83;
      _nw49[(int)(2013)] = 164;
      _nw49[(int)(2014)] = 13;
      _nw49[(int)(2015)] = 11;
      _nw49[(int)(2016)] = 190;
      _nw49[(int)(2017)] = 52;
      _nw49[(int)(2018)] = 11;
      _nw49[(int)(2019)] = 165;
      _nw49[(int)(2020)] = 35;
      _nw49[(int)(2021)] = 70;
      _nw49[(int)(2022)] = 217;
      _nw49[(int)(2023)] = 19;
      _nw49[(int)(2024)] = 151;
      _nw49[(int)(2025)] = 112;
      _nw49[(int)(2026)] = 64;
      _nw49[(int)(2027)] = 190;
      _nw49[(int)(2028)] = 214;
      _nw49[(int)(2029)] = 142;
      _nw49[(int)(2030)] = 132;
      _nw49[(int)(2031)] = 48;
      _nw49[(int)(2032)] = 20;
      _nw49[(int)(2033)] = 51;
      _nw49[(int)(2034)] = 15;
      _nw49[(int)(2035)] = 242;
      _nw49[(int)(2036)] = 35;
      _nw49[(int)(2037)] = 27;
      _nw49[(int)(2038)] = 175;
      _nw49[(int)(2039)] = 106;
      _nw49[(int)(2040)] = 222;
      _nw49[(int)(2041)] = 165;
      _nw49[(int)(2042)] = 153;
      _nw49[(int)(2043)] = 231;
      _nw49[(int)(2044)] = 119;
      _nw49[(int)(2045)] = 71;
      _nw49[(int)(2046)] = 155;
      _nw49[(int)(2047)] = 75;
      _nw49[(int)(2048)] = 75;
      _nw49[(int)(2049)] = 124;
      _nw49[(int)(2050)] = 106;
      _nw49[(int)(2051)] = 225;
      _nw49[(int)(2052)] = 142;
      _nw49[(int)(2053)] = 247;
      _nw49[(int)(2054)] = 7;
      _nw49[(int)(2055)] = 22;
      _nw49[(int)(2056)] = 245;
      _nw49[(int)(2057)] = 213;
      _nw49[(int)(2058)] = 102;
      _nw49[(int)(2059)] = 86;
      _nw49[(int)(2060)] = 62;
      _nw49[(int)(2061)] = 162;
      _nw49[(int)(2062)] = 223;
      _nw49[(int)(2063)] = 102;
      _nw49[(int)(2064)] = 172;
      _nw49[(int)(2065)] = 215;
      _nw49[(int)(2066)] = 22;
      _nw49[(int)(2067)] = 202;
      _nw49[(int)(2068)] = 185;
      _nw49[(int)(2069)] = 35;
      _nw49[(int)(2070)] = 163;
      _nw49[(int)(2071)] = 84;
      _nw49[(int)(2072)] = 154;
      _nw49[(int)(2073)] = 188;
      _nw49[(int)(2074)] = 46;
      _nw49[(int)(2075)] = 203;
      _nw49[(int)(2076)] = 230;
      _nw49[(int)(2077)] = 172;
      _nw49[(int)(2078)] = 136;
      _nw49[(int)(2079)] = 130;
      _nw49[(int)(2080)] = 95;
      _nw49[(int)(2081)] = 86;
      _nw49[(int)(2082)] = 70;
      _nw49[(int)(2083)] = 128;
      _nw49[(int)(2084)] = 232;
      _nw49[(int)(2085)] = 26;
      _nw49[(int)(2086)] = 105;
      _nw49[(int)(2087)] = 20;
      _nw49[(int)(2088)] = 108;
      _nw49[(int)(2089)] = 34;
      _nw49[(int)(2090)] = 129;
      _nw49[(int)(2091)] = 36;
      _nw49[(int)(2092)] = 74;
      _nw49[(int)(2093)] = 39;
      _nw49[(int)(2094)] = 184;
      _nw49[(int)(2095)] = 87;
      _nw49[(int)(2096)] = 110;
      _nw49[(int)(2097)] = 204;
      _nw49[(int)(2098)] = 209;
      _nw49[(int)(2099)] = 205;
      _nw49[(int)(2100)] = 193;
      _nw49[(int)(2101)] = 229;
      _nw49[(int)(2102)] = 25;
      _nw49[(int)(2103)] = 142;
      _nw49[(int)(2104)] = 160;
      _nw49[(int)(2105)] = 255;
      _nw49[(int)(2106)] = 34;
      _nw49[(int)(2107)] = 217;
      _nw49[(int)(2108)] = 95;
      _nw49[(int)(2109)] = 228;
      _nw49[(int)(2110)] = 140;
      _nw49[(int)(2111)] = 121;
      _nw49[(int)(2112)] = 126;
      _nw49[(int)(2113)] = 22;
      _nw49[(int)(2114)] = 121;
      _nw49[(int)(2115)] = 117;
      _nw49[(int)(2116)] = 115;
      _nw49[(int)(2117)] = 233;
      _nw49[(int)(2118)] = 35;
      _nw49[(int)(2119)] = 77;
      _nw49[(int)(2120)] = 206;
      _nw49[(int)(2121)] = 92;
      _nw49[(int)(2122)] = 119;
      _nw49[(int)(2123)] = 242;
      _nw49[(int)(2124)] = 229;
      _nw49[(int)(2125)] = 204;
      _nw49[(int)(2126)] = 34;
      _nw49[(int)(2127)] = 155;
      _nw49[(int)(2128)] = 38;
      _nw49[(int)(2129)] = 212;
      _nw49[(int)(2130)] = 50;
      _nw49[(int)(2131)] = 48;
      _nw49[(int)(2132)] = 249;
      _nw49[(int)(2133)] = 191;
      _nw49[(int)(2134)] = 145;
      _nw49[(int)(2135)] = 50;
      _nw49[(int)(2136)] = 191;
      _nw49[(int)(2137)] = 150;
      _nw49[(int)(2138)] = 190;
      _nw49[(int)(2139)] = 93;
      _nw49[(int)(2140)] = 91;
      _nw49[(int)(2141)] = 29;
      _nw49[(int)(2142)] = 163;
      _nw49[(int)(2143)] = 122;
      _nw49[(int)(2144)] = 85;
      _nw49[(int)(2145)] = 254;
      _nw49[(int)(2146)] = 93;
      _nw49[(int)(2147)] = 14;
      _nw49[(int)(2148)] = 213;
      _nw49[(int)(2149)] = 129;
      _nw49[(int)(2150)] = 24;
      _nw49[(int)(2151)] = 158;
      _nw49[(int)(2152)] = 133;
      _nw49[(int)(2153)] = 185;
      _nw49[(int)(2154)] = 177;
      _nw49[(int)(2155)] = 110;
      _nw49[(int)(2156)] = 220;
      _nw49[(int)(2157)] = 109;
      _nw49[(int)(2158)] = 33;
      _nw49[(int)(2159)] = 45;
      _nw49[(int)(2160)] = 243;
      _nw49[(int)(2161)] = 25;
      _nw49[(int)(2162)] = 224;
      _nw49[(int)(2163)] = 131;
      _nw49[(int)(2164)] = 27;
      _nw49[(int)(2165)] = 110;
      _nw49[(int)(2166)] = 64;
      _nw49[(int)(2167)] = 151;
      _nw49[(int)(2168)] = 128;
      _nw49[(int)(2169)] = 18;
      _nw49[(int)(2170)] = 7;
      _nw49[(int)(2171)] = 103;
      _nw49[(int)(2172)] = 45;
      _nw49[(int)(2173)] = 245;
      _nw49[(int)(2174)] = 182;
      _nw49[(int)(2175)] = 171;
      _nw49[(int)(2176)] = 225;
      _nw49[(int)(2177)] = 236;
      _nw49[(int)(2178)] = 21;
      _nw49[(int)(2179)] = 98;
      _nw49[(int)(2180)] = 255;
      _nw49[(int)(2181)] = 137;
      _nw49[(int)(2182)] = 44;
      _nw49[(int)(2183)] = 40;
      _nw49[(int)(2184)] = 68;
      _nw49[(int)(2185)] = 124;
      _nw49[(int)(2186)] = 12;
      _nw49[(int)(2187)] = 21;
      _nw49[(int)(2188)] = 160;
      _nw49[(int)(2189)] = 230;
      _nw49[(int)(2190)] = 85;
      _nw49[(int)(2191)] = 83;
      _nw49[(int)(2192)] = 20;
      _nw49[(int)(2193)] = 2;
      _nw49[(int)(2194)] = 161;
      _nw49[(int)(2195)] = 219;
      _nw49[(int)(2196)] = 132;
      _nw49[(int)(2197)] = 150;
      _nw49[(int)(2198)] = 31;
      _nw49[(int)(2199)] = 140;
      _nw49[(int)(2200)] = 244;
      _nw49[(int)(2201)] = 103;
      _nw49[(int)(2202)] = 76;
      _nw49[(int)(2203)] = 144;
      _nw49[(int)(2204)] = 182;
      _nw49[(int)(2205)] = 70;
      _nw49[(int)(2206)] = 76;
      _nw49[(int)(2207)] = 191;
      _nw49[(int)(2208)] = 16;
      _nw49[(int)(2209)] = 242;
      _nw49[(int)(2210)] = 254;
      _nw49[(int)(2211)] = 9;
      _nw49[(int)(2212)] = 39;
      _nw49[(int)(2213)] = 46;
      _nw49[(int)(2214)] = 4;
      _nw49[(int)(2215)] = 156;
      _nw49[(int)(2216)] = 243;
      _nw49[(int)(2217)] = 6;
      _nw49[(int)(2218)] = 40;
      _nw49[(int)(2219)] = 119;
      _nw49[(int)(2220)] = 9;
      _nw49[(int)(2221)] = 202;
      _nw49[(int)(2222)] = 174;
      _nw49[(int)(2223)] = 55;
      _nw49[(int)(2224)] = 159;
      _nw49[(int)(2225)] = 225;
      _nw49[(int)(2226)] = 132;
      _nw49[(int)(2227)] = 78;
      _nw49[(int)(2228)] = 160;
      _nw49[(int)(2229)] = 53;
      _nw49[(int)(2230)] = 189;
      _nw49[(int)(2231)] = 77;
      _nw49[(int)(2232)] = 170;
      _nw49[(int)(2233)] = 185;
      _nw49[(int)(2234)] = 96;
      _nw49[(int)(2235)] = 169;
      _nw49[(int)(2236)] = 247;
      _nw49[(int)(2237)] = 122;
      _nw49[(int)(2238)] = 159;
      _nw49[(int)(2239)] = 195;
      _nw49[(int)(2240)] = 226;
      _nw49[(int)(2241)] = 255;
      _nw49[(int)(2242)] = 191;
      _nw49[(int)(2243)] = 142;
      _nw49[(int)(2244)] = 25;
      _nw49[(int)(2245)] = 168;
      _nw49[(int)(2246)] = 162;
      _nw49[(int)(2247)] = 79;
      _nw49[(int)(2248)] = 139;
      _nw49[(int)(2249)] = 164;
      _nw49[(int)(2250)] = 167;
      _nw49[(int)(2251)] = 11;
      _nw49[(int)(2252)] = 64;
      _nw49[(int)(2253)] = 133;
      _nw49[(int)(2254)] = 55;
      _nw49[(int)(2255)] = 227;
      _nw49[(int)(2256)] = 180;
      _nw49[(int)(2257)] = 192;
      _nw49[(int)(2258)] = 11;
      _nw49[(int)(2259)] = 166;
      _nw49[(int)(2260)] = 255;
      _nw49[(int)(2261)] = 65;
      _nw49[(int)(2262)] = 141;
      _nw49[(int)(2263)] = 110;
      _nw49[(int)(2264)] = 38;
      _nw49[(int)(2265)] = 94;
      _nw49[(int)(2266)] = 1;
      _nw49[(int)(2267)] = 43;
      _nw49[(int)(2268)] = 177;
      _nw49[(int)(2269)] = 25;
      _nw49[(int)(2270)] = 253;
      _nw49[(int)(2271)] = 199;
      _nw49[(int)(2272)] = 175;
      _nw49[(int)(2273)] = 247;
      _nw49[(int)(2274)] = 5;
      _nw49[(int)(2275)] = 35;
      _nw49[(int)(2276)] = 109;
      _nw49[(int)(2277)] = 177;
      _nw49[(int)(2278)] = 137;
      _nw49[(int)(2279)] = 162;
      _nw49[(int)(2280)] = 10;
      _nw49[(int)(2281)] = 177;
      _nw49[(int)(2282)] = 199;
      _nw49[(int)(2283)] = 202;
      _nw49[(int)(2284)] = 112;
      _nw49[(int)(2285)] = 131;
      _nw49[(int)(2286)] = 103;
      _nw49[(int)(2287)] = 248;
      _nw49[(int)(2288)] = 221;
      _nw49[(int)(2289)] = 232;
      _nw49[(int)(2290)] = 14;
      _nw49[(int)(2291)] = 189;
      _nw49[(int)(2292)] = 148;
      _nw49[(int)(2293)] = 150;
      _nw49[(int)(2294)] = 61;
      _nw49[(int)(2295)] = 107;
      _nw49[(int)(2296)] = 133;
      _nw49[(int)(2297)] = 4;
      _nw49[(int)(2298)] = 151;
      _nw49[(int)(2299)] = 175;
      _nw49[(int)(2300)] = 120;
      _nw49[(int)(2301)] = 56;
      _nw49[(int)(2302)] = 136;
      _nw49[(int)(2303)] = 135;
      _nw49[(int)(2304)] = 201;
      _nw49[(int)(2305)] = 94;
      _nw49[(int)(2306)] = 141;
      _nw49[(int)(2307)] = 42;
      _nw49[(int)(2308)] = 103;
      _nw49[(int)(2309)] = 150;
      _nw49[(int)(2310)] = 67;
      _nw49[(int)(2311)] = 72;
      _nw49[(int)(2312)] = 200;
      _nw49[(int)(2313)] = 81;
      _nw49[(int)(2314)] = 61;
      _nw49[(int)(2315)] = 7;
      _nw49[(int)(2316)] = 104;
      _nw49[(int)(2317)] = 248;
      _nw49[(int)(2318)] = 65;
      _nw49[(int)(2319)] = 99;
      _nw49[(int)(2320)] = 179;
      _nw49[(int)(2321)] = 57;
      _nw49[(int)(2322)] = 176;
      _nw49[(int)(2323)] = 246;
      _nw49[(int)(2324)] = 171;
      _nw49[(int)(2325)] = 165;
      _nw49[(int)(2326)] = 199;
      _nw49[(int)(2327)] = 2;
      _nw49[(int)(2328)] = 255;
      _nw49[(int)(2329)] = 244;
      _nw49[(int)(2330)] = 156;
      _nw49[(int)(2331)] = 85;
      _nw49[(int)(2332)] = 80;
      _nw49[(int)(2333)] = 59;
      _nw49[(int)(2334)] = 74;
      _nw49[(int)(2335)] = 109;
      _nw49[(int)(2336)] = 136;
      _nw49[(int)(2337)] = 118;
      _nw49[(int)(2338)] = 172;
      _nw49[(int)(2339)] = 254;
      _nw49[(int)(2340)] = 165;
      _nw49[(int)(2341)] = 231;
      _nw49[(int)(2342)] = 115;
      _nw49[(int)(2343)] = 245;
      _nw49[(int)(2344)] = 57;
      _nw49[(int)(2345)] = 227;
      _nw49[(int)(2346)] = 144;
      _nw49[(int)(2347)] = 3;
      _nw49[(int)(2348)] = 181;
      _nw49[(int)(2349)] = 247;
      _nw49[(int)(2350)] = 89;
      _nw49[(int)(2351)] = 6;
      _nw49[(int)(2352)] = 190;
      _nw49[(int)(2353)] = 10;
      _nw49[(int)(2354)] = 244;
      _nw49[(int)(2355)] = 123;
      _nw49[(int)(2356)] = 116;
      _nw49[(int)(2357)] = 144;
      _nw49[(int)(2358)] = 6;
      _nw49[(int)(2359)] = 33;
      _nw49[(int)(2360)] = 254;
      _nw49[(int)(2361)] = 139;
      _nw49[(int)(2362)] = 30;
      _nw49[(int)(2363)] = 115;
      _nw49[(int)(2364)] = 118;
      _nw49[(int)(2365)] = 72;
      _nw49[(int)(2366)] = 225;
      _nw49[(int)(2367)] = 150;
      _nw49[(int)(2368)] = 36;
      _nw49[(int)(2369)] = 203;
      _nw49[(int)(2370)] = 49;
      _nw49[(int)(2371)] = 219;
      _nw49[(int)(2372)] = 25;
      _nw49[(int)(2373)] = 254;
      _nw49[(int)(2374)] = 246;
      _nw49[(int)(2375)] = 59;
      _nw49[(int)(2376)] = 78;
      _nw49[(int)(2377)] = 71;
      _nw49[(int)(2378)] = 222;
      _nw49[(int)(2379)] = 157;
      _nw49[(int)(2380)] = 170;
      _nw49[(int)(2381)] = 63;
      _nw49[(int)(2382)] = 175;
      _nw49[(int)(2383)] = 170;
      _nw49[(int)(2384)] = 129;
      _nw49[(int)(2385)] = 236;
      _nw49[(int)(2386)] = 70;
      _nw49[(int)(2387)] = 155;
      _nw49[(int)(2388)] = 242;
      _nw49[(int)(2389)] = 111;
      _nw49[(int)(2390)] = 40;
      _nw49[(int)(2391)] = 134;
      _nw49[(int)(2392)] = 139;
      _nw49[(int)(2393)] = 148;
      _nw49[(int)(2394)] = 198;
      _nw49[(int)(2395)] = 49;
      _nw49[(int)(2396)] = 132;
      _nw49[(int)(2397)] = 69;
      _nw49[(int)(2398)] = 132;
      _nw49[(int)(2399)] = 145;
      _nw49[(int)(2400)] = 135;
      _nw49[(int)(2401)] = 119;
      _nw49[(int)(2402)] = 77;
      _nw49[(int)(2403)] = 109;
      _nw49[(int)(2404)] = 198;
      _nw49[(int)(2405)] = 208;
      _nw49[(int)(2406)] = 36;
      _nw49[(int)(2407)] = 226;
      _nw49[(int)(2408)] = 180;
      _nw49[(int)(2409)] = 36;
      _nw49[(int)(2410)] = 232;
      _nw49[(int)(2411)] = 208;
      _nw49[(int)(2412)] = 8;
      _nw49[(int)(2413)] = 94;
      _nw49[(int)(2414)] = 21;
      _nw49[(int)(2415)] = 155;
      _nw49[(int)(2416)] = 179;
      _nw49[(int)(2417)] = 174;
      _nw49[(int)(2418)] = 42;
      _nw49[(int)(2419)] = 133;
      _nw49[(int)(2420)] = 208;
      _nw49[(int)(2421)] = 251;
      _nw49[(int)(2422)] = 147;
      _nw49[(int)(2423)] = 26;
      _nw49[(int)(2424)] = 7;
      _nw49[(int)(2425)] = 220;
      _nw49[(int)(2426)] = 148;
      _nw49[(int)(2427)] = 61;
      _nw49[(int)(2428)] = 141;
      _nw49[(int)(2429)] = 228;
      _nw49[(int)(2430)] = 180;
      _nw49[(int)(2431)] = 232;
      _nw49[(int)(2432)] = 56;
      _nw49[(int)(2433)] = 28;
      _nw49[(int)(2434)] = 169;
      _nw49[(int)(2435)] = 35;
      _nw49[(int)(2436)] = 158;
      _nw49[(int)(2437)] = 79;
      _nw49[(int)(2438)] = 192;
      _nw49[(int)(2439)] = 26;
      _nw49[(int)(2440)] = 17;
      _nw49[(int)(2441)] = 90;
      _nw49[(int)(2442)] = 146;
      _nw49[(int)(2443)] = 187;
      _nw49[(int)(2444)] = 253;
      _nw49[(int)(2445)] = 120;
      _nw49[(int)(2446)] = 134;
      _nw49[(int)(2447)] = 86;
      _nw49[(int)(2448)] = 67;
      _nw49[(int)(2449)] = 144;
      _nw49[(int)(2450)] = 108;
      _nw49[(int)(2451)] = 70;
      _nw49[(int)(2452)] = 54;
      _nw49[(int)(2453)] = 48;
      _nw49[(int)(2454)] = 138;
      _nw49[(int)(2455)] = 13;
      _nw49[(int)(2456)] = 50;
      _nw49[(int)(2457)] = 179;
      _nw49[(int)(2458)] = 1;
      _nw49[(int)(2459)] = 146;
      _nw49[(int)(2460)] = 123;
      _nw49[(int)(2461)] = 235;
      _nw49[(int)(2462)] = 240;
      _nw49[(int)(2463)] = 248;
      _nw49[(int)(2464)] = 109;
      _nw49[(int)(2465)] = 173;
      _nw49[(int)(2466)] = 143;
      _nw49[(int)(2467)] = 34;
      _nw49[(int)(2468)] = 182;
      _nw49[(int)(2469)] = 81;
      _nw49[(int)(2470)] = 46;
      _nw49[(int)(2471)] = 48;
      _nw49[(int)(2472)] = 242;
      _nw49[(int)(2473)] = 60;
      _nw49[(int)(2474)] = 182;
      _nw49[(int)(2475)] = 230;
      _nw49[(int)(2476)] = 78;
      _nw49[(int)(2477)] = 169;
      _nw49[(int)(2478)] = 98;
      _nw49[(int)(2479)] = 38;
      _nw49[(int)(2480)] = 11;
      _nw49[(int)(2481)] = 53;
      _nw49[(int)(2482)] = 26;
      _nw49[(int)(2483)] = 81;
      _nw49[(int)(2484)] = 168;
      _nw49[(int)(2485)] = 66;
      _nw49[(int)(2486)] = 233;
      _nw49[(int)(2487)] = 95;
      _nw49[(int)(2488)] = 90;
      _nw49[(int)(2489)] = 161;
      _nw49[(int)(2490)] = 127;
      _nw49[(int)(2491)] = 186;
      _nw49[(int)(2492)] = 104;
      _nw49[(int)(2493)] = 159;
      _nw49[(int)(2494)] = 161;
      _nw49[(int)(2495)] = 182;
      _nw49[(int)(2496)] = 178;
      _nw49[(int)(2497)] = 237;
      _nw49[(int)(2498)] = 12;
      _nw49[(int)(2499)] = 230;
      _nw49[(int)(2500)] = 169;
      _nw49[(int)(2501)] = 179;
      _nw49[(int)(2502)] = 46;
      _nw49[(int)(2503)] = 214;
      _nw49[(int)(2504)] = 91;
      _nw49[(int)(2505)] = 154;
      _nw49[(int)(2506)] = 96;
      _nw49[(int)(2507)] = 212;
      _nw49[(int)(2508)] = 20;
      _nw49[(int)(2509)] = 212;
      _nw49[(int)(2510)] = 227;
      _nw49[(int)(2511)] = 161;
      _nw49[(int)(2512)] = 187;
      _nw49[(int)(2513)] = 181;
      _nw49[(int)(2514)] = 41;
      _nw49[(int)(2515)] = 201;
      _nw49[(int)(2516)] = 18;
      _nw49[(int)(2517)] = 149;
      _nw49[(int)(2518)] = 212;
      _nw49[(int)(2519)] = 216;
      _nw49[(int)(2520)] = 11;
      _nw49[(int)(2521)] = 152;
      _nw49[(int)(2522)] = 9;
      _nw49[(int)(2523)] = 217;
      _nw49[(int)(2524)] = 134;
      _nw49[(int)(2525)] = 223;
      _nw49[(int)(2526)] = 229;
      _nw49[(int)(2527)] = 195;
      _nw49[(int)(2528)] = 83;
      _nw49[(int)(2529)] = 4;
      _nw49[(int)(2530)] = 141;
      _nw49[(int)(2531)] = 188;
      _nw49[(int)(2532)] = 220;
      _nw49[(int)(2533)] = 177;
      _nw49[(int)(2534)] = 112;
      _nw49[(int)(2535)] = 161;
      _nw49[(int)(2536)] = 64;
      _nw49[(int)(2537)] = 127;
      _nw49[(int)(2538)] = 223;
      _nw49[(int)(2539)] = 173;
      _nw49[(int)(2540)] = 204;
      _nw49[(int)(2541)] = 116;
      _nw49[(int)(2542)] = 96;
      _nw49[(int)(2543)] = 26;
      _nw49[(int)(2544)] = 182;
      _nw49[(int)(2545)] = 204;
      _nw49[(int)(2546)] = 128;
      _nw49[(int)(2547)] = 146;
      _nw49[(int)(2548)] = 241;
      _nw49[(int)(2549)] = 212;
      _nw49[(int)(2550)] = 9;
      _nw49[(int)(2551)] = 234;
      _nw49[(int)(2552)] = 101;
      _nw49[(int)(2553)] = 42;
      _nw49[(int)(2554)] = 233;
      _nw49[(int)(2555)] = 85;
      _nw49[(int)(2556)] = 220;
      _nw49[(int)(2557)] = 185;
      _nw49[(int)(2558)] = 126;
      _nw49[(int)(2559)] = 25;
      _nw49[(int)(2560)] = 175;
      _nw49[(int)(2561)] = 72;
      _nw49[(int)(2562)] = 165;
      _nw49[(int)(2563)] = 239;
      _nw49[(int)(2564)] = 241;
      _nw49[(int)(2565)] = 124;
      _nw49[(int)(2566)] = 74;
      _nw49[(int)(2567)] = 10;
      _nw49[(int)(2568)] = 152;
      _nw49[(int)(2569)] = 218;
      _nw49[(int)(2570)] = 1;
      _nw49[(int)(2571)] = 36;
      _nw49[(int)(2572)] = 161;
      _nw49[(int)(2573)] = 251;
      _nw49[(int)(2574)] = 98;
      _nw49[(int)(2575)] = 148;
      _nw49[(int)(2576)] = 42;
      _nw49[(int)(2577)] = 38;
      _nw49[(int)(2578)] = 77;
      _nw49[(int)(2579)] = 103;
      _nw49[(int)(2580)] = 235;
      _nw49[(int)(2581)] = 150;
      _nw49[(int)(2582)] = 200;
      _nw49[(int)(2583)] = 182;
      _nw49[(int)(2584)] = 207;
      _nw49[(int)(2585)] = 150;
      _nw49[(int)(2586)] = 18;
      _nw49[(int)(2587)] = 207;
      _nw49[(int)(2588)] = 208;
      _nw49[(int)(2589)] = 199;
      _nw49[(int)(2590)] = 177;
      _nw49[(int)(2591)] = 172;
      _nw49[(int)(2592)] = 204;
      _nw49[(int)(2593)] = 9;
      _nw49[(int)(2594)] = 93;
      _nw49[(int)(2595)] = 93;
      _nw49[(int)(2596)] = 102;
      _nw49[(int)(2597)] = 20;
      _nw49[(int)(2598)] = 193;
      _nw49[(int)(2599)] = 235;
      _nw49[(int)(2600)] = 247;
      _nw49[(int)(2601)] = 8;
      _nw49[(int)(2602)] = 76;
      _nw49[(int)(2603)] = 84;
      _nw49[(int)(2604)] = 177;
      _nw49[(int)(2605)] = 199;
      _nw49[(int)(2606)] = 146;
      _nw49[(int)(2607)] = 136;
      _nw49[(int)(2608)] = 109;
      _nw49[(int)(2609)] = 238;
      _nw49[(int)(2610)] = 140;
      _nw49[(int)(2611)] = 180;
      _nw49[(int)(2612)] = 216;
      _nw49[(int)(2613)] = 71;
      _nw49[(int)(2614)] = 65;
      _nw49[(int)(2615)] = 76;
      _nw49[(int)(2616)] = 63;
      _nw49[(int)(2617)] = 80;
      _nw49[(int)(2618)] = 193;
      _nw49[(int)(2619)] = 162;
      _nw49[(int)(2620)] = 187;
      _nw49[(int)(2621)] = 92;
      _nw49[(int)(2622)] = 36;
      _nw49[(int)(2623)] = 37;
      _nw49[(int)(2624)] = 210;
      _nw49[(int)(2625)] = 177;
      _nw49[(int)(2626)] = 212;
      _nw49[(int)(2627)] = 228;
      _nw49[(int)(2628)] = 21;
      _nw49[(int)(2629)] = 204;
      _nw49[(int)(2630)] = 204;
      _nw49[(int)(2631)] = 239;
      _nw49[(int)(2632)] = 225;
      _nw49[(int)(2633)] = 64;
      _nw49[(int)(2634)] = 200;
      _nw49[(int)(2635)] = 118;
      _nw49[(int)(2636)] = 175;
      _nw49[(int)(2637)] = 166;
      _nw49[(int)(2638)] = 184;
      _nw49[(int)(2639)] = 43;
      _nw49[(int)(2640)] = 247;
      _nw49[(int)(2641)] = 177;
      _nw49[(int)(2642)] = 219;
      _nw49[(int)(2643)] = 99;
      _nw49[(int)(2644)] = 88;
      _nw49[(int)(2645)] = 69;
      _nw49[(int)(2646)] = 220;
      _nw49[(int)(2647)] = 143;
      _nw49[(int)(2648)] = 126;
      _nw49[(int)(2649)] = 144;
      _nw49[(int)(2650)] = 34;
      _nw49[(int)(2651)] = 245;
      _nw49[(int)(2652)] = 237;
      _nw49[(int)(2653)] = 46;
      _nw49[(int)(2654)] = 202;
      _nw49[(int)(2655)] = 146;
      _nw49[(int)(2656)] = 211;
      _nw49[(int)(2657)] = 146;
      _nw49[(int)(2658)] = 160;
      _nw49[(int)(2659)] = 232;
      _nw49[(int)(2660)] = 171;
      _nw49[(int)(2661)] = 18;
      _nw49[(int)(2662)] = 175;
      _nw49[(int)(2663)] = 150;
      _nw49[(int)(2664)] = 236;
      _nw49[(int)(2665)] = 169;
      _nw49[(int)(2666)] = 42;
      _nw49[(int)(2667)] = 71;
      _nw49[(int)(2668)] = 154;
      _nw49[(int)(2669)] = 151;
      _nw49[(int)(2670)] = 101;
      _nw49[(int)(2671)] = 148;
      _nw49[(int)(2672)] = 101;
      _nw49[(int)(2673)] = 102;
      _nw49[(int)(2674)] = 224;
      _nw49[(int)(2675)] = 197;
      _nw49[(int)(2676)] = 45;
      _nw49[(int)(2677)] = 223;
      _nw49[(int)(2678)] = 243;
      _nw49[(int)(2679)] = 97;
      _nw49[(int)(2680)] = 205;
      _nw49[(int)(2681)] = 29;
      _nw49[(int)(2682)] = 107;
      _nw49[(int)(2683)] = 72;
      _nw49[(int)(2684)] = 0;
      _nw49[(int)(2685)] = 94;
      _nw49[(int)(2686)] = 141;
      _nw49[(int)(2687)] = 145;
      _nw49[(int)(2688)] = 241;
      _nw49[(int)(2689)] = 30;
      _nw49[(int)(2690)] = 166;
      _nw49[(int)(2691)] = 97;
      _nw49[(int)(2692)] = 61;
      _nw49[(int)(2693)] = 222;
      _nw49[(int)(2694)] = 49;
      _nw49[(int)(2695)] = 2;
      _nw49[(int)(2696)] = 105;
      _nw49[(int)(2697)] = 129;
      _nw49[(int)(2698)] = 43;
      _nw49[(int)(2699)] = 43;
      _nw49[(int)(2700)] = 48;
      _nw49[(int)(2701)] = 46;
      _nw49[(int)(2702)] = 158;
      _nw49[(int)(2703)] = 176;
      _nw49[(int)(2704)] = 208;
      _nw49[(int)(2705)] = 71;
      _nw49[(int)(2706)] = 14;
      _nw49[(int)(2707)] = 83;
      _nw49[(int)(2708)] = 234;
      _nw49[(int)(2709)] = 3;
      _nw49[(int)(2710)] = 87;
      _nw49[(int)(2711)] = 193;
      _nw49[(int)(2712)] = 148;
      _nw49[(int)(2713)] = 98;
      _nw49[(int)(2714)] = 61;
      _nw49[(int)(2715)] = 206;
      _nw49[(int)(2716)] = 100;
      _nw49[(int)(2717)] = 3;
      _nw49[(int)(2718)] = 32;
      _nw49[(int)(2719)] = 147;
      _nw49[(int)(2720)] = 85;
      _nw49[(int)(2721)] = 47;
      _nw49[(int)(2722)] = 209;
      _nw49[(int)(2723)] = 201;
      _nw49[(int)(2724)] = 251;
      _nw49[(int)(2725)] = 150;
      _nw49[(int)(2726)] = 199;
      _nw49[(int)(2727)] = 57;
      _nw49[(int)(2728)] = 97;
      _nw49[(int)(2729)] = 220;
      _nw49[(int)(2730)] = 18;
      _nw49[(int)(2731)] = 135;
      _nw49[(int)(2732)] = 190;
      _nw49[(int)(2733)] = 30;
      _nw49[(int)(2734)] = 203;
      _nw49[(int)(2735)] = 234;
      _nw49[(int)(2736)] = 187;
      _nw49[(int)(2737)] = 135;
      _nw49[(int)(2738)] = 48;
      _nw49[(int)(2739)] = 61;
      _nw49[(int)(2740)] = 53;
      _nw49[(int)(2741)] = 20;
      _nw49[(int)(2742)] = 172;
      _nw49[(int)(2743)] = 63;
      _nw49[(int)(2744)] = 100;
      _nw49[(int)(2745)] = 138;
      _nw49[(int)(2746)] = 207;
      _nw49[(int)(2747)] = 205;
      _nw49[(int)(2748)] = 141;
      _nw49[(int)(2749)] = 233;
      _nw49[(int)(2750)] = 185;
      _nw49[(int)(2751)] = 191;
      _nw49[(int)(2752)] = 191;
      _nw49[(int)(2753)] = 199;
      _nw49[(int)(2754)] = 112;
      _nw49[(int)(2755)] = 208;
      _nw49[(int)(2756)] = 224;
      _nw49[(int)(2757)] = 111;
      _nw49[(int)(2758)] = 138;
      _nw49[(int)(2759)] = 91;
      _nw49[(int)(2760)] = 201;
      _nw49[(int)(2761)] = 199;
      _nw49[(int)(2762)] = 90;
      _nw49[(int)(2763)] = 206;
      _nw49[(int)(2764)] = 139;
      _nw49[(int)(2765)] = 48;
      _nw49[(int)(2766)] = 161;
      _nw49[(int)(2767)] = 245;
      _nw49[(int)(2768)] = 160;
      _nw49[(int)(2769)] = 253;
      _nw49[(int)(2770)] = 75;
      _nw49[(int)(2771)] = 36;
      _nw49[(int)(2772)] = 12;
      _nw49[(int)(2773)] = 243;
      _nw49[(int)(2774)] = 182;
      _nw49[(int)(2775)] = 252;
      _nw49[(int)(2776)] = 254;
      _nw49[(int)(2777)] = 185;
      _nw49[(int)(2778)] = 223;
      _nw49[(int)(2779)] = 187;
      _nw49[(int)(2780)] = 254;
      _nw49[(int)(2781)] = 33;
      _nw49[(int)(2782)] = 99;
      _nw49[(int)(2783)] = 185;
      _nw49[(int)(2784)] = 111;
      _nw49[(int)(2785)] = 233;
      _nw49[(int)(2786)] = 101;
      _nw49[(int)(2787)] = 15;
      _nw49[(int)(2788)] = 140;
      _nw49[(int)(2789)] = 62;
      _nw49[(int)(2790)] = 172;
      _nw49[(int)(2791)] = 45;
      _nw49[(int)(2792)] = 38;
      _nw49[(int)(2793)] = 204;
      _nw49[(int)(2794)] = 200;
      _nw49[(int)(2795)] = 104;
      _nw49[(int)(2796)] = 111;
      _nw49[(int)(2797)] = 50;
      _nw49[(int)(2798)] = 64;
      _nw49[(int)(2799)] = 145;
      _nw49[(int)(2800)] = 51;
      _nw49[(int)(2801)] = 27;
      _nw49[(int)(2802)] = 203;
      _nw49[(int)(2803)] = 240;
      _nw49[(int)(2804)] = 122;
      _nw49[(int)(2805)] = 17;
      _nw49[(int)(2806)] = 70;
      _nw49[(int)(2807)] = 120;
      _nw49[(int)(2808)] = 1;
      _nw49[(int)(2809)] = 192;
      _nw49[(int)(2810)] = 161;
      _nw49[(int)(2811)] = 246;
      _nw49[(int)(2812)] = 120;
      _nw49[(int)(2813)] = 221;
      _nw49[(int)(2814)] = 56;
      _nw49[(int)(2815)] = 102;
      _nw49[(int)(2816)] = 226;
      _nw49[(int)(2817)] = 243;
      _nw49[(int)(2818)] = 151;
      _nw49[(int)(2819)] = 47;
      _nw49[(int)(2820)] = 252;
      _nw49[(int)(2821)] = 221;
      _nw49[(int)(2822)] = 122;
      _nw49[(int)(2823)] = 216;
      _nw49[(int)(2824)] = 38;
      _nw49[(int)(2825)] = 84;
      _nw49[(int)(2826)] = 189;
      _nw49[(int)(2827)] = 181;
      _nw49[(int)(2828)] = 163;
      _nw49[(int)(2829)] = 148;
      _nw49[(int)(2830)] = 228;
      _nw49[(int)(2831)] = 8;
      _nw49[(int)(2832)] = 94;
      _nw49[(int)(2833)] = 101;
      _nw49[(int)(2834)] = 198;
      _nw49[(int)(2835)] = 88;
      _nw49[(int)(2836)] = 98;
      _nw49[(int)(2837)] = 83;
      _nw49[(int)(2838)] = 203;
      _nw49[(int)(2839)] = 70;
      _nw49[(int)(2840)] = 154;
      _nw49[(int)(2841)] = 54;
      _nw49[(int)(2842)] = 209;
      _nw49[(int)(2843)] = 246;
      _nw49[(int)(2844)] = 67;
      _nw49[(int)(2845)] = 249;
      _nw49[(int)(2846)] = 57;
      _nw49[(int)(2847)] = 16;
      _nw49[(int)(2848)] = 201;
      _nw49[(int)(2849)] = 51;
      _nw49[(int)(2850)] = 124;
      _nw49[(int)(2851)] = 26;
      _nw49[(int)(2852)] = 49;
      _nw49[(int)(2853)] = 145;
      _nw49[(int)(2854)] = 66;
      _nw49[(int)(2855)] = 223;
      _nw49[(int)(2856)] = 248;
      _nw49[(int)(2857)] = 72;
      _nw49[(int)(2858)] = 175;
      _nw49[(int)(2859)] = 165;
      _nw49[(int)(2860)] = 134;
      _nw49[(int)(2861)] = 74;
      _nw49[(int)(2862)] = 92;
      _nw49[(int)(2863)] = 72;
      _nw49[(int)(2864)] = 48;
      _nw49[(int)(2865)] = 98;
      _nw49[(int)(2866)] = 114;
      _nw49[(int)(2867)] = 35;
      _nw49[(int)(2868)] = 85;
      _nw49[(int)(2869)] = 105;
      _nw49[(int)(2870)] = 148;
      _nw49[(int)(2871)] = 156;
      _nw49[(int)(2872)] = 103;
      _nw49[(int)(2873)] = 97;
      _nw49[(int)(2874)] = 169;
      _nw49[(int)(2875)] = 153;
      _nw49[(int)(2876)] = 235;
      _nw49[(int)(2877)] = 239;
      _nw49[(int)(2878)] = 191;
      _nw49[(int)(2879)] = 231;
      _nw49[(int)(2880)] = 225;
      _nw49[(int)(2881)] = 126;
      _nw49[(int)(2882)] = 36;
      _nw49[(int)(2883)] = 98;
      _nw49[(int)(2884)] = 56;
      _nw49[(int)(2885)] = 168;
      _nw49[(int)(2886)] = 134;
      _nw49[(int)(2887)] = 215;
      _nw49[(int)(2888)] = 58;
      _nw49[(int)(2889)] = 160;
      _nw49[(int)(2890)] = 149;
      _nw49[(int)(2891)] = 35;
      _nw49[(int)(2892)] = 130;
      _nw49[(int)(2893)] = 124;
      _nw49[(int)(2894)] = 240;
      _nw49[(int)(2895)] = 92;
      _nw49[(int)(2896)] = 107;
      _nw49[(int)(2897)] = 167;
      _nw49[(int)(2898)] = 144;
      _nw49[(int)(2899)] = 47;
      _nw49[(int)(2900)] = 129;
      _nw49[(int)(2901)] = 4;
      _nw49[(int)(2902)] = 82;
      _nw49[(int)(2903)] = 170;
      _nw49[(int)(2904)] = 34;
      _nw49[(int)(2905)] = 226;
      _nw49[(int)(2906)] = 171;
      _nw49[(int)(2907)] = 7;
      _nw49[(int)(2908)] = 123;
      _nw49[(int)(2909)] = 34;
      _nw49[(int)(2910)] = 128;
      _nw49[(int)(2911)] = 236;
      _nw49[(int)(2912)] = 162;
      _nw49[(int)(2913)] = 117;
      _nw49[(int)(2914)] = 108;
      _nw49[(int)(2915)] = 83;
      _nw49[(int)(2916)] = 100;
      _nw49[(int)(2917)] = 180;
      _nw49[(int)(2918)] = 226;
      _nw49[(int)(2919)] = 40;
      _nw49[(int)(2920)] = 251;
      _nw49[(int)(2921)] = 227;
      _nw49[(int)(2922)] = 173;
      _nw49[(int)(2923)] = 171;
      _nw49[(int)(2924)] = 196;
      _nw49[(int)(2925)] = 81;
      _nw49[(int)(2926)] = 82;
      _nw49[(int)(2927)] = 242;
      _nw49[(int)(2928)] = 148;
      _nw49[(int)(2929)] = 193;
      _nw49[(int)(2930)] = 10;
      _nw49[(int)(2931)] = 183;
      _nw49[(int)(2932)] = 51;
      _nw49[(int)(2933)] = 142;
      _nw49[(int)(2934)] = 82;
      _nw49[(int)(2935)] = 76;
      _nw49[(int)(2936)] = 112;
      _nw49[(int)(2937)] = 80;
      _nw49[(int)(2938)] = 206;
      _nw49[(int)(2939)] = 9;
      _nw49[(int)(2940)] = 237;
      _nw49[(int)(2941)] = 227;
      _nw49[(int)(2942)] = 10;
      _nw49[(int)(2943)] = 115;
      _nw49[(int)(2944)] = 182;
      _nw49[(int)(2945)] = 76;
      _nw49[(int)(2946)] = 89;
      _nw49[(int)(2947)] = 224;
      _nw49[(int)(2948)] = 184;
      _nw49[(int)(2949)] = 94;
      _nw49[(int)(2950)] = 13;
      _nw49[(int)(2951)] = 210;
      _nw49[(int)(2952)] = 219;
      _nw49[(int)(2953)] = 136;
      _nw49[(int)(2954)] = 116;
      _nw49[(int)(2955)] = 221;
      _nw49[(int)(2956)] = 59;
      _nw49[(int)(2957)] = 195;
      _nw49[(int)(2958)] = 76;
      _nw49[(int)(2959)] = 144;
      _nw49[(int)(2960)] = 46;
      _nw49[(int)(2961)] = 149;
      _nw49[(int)(2962)] = 59;
      _nw49[(int)(2963)] = 55;
      _nw49[(int)(2964)] = 243;
      _nw49[(int)(2965)] = 129;
      _nw49[(int)(2966)] = 199;
      _nw49[(int)(2967)] = 46;
      _nw49[(int)(2968)] = 180;
      _nw49[(int)(2969)] = 164;
      _nw49[(int)(2970)] = 21;
      _nw49[(int)(2971)] = 0;
      _nw49[(int)(2972)] = 48;
      _nw49[(int)(2973)] = 56;
      _nw49[(int)(2974)] = 201;
      _nw49[(int)(2975)] = 67;
      _nw49[(int)(2976)] = 30;
      _nw49[(int)(2977)] = 190;
      _nw49[(int)(2978)] = 145;
      _nw49[(int)(2979)] = 161;
      _nw49[(int)(2980)] = 130;
      _nw49[(int)(2981)] = 124;
      _nw49[(int)(2982)] = 248;
      _nw49[(int)(2983)] = 29;
      _nw49[(int)(2984)] = 103;
      _nw49[(int)(2985)] = 111;
      _nw49[(int)(2986)] = 14;
      _nw49[(int)(2987)] = 113;
      _nw49[(int)(2988)] = 16;
      _nw49[(int)(2989)] = 54;
      _nw49[(int)(2990)] = 246;
      _nw49[(int)(2991)] = 60;
      _nw49[(int)(2992)] = 1;
      _nw49[(int)(2993)] = 202;
      _nw49[(int)(2994)] = 143;
      _nw49[(int)(2995)] = 67;
      _nw49[(int)(2996)] = 253;
      _nw49[(int)(2997)] = 183;
      _nw49[(int)(2998)] = 141;
      _nw49[(int)(2999)] = 247;
      _nw49[(int)(3000)] = 82;
      _nw49[(int)(3001)] = 84;
      _nw49[(int)(3002)] = 33;
      _nw49[(int)(3003)] = 155;
      _nw49[(int)(3004)] = 177;
      _nw49[(int)(3005)] = 95;
      _nw49[(int)(3006)] = 64;
      _nw49[(int)(3007)] = 132;
      _nw49[(int)(3008)] = 187;
      _nw49[(int)(3009)] = 210;
      _nw49[(int)(3010)] = 167;
      _nw49[(int)(3011)] = 26;
      _nw49[(int)(3012)] = 211;
      _nw49[(int)(3013)] = 170;
      _nw49[(int)(3014)] = 238;
      _nw49[(int)(3015)] = 182;
      _nw49[(int)(3016)] = 239;
      _nw49[(int)(3017)] = 64;
      _nw49[(int)(3018)] = 191;
      _nw49[(int)(3019)] = 31;
      _nw49[(int)(3020)] = 71;
      _nw49[(int)(3021)] = 61;
      _nw49[(int)(3022)] = 186;
      _nw49[(int)(3023)] = 145;
      _nw49[(int)(3024)] = 168;
      _nw49[(int)(3025)] = 133;
      _nw49[(int)(3026)] = 42;
      _nw49[(int)(3027)] = 19;
      _nw49[(int)(3028)] = 20;
      _nw49[(int)(3029)] = 242;
      _nw49[(int)(3030)] = 220;
      _nw49[(int)(3031)] = 132;
      _nw49[(int)(3032)] = 159;
      _nw49[(int)(3033)] = 235;
      _nw49[(int)(3034)] = 202;
      _nw49[(int)(3035)] = 151;
      _nw49[(int)(3036)] = 230;
      _nw49[(int)(3037)] = 219;
      _nw49[(int)(3038)] = 62;
      _nw49[(int)(3039)] = 57;
      _nw49[(int)(3040)] = 20;
      _nw49[(int)(3041)] = 230;
      _nw49[(int)(3042)] = 153;
      _nw49[(int)(3043)] = 229;
      _nw49[(int)(3044)] = 128;
      _nw49[(int)(3045)] = 20;
      _nw49[(int)(3046)] = 32;
      _nw49[(int)(3047)] = 228;
      _nw49[(int)(3048)] = 11;
      _nw49[(int)(3049)] = 179;
      _nw49[(int)(3050)] = 50;
      _nw49[(int)(3051)] = 90;
      _nw49[(int)(3052)] = 158;
      _nw49[(int)(3053)] = 105;
      _nw49[(int)(3054)] = 167;
      _nw49[(int)(3055)] = 76;
      _nw49[(int)(3056)] = 140;
      _nw49[(int)(3057)] = 183;
      _nw49[(int)(3058)] = 31;
      _nw49[(int)(3059)] = 159;
      _nw49[(int)(3060)] = 183;
      _nw49[(int)(3061)] = 44;
      _nw49[(int)(3062)] = 130;
      _nw49[(int)(3063)] = 32;
      _nw49[(int)(3064)] = 146;
      _nw49[(int)(3065)] = 240;
      _nw49[(int)(3066)] = 13;
      _nw49[(int)(3067)] = 57;
      _nw49[(int)(3068)] = 151;
      _nw49[(int)(3069)] = 65;
      _nw49[(int)(3070)] = 60;
      _nw49[(int)(3071)] = 180;
      _nw49[(int)(3072)] = 161;
      _nw49[(int)(3073)] = 96;
      _nw49[(int)(3074)] = 103;
      _nw49[(int)(3075)] = 8;
      _nw49[(int)(3076)] = 68;
      _nw49[(int)(3077)] = 204;
      _nw49[(int)(3078)] = 156;
      _nw49[(int)(3079)] = 202;
      _nw49[(int)(3080)] = 11;
      _nw49[(int)(3081)] = 68;
      _nw49[(int)(3082)] = 182;
      _nw49[(int)(3083)] = 177;
      _nw49[(int)(3084)] = 53;
      _nw49[(int)(3085)] = 73;
      _nw49[(int)(3086)] = 204;
      _nw49[(int)(3087)] = 167;
      _nw49[(int)(3088)] = 175;
      _nw49[(int)(3089)] = 193;
      _nw49[(int)(3090)] = 20;
      _nw49[(int)(3091)] = 1;
      _nw49[(int)(3092)] = 170;
      _nw49[(int)(3093)] = 111;
      _nw49[(int)(3094)] = 249;
      _nw49[(int)(3095)] = 29;
      _nw49[(int)(3096)] = 142;
      _nw49[(int)(3097)] = 198;
      _nw49[(int)(3098)] = 30;
      _nw49[(int)(3099)] = 147;
      _nw49[(int)(3100)] = 25;
      _nw49[(int)(3101)] = 241;
      _nw49[(int)(3102)] = 3;
      _nw49[(int)(3103)] = 22;
      _nw49[(int)(3104)] = 147;
      _nw49[(int)(3105)] = 72;
      _nw49[(int)(3106)] = 123;
      _nw49[(int)(3107)] = 245;
      _nw49[(int)(3108)] = 109;
      _nw49[(int)(3109)] = 181;
      _nw49[(int)(3110)] = 67;
      _nw49[(int)(3111)] = 162;
      _nw49[(int)(3112)] = 164;
      _nw49[(int)(3113)] = 154;
      _nw49[(int)(3114)] = 71;
      _nw49[(int)(3115)] = 28;
      _nw49[(int)(3116)] = 48;
      _nw49[(int)(3117)] = 11;
      _nw49[(int)(3118)] = 204;
      _nw49[(int)(3119)] = 2;
      _nw49[(int)(3120)] = 143;
      _nw49[(int)(3121)] = 150;
      _nw49[(int)(3122)] = 6;
      _nw49[(int)(3123)] = 72;
      _nw49[(int)(3124)] = 9;
      _nw49[(int)(3125)] = 108;
      _nw49[(int)(3126)] = 187;
      _nw49[(int)(3127)] = 16;
      _nw49[(int)(3128)] = 209;
      _nw49[(int)(3129)] = 184;
      _nw49[(int)(3130)] = 1;
      _nw49[(int)(3131)] = 183;
      _nw49[(int)(3132)] = 131;
      _nw49[(int)(3133)] = 219;
      _nw49[(int)(3134)] = 118;
      _nw49[(int)(3135)] = 1;
      _nw49[(int)(3136)] = 61;
      _nw49[(int)(3137)] = 12;
      _nw49[(int)(3138)] = 60;
      _nw49[(int)(3139)] = 187;
      _nw49[(int)(3140)] = 47;
      _nw49[(int)(3141)] = 30;
      _nw49[(int)(3142)] = 1;
      _nw49[(int)(3143)] = 154;
      _nw49[(int)(3144)] = 234;
      _nw49[(int)(3145)] = 127;
      _nw49[(int)(3146)] = 23;
      _nw49[(int)(3147)] = 194;
      _nw49[(int)(3148)] = 199;
      _nw49[(int)(3149)] = 194;
      _nw49[(int)(3150)] = 204;
      _nw49[(int)(3151)] = 226;
      _nw49[(int)(3152)] = 124;
      _nw49[(int)(3153)] = 222;
      _nw49[(int)(3154)] = 166;
      _nw49[(int)(3155)] = 249;
      _nw49[(int)(3156)] = 88;
      _nw49[(int)(3157)] = 54;
      _nw49[(int)(3158)] = 191;
      _nw49[(int)(3159)] = 118;
      _nw49[(int)(3160)] = 221;
      _nw49[(int)(3161)] = 27;
      _nw49[(int)(3162)] = 238;
      _nw49[(int)(3163)] = 61;
      _nw49[(int)(3164)] = 134;
      _nw49[(int)(3165)] = 23;
      _nw49[(int)(3166)] = 175;
      _nw49[(int)(3167)] = 218;
      _nw49[(int)(3168)] = 197;
      _nw49[(int)(3169)] = 42;
      _nw49[(int)(3170)] = 210;
      _nw49[(int)(3171)] = 43;
      _nw49[(int)(3172)] = 179;
      _nw49[(int)(3173)] = 250;
      _nw49[(int)(3174)] = 0;
      _nw49[(int)(3175)] = 245;
      _nw49[(int)(3176)] = 102;
      _nw49[(int)(3177)] = 222;
      _nw49[(int)(3178)] = 196;
      _nw49[(int)(3179)] = 95;
      _nw49[(int)(3180)] = 250;
      _nw49[(int)(3181)] = 62;
      _nw49[(int)(3182)] = 152;
      _nw49[(int)(3183)] = 49;
      _nw49[(int)(3184)] = 131;
      _nw49[(int)(3185)] = 181;
      _nw49[(int)(3186)] = 121;
      _nw49[(int)(3187)] = 77;
      _nw49[(int)(3188)] = 23;
      _nw49[(int)(3189)] = 50;
      _nw49[(int)(3190)] = 244;
      _nw49[(int)(3191)] = 106;
      _nw49[(int)(3192)] = 205;
      _nw49[(int)(3193)] = 227;
      _nw49[(int)(3194)] = 163;
      _nw49[(int)(3195)] = 221;
      _nw49[(int)(3196)] = 250;
      _nw49[(int)(3197)] = 232;
      _nw49[(int)(3198)] = 106;
      _nw49[(int)(3199)] = 230;
      _nw49[(int)(3200)] = 62;
      _nw49[(int)(3201)] = 134;
      _nw49[(int)(3202)] = 235;
      _nw49[(int)(3203)] = 121;
      _nw49[(int)(3204)] = 225;
      _nw49[(int)(3205)] = 253;
      _nw49[(int)(3206)] = 210;
      _nw49[(int)(3207)] = 123;
      _nw49[(int)(3208)] = 204;
      _nw49[(int)(3209)] = 57;
      _nw49[(int)(3210)] = 218;
      _nw49[(int)(3211)] = 6;
      _nw49[(int)(3212)] = 228;
      _nw49[(int)(3213)] = 128;
      _nw49[(int)(3214)] = 9;
      _nw49[(int)(3215)] = 13;
      _nw49[(int)(3216)] = 245;
      _nw49[(int)(3217)] = 98;
      _nw49[(int)(3218)] = 218;
      _nw49[(int)(3219)] = 158;
      _nw49[(int)(3220)] = 229;
      _nw49[(int)(3221)] = 137;
      _nw49[(int)(3222)] = 238;
      _nw49[(int)(3223)] = 231;
      _nw49[(int)(3224)] = 13;
      _nw49[(int)(3225)] = 197;
      _nw49[(int)(3226)] = 185;
      _nw49[(int)(3227)] = 214;
      _nw49[(int)(3228)] = 136;
      _nw49[(int)(3229)] = 249;
      _nw49[(int)(3230)] = 173;
      _nw49[(int)(3231)] = 108;
      _nw49[(int)(3232)] = 236;
      _nw49[(int)(3233)] = 122;
      _nw49[(int)(3234)] = 0;
      _nw49[(int)(3235)] = 70;
      _nw49[(int)(3236)] = 154;
      _nw49[(int)(3237)] = 216;
      _nw49[(int)(3238)] = 73;
      _nw49[(int)(3239)] = 195;
      _nw49[(int)(3240)] = 64;
      _nw49[(int)(3241)] = 195;
      _nw49[(int)(3242)] = 75;
      _nw49[(int)(3243)] = 204;
      _nw49[(int)(3244)] = 33;
      _nw49[(int)(3245)] = 188;
      _nw49[(int)(3246)] = 49;
      _nw49[(int)(3247)] = 244;
      _nw49[(int)(3248)] = 238;
      _nw49[(int)(3249)] = 203;
      _nw49[(int)(3250)] = 100;
      _nw49[(int)(3251)] = 137;
      _nw49[(int)(3252)] = 9;
      _nw49[(int)(3253)] = 102;
      _nw49[(int)(3254)] = 65;
      _nw49[(int)(3255)] = 109;
      _nw49[(int)(3256)] = 56;
      _nw49[(int)(3257)] = 211;
      _nw49[(int)(3258)] = 159;
      _nw49[(int)(3259)] = 204;
      _nw49[(int)(3260)] = 80;
      _nw49[(int)(3261)] = 109;
      _nw49[(int)(3262)] = 237;
      _nw49[(int)(3263)] = 106;
      _nw49[(int)(3264)] = 203;
      _nw49[(int)(3265)] = 41;
      _nw49[(int)(3266)] = 114;
      _nw49[(int)(3267)] = 50;
      _nw49[(int)(3268)] = 80;
      _nw49[(int)(3269)] = 65;
      _nw49[(int)(3270)] = 189;
      _nw49[(int)(3271)] = 52;
      _nw49[(int)(3272)] = 143;
      _nw49[(int)(3273)] = 97;
      _nw49[(int)(3274)] = 126;
      _nw49[(int)(3275)] = 61;
      _nw49[(int)(3276)] = 211;
      _nw49[(int)(3277)] = 99;
      _nw49[(int)(3278)] = 207;
      _nw49[(int)(3279)] = 82;
      _nw49[(int)(3280)] = 150;
      _nw49[(int)(3281)] = 91;
      _nw49[(int)(3282)] = 10;
      _nw49[(int)(3283)] = 35;
      _nw49[(int)(3284)] = 248;
      _nw49[(int)(3285)] = 10;
      _nw49[(int)(3286)] = 26;
      _nw49[(int)(3287)] = 191;
      _nw49[(int)(3288)] = 154;
      _nw49[(int)(3289)] = 177;
      _nw49[(int)(3290)] = 166;
      _nw49[(int)(3291)] = 156;
      _nw49[(int)(3292)] = 25;
      _nw49[(int)(3293)] = 127;
      _nw49[(int)(3294)] = 135;
      _nw49[(int)(3295)] = 193;
      _nw49[(int)(3296)] = 233;
      _nw49[(int)(3297)] = 15;
      _nw49[(int)(3298)] = 173;
      _nw49[(int)(3299)] = 208;
      _nw49[(int)(3300)] = 73;
      _nw49[(int)(3301)] = 11;
      _nw49[(int)(3302)] = 150;
      _nw49[(int)(3303)] = 25;
      _nw49[(int)(3304)] = 26;
      _nw49[(int)(3305)] = 29;
      _nw49[(int)(3306)] = 73;
      _nw49[(int)(3307)] = 141;
      _nw49[(int)(3308)] = 142;
      _nw49[(int)(3309)] = 147;
      _nw49[(int)(3310)] = 165;
      _nw49[(int)(3311)] = 109;
      _nw49[(int)(3312)] = 30;
      _nw49[(int)(3313)] = 58;
      _nw49[(int)(3314)] = 226;
      _nw49[(int)(3315)] = 226;
      _nw49[(int)(3316)] = 114;
      _nw49[(int)(3317)] = 128;
      _nw49[(int)(3318)] = 146;
      _nw49[(int)(3319)] = 59;
      _nw49[(int)(3320)] = 168;
      _nw49[(int)(3321)] = 6;
      _nw49[(int)(3322)] = 166;
      _nw49[(int)(3323)] = 94;
      _nw49[(int)(3324)] = 173;
      _nw49[(int)(3325)] = 53;
      _nw49[(int)(3326)] = 182;
      _nw49[(int)(3327)] = 178;
      _nw49[(int)(3328)] = 217;
      _nw49[(int)(3329)] = 238;
      _nw49[(int)(3330)] = 237;
      _nw49[(int)(3331)] = 0;
      _nw49[(int)(3332)] = 181;
      _nw49[(int)(3333)] = 161;
      _nw49[(int)(3334)] = 226;
      _nw49[(int)(3335)] = 15;
      _nw49[(int)(3336)] = 6;
      _nw49[(int)(3337)] = 225;
      _nw49[(int)(3338)] = 231;
      _nw49[(int)(3339)] = 180;
      _nw49[(int)(3340)] = 45;
      _nw49[(int)(3341)] = 62;
      _nw49[(int)(3342)] = 41;
      _nw49[(int)(3343)] = 186;
      _nw49[(int)(3344)] = 174;
      _nw49[(int)(3345)] = 29;
      _nw49[(int)(3346)] = 58;
      _nw49[(int)(3347)] = 89;
      _nw49[(int)(3348)] = 93;
      _nw49[(int)(3349)] = 239;
      _nw49[(int)(3350)] = 235;
      _nw49[(int)(3351)] = 210;
      _nw49[(int)(3352)] = 184;
      _nw49[(int)(3353)] = 20;
      _nw49[(int)(3354)] = 172;
      _nw49[(int)(3355)] = 82;
      _nw49[(int)(3356)] = 28;
      _nw49[(int)(3357)] = 90;
      _nw49[(int)(3358)] = 189;
      _nw49[(int)(3359)] = 232;
      _nw49[(int)(3360)] = 136;
      _nw49[(int)(3361)] = 72;
      _nw49[(int)(3362)] = 199;
      _nw49[(int)(3363)] = 222;
      _nw49[(int)(3364)] = 73;
      _nw49[(int)(3365)] = 202;
      _nw49[(int)(3366)] = 226;
      _nw49[(int)(3367)] = 11;
      _nw49[(int)(3368)] = 54;
      _nw49[(int)(3369)] = 127;
      _nw49[(int)(3370)] = 180;
      _nw49[(int)(3371)] = 169;
      _nw49[(int)(3372)] = 171;
      _nw49[(int)(3373)] = 70;
      _nw49[(int)(3374)] = 241;
      _nw49[(int)(3375)] = 127;
      _nw49[(int)(3376)] = 54;
      _nw49[(int)(3377)] = 10;
      _nw49[(int)(3378)] = 188;
      _nw49[(int)(3379)] = 18;
      _nw49[(int)(3380)] = 52;
      _nw49[(int)(3381)] = 179;
      _nw49[(int)(3382)] = 174;
      _nw49[(int)(3383)] = 41;
      _nw49[(int)(3384)] = 240;
      _nw49[(int)(3385)] = 214;
      _nw49[(int)(3386)] = 15;
      _nw49[(int)(3387)] = 3;
      _nw49[(int)(3388)] = 202;
      _nw49[(int)(3389)] = 144;
      _nw49[(int)(3390)] = 47;
      _nw49[(int)(3391)] = 170;
      _nw49[(int)(3392)] = 8;
      _nw49[(int)(3393)] = 230;
      _nw49[(int)(3394)] = 76;
      _nw49[(int)(3395)] = 202;
      _nw49[(int)(3396)] = 220;
      _nw49[(int)(3397)] = 151;
      _nw49[(int)(3398)] = 200;
      _nw49[(int)(3399)] = 155;
      _nw49[(int)(3400)] = 194;
      _nw49[(int)(3401)] = 211;
      _nw49[(int)(3402)] = 78;
      _nw49[(int)(3403)] = 4;
      _nw49[(int)(3404)] = 79;
      _nw49[(int)(3405)] = 107;
      _nw49[(int)(3406)] = 135;
      _nw49[(int)(3407)] = 10;
      _nw49[(int)(3408)] = 114;
      _nw49[(int)(3409)] = 195;
      _nw49[(int)(3410)] = 97;
      _nw49[(int)(3411)] = 80;
      _nw49[(int)(3412)] = 158;
      _nw49[(int)(3413)] = 160;
      _nw49[(int)(3414)] = 39;
      _nw49[(int)(3415)] = 159;
      _nw49[(int)(3416)] = 191;
      _nw49[(int)(3417)] = 12;
      _nw49[(int)(3418)] = 203;
      _nw49[(int)(3419)] = 8;
      _nw49[(int)(3420)] = 144;
      _nw49[(int)(3421)] = 0;
      _nw49[(int)(3422)] = 65;
      _nw49[(int)(3423)] = 65;
      _nw49[(int)(3424)] = 199;
      _nw49[(int)(3425)] = 187;
      _nw49[(int)(3426)] = 239;
      _nw49[(int)(3427)] = 153;
      _nw49[(int)(3428)] = 142;
      _nw49[(int)(3429)] = 22;
      _nw49[(int)(3430)] = 189;
      _nw49[(int)(3431)] = 24;
      _nw49[(int)(3432)] = 29;
      _nw49[(int)(3433)] = 14;
      _nw49[(int)(3434)] = 64;
      _nw49[(int)(3435)] = 129;
      _nw49[(int)(3436)] = 12;
      _nw49[(int)(3437)] = 145;
      _nw49[(int)(3438)] = 145;
      _nw49[(int)(3439)] = 129;
      _nw49[(int)(3440)] = 49;
      _nw49[(int)(3441)] = 40;
      _nw49[(int)(3442)] = 240;
      _nw49[(int)(3443)] = 223;
      _nw49[(int)(3444)] = 128;
      _nw49[(int)(3445)] = 201;
      _nw49[(int)(3446)] = 26;
      _nw49[(int)(3447)] = 182;
      _nw49[(int)(3448)] = 61;
      _nw49[(int)(3449)] = 174;
      _nw49[(int)(3450)] = 225;
      _nw49[(int)(3451)] = 1;
      _nw49[(int)(3452)] = 223;
      _nw49[(int)(3453)] = 171;
      _nw49[(int)(3454)] = 59;
      _nw49[(int)(3455)] = 159;
      _nw49[(int)(3456)] = 201;
      _nw49[(int)(3457)] = 74;
      _nw49[(int)(3458)] = 11;
      _nw49[(int)(3459)] = 204;
      _nw49[(int)(3460)] = 192;
      _nw49[(int)(3461)] = 93;
      _nw49[(int)(3462)] = 175;
      _nw49[(int)(3463)] = 109;
      _nw49[(int)(3464)] = 89;
      _nw49[(int)(3465)] = 186;
      _nw49[(int)(3466)] = 74;
      _nw49[(int)(3467)] = 148;
      _nw49[(int)(3468)] = 19;
      _nw49[(int)(3469)] = 207;
      _nw49[(int)(3470)] = 215;
      _nw49[(int)(3471)] = 60;
      _nw49[(int)(3472)] = 94;
      _nw49[(int)(3473)] = 188;
      _nw49[(int)(3474)] = 184;
      _nw49[(int)(3475)] = 87;
      _nw49[(int)(3476)] = 31;
      _nw49[(int)(3477)] = 170;
      _nw49[(int)(3478)] = 170;
      _nw49[(int)(3479)] = 200;
      _nw49[(int)(3480)] = 43;
      _nw49[(int)(3481)] = 193;
      _nw49[(int)(3482)] = 231;
      _nw49[(int)(3483)] = 116;
      _nw49[(int)(3484)] = 166;
      _nw49[(int)(3485)] = 2;
      _nw49[(int)(3486)] = 84;
      _nw49[(int)(3487)] = 77;
      _nw49[(int)(3488)] = 136;
      _nw49[(int)(3489)] = 177;
      _nw49[(int)(3490)] = 196;
      _nw49[(int)(3491)] = 19;
      _nw49[(int)(3492)] = 231;
      _nw49[(int)(3493)] = 169;
      _nw49[(int)(3494)] = 37;
      _nw49[(int)(3495)] = 139;
      _nw49[(int)(3496)] = 234;
      _nw49[(int)(3497)] = 103;
      _nw49[(int)(3498)] = 196;
      _nw49[(int)(3499)] = 47;
      _nw49[(int)(3500)] = 201;
      _nw49[(int)(3501)] = 140;
      _nw49[(int)(3502)] = 19;
      _nw49[(int)(3503)] = 80;
      _nw49[(int)(3504)] = 217;
      _nw49[(int)(3505)] = 202;
      _nw49[(int)(3506)] = 212;
      _nw49[(int)(3507)] = 19;
      _nw49[(int)(3508)] = 113;
      _nw49[(int)(3509)] = 208;
      _nw49[(int)(3510)] = 250;
      _nw49[(int)(3511)] = 49;
      _nw49[(int)(3512)] = 155;
      _nw49[(int)(3513)] = 47;
      _nw49[(int)(3514)] = 62;
      _nw49[(int)(3515)] = 119;
      _nw49[(int)(3516)] = 86;
      _nw49[(int)(3517)] = 36;
      _nw49[(int)(3518)] = 206;
      _nw49[(int)(3519)] = 139;
      _nw49[(int)(3520)] = 99;
      _nw49[(int)(3521)] = 18;
      _nw49[(int)(3522)] = 225;
      _nw49[(int)(3523)] = 41;
      _nw49[(int)(3524)] = 11;
      _nw49[(int)(3525)] = 37;
      _nw49[(int)(3526)] = 231;
      _nw49[(int)(3527)] = 220;
      _nw49[(int)(3528)] = 3;
      _nw49[(int)(3529)] = 189;
      _nw49[(int)(3530)] = 248;
      _nw49[(int)(3531)] = 198;
      _nw49[(int)(3532)] = 187;
      _nw49[(int)(3533)] = 123;
      _nw49[(int)(3534)] = 46;
      _nw49[(int)(3535)] = 7;
      _nw49[(int)(3536)] = 26;
      _nw49[(int)(3537)] = 160;
      _nw49[(int)(3538)] = 122;
      _nw49[(int)(3539)] = 227;
      _nw49[(int)(3540)] = 11;
      _nw49[(int)(3541)] = 71;
      _nw49[(int)(3542)] = 169;
      _nw49[(int)(3543)] = 210;
      _nw49[(int)(3544)] = 82;
      _nw49[(int)(3545)] = 62;
      _nw49[(int)(3546)] = 40;
      _nw49[(int)(3547)] = 133;
      _nw49[(int)(3548)] = 2;
      _nw49[(int)(3549)] = 58;
      _nw49[(int)(3550)] = 88;
      _nw49[(int)(3551)] = 177;
      _nw49[(int)(3552)] = 245;
      _nw49[(int)(3553)] = 84;
      _nw49[(int)(3554)] = 74;
      _nw49[(int)(3555)] = 33;
      _nw49[(int)(3556)] = 70;
      _nw49[(int)(3557)] = 146;
      _nw49[(int)(3558)] = 209;
      _nw49[(int)(3559)] = 67;
      _nw49[(int)(3560)] = 170;
      _nw49[(int)(3561)] = 38;
      _nw49[(int)(3562)] = 248;
      _nw49[(int)(3563)] = 134;
      _nw49[(int)(3564)] = 133;
      _nw49[(int)(3565)] = 137;
      _nw49[(int)(3566)] = 111;
      _nw49[(int)(3567)] = 82;
      _nw49[(int)(3568)] = 189;
      _nw49[(int)(3569)] = 205;
      _nw49[(int)(3570)] = 119;
      _nw49[(int)(3571)] = 37;
      _nw49[(int)(3572)] = 138;
      _nw49[(int)(3573)] = 173;
      _nw49[(int)(3574)] = 97;
      _nw49[(int)(3575)] = 220;
      _nw49[(int)(3576)] = 110;
      _nw49[(int)(3577)] = 131;
      _nw49[(int)(3578)] = 39;
      _nw49[(int)(3579)] = 51;
      _nw49[(int)(3580)] = 179;
      _nw49[(int)(3581)] = 80;
      _nw49[(int)(3582)] = 238;
      _nw49[(int)(3583)] = 111;
      _nw49[(int)(3584)] = 41;
      _nw49[(int)(3585)] = 47;
      _nw49[(int)(3586)] = 100;
      _nw49[(int)(3587)] = 82;
      _nw49[(int)(3588)] = 102;
      _nw49[(int)(3589)] = 226;
      _nw49[(int)(3590)] = 191;
      _nw49[(int)(3591)] = 244;
      _nw49[(int)(3592)] = 106;
      _nw49[(int)(3593)] = 26;
      _nw49[(int)(3594)] = 21;
      _nw49[(int)(3595)] = 81;
      _nw49[(int)(3596)] = 203;
      _nw49[(int)(3597)] = 54;
      _nw49[(int)(3598)] = 182;
      _nw49[(int)(3599)] = 88;
      _nw49[(int)(3600)] = 112;
      _nw49[(int)(3601)] = 153;
      _nw49[(int)(3602)] = 195;
      _nw49[(int)(3603)] = 82;
      _nw49[(int)(3604)] = 29;
      _nw49[(int)(3605)] = 182;
      _nw49[(int)(3606)] = 181;
      _nw49[(int)(3607)] = 56;
      _nw49[(int)(3608)] = 102;
      _nw49[(int)(3609)] = 230;
      _nw49[(int)(3610)] = 255;
      _nw49[(int)(3611)] = 245;
      _nw49[(int)(3612)] = 37;
      _nw49[(int)(3613)] = 145;
      _nw49[(int)(3614)] = 199;
      _nw49[(int)(3615)] = 62;
      _nw49[(int)(3616)] = 84;
      _nw49[(int)(3617)] = 201;
      _nw49[(int)(3618)] = 155;
      _nw49[(int)(3619)] = 19;
      _nw49[(int)(3620)] = 186;
      _nw49[(int)(3621)] = 75;
      _nw49[(int)(3622)] = 218;
      _nw49[(int)(3623)] = 57;
      _nw49[(int)(3624)] = 210;
      _nw49[(int)(3625)] = 210;
      _nw49[(int)(3626)] = 91;
      _nw49[(int)(3627)] = 163;
      _nw49[(int)(3628)] = 20;
      _nw49[(int)(3629)] = 133;
      _nw49[(int)(3630)] = 8;
      _nw49[(int)(3631)] = 120;
      _nw49[(int)(3632)] = 150;
      _nw49[(int)(3633)] = 20;
      _nw49[(int)(3634)] = 142;
      _nw49[(int)(3635)] = 4;
      _nw49[(int)(3636)] = 125;
      _nw49[(int)(3637)] = 233;
      _nw49[(int)(3638)] = 42;
      _nw49[(int)(3639)] = 248;
      _nw49[(int)(3640)] = 116;
      _nw49[(int)(3641)] = 117;
      _nw49[(int)(3642)] = 94;
      _nw49[(int)(3643)] = 133;
      _nw49[(int)(3644)] = 70;
      _nw49[(int)(3645)] = 7;
      _nw49[(int)(3646)] = 63;
      _nw49[(int)(3647)] = 114;
      _nw49[(int)(3648)] = 197;
      _nw49[(int)(3649)] = 67;
      _nw49[(int)(3650)] = 39;
      _nw49[(int)(3651)] = 222;
      _nw49[(int)(3652)] = 122;
      _nw49[(int)(3653)] = 234;
      _nw49[(int)(3654)] = 104;
      _nw49[(int)(3655)] = 125;
      _nw49[(int)(3656)] = 232;
      _nw49[(int)(3657)] = 122;
      _nw49[(int)(3658)] = 143;
      _nw49[(int)(3659)] = 195;
      _nw49[(int)(3660)] = 45;
      _nw49[(int)(3661)] = 157;
      _nw49[(int)(3662)] = 114;
      _nw49[(int)(3663)] = 176;
      _nw49[(int)(3664)] = 82;
      _nw49[(int)(3665)] = 229;
      _nw49[(int)(3666)] = 54;
      _nw49[(int)(3667)] = 250;
      _nw49[(int)(3668)] = 135;
      _nw49[(int)(3669)] = 1;
      _nw49[(int)(3670)] = 52;
      _nw49[(int)(3671)] = 55;
      _nw49[(int)(3672)] = 18;
      _nw49[(int)(3673)] = 138;
      _nw49[(int)(3674)] = 116;
      _nw49[(int)(3675)] = 134;
      _nw49[(int)(3676)] = 31;
      _nw49[(int)(3677)] = 74;
      _nw49[(int)(3678)] = 64;
      _nw49[(int)(3679)] = 43;
      _nw49[(int)(3680)] = 209;
      _nw49[(int)(3681)] = 254;
      _nw49[(int)(3682)] = 34;
      _nw49[(int)(3683)] = 111;
      _nw49[(int)(3684)] = 92;
      _nw49[(int)(3685)] = 200;
      _nw49[(int)(3686)] = 10;
      _nw49[(int)(3687)] = 140;
      _nw49[(int)(3688)] = 49;
      _nw49[(int)(3689)] = 67;
      _nw49[(int)(3690)] = 18;
      _nw49[(int)(3691)] = 114;
      _nw49[(int)(3692)] = 100;
      _nw49[(int)(3693)] = 189;
      _nw49[(int)(3694)] = 107;
      _nw49[(int)(3695)] = 231;
      _nw49[(int)(3696)] = 23;
      _nw49[(int)(3697)] = 114;
      _nw49[(int)(3698)] = 227;
      _nw49[(int)(3699)] = 253;
      _nw49[(int)(3700)] = 127;
      _nw49[(int)(3701)] = 246;
      _nw49[(int)(3702)] = 129;
      _nw49[(int)(3703)] = 118;
      _nw49[(int)(3704)] = 169;
      _nw49[(int)(3705)] = 67;
      _nw49[(int)(3706)] = 221;
      _nw49[(int)(3707)] = 82;
      _nw49[(int)(3708)] = 93;
      _nw49[(int)(3709)] = 188;
      _nw49[(int)(3710)] = 59;
      _nw49[(int)(3711)] = 247;
      _nw49[(int)(3712)] = 160;
      _nw49[(int)(3713)] = 148;
      _nw49[(int)(3714)] = 206;
      _nw49[(int)(3715)] = 214;
      _nw49[(int)(3716)] = 192;
      _nw49[(int)(3717)] = 220;
      _nw49[(int)(3718)] = 177;
      _nw49[(int)(3719)] = 160;
      _nw49[(int)(3720)] = 222;
      _nw49[(int)(3721)] = 130;
      _nw49[(int)(3722)] = 229;
      _nw49[(int)(3723)] = 165;
      _nw49[(int)(3724)] = 39;
      _nw49[(int)(3725)] = 49;
      _nw49[(int)(3726)] = 3;
      _nw49[(int)(3727)] = 173;
      _nw49[(int)(3728)] = 100;
      _nw49[(int)(3729)] = 148;
      _nw49[(int)(3730)] = 119;
      _nw49[(int)(3731)] = 124;
      _nw49[(int)(3732)] = 211;
      _nw49[(int)(3733)] = 223;
      _nw49[(int)(3734)] = 138;
      _nw49[(int)(3735)] = 142;
      _nw49[(int)(3736)] = 149;
      _nw49[(int)(3737)] = 32;
      _nw49[(int)(3738)] = 217;
      _nw49[(int)(3739)] = 135;
      _nw49[(int)(3740)] = 173;
      _nw49[(int)(3741)] = 39;
      _nw49[(int)(3742)] = 68;
      _nw49[(int)(3743)] = 196;
      _nw49[(int)(3744)] = 97;
      _nw49[(int)(3745)] = 178;
      _nw49[(int)(3746)] = 50;
      _nw49[(int)(3747)] = 65;
      _nw49[(int)(3748)] = 11;
      _nw49[(int)(3749)] = 167;
      _nw49[(int)(3750)] = 48;
      _nw49[(int)(3751)] = 40;
      _nw49[(int)(3752)] = 212;
      _nw49[(int)(3753)] = 93;
      _nw49[(int)(3754)] = 228;
      _nw49[(int)(3755)] = 219;
      _nw49[(int)(3756)] = 210;
      _nw49[(int)(3757)] = 173;
      _nw49[(int)(3758)] = 188;
      _nw49[(int)(3759)] = 45;
      _nw49[(int)(3760)] = 108;
      _nw49[(int)(3761)] = 29;
      _nw49[(int)(3762)] = 214;
      _nw49[(int)(3763)] = 177;
      _nw49[(int)(3764)] = 249;
      _nw49[(int)(3765)] = 194;
      _nw49[(int)(3766)] = 57;
      _nw49[(int)(3767)] = 145;
      _nw49[(int)(3768)] = 85;
      _nw49[(int)(3769)] = 2;
      _nw49[(int)(3770)] = 236;
      _nw49[(int)(3771)] = 155;
      _nw49[(int)(3772)] = 96;
      _nw49[(int)(3773)] = 186;
      _nw49[(int)(3774)] = 7;
      _nw49[(int)(3775)] = 219;
      _nw49[(int)(3776)] = 63;
      _nw49[(int)(3777)] = 26;
      _nw49[(int)(3778)] = 70;
      _nw49[(int)(3779)] = 109;
      _nw49[(int)(3780)] = 2;
      _nw49[(int)(3781)] = 247;
      _nw49[(int)(3782)] = 216;
      _nw49[(int)(3783)] = 110;
      _nw49[(int)(3784)] = 31;
      _nw49[(int)(3785)] = 122;
      _nw49[(int)(3786)] = 88;
      _nw49[(int)(3787)] = 160;
      _nw49[(int)(3788)] = 38;
      _nw49[(int)(3789)] = 240;
      _nw49[(int)(3790)] = 95;
      _nw49[(int)(3791)] = 241;
      _nw49[(int)(3792)] = 76;
      _nw49[(int)(3793)] = 18;
      _nw49[(int)(3794)] = 197;
      _nw49[(int)(3795)] = 108;
      _nw49[(int)(3796)] = 241;
      _nw49[(int)(3797)] = 133;
      _nw49[(int)(3798)] = 56;
      _nw49[(int)(3799)] = 119;
      _nw49[(int)(3800)] = 156;
      _nw49[(int)(3801)] = 84;
      _nw49[(int)(3802)] = 109;
      _nw49[(int)(3803)] = 141;
      _nw49[(int)(3804)] = 45;
      _nw49[(int)(3805)] = 39;
      _nw49[(int)(3806)] = 98;
      _nw49[(int)(3807)] = 12;
      _nw49[(int)(3808)] = 117;
      _nw49[(int)(3809)] = 130;
      _nw49[(int)(3810)] = 239;
      _nw49[(int)(3811)] = 179;
      _nw49[(int)(3812)] = 253;
      _nw49[(int)(3813)] = 24;
      _nw49[(int)(3814)] = 145;
      _nw49[(int)(3815)] = 104;
      _nw49[(int)(3816)] = 239;
      _nw49[(int)(3817)] = 225;
      _nw49[(int)(3818)] = 168;
      _nw49[(int)(3819)] = 105;
      _nw49[(int)(3820)] = 146;
      _nw49[(int)(3821)] = 191;
      _nw49[(int)(3822)] = 20;
      _nw49[(int)(3823)] = 196;
      _nw49[(int)(3824)] = 9;
      _nw49[(int)(3825)] = 44;
      _nw49[(int)(3826)] = 136;
      _nw49[(int)(3827)] = 238;
      _nw49[(int)(3828)] = 81;
      _nw49[(int)(3829)] = 135;
      _nw49[(int)(3830)] = 251;
      _nw49[(int)(3831)] = 183;
      _nw49[(int)(3832)] = 129;
      _nw49[(int)(3833)] = 43;
      _nw49[(int)(3834)] = 76;
      _nw49[(int)(3835)] = 105;
      _nw49[(int)(3836)] = 222;
      _nw49[(int)(3837)] = 136;
      _nw49[(int)(3838)] = 12;
      _nw49[(int)(3839)] = 183;
      _nw49[(int)(3840)] = 190;
      _nw49[(int)(3841)] = 46;
      _nw49[(int)(3842)] = 194;
      _nw49[(int)(3843)] = 166;
      _nw49[(int)(3844)] = 177;
      _nw49[(int)(3845)] = 230;
      _nw49[(int)(3846)] = 218;
      _nw49[(int)(3847)] = 209;
      _nw49[(int)(3848)] = 62;
      _nw49[(int)(3849)] = 79;
      _nw49[(int)(3850)] = 179;
      _nw49[(int)(3851)] = 85;
      _nw49[(int)(3852)] = 208;
      _nw49[(int)(3853)] = 187;
      _nw49[(int)(3854)] = 169;
      _nw49[(int)(3855)] = 227;
      _nw49[(int)(3856)] = 98;
      _nw49[(int)(3857)] = 251;
      _nw49[(int)(3858)] = 72;
      _nw49[(int)(3859)] = 179;
      _nw49[(int)(3860)] = 94;
      _nw49[(int)(3861)] = 109;
      _nw49[(int)(3862)] = 10;
      _nw49[(int)(3863)] = 209;
      _nw49[(int)(3864)] = 215;
      _nw49[(int)(3865)] = 78;
      _nw49[(int)(3866)] = 137;
      _nw49[(int)(3867)] = 1;
      _nw49[(int)(3868)] = 223;
      _nw49[(int)(3869)] = 211;
      _nw49[(int)(3870)] = 125;
      _nw49[(int)(3871)] = 57;
      _nw49[(int)(3872)] = 59;
      _nw49[(int)(3873)] = 2;
      _nw49[(int)(3874)] = 255;
      _nw49[(int)(3875)] = 121;
      _nw49[(int)(3876)] = 5;
      _nw49[(int)(3877)] = 101;
      _nw49[(int)(3878)] = 138;
      _nw49[(int)(3879)] = 223;
      _nw49[(int)(3880)] = 200;
      _nw49[(int)(3881)] = 141;
      _nw49[(int)(3882)] = 75;
      _nw49[(int)(3883)] = 17;
      _nw49[(int)(3884)] = 105;
      _nw49[(int)(3885)] = 48;
      _nw49[(int)(3886)] = 168;
      _nw49[(int)(3887)] = 138;
      _nw49[(int)(3888)] = 118;
      _nw49[(int)(3889)] = 26;
      _nw49[(int)(3890)] = 202;
      _nw49[(int)(3891)] = 244;
      _nw49[(int)(3892)] = 164;
      _nw49[(int)(3893)] = 246;
      _nw49[(int)(3894)] = 191;
      _nw49[(int)(3895)] = 83;
      _nw49[(int)(3896)] = 26;
      _nw49[(int)(3897)] = 187;
      _nw49[(int)(3898)] = 5;
      _nw49[(int)(3899)] = 250;
      _nw49[(int)(3900)] = 160;
      _nw49[(int)(3901)] = 180;
      _nw49[(int)(3902)] = 26;
      _nw49[(int)(3903)] = 133;
      _nw49[(int)(3904)] = 62;
      _nw49[(int)(3905)] = 89;
      _nw49[(int)(3906)] = 253;
      _nw49[(int)(3907)] = 243;
      _nw49[(int)(3908)] = 175;
      _nw49[(int)(3909)] = 121;
      _nw49[(int)(3910)] = 219;
      _nw49[(int)(3911)] = 19;
      _nw49[(int)(3912)] = 203;
      _nw49[(int)(3913)] = 32;
      _nw49[(int)(3914)] = 149;
      _nw49[(int)(3915)] = 134;
      _nw49[(int)(3916)] = 7;
      _nw49[(int)(3917)] = 222;
      _nw49[(int)(3918)] = 183;
      _nw49[(int)(3919)] = 3;
      _nw49[(int)(3920)] = 111;
      _nw49[(int)(3921)] = 219;
      _nw49[(int)(3922)] = 197;
      _nw49[(int)(3923)] = 99;
      _nw49[(int)(3924)] = 154;
      _nw49[(int)(3925)] = 127;
      _nw49[(int)(3926)] = 227;
      _nw49[(int)(3927)] = 197;
      _nw49[(int)(3928)] = 13;
      _nw49[(int)(3929)] = 137;
      _nw49[(int)(3930)] = 9;
      _nw49[(int)(3931)] = 176;
      _nw49[(int)(3932)] = 58;
      _nw49[(int)(3933)] = 91;
      _nw49[(int)(3934)] = 131;
      _nw49[(int)(3935)] = 55;
      _nw49[(int)(3936)] = 16;
      _nw49[(int)(3937)] = 102;
      _nw49[(int)(3938)] = 241;
      _nw49[(int)(3939)] = 177;
      _nw49[(int)(3940)] = 17;
      _nw49[(int)(3941)] = 253;
      _nw49[(int)(3942)] = 213;
      _nw49[(int)(3943)] = 21;
      _nw49[(int)(3944)] = 18;
      _nw49[(int)(3945)] = 136;
      _nw49[(int)(3946)] = 131;
      _nw49[(int)(3947)] = 52;
      _nw49[(int)(3948)] = 241;
      _nw49[(int)(3949)] = 186;
      _nw49[(int)(3950)] = 219;
      _nw49[(int)(3951)] = 201;
      _nw49[(int)(3952)] = 215;
      _nw49[(int)(3953)] = 42;
      _nw49[(int)(3954)] = 218;
      _nw49[(int)(3955)] = 127;
      _nw49[(int)(3956)] = 110;
      _nw49[(int)(3957)] = 109;
      _nw49[(int)(3958)] = 197;
      _nw49[(int)(3959)] = 230;
      _nw49[(int)(3960)] = 4;
      _nw49[(int)(3961)] = 32;
      _nw49[(int)(3962)] = 35;
      _nw49[(int)(3963)] = 136;
      _nw49[(int)(3964)] = 65;
      _nw49[(int)(3965)] = 239;
      _nw49[(int)(3966)] = 13;
      _nw49[(int)(3967)] = 186;
      _nw49[(int)(3968)] = 11;
      _nw49[(int)(3969)] = 193;
      _nw49[(int)(3970)] = 127;
      _nw49[(int)(3971)] = 98;
      _nw49[(int)(3972)] = 211;
      _nw49[(int)(3973)] = 233;
      _nw49[(int)(3974)] = 145;
      _nw49[(int)(3975)] = 159;
      _nw49[(int)(3976)] = 194;
      _nw49[(int)(3977)] = 26;
      _nw49[(int)(3978)] = 188;
      _nw49[(int)(3979)] = 122;
      _nw49[(int)(3980)] = 211;
      _nw49[(int)(3981)] = 138;
      _nw49[(int)(3982)] = 234;
      _nw49[(int)(3983)] = 174;
      _nw49[(int)(3984)] = 253;
      _nw49[(int)(3985)] = 62;
      _nw49[(int)(3986)] = 113;
      _nw49[(int)(3987)] = 219;
      _nw49[(int)(3988)] = 160;
      _nw49[(int)(3989)] = 127;
      _nw49[(int)(3990)] = 45;
      _nw49[(int)(3991)] = 121;
      _nw49[(int)(3992)] = 238;
      _nw49[(int)(3993)] = 131;
      _nw49[(int)(3994)] = 105;
      _nw49[(int)(3995)] = 205;
      _nw49[(int)(3996)] = 180;
      _nw49[(int)(3997)] = 51;
      _nw49[(int)(3998)] = 15;
      _nw49[(int)(3999)] = 131;
      _nw49[(int)(4000)] = 208;
      _nw49[(int)(4001)] = 167;
      _nw49[(int)(4002)] = 135;
      _nw49[(int)(4003)] = 118;
      _nw49[(int)(4004)] = 90;
      _nw49[(int)(4005)] = 156;
      _nw49[(int)(4006)] = 228;
      _nw49[(int)(4007)] = 206;
      _nw49[(int)(4008)] = 230;
      _nw49[(int)(4009)] = 236;
      _nw49[(int)(4010)] = 251;
      _nw49[(int)(4011)] = 129;
      _nw49[(int)(4012)] = 58;
      _nw49[(int)(4013)] = 169;
      _nw49[(int)(4014)] = 49;
      _nw49[(int)(4015)] = 140;
      _nw49[(int)(4016)] = 64;
      _nw49[(int)(4017)] = 224;
      _nw49[(int)(4018)] = 32;
      _nw49[(int)(4019)] = 108;
      _nw49[(int)(4020)] = 1;
      _nw49[(int)(4021)] = 3;
      _nw49[(int)(4022)] = 41;
      _nw49[(int)(4023)] = 5;
      _nw49[(int)(4024)] = 225;
      _nw49[(int)(4025)] = 33;
      _nw49[(int)(4026)] = 103;
      _nw49[(int)(4027)] = 205;
      _nw49[(int)(4028)] = 63;
      _nw49[(int)(4029)] = 0;
      _nw49[(int)(4030)] = 165;
      _nw49[(int)(4031)] = 54;
      _nw49[(int)(4032)] = 34;
      _nw49[(int)(4033)] = 51;
      _nw49[(int)(4034)] = 116;
      _nw49[(int)(4035)] = 125;
      _nw49[(int)(4036)] = 237;
      _nw49[(int)(4037)] = 157;
      _nw49[(int)(4038)] = 201;
      _nw49[(int)(4039)] = 250;
      _nw49[(int)(4040)] = 226;
      _nw49[(int)(4041)] = 218;
      _nw49[(int)(4042)] = 22;
      _nw49[(int)(4043)] = 34;
      _nw49[(int)(4044)] = 92;
      _nw49[(int)(4045)] = 168;
      _nw49[(int)(4046)] = 68;
      _nw49[(int)(4047)] = 166;
      _nw49[(int)(4048)] = 106;
      _nw49[(int)(4049)] = 75;
      _nw49[(int)(4050)] = 121;
      _nw49[(int)(4051)] = 66;
      _nw49[(int)(4052)] = 183;
      _nw49[(int)(4053)] = 214;
      _nw49[(int)(4054)] = 29;
      _nw49[(int)(4055)] = 39;
      _nw49[(int)(4056)] = 19;
      _nw49[(int)(4057)] = 226;
      _nw49[(int)(4058)] = 125;
      _nw49[(int)(4059)] = 46;
      _nw49[(int)(4060)] = 91;
      _nw49[(int)(4061)] = 48;
      _nw49[(int)(4062)] = 157;
      _nw49[(int)(4063)] = 10;
      _nw49[(int)(4064)] = 26;
      _nw49[(int)(4065)] = 205;
      _nw49[(int)(4066)] = 55;
      _nw49[(int)(4067)] = 139;
      _nw49[(int)(4068)] = 76;
      _nw49[(int)(4069)] = 129;
      _nw49[(int)(4070)] = 196;
      _nw49[(int)(4071)] = 33;
      _nw49[(int)(4072)] = 49;
      _nw49[(int)(4073)] = 32;
      _nw49[(int)(4074)] = 201;
      _nw49[(int)(4075)] = 219;
      _nw49[(int)(4076)] = 177;
      _nw49[(int)(4077)] = 237;
      _nw49[(int)(4078)] = 144;
      _nw49[(int)(4079)] = 73;
      _nw49[(int)(4080)] = 125;
      _nw49[(int)(4081)] = 228;
      _nw49[(int)(4082)] = 101;
      _nw49[(int)(4083)] = 245;
      _nw49[(int)(4084)] = 103;
      _nw49[(int)(4085)] = 17;
      _nw49[(int)(4086)] = 125;
      _nw49[(int)(4087)] = 19;
      _nw49[(int)(4088)] = 93;
      _nw49[(int)(4089)] = 161;
      _nw49[(int)(4090)] = 178;
      _nw49[(int)(4091)] = 243;
      _nw49[(int)(4092)] = 110;
      _nw49[(int)(4093)] = 40;
      _nw49[(int)(4094)] = 136;
      _nw49[(int)(4095)] = 2;
      _nw49[(int)(4096)] = 94;
      _nw49[(int)(4097)] = 244;
      _nw49[(int)(4098)] = 220;
      _nw49[(int)(4099)] = 80;
      _nw49[(int)(4100)] = 8;
      _nw49[(int)(4101)] = 14;
      _nw49[(int)(4102)] = 217;
      _nw49[(int)(4103)] = 238;
      _nw49[(int)(4104)] = 20;
      _nw49[(int)(4105)] = 126;
      _nw49[(int)(4106)] = 147;
      _nw49[(int)(4107)] = 142;
      _nw49[(int)(4108)] = 106;
      _nw49[(int)(4109)] = 68;
      _nw49[(int)(4110)] = 92;
      _nw49[(int)(4111)] = 207;
      _nw49[(int)(4112)] = 77;
      _nw49[(int)(4113)] = 229;
      _nw49[(int)(4114)] = 198;
      _nw49[(int)(4115)] = 225;
      _nw49[(int)(4116)] = 241;
      _nw49[(int)(4117)] = 195;
      _nw49[(int)(4118)] = 152;
      _nw49[(int)(4119)] = 46;
      _nw49[(int)(4120)] = 50;
      _nw49[(int)(4121)] = 76;
      _nw49[(int)(4122)] = 24;
      _nw49[(int)(4123)] = 175;
      _nw49[(int)(4124)] = 74;
      _nw49[(int)(4125)] = 28;
      _nw49[(int)(4126)] = 55;
      _nw49[(int)(4127)] = 44;
      _nw49[(int)(4128)] = 110;
      _nw49[(int)(4129)] = 108;
      _nw49[(int)(4130)] = 142;
      _nw49[(int)(4131)] = 207;
      _nw49[(int)(4132)] = 159;
      _nw49[(int)(4133)] = 207;
      _nw49[(int)(4134)] = 229;
      _nw49[(int)(4135)] = 8;
      _nw49[(int)(4136)] = 245;
      _nw49[(int)(4137)] = 66;
      _nw49[(int)(4138)] = 165;
      _nw49[(int)(4139)] = 28;
      _nw49[(int)(4140)] = 144;
      _nw49[(int)(4141)] = 50;
      _nw49[(int)(4142)] = 32;
      _nw49[(int)(4143)] = 225;
      _nw49[(int)(4144)] = 177;
      _nw49[(int)(4145)] = 229;
      _nw49[(int)(4146)] = 96;
      _nw49[(int)(4147)] = 50;
      _nw49[(int)(4148)] = 217;
      _nw49[(int)(4149)] = 83;
      _nw49[(int)(4150)] = 215;
      _nw49[(int)(4151)] = 17;
      _nw49[(int)(4152)] = 190;
      _nw49[(int)(4153)] = 176;
      _nw49[(int)(4154)] = 51;
      _nw49[(int)(4155)] = 128;
      _nw49[(int)(4156)] = 39;
      _nw49[(int)(4157)] = 122;
      _nw49[(int)(4158)] = 135;
      _nw49[(int)(4159)] = 71;
      _nw49[(int)(4160)] = 89;
      _nw49[(int)(4161)] = 17;
      _nw49[(int)(4162)] = 85;
      _nw49[(int)(4163)] = 80;
      _nw49[(int)(4164)] = 240;
      _nw49[(int)(4165)] = 165;
      _nw49[(int)(4166)] = 6;
      _nw49[(int)(4167)] = 131;
      _nw49[(int)(4168)] = 250;
      _nw49[(int)(4169)] = 6;
      _nw49[(int)(4170)] = 133;
      _nw49[(int)(4171)] = 153;
      _nw49[(int)(4172)] = 0;
      _nw49[(int)(4173)] = 14;
      _nw49[(int)(4174)] = 114;
      _nw49[(int)(4175)] = 44;
      _nw49[(int)(4176)] = 43;
      _nw49[(int)(4177)] = 20;
      _nw49[(int)(4178)] = 170;
      _nw49[(int)(4179)] = 254;
      _nw49[(int)(4180)] = 77;
      _nw49[(int)(4181)] = 226;
      _nw49[(int)(4182)] = 90;
      _nw49[(int)(4183)] = 23;
      _nw49[(int)(4184)] = 34;
      _nw49[(int)(4185)] = 219;
      _nw49[(int)(4186)] = 244;
      _nw49[(int)(4187)] = 84;
      _nw49[(int)(4188)] = 10;
      _nw49[(int)(4189)] = 127;
      _nw49[(int)(4190)] = 174;
      _nw49[(int)(4191)] = 211;
      _nw49[(int)(4192)] = 58;
      _nw49[(int)(4193)] = 225;
      _nw49[(int)(4194)] = 185;
      _nw49[(int)(4195)] = 217;
      _nw49[(int)(4196)] = 113;
      _nw49[(int)(4197)] = 187;
      _nw49[(int)(4198)] = 28;
      _nw49[(int)(4199)] = 82;
      _nw49[(int)(4200)] = 137;
      _nw49[(int)(4201)] = 172;
      _nw49[(int)(4202)] = 54;
      _nw49[(int)(4203)] = 229;
      _nw49[(int)(4204)] = 205;
      _nw49[(int)(4205)] = 65;
      _nw49[(int)(4206)] = 54;
      _nw49[(int)(4207)] = 255;
      _nw49[(int)(4208)] = 107;
      _nw49[(int)(4209)] = 230;
      _nw49[(int)(4210)] = 210;
      _nw49[(int)(4211)] = 163;
      _nw49[(int)(4212)] = 132;
      _nw49[(int)(4213)] = 139;
      _nw49[(int)(4214)] = 188;
      _nw49[(int)(4215)] = 177;
      _nw49[(int)(4216)] = 139;
      _nw49[(int)(4217)] = 72;
      _nw49[(int)(4218)] = 163;
      _nw49[(int)(4219)] = 88;
      _nw49[(int)(4220)] = 169;
      _nw49[(int)(4221)] = 144;
      _nw49[(int)(4222)] = 95;
      _nw49[(int)(4223)] = 234;
      _nw49[(int)(4224)] = 211;
      _nw49[(int)(4225)] = 49;
      _nw49[(int)(4226)] = 45;
      _nw49[(int)(4227)] = 154;
      _nw49[(int)(4228)] = 67;
      _nw49[(int)(4229)] = 190;
      _nw49[(int)(4230)] = 161;
      _nw49[(int)(4231)] = 120;
      _nw49[(int)(4232)] = 63;
      _nw49[(int)(4233)] = 212;
      _nw49[(int)(4234)] = 81;
      _nw49[(int)(4235)] = 252;
      _nw49[(int)(4236)] = 59;
      _nw49[(int)(4237)] = 210;
      _nw49[(int)(4238)] = 166;
      _nw49[(int)(4239)] = 195;
      _nw49[(int)(4240)] = 139;
      _nw49[(int)(4241)] = 232;
      _nw49[(int)(4242)] = 58;
      _nw49[(int)(4243)] = 141;
      _nw49[(int)(4244)] = 36;
      _nw49[(int)(4245)] = 153;
      _nw49[(int)(4246)] = 132;
      _nw49[(int)(4247)] = 109;
      _nw49[(int)(4248)] = 51;
      _nw49[(int)(4249)] = 60;
      _nw49[(int)(4250)] = 195;
      _nw49[(int)(4251)] = 210;
      _nw49[(int)(4252)] = 175;
      _nw49[(int)(4253)] = 25;
      _nw49[(int)(4254)] = 183;
      _nw49[(int)(4255)] = 205;
      _nw49[(int)(4256)] = 35;
      _nw49[(int)(4257)] = 92;
      _nw49[(int)(4258)] = 85;
      _nw49[(int)(4259)] = 40;
      _nw49[(int)(4260)] = 47;
      _nw49[(int)(4261)] = 6;
      _nw49[(int)(4262)] = 9;
      _nw49[(int)(4263)] = 74;
      _nw49[(int)(4264)] = 242;
      _nw49[(int)(4265)] = 27;
      _nw49[(int)(4266)] = 192;
      _nw49[(int)(4267)] = 148;
      _nw49[(int)(4268)] = 129;
      _nw49[(int)(4269)] = 130;
      _nw49[(int)(4270)] = 238;
      _nw49[(int)(4271)] = 140;
      _nw49[(int)(4272)] = 48;
      _nw49[(int)(4273)] = 158;
      _nw49[(int)(4274)] = 138;
      _nw49[(int)(4275)] = 138;
      _nw49[(int)(4276)] = 99;
      _nw49[(int)(4277)] = 20;
      _nw49[(int)(4278)] = 228;
      _nw49[(int)(4279)] = 114;
      _nw49[(int)(4280)] = 119;
      _nw49[(int)(4281)] = 149;
      _nw49[(int)(4282)] = 129;
      _nw49[(int)(4283)] = 85;
      _nw49[(int)(4284)] = 157;
      _nw49[(int)(4285)] = 54;
      _nw49[(int)(4286)] = 103;
      _nw49[(int)(4287)] = 187;
      _nw49[(int)(4288)] = 238;
      _nw49[(int)(4289)] = 213;
      _nw49[(int)(4290)] = 119;
      _nw49[(int)(4291)] = 147;
      _nw49[(int)(4292)] = 46;
      _nw49[(int)(4293)] = 205;
      _nw49[(int)(4294)] = 101;
      _nw49[(int)(4295)] = 24;
      _nw49[(int)(4296)] = 154;
      _nw49[(int)(4297)] = 28;
      _nw49[(int)(4298)] = 11;
      _nw49[(int)(4299)] = 76;
      _nw49[(int)(4300)] = 237;
      _nw49[(int)(4301)] = 44;
      _nw49[(int)(4302)] = 87;
      _nw49[(int)(4303)] = 118;
      _nw49[(int)(4304)] = 8;
      _nw49[(int)(4305)] = 84;
      _nw49[(int)(4306)] = 57;
      _nw49[(int)(4307)] = 28;
      _nw49[(int)(4308)] = 213;
      _nw49[(int)(4309)] = 237;
      _nw49[(int)(4310)] = 95;
      _nw49[(int)(4311)] = 243;
      _nw49[(int)(4312)] = 150;
      _nw49[(int)(4313)] = 200;
      _nw49[(int)(4314)] = 68;
      _nw49[(int)(4315)] = 41;
      _nw49[(int)(4316)] = 168;
      _nw49[(int)(4317)] = 116;
      _nw49[(int)(4318)] = 38;
      _nw49[(int)(4319)] = 184;
      _nw49[(int)(4320)] = 152;
      _nw49[(int)(4321)] = 140;
      _nw49[(int)(4322)] = 83;
      _nw49[(int)(4323)] = 191;
      _nw49[(int)(4324)] = 155;
      _nw49[(int)(4325)] = 202;
      _nw49[(int)(4326)] = 39;
      _nw49[(int)(4327)] = 220;
      _nw49[(int)(4328)] = 183;
      _nw49[(int)(4329)] = 179;
      _nw49[(int)(4330)] = 229;
      _nw49[(int)(4331)] = 227;
      _nw49[(int)(4332)] = 111;
      _nw49[(int)(4333)] = 94;
      _nw49[(int)(4334)] = 22;
      _nw49[(int)(4335)] = 232;
      _nw49[(int)(4336)] = 113;
      _nw49[(int)(4337)] = 113;
      _nw49[(int)(4338)] = 21;
      _nw49[(int)(4339)] = 213;
      _nw49[(int)(4340)] = 109;
      _nw49[(int)(4341)] = 129;
      _nw49[(int)(4342)] = 20;
      _nw49[(int)(4343)] = 111;
      _nw49[(int)(4344)] = 83;
      _nw49[(int)(4345)] = 163;
      _nw49[(int)(4346)] = 210;
      _nw49[(int)(4347)] = 195;
      _nw49[(int)(4348)] = 15;
      _nw49[(int)(4349)] = 75;
      _nw49[(int)(4350)] = 170;
      _nw49[(int)(4351)] = 197;
      _nw49[(int)(4352)] = 28;
      _nw49[(int)(4353)] = 128;
      _nw49[(int)(4354)] = 201;
      _nw49[(int)(4355)] = 196;
      _nw49[(int)(4356)] = 84;
      _nw49[(int)(4357)] = 60;
      _nw49[(int)(4358)] = 128;
      _nw49[(int)(4359)] = 253;
      _nw49[(int)(4360)] = 132;
      _nw49[(int)(4361)] = 22;
      _nw49[(int)(4362)] = 211;
      _nw49[(int)(4363)] = 100;
      _nw49[(int)(4364)] = 190;
      _nw49[(int)(4365)] = 129;
      _nw49[(int)(4366)] = 137;
      _nw49[(int)(4367)] = 174;
      _nw49[(int)(4368)] = 176;
      _nw49[(int)(4369)] = 221;
      _nw49[(int)(4370)] = 28;
      _nw49[(int)(4371)] = 126;
      _nw49[(int)(4372)] = 166;
      _nw49[(int)(4373)] = 48;
      _nw49[(int)(4374)] = 152;
      _nw49[(int)(4375)] = 114;
      _nw49[(int)(4376)] = 233;
      _nw49[(int)(4377)] = 102;
      _nw49[(int)(4378)] = 110;
      _nw49[(int)(4379)] = 89;
      _nw49[(int)(4380)] = 118;
      _nw49[(int)(4381)] = 59;
      _nw49[(int)(4382)] = 43;
      _nw49[(int)(4383)] = 31;
      _nw49[(int)(4384)] = 195;
      _nw49[(int)(4385)] = 56;
      _nw49[(int)(4386)] = 131;
      _nw49[(int)(4387)] = 187;
      _nw49[(int)(4388)] = 86;
      _nw49[(int)(4389)] = 113;
      _nw49[(int)(4390)] = 127;
      _nw49[(int)(4391)] = 219;
      _nw49[(int)(4392)] = 125;
      _nw49[(int)(4393)] = 251;
      _nw49[(int)(4394)] = 25;
      _nw49[(int)(4395)] = 162;
      _nw49[(int)(4396)] = 108;
      _nw49[(int)(4397)] = 190;
      _nw49[(int)(4398)] = 254;
      _nw49[(int)(4399)] = 20;
      _nw49[(int)(4400)] = 160;
      _nw49[(int)(4401)] = 18;
      _nw49[(int)(4402)] = 52;
      _nw49[(int)(4403)] = 81;
      _nw49[(int)(4404)] = 84;
      _nw49[(int)(4405)] = 252;
      _nw49[(int)(4406)] = 43;
      _nw49[(int)(4407)] = 69;
      _nw49[(int)(4408)] = 101;
      _nw49[(int)(4409)] = 115;
      _nw49[(int)(4410)] = 255;
      _nw49[(int)(4411)] = 197;
      _nw49[(int)(4412)] = 81;
      _nw49[(int)(4413)] = 100;
      _nw49[(int)(4414)] = 42;
      _nw49[(int)(4415)] = 242;
      _nw49[(int)(4416)] = 158;
      _nw49[(int)(4417)] = 5;
      _nw49[(int)(4418)] = 48;
      _nw49[(int)(4419)] = 4;
      _nw49[(int)(4420)] = 19;
      _nw49[(int)(4421)] = 241;
      _nw49[(int)(4422)] = 1;
      _nw49[(int)(4423)] = 37;
      _nw49[(int)(4424)] = 4;
      _nw49[(int)(4425)] = 211;
      _nw49[(int)(4426)] = 28;
      _nw49[(int)(4427)] = 9;
      _nw49[(int)(4428)] = 232;
      _nw49[(int)(4429)] = 200;
      _nw49[(int)(4430)] = 149;
      _nw49[(int)(4431)] = 64;
      _nw49[(int)(4432)] = 28;
      _nw49[(int)(4433)] = 218;
      _nw49[(int)(4434)] = 77;
      _nw49[(int)(4435)] = 134;
      _nw49[(int)(4436)] = 111;
      _nw49[(int)(4437)] = 201;
      _nw49[(int)(4438)] = 139;
      _nw49[(int)(4439)] = 171;
      _nw49[(int)(4440)] = 54;
      _nw49[(int)(4441)] = 190;
      _nw49[(int)(4442)] = 64;
      _nw49[(int)(4443)] = 246;
      _nw49[(int)(4444)] = 89;
      _nw49[(int)(4445)] = 26;
      _nw49[(int)(4446)] = 246;
      _nw49[(int)(4447)] = 140;
      _nw49[(int)(4448)] = 193;
      _nw49[(int)(4449)] = 133;
      _nw49[(int)(4450)] = 177;
      _nw49[(int)(4451)] = 77;
      _nw49[(int)(4452)] = 85;
      _nw49[(int)(4453)] = 125;
      _nw49[(int)(4454)] = 200;
      _nw49[(int)(4455)] = 119;
      _nw49[(int)(4456)] = 47;
      _nw49[(int)(4457)] = 38;
      _nw49[(int)(4458)] = 144;
      _nw49[(int)(4459)] = 38;
      _nw49[(int)(4460)] = 214;
      _nw49[(int)(4461)] = 98;
      _nw49[(int)(4462)] = 150;
      _nw49[(int)(4463)] = 90;
      _nw49[(int)(4464)] = 204;
      _nw49[(int)(4465)] = 205;
      _nw49[(int)(4466)] = 103;
      _nw49[(int)(4467)] = 114;
      _nw49[(int)(4468)] = 6;
      _nw49[(int)(4469)] = 213;
      _nw49[(int)(4470)] = 118;
      _nw49[(int)(4471)] = 36;
      _nw49[(int)(4472)] = 145;
      _nw49[(int)(4473)] = 109;
      _nw49[(int)(4474)] = 191;
      _nw49[(int)(4475)] = 139;
      _nw49[(int)(4476)] = 154;
      _nw49[(int)(4477)] = 179;
      _nw49[(int)(4478)] = 12;
      _nw49[(int)(4479)] = 210;
      _nw49[(int)(4480)] = 230;
      _nw49[(int)(4481)] = 21;
      _nw49[(int)(4482)] = 138;
      _nw49[(int)(4483)] = 204;
      _nw49[(int)(4484)] = 252;
      _nw49[(int)(4485)] = 192;
      _nw49[(int)(4486)] = 137;
      _nw49[(int)(4487)] = 97;
      _nw49[(int)(4488)] = 144;
      _nw49[(int)(4489)] = 250;
      _nw49[(int)(4490)] = 248;
      _nw49[(int)(4491)] = 193;
      _nw49[(int)(4492)] = 75;
      _nw49[(int)(4493)] = 156;
      _nw49[(int)(4494)] = 56;
      _nw49[(int)(4495)] = 114;
      _nw49[(int)(4496)] = 218;
      _nw49[(int)(4497)] = 127;
      _nw49[(int)(4498)] = 118;
      _nw49[(int)(4499)] = 36;
      _nw49[(int)(4500)] = 110;
      _nw49[(int)(4501)] = 103;
      _nw49[(int)(4502)] = 85;
      _nw49[(int)(4503)] = 191;
      _nw49[(int)(4504)] = 229;
      _nw49[(int)(4505)] = 197;
      _nw49[(int)(4506)] = 41;
      _nw49[(int)(4507)] = 250;
      _nw49[(int)(4508)] = 28;
      _nw49[(int)(4509)] = 220;
      _nw49[(int)(4510)] = 177;
      _nw49[(int)(4511)] = 227;
      _nw49[(int)(4512)] = 156;
      _nw49[(int)(4513)] = 50;
      _nw49[(int)(4514)] = 100;
      _nw49[(int)(4515)] = 219;
      _nw49[(int)(4516)] = 46;
      _nw49[(int)(4517)] = 126;
      _nw49[(int)(4518)] = 80;
      _nw49[(int)(4519)] = 107;
      _nw49[(int)(4520)] = 17;
      _nw49[(int)(4521)] = 157;
      _nw49[(int)(4522)] = 0;
      _nw49[(int)(4523)] = 140;
      _nw49[(int)(4524)] = 173;
      _nw49[(int)(4525)] = 46;
      _nw49[(int)(4526)] = 147;
      _nw49[(int)(4527)] = 36;
      _nw49[(int)(4528)] = 251;
      _nw49[(int)(4529)] = 155;
      _nw49[(int)(4530)] = 255;
      _nw49[(int)(4531)] = 123;
      _nw49[(int)(4532)] = 51;
      _nw49[(int)(4533)] = 136;
      _nw49[(int)(4534)] = 27;
      _nw49[(int)(4535)] = 120;
      _nw49[(int)(4536)] = 242;
      _nw49[(int)(4537)] = 39;
      _nw49[(int)(4538)] = 117;
      _nw49[(int)(4539)] = 241;
      _nw49[(int)(4540)] = 26;
      _nw49[(int)(4541)] = 161;
      _nw49[(int)(4542)] = 67;
      _nw49[(int)(4543)] = 213;
      _nw49[(int)(4544)] = 3;
      _nw49[(int)(4545)] = 101;
      _nw49[(int)(4546)] = 192;
      _nw49[(int)(4547)] = 129;
      _nw49[(int)(4548)] = 137;
      _nw49[(int)(4549)] = 165;
      _nw49[(int)(4550)] = 160;
      _nw49[(int)(4551)] = 124;
      _nw49[(int)(4552)] = 94;
      _nw49[(int)(4553)] = 214;
      _nw49[(int)(4554)] = 4;
      _nw49[(int)(4555)] = 215;
      _nw49[(int)(4556)] = 112;
      _nw49[(int)(4557)] = 187;
      _nw49[(int)(4558)] = 75;
      _nw49[(int)(4559)] = 189;
      _nw49[(int)(4560)] = 158;
      _nw49[(int)(4561)] = 88;
      _nw49[(int)(4562)] = 116;
      _nw49[(int)(4563)] = 170;
      _nw49[(int)(4564)] = 135;
      _nw49[(int)(4565)] = 129;
      _nw49[(int)(4566)] = 164;
      _nw49[(int)(4567)] = 191;
      _nw49[(int)(4568)] = 65;
      _nw49[(int)(4569)] = 71;
      _nw49[(int)(4570)] = 238;
      _nw49[(int)(4571)] = 201;
      _nw49[(int)(4572)] = 87;
      _nw49[(int)(4573)] = 207;
      _nw49[(int)(4574)] = 148;
      _nw49[(int)(4575)] = 246;
      _nw49[(int)(4576)] = 134;
      _nw49[(int)(4577)] = 175;
      _nw49[(int)(4578)] = 203;
      _nw49[(int)(4579)] = 122;
      _nw49[(int)(4580)] = 51;
      _nw49[(int)(4581)] = 193;
      _nw49[(int)(4582)] = 35;
      _nw49[(int)(4583)] = 50;
      _nw49[(int)(4584)] = 69;
      _nw49[(int)(4585)] = 203;
      _nw49[(int)(4586)] = 214;
      _nw49[(int)(4587)] = 44;
      _nw49[(int)(4588)] = 145;
      _nw49[(int)(4589)] = 121;
      _nw49[(int)(4590)] = 80;
      _nw49[(int)(4591)] = 25;
      _nw49[(int)(4592)] = 14;
      _nw49[(int)(4593)] = 249;
      _nw49[(int)(4594)] = 41;
      _nw49[(int)(4595)] = 246;
      _nw49[(int)(4596)] = 89;
      _nw49[(int)(4597)] = 245;
      _nw49[(int)(4598)] = 101;
      _nw49[(int)(4599)] = 46;
      _nw49[(int)(4600)] = 98;
      _nw49[(int)(4601)] = 93;
      _nw49[(int)(4602)] = 106;
      _nw49[(int)(4603)] = 193;
      _nw49[(int)(4604)] = 240;
      _nw49[(int)(4605)] = 42;
      _nw49[(int)(4606)] = 164;
      _nw49[(int)(4607)] = 112;
      _nw49[(int)(4608)] = 233;
      _nw49[(int)(4609)] = 198;
      _nw49[(int)(4610)] = 2;
      _nw49[(int)(4611)] = 162;
      _nw49[(int)(4612)] = 138;
      _nw49[(int)(4613)] = 207;
      _nw49[(int)(4614)] = 16;
      _nw49[(int)(4615)] = 86;
      _nw49[(int)(4616)] = 191;
      _nw49[(int)(4617)] = 83;
      _nw49[(int)(4618)] = 73;
      _nw49[(int)(4619)] = 32;
      _nw49[(int)(4620)] = 229;
      _nw49[(int)(4621)] = 77;
      _nw49[(int)(4622)] = 181;
      _nw49[(int)(4623)] = 69;
      _nw49[(int)(4624)] = 100;
      _nw49[(int)(4625)] = 158;
      _nw49[(int)(4626)] = 207;
      _nw49[(int)(4627)] = 26;
      _nw49[(int)(4628)] = 9;
      _nw49[(int)(4629)] = 190;
      _nw49[(int)(4630)] = 139;
      _nw49[(int)(4631)] = 223;
      _nw49[(int)(4632)] = 195;
      _nw49[(int)(4633)] = 17;
      _nw49[(int)(4634)] = 115;
      _nw49[(int)(4635)] = 22;
      _nw49[(int)(4636)] = 54;
      _nw49[(int)(4637)] = 150;
      _nw49[(int)(4638)] = 220;
      _nw49[(int)(4639)] = 28;
      _nw49[(int)(4640)] = 141;
      _nw49[(int)(4641)] = 110;
      _nw49[(int)(4642)] = 123;
      _nw49[(int)(4643)] = 80;
      _nw49[(int)(4644)] = 202;
      _nw49[(int)(4645)] = 130;
      _nw49[(int)(4646)] = 108;
      _nw49[(int)(4647)] = 86;
      _nw49[(int)(4648)] = 205;
      _nw49[(int)(4649)] = 60;
      _nw49[(int)(4650)] = 48;
      _nw49[(int)(4651)] = 75;
      _nw49[(int)(4652)] = 206;
      _nw49[(int)(4653)] = 38;
      _nw49[(int)(4654)] = 113;
      _nw49[(int)(4655)] = 44;
      _nw49[(int)(4656)] = 237;
      _nw49[(int)(4657)] = 245;
      _nw49[(int)(4658)] = 69;
      _nw49[(int)(4659)] = 21;
      _nw49[(int)(4660)] = 255;
      _nw49[(int)(4661)] = 85;
      _nw49[(int)(4662)] = 162;
      _nw49[(int)(4663)] = 137;
      _nw49[(int)(4664)] = 197;
      _nw49[(int)(4665)] = 107;
      _nw49[(int)(4666)] = 196;
      _nw49[(int)(4667)] = 103;
      _nw49[(int)(4668)] = 164;
      _nw49[(int)(4669)] = 68;
      _nw49[(int)(4670)] = 248;
      _nw49[(int)(4671)] = 46;
      _nw49[(int)(4672)] = 9;
      _nw49[(int)(4673)] = 178;
      _nw49[(int)(4674)] = 183;
      _nw49[(int)(4675)] = 231;
      _nw49[(int)(4676)] = 147;
      _nw49[(int)(4677)] = 97;
      _nw49[(int)(4678)] = 84;
      _nw49[(int)(4679)] = 56;
      _nw49[(int)(4680)] = 245;
      _nw49[(int)(4681)] = 75;
      _nw49[(int)(4682)] = 63;
      _nw49[(int)(4683)] = 24;
      _nw49[(int)(4684)] = 153;
      _nw49[(int)(4685)] = 169;
      _nw49[(int)(4686)] = 81;
      _nw49[(int)(4687)] = 103;
      _nw49[(int)(4688)] = 167;
      _nw49[(int)(4689)] = 74;
      _nw49[(int)(4690)] = 239;
      _nw49[(int)(4691)] = 19;
      _nw49[(int)(4692)] = 25;
      _nw49[(int)(4693)] = 151;
      _nw49[(int)(4694)] = 7;
      _nw49[(int)(4695)] = 17;
      _nw49[(int)(4696)] = 141;
      _nw49[(int)(4697)] = 185;
      _nw49[(int)(4698)] = 180;
      _nw49[(int)(4699)] = 251;
      _nw49[(int)(4700)] = 132;
      _nw49[(int)(4701)] = 211;
      _nw49[(int)(4702)] = 154;
      _nw49[(int)(4703)] = 156;
      _nw49[(int)(4704)] = 37;
      _nw49[(int)(4705)] = 3;
      _nw49[(int)(4706)] = 61;
      _nw49[(int)(4707)] = 109;
      _nw49[(int)(4708)] = 155;
      _nw49[(int)(4709)] = 12;
      _nw49[(int)(4710)] = 37;
      _nw49[(int)(4711)] = 132;
      _nw49[(int)(4712)] = 156;
      _nw49[(int)(4713)] = 195;
      _nw49[(int)(4714)] = 97;
      _nw49[(int)(4715)] = 150;
      _nw49[(int)(4716)] = 139;
      _nw49[(int)(4717)] = 175;
      _nw49[(int)(4718)] = 189;
      _nw49[(int)(4719)] = 199;
      _nw49[(int)(4720)] = 106;
      _nw49[(int)(4721)] = 74;
      _nw49[(int)(4722)] = 38;
      _nw49[(int)(4723)] = 212;
      _nw49[(int)(4724)] = 79;
      _nw49[(int)(4725)] = 64;
      _nw49[(int)(4726)] = 235;
      _nw49[(int)(4727)] = 192;
      _nw49[(int)(4728)] = 78;
      _nw49[(int)(4729)] = 135;
      _nw49[(int)(4730)] = 213;
      _nw49[(int)(4731)] = 217;
      _nw49[(int)(4732)] = 176;
      _nw49[(int)(4733)] = 172;
      _nw49[(int)(4734)] = 73;
      _nw49[(int)(4735)] = 182;
      _nw49[(int)(4736)] = 61;
      _nw49[(int)(4737)] = 86;
      _nw49[(int)(4738)] = 153;
      _nw49[(int)(4739)] = 227;
      _nw49[(int)(4740)] = 190;
      _nw49[(int)(4741)] = 174;
      _nw49[(int)(4742)] = 212;
      _nw49[(int)(4743)] = 239;
      _nw49[(int)(4744)] = 76;
      _nw49[(int)(4745)] = 71;
      _nw49[(int)(4746)] = 109;
      _nw49[(int)(4747)] = 177;
      _nw49[(int)(4748)] = 141;
      _nw49[(int)(4749)] = 193;
      _nw49[(int)(4750)] = 156;
      _nw49[(int)(4751)] = 161;
      _nw49[(int)(4752)] = 73;
      _nw49[(int)(4753)] = 182;
      _nw49[(int)(4754)] = 150;
      _nw49[(int)(4755)] = 29;
      _nw49[(int)(4756)] = 223;
      _nw49[(int)(4757)] = 86;
      _nw49[(int)(4758)] = 59;
      _nw49[(int)(4759)] = 170;
      _nw49[(int)(4760)] = 241;
      _nw49[(int)(4761)] = 209;
      _nw49[(int)(4762)] = 21;
      _nw49[(int)(4763)] = 188;
      _nw49[(int)(4764)] = 84;
      _nw49[(int)(4765)] = 23;
      _nw49[(int)(4766)] = 237;
      _nw49[(int)(4767)] = 233;
      _nw49[(int)(4768)] = 180;
      _nw49[(int)(4769)] = 92;
      _nw49[(int)(4770)] = 69;
      _nw49[(int)(4771)] = 72;
      _nw49[(int)(4772)] = 23;
      _nw49[(int)(4773)] = 253;
      _nw49[(int)(4774)] = 175;
      _nw49[(int)(4775)] = 180;
      _nw49[(int)(4776)] = 141;
      _nw49[(int)(4777)] = 120;
      _nw49[(int)(4778)] = 1;
      _nw49[(int)(4779)] = 148;
      _nw49[(int)(4780)] = 213;
      _nw49[(int)(4781)] = 168;
      _nw49[(int)(4782)] = 148;
      _nw49[(int)(4783)] = 62;
      _nw49[(int)(4784)] = 238;
      _nw49[(int)(4785)] = 243;
      _nw49[(int)(4786)] = 60;
      _nw49[(int)(4787)] = 113;
      _nw49[(int)(4788)] = 110;
      _nw49[(int)(4789)] = 244;
      _nw49[(int)(4790)] = 102;
      _nw49[(int)(4791)] = 62;
      _nw49[(int)(4792)] = 35;
      _nw49[(int)(4793)] = 122;
      _nw49[(int)(4794)] = 136;
      _nw49[(int)(4795)] = 179;
      _nw49[(int)(4796)] = 207;
      _nw49[(int)(4797)] = 240;
      _nw49[(int)(4798)] = 188;
      _nw49[(int)(4799)] = 67;
      _nw49[(int)(4800)] = 137;
      _nw49[(int)(4801)] = 28;
      _nw49[(int)(4802)] = 91;
      _nw49[(int)(4803)] = 74;
      _nw49[(int)(4804)] = 201;
      _nw49[(int)(4805)] = 240;
      _nw49[(int)(4806)] = 202;
      _nw49[(int)(4807)] = 178;
      _nw49[(int)(4808)] = 95;
      _nw49[(int)(4809)] = 224;
      _nw49[(int)(4810)] = 230;
      _nw49[(int)(4811)] = 232;
      _nw49[(int)(4812)] = 221;
      _nw49[(int)(4813)] = 14;
      _nw49[(int)(4814)] = 209;
      _nw49[(int)(4815)] = 174;
      _nw49[(int)(4816)] = 221;
      _nw49[(int)(4817)] = 111;
      _nw49[(int)(4818)] = 119;
      _nw49[(int)(4819)] = 122;
      _nw49[(int)(4820)] = 253;
      _nw49[(int)(4821)] = 237;
      _nw49[(int)(4822)] = 131;
      _nw49[(int)(4823)] = 104;
      _nw49[(int)(4824)] = 78;
      _nw49[(int)(4825)] = 200;
      _nw49[(int)(4826)] = 147;
      _nw49[(int)(4827)] = 247;
      _nw49[(int)(4828)] = 161;
      _nw49[(int)(4829)] = 197;
      _nw49[(int)(4830)] = 96;
      _nw49[(int)(4831)] = 16;
      _nw49[(int)(4832)] = 26;
      _nw49[(int)(4833)] = 249;
      _nw49[(int)(4834)] = 0;
      _nw49[(int)(4835)] = 125;
      _nw49[(int)(4836)] = 205;
      _nw49[(int)(4837)] = 247;
      _nw49[(int)(4838)] = 252;
      _nw49[(int)(4839)] = 159;
      _nw49[(int)(4840)] = 174;
      _nw49[(int)(4841)] = 189;
      _nw49[(int)(4842)] = 129;
      _nw49[(int)(4843)] = 176;
      _nw49[(int)(4844)] = 66;
      _nw49[(int)(4845)] = 212;
      _nw49[(int)(4846)] = 187;
      _nw49[(int)(4847)] = 13;
      _nw49[(int)(4848)] = 17;
      _nw49[(int)(4849)] = 174;
      _nw49[(int)(4850)] = 207;
      _nw49[(int)(4851)] = 237;
      _nw49[(int)(4852)] = 207;
      _nw49[(int)(4853)] = 28;
      _nw49[(int)(4854)] = 164;
      _nw49[(int)(4855)] = 168;
      _nw49[(int)(4856)] = 234;
      _nw49[(int)(4857)] = 52;
      _nw49[(int)(4858)] = 200;
      _nw49[(int)(4859)] = 253;
      _nw49[(int)(4860)] = 153;
      _nw49[(int)(4861)] = 237;
      _nw49[(int)(4862)] = 117;
      _nw49[(int)(4863)] = 111;
      _nw49[(int)(4864)] = 145;
      _nw49[(int)(4865)] = 66;
      _nw49[(int)(4866)] = 50;
      _nw49[(int)(4867)] = 245;
      _nw49[(int)(4868)] = 59;
      _nw49[(int)(4869)] = 90;
      _nw49[(int)(4870)] = 73;
      _nw49[(int)(4871)] = 234;
      _nw49[(int)(4872)] = 18;
      _nw49[(int)(4873)] = 188;
      _nw49[(int)(4874)] = 81;
      _nw49[(int)(4875)] = 212;
      _nw49[(int)(4876)] = 190;
      _nw49[(int)(4877)] = 26;
      _nw49[(int)(4878)] = 31;
      _nw49[(int)(4879)] = 107;
      _nw49[(int)(4880)] = 98;
      _nw49[(int)(4881)] = 37;
      _nw49[(int)(4882)] = 39;
      _nw49[(int)(4883)] = 98;
      _nw49[(int)(4884)] = 244;
      _nw49[(int)(4885)] = 191;
      _nw49[(int)(4886)] = 191;
      _nw49[(int)(4887)] = 178;
      _nw49[(int)(4888)] = 199;
      _nw49[(int)(4889)] = 16;
      _nw49[(int)(4890)] = 214;
      _nw49[(int)(4891)] = 85;
      _nw49[(int)(4892)] = 15;
      _nw49[(int)(4893)] = 5;
      _nw49[(int)(4894)] = 211;
      _nw49[(int)(4895)] = 23;
      _nw49[(int)(4896)] = 229;
      _nw49[(int)(4897)] = 144;
      _nw49[(int)(4898)] = 98;
      _nw49[(int)(4899)] = 90;
      _nw49[(int)(4900)] = 209;
      _nw49[(int)(4901)] = 59;
      _nw49[(int)(4902)] = 198;
      _nw49[(int)(4903)] = 215;
      _nw49[(int)(4904)] = 54;
      _nw49[(int)(4905)] = 195;
      _nw49[(int)(4906)] = 39;
      _nw49[(int)(4907)] = 124;
      _nw49[(int)(4908)] = 177;
      _nw49[(int)(4909)] = 48;
      _nw49[(int)(4910)] = 60;
      _nw49[(int)(4911)] = 123;
      _nw49[(int)(4912)] = 143;
      _nw49[(int)(4913)] = 37;
      _nw49[(int)(4914)] = 190;
      _nw49[(int)(4915)] = 176;
      _nw49[(int)(4916)] = 105;
      _nw49[(int)(4917)] = 13;
      _nw49[(int)(4918)] = 19;
      _nw49[(int)(4919)] = 97;
      _nw49[(int)(4920)] = 65;
      _nw49[(int)(4921)] = 31;
      _nw49[(int)(4922)] = 0;
      _nw49[(int)(4923)] = 156;
      _nw49[(int)(4924)] = 27;
      _nw49[(int)(4925)] = 234;
      _nw49[(int)(4926)] = 36;
      _nw49[(int)(4927)] = 239;
      _nw49[(int)(4928)] = 68;
      _nw49[(int)(4929)] = 223;
      _nw49[(int)(4930)] = 209;
      _nw49[(int)(4931)] = 211;
      _nw49[(int)(4932)] = 244;
      _nw49[(int)(4933)] = 244;
      _nw49[(int)(4934)] = 69;
      _nw49[(int)(4935)] = 220;
      _nw49[(int)(4936)] = 190;
      _nw49[(int)(4937)] = 117;
      _nw49[(int)(4938)] = 107;
      _nw49[(int)(4939)] = 48;
      _nw49[(int)(4940)] = 88;
      _nw49[(int)(4941)] = 22;
      _nw49[(int)(4942)] = 153;
      _nw49[(int)(4943)] = 255;
      _nw49[(int)(4944)] = 70;
      _nw49[(int)(4945)] = 16;
      _nw49[(int)(4946)] = 13;
      _nw49[(int)(4947)] = 74;
      _nw49[(int)(4948)] = 128;
      _nw49[(int)(4949)] = 216;
      _nw49[(int)(4950)] = 241;
      _nw49[(int)(4951)] = 230;
      _nw49[(int)(4952)] = 43;
      _nw49[(int)(4953)] = 166;
      _nw49[(int)(4954)] = 53;
      _nw49[(int)(4955)] = 69;
      _nw49[(int)(4956)] = 48;
      _nw49[(int)(4957)] = 105;
      _nw49[(int)(4958)] = 11;
      _nw49[(int)(4959)] = 46;
      _nw49[(int)(4960)] = 192;
      _nw49[(int)(4961)] = 108;
      _nw49[(int)(4962)] = 184;
      _nw49[(int)(4963)] = 117;
      _nw49[(int)(4964)] = 49;
      _nw49[(int)(4965)] = 138;
      _nw49[(int)(4966)] = 5;
      _nw49[(int)(4967)] = 96;
      _nw49[(int)(4968)] = 150;
      _nw49[(int)(4969)] = 51;
      _nw49[(int)(4970)] = 105;
      _nw49[(int)(4971)] = 26;
      _nw49[(int)(4972)] = 167;
      _nw49[(int)(4973)] = 29;
      _nw49[(int)(4974)] = 189;
      _nw49[(int)(4975)] = 95;
      _nw49[(int)(4976)] = 119;
      _nw49[(int)(4977)] = 52;
      _nw49[(int)(4978)] = 247;
      _nw49[(int)(4979)] = 0;
      _nw49[(int)(4980)] = 246;
      _nw49[(int)(4981)] = 227;
      _nw49[(int)(4982)] = 168;
      _nw49[(int)(4983)] = 236;
      _nw49[(int)(4984)] = 226;
      _nw49[(int)(4985)] = 115;
      _nw49[(int)(4986)] = 170;
      _nw49[(int)(4987)] = 196;
      _nw49[(int)(4988)] = 114;
      _nw49[(int)(4989)] = 62;
      _nw49[(int)(4990)] = 50;
      _nw49[(int)(4991)] = 249;
      _nw49[(int)(4992)] = 224;
      _nw49[(int)(4993)] = 247;
      _nw49[(int)(4994)] = 45;
      _nw49[(int)(4995)] = 238;
      _nw49[(int)(4996)] = 98;
      _nw49[(int)(4997)] = 163;
      _nw49[(int)(4998)] = 192;
      _nw49[(int)(4999)] = 230;
      _nw49[(int)(5000)] = 244;
      _nw49[(int)(5001)] = 222;
      _nw49[(int)(5002)] = 174;
      _nw49[(int)(5003)] = 188;
      _nw49[(int)(5004)] = 252;
      _nw49[(int)(5005)] = 89;
      _nw49[(int)(5006)] = 15;
      _nw49[(int)(5007)] = 83;
      _nw49[(int)(5008)] = 126;
      _nw49[(int)(5009)] = 225;
      _nw49[(int)(5010)] = 134;
      _nw49[(int)(5011)] = 227;
      _nw49[(int)(5012)] = 89;
      _nw49[(int)(5013)] = 253;
      _nw49[(int)(5014)] = 210;
      _nw49[(int)(5015)] = 104;
      _nw49[(int)(5016)] = 171;
      _nw49[(int)(5017)] = 153;
      _nw49[(int)(5018)] = 92;
      _nw49[(int)(5019)] = 102;
      _nw49[(int)(5020)] = 247;
      _nw49[(int)(5021)] = 22;
      _nw49[(int)(5022)] = 209;
      _nw49[(int)(5023)] = 236;
      _nw49[(int)(5024)] = 203;
      _nw49[(int)(5025)] = 7;
      _nw49[(int)(5026)] = 238;
      _nw49[(int)(5027)] = 65;
      _nw49[(int)(5028)] = 19;
      _nw49[(int)(5029)] = 8;
      _nw49[(int)(5030)] = 189;
      _nw49[(int)(5031)] = 186;
      _nw49[(int)(5032)] = 28;
      _nw49[(int)(5033)] = 120;
      _nw49[(int)(5034)] = 191;
      _nw49[(int)(5035)] = 108;
      _nw49[(int)(5036)] = 245;
      _nw49[(int)(5037)] = 119;
      _nw49[(int)(5038)] = 163;
      _nw49[(int)(5039)] = 189;
      _nw49[(int)(5040)] = 85;
      _nw49[(int)(5041)] = 175;
      _nw49[(int)(5042)] = 38;
      _nw49[(int)(5043)] = 146;
      _nw49[(int)(5044)] = 162;
      _nw49[(int)(5045)] = 60;
      _nw49[(int)(5046)] = 144;
      _nw49[(int)(5047)] = 0;
      _nw49[(int)(5048)] = 207;
      _nw49[(int)(5049)] = 153;
      _nw49[(int)(5050)] = 96;
      _nw49[(int)(5051)] = 129;
      _nw49[(int)(5052)] = 196;
      _nw49[(int)(5053)] = 207;
      _nw49[(int)(5054)] = 209;
      _nw49[(int)(5055)] = 186;
      _nw49[(int)(5056)] = 159;
      _nw49[(int)(5057)] = 98;
      _nw49[(int)(5058)] = 183;
      _nw49[(int)(5059)] = 139;
      _nw49[(int)(5060)] = 20;
      _nw49[(int)(5061)] = 73;
      _nw49[(int)(5062)] = 79;
      _nw49[(int)(5063)] = 167;
      _nw49[(int)(5064)] = 108;
      _nw49[(int)(5065)] = 60;
      _nw49[(int)(5066)] = 200;
      _nw49[(int)(5067)] = 153;
      _nw49[(int)(5068)] = 172;
      _nw49[(int)(5069)] = 106;
      _nw49[(int)(5070)] = 105;
      _nw49[(int)(5071)] = 54;
      _nw49[(int)(5072)] = 94;
      _nw49[(int)(5073)] = 49;
      _nw49[(int)(5074)] = 108;
      _nw49[(int)(5075)] = 88;
      _nw49[(int)(5076)] = 195;
      _nw49[(int)(5077)] = 191;
      _nw49[(int)(5078)] = 72;
      _nw49[(int)(5079)] = 71;
      _nw49[(int)(5080)] = 206;
      _nw49[(int)(5081)] = 91;
      _nw49[(int)(5082)] = 26;
      _nw49[(int)(5083)] = 11;
      _nw49[(int)(5084)] = 181;
      _nw49[(int)(5085)] = 11;
      _nw49[(int)(5086)] = 240;
      _nw49[(int)(5087)] = 17;
      _nw49[(int)(5088)] = 103;
      _nw49[(int)(5089)] = 133;
      _nw49[(int)(5090)] = 27;
      _nw49[(int)(5091)] = 16;
      _nw49[(int)(5092)] = 51;
      _nw49[(int)(5093)] = 69;
      _nw49[(int)(5094)] = 57;
      _nw49[(int)(5095)] = 193;
      _nw49[(int)(5096)] = 65;
      _nw49[(int)(5097)] = 239;
      _nw49[(int)(5098)] = 166;
      _nw49[(int)(5099)] = 164;
      _nw49[(int)(5100)] = 21;
      _nw49[(int)(5101)] = 3;
      _nw49[(int)(5102)] = 182;
      _nw49[(int)(5103)] = 236;
      _nw49[(int)(5104)] = 9;
      _nw49[(int)(5105)] = 61;
      _nw49[(int)(5106)] = 95;
      _nw49[(int)(5107)] = 34;
      _nw49[(int)(5108)] = 169;
      _nw49[(int)(5109)] = 112;
      _nw49[(int)(5110)] = 131;
      _nw49[(int)(5111)] = 161;
      _nw49[(int)(5112)] = 115;
      _nw49[(int)(5113)] = 230;
      _nw49[(int)(5114)] = 235;
      _nw49[(int)(5115)] = 251;
      _nw49[(int)(5116)] = 163;
      _nw49[(int)(5117)] = 146;
      _nw49[(int)(5118)] = 245;
      _nw49[(int)(5119)] = 33;
      _nw49[(int)(5120)] = 189;
      _nw49[(int)(5121)] = 3;
      _nw49[(int)(5122)] = 25;
      _nw49[(int)(5123)] = 21;
      _nw49[(int)(5124)] = 177;
      _nw49[(int)(5125)] = 115;
      _nw49[(int)(5126)] = 194;
      _nw49[(int)(5127)] = 230;
      _nw49[(int)(5128)] = 68;
      _nw49[(int)(5129)] = 185;
      _nw49[(int)(5130)] = 48;
      _nw49[(int)(5131)] = 14;
      _nw49[(int)(5132)] = 57;
      _nw49[(int)(5133)] = 206;
      _nw49[(int)(5134)] = 231;
      _nw49[(int)(5135)] = 7;
      _nw49[(int)(5136)] = 73;
      _nw49[(int)(5137)] = 123;
      _nw49[(int)(5138)] = 109;
      _nw49[(int)(5139)] = 123;
      _nw49[(int)(5140)] = 2;
      _nw49[(int)(5141)] = 116;
      _nw49[(int)(5142)] = 167;
      _nw49[(int)(5143)] = 189;
      _nw49[(int)(5144)] = 56;
      _nw49[(int)(5145)] = 53;
      _nw49[(int)(5146)] = 179;
      _nw49[(int)(5147)] = 89;
      _nw49[(int)(5148)] = 58;
      _nw49[(int)(5149)] = 16;
      _nw49[(int)(5150)] = 107;
      _nw49[(int)(5151)] = 244;
      _nw49[(int)(5152)] = 242;
      _nw49[(int)(5153)] = 186;
      _nw49[(int)(5154)] = 212;
      _nw49[(int)(5155)] = 181;
      _nw49[(int)(5156)] = 191;
      _nw49[(int)(5157)] = 225;
      _nw49[(int)(5158)] = 30;
      _nw49[(int)(5159)] = 0;
      _nw49[(int)(5160)] = 237;
      _nw49[(int)(5161)] = 51;
      _nw49[(int)(5162)] = 47;
      _nw49[(int)(5163)] = 199;
      _nw49[(int)(5164)] = 243;
      _nw49[(int)(5165)] = 69;
      _nw49[(int)(5166)] = 70;
      _nw49[(int)(5167)] = 175;
      _nw49[(int)(5168)] = 185;
      _nw49[(int)(5169)] = 242;
      _nw49[(int)(5170)] = 226;
      _nw49[(int)(5171)] = 7;
      _nw49[(int)(5172)] = 74;
      _nw49[(int)(5173)] = 241;
      _nw49[(int)(5174)] = 206;
      _nw49[(int)(5175)] = 166;
      _nw49[(int)(5176)] = 135;
      _nw49[(int)(5177)] = 47;
      _nw49[(int)(5178)] = 235;
      _nw49[(int)(5179)] = 88;
      _nw49[(int)(5180)] = 51;
      _nw49[(int)(5181)] = 194;
      _nw49[(int)(5182)] = 83;
      _nw49[(int)(5183)] = 178;
      _nw49[(int)(5184)] = 210;
      _nw49[(int)(5185)] = 94;
      _nw49[(int)(5186)] = 93;
      _nw49[(int)(5187)] = 133;
      _nw49[(int)(5188)] = 149;
      _nw49[(int)(5189)] = 166;
      _nw49[(int)(5190)] = 204;
      _nw49[(int)(5191)] = 78;
      _nw49[(int)(5192)] = 57;
      _nw49[(int)(5193)] = 99;
      _nw49[(int)(5194)] = 102;
      _nw49[(int)(5195)] = 164;
      _nw49[(int)(5196)] = 178;
      _nw49[(int)(5197)] = 123;
      _nw49[(int)(5198)] = 190;
      _nw49[(int)(5199)] = 129;
      _nw49[(int)(5200)] = 133;
      _nw49[(int)(5201)] = 225;
      _nw49[(int)(5202)] = 175;
      _nw49[(int)(5203)] = 176;
      _nw49[(int)(5204)] = 98;
      _nw49[(int)(5205)] = 159;
      _nw49[(int)(5206)] = 113;
      _nw49[(int)(5207)] = 225;
      _nw49[(int)(5208)] = 122;
      _nw49[(int)(5209)] = 209;
      _nw49[(int)(5210)] = 167;
      _nw49[(int)(5211)] = 185;
      _nw49[(int)(5212)] = 180;
      _nw49[(int)(5213)] = 140;
      _nw49[(int)(5214)] = 16;
      _nw49[(int)(5215)] = 175;
      _nw49[(int)(5216)] = 104;
      _nw49[(int)(5217)] = 214;
      _nw49[(int)(5218)] = 177;
      _nw49[(int)(5219)] = 201;
      _nw49[(int)(5220)] = 131;
      _nw49[(int)(5221)] = 10;
      _nw49[(int)(5222)] = 206;
      _nw49[(int)(5223)] = 117;
      _nw49[(int)(5224)] = 115;
      _nw49[(int)(5225)] = 183;
      _nw49[(int)(5226)] = 24;
      _nw49[(int)(5227)] = 25;
      _nw49[(int)(5228)] = 145;
      _nw49[(int)(5229)] = 228;
      _nw49[(int)(5230)] = 43;
      _nw49[(int)(5231)] = 81;
      _nw49[(int)(5232)] = 45;
      _nw49[(int)(5233)] = 123;
      _nw49[(int)(5234)] = 162;
      _nw49[(int)(5235)] = 111;
      _nw49[(int)(5236)] = 251;
      _nw49[(int)(5237)] = 6;
      _nw49[(int)(5238)] = 102;
      _nw49[(int)(5239)] = 198;
      _nw49[(int)(5240)] = 175;
      _nw49[(int)(5241)] = 156;
      _nw49[(int)(5242)] = 187;
      _nw49[(int)(5243)] = 122;
      _nw49[(int)(5244)] = 201;
      _nw49[(int)(5245)] = 49;
      _nw49[(int)(5246)] = 9;
      _nw49[(int)(5247)] = 236;
      _nw49[(int)(5248)] = 11;
      _nw49[(int)(5249)] = 44;
      _nw49[(int)(5250)] = 87;
      _nw49[(int)(5251)] = 83;
      _nw49[(int)(5252)] = 236;
      _nw49[(int)(5253)] = 215;
      _nw49[(int)(5254)] = 131;
      _nw49[(int)(5255)] = 104;
      _nw49[(int)(5256)] = 177;
      _nw49[(int)(5257)] = 211;
      _nw49[(int)(5258)] = 58;
      _nw49[(int)(5259)] = 87;
      _nw49[(int)(5260)] = 255;
      _nw49[(int)(5261)] = 228;
      _nw49[(int)(5262)] = 87;
      _nw49[(int)(5263)] = 3;
      _nw49[(int)(5264)] = 161;
      _nw49[(int)(5265)] = 227;
      _nw49[(int)(5266)] = 85;
      _nw49[(int)(5267)] = 10;
      _nw49[(int)(5268)] = 226;
      _nw49[(int)(5269)] = 12;
      _nw49[(int)(5270)] = 185;
      _nw49[(int)(5271)] = 121;
      _nw49[(int)(5272)] = 134;
      _nw49[(int)(5273)] = 123;
      _nw49[(int)(5274)] = 246;
      _nw49[(int)(5275)] = 248;
      _nw49[(int)(5276)] = 130;
      _nw49[(int)(5277)] = 13;
      _nw49[(int)(5278)] = 184;
      _nw49[(int)(5279)] = 68;
      _nw49[(int)(5280)] = 182;
      _nw49[(int)(5281)] = 75;
      _nw49[(int)(5282)] = 61;
      _nw49[(int)(5283)] = 30;
      _nw49[(int)(5284)] = 43;
      _nw49[(int)(5285)] = 164;
      _nw49[(int)(5286)] = 168;
      _nw49[(int)(5287)] = 191;
      _nw49[(int)(5288)] = 232;
      _nw49[(int)(5289)] = 69;
      _nw49[(int)(5290)] = 196;
      _nw49[(int)(5291)] = 221;
      _nw49[(int)(5292)] = 203;
      _nw49[(int)(5293)] = 238;
      _nw49[(int)(5294)] = 0;
      _nw49[(int)(5295)] = 250;
      _nw49[(int)(5296)] = 43;
      _nw49[(int)(5297)] = 167;
      _nw49[(int)(5298)] = 226;
      _nw49[(int)(5299)] = 215;
      _nw49[(int)(5300)] = 167;
      _nw49[(int)(5301)] = 239;
      _nw49[(int)(5302)] = 126;
      _nw49[(int)(5303)] = 144;
      _nw49[(int)(5304)] = 128;
      _nw49[(int)(5305)] = 127;
      _nw49[(int)(5306)] = 89;
      _nw49[(int)(5307)] = 42;
      _nw49[(int)(5308)] = 153;
      _nw49[(int)(5309)] = 253;
      _nw49[(int)(5310)] = 81;
      _nw49[(int)(5311)] = 225;
      _nw49[(int)(5312)] = 237;
      _nw49[(int)(5313)] = 4;
      _nw49[(int)(5314)] = 164;
      _nw49[(int)(5315)] = 254;
      _nw49[(int)(5316)] = 61;
      _nw49[(int)(5317)] = 39;
      _nw49[(int)(5318)] = 150;
      _nw49[(int)(5319)] = 233;
      _nw49[(int)(5320)] = 180;
      _nw49[(int)(5321)] = 237;
      _nw49[(int)(5322)] = 239;
      _nw49[(int)(5323)] = 112;
      _nw49[(int)(5324)] = 35;
      _nw49[(int)(5325)] = 96;
      _nw49[(int)(5326)] = 94;
      _nw49[(int)(5327)] = 67;
      _nw49[(int)(5328)] = 44;
      _nw49[(int)(5329)] = 126;
      _nw49[(int)(5330)] = 177;
      _nw49[(int)(5331)] = 251;
      _nw49[(int)(5332)] = 165;
      _nw49[(int)(5333)] = 31;
      _nw49[(int)(5334)] = 93;
      _nw49[(int)(5335)] = 48;
      _nw49[(int)(5336)] = 210;
      _nw49[(int)(5337)] = 106;
      _nw49[(int)(5338)] = 71;
      _nw49[(int)(5339)] = 22;
      _nw49[(int)(5340)] = 17;
      _nw49[(int)(5341)] = 56;
      _nw49[(int)(5342)] = 7;
      _nw49[(int)(5343)] = 60;
      _nw49[(int)(5344)] = 1;
      _nw49[(int)(5345)] = 12;
      _nw49[(int)(5346)] = 94;
      _nw49[(int)(5347)] = 16;
      _nw49[(int)(5348)] = 19;
      _nw49[(int)(5349)] = 149;
      _nw49[(int)(5350)] = 85;
      _nw49[(int)(5351)] = 133;
      _nw49[(int)(5352)] = 234;
      _nw49[(int)(5353)] = 20;
      _nw49[(int)(5354)] = 248;
      _nw49[(int)(5355)] = 218;
      _nw49[(int)(5356)] = 144;
      _nw49[(int)(5357)] = 17;
      _nw49[(int)(5358)] = 180;
      _nw49[(int)(5359)] = 42;
      _nw49[(int)(5360)] = 99;
      _nw49[(int)(5361)] = 137;
      _nw49[(int)(5362)] = 9;
      _nw49[(int)(5363)] = 19;
      _nw49[(int)(5364)] = 28;
      _nw49[(int)(5365)] = 144;
      _nw49[(int)(5366)] = 77;
      _nw49[(int)(5367)] = 34;
      _nw49[(int)(5368)] = 57;
      _nw49[(int)(5369)] = 128;
      _nw49[(int)(5370)] = 223;
      _nw49[(int)(5371)] = 168;
      _nw49[(int)(5372)] = 205;
      _nw49[(int)(5373)] = 149;
      _nw49[(int)(5374)] = 115;
      _nw49[(int)(5375)] = 145;
      _nw49[(int)(5376)] = 175;
      _nw49[(int)(5377)] = 97;
      _nw49[(int)(5378)] = 177;
      _nw49[(int)(5379)] = 193;
      _nw49[(int)(5380)] = 203;
      _nw49[(int)(5381)] = 103;
      _nw49[(int)(5382)] = 15;
      _nw49[(int)(5383)] = 222;
      _nw49[(int)(5384)] = 211;
      _nw49[(int)(5385)] = 184;
      _nw49[(int)(5386)] = 255;
      _nw49[(int)(5387)] = 119;
      _nw49[(int)(5388)] = 20;
      _nw49[(int)(5389)] = 10;
      _nw49[(int)(5390)] = 45;
      _nw49[(int)(5391)] = 179;
      _nw49[(int)(5392)] = 95;
      _nw49[(int)(5393)] = 141;
      _nw49[(int)(5394)] = 198;
      _nw49[(int)(5395)] = 68;
      _nw49[(int)(5396)] = 147;
      _nw49[(int)(5397)] = 79;
      _nw49[(int)(5398)] = 134;
      _nw49[(int)(5399)] = 87;
      _nw49[(int)(5400)] = 108;
      _nw49[(int)(5401)] = 162;
      _nw49[(int)(5402)] = 165;
      _nw49[(int)(5403)] = 5;
      _nw49[(int)(5404)] = 61;
      _nw49[(int)(5405)] = 3;
      _nw49[(int)(5406)] = 210;
      _nw49[(int)(5407)] = 79;
      _nw49[(int)(5408)] = 133;
      _nw49[(int)(5409)] = 68;
      _nw49[(int)(5410)] = 79;
      _nw49[(int)(5411)] = 81;
      _nw49[(int)(5412)] = 85;
      _nw49[(int)(5413)] = 37;
      _nw49[(int)(5414)] = 253;
      _nw49[(int)(5415)] = 184;
      _nw49[(int)(5416)] = 105;
      _nw49[(int)(5417)] = 28;
      _nw49[(int)(5418)] = 114;
      _nw49[(int)(5419)] = 153;
      _nw49[(int)(5420)] = 13;
      _nw49[(int)(5421)] = 180;
      _nw49[(int)(5422)] = 37;
      _nw49[(int)(5423)] = 66;
      _nw49[(int)(5424)] = 217;
      _nw49[(int)(5425)] = 19;
      _nw49[(int)(5426)] = 12;
      _nw49[(int)(5427)] = 86;
      _nw49[(int)(5428)] = 80;
      _nw49[(int)(5429)] = 141;
      _nw49[(int)(5430)] = 111;
      _nw49[(int)(5431)] = 126;
      _nw49[(int)(5432)] = 202;
      _nw49[(int)(5433)] = 168;
      _nw49[(int)(5434)] = 32;
      _nw49[(int)(5435)] = 209;
      _nw49[(int)(5436)] = 241;
      _nw49[(int)(5437)] = 159;
      _nw49[(int)(5438)] = 187;
      _nw49[(int)(5439)] = 194;
      _nw49[(int)(5440)] = 19;
      _nw49[(int)(5441)] = 250;
      _nw49[(int)(5442)] = 43;
      _nw49[(int)(5443)] = 70;
      _nw49[(int)(5444)] = 1;
      _nw49[(int)(5445)] = 243;
      _nw49[(int)(5446)] = 231;
      _nw49[(int)(5447)] = 42;
      _nw49[(int)(5448)] = 37;
      _nw49[(int)(5449)] = 96;
      _nw49[(int)(5450)] = 246;
      _nw49[(int)(5451)] = 178;
      _nw49[(int)(5452)] = 181;
      _nw49[(int)(5453)] = 156;
      _nw49[(int)(5454)] = 130;
      _nw49[(int)(5455)] = 64;
      _nw49[(int)(5456)] = 194;
      _nw49[(int)(5457)] = 220;
      _nw49[(int)(5458)] = 60;
      _nw49[(int)(5459)] = 84;
      _nw49[(int)(5460)] = 56;
      _nw49[(int)(5461)] = 122;
      _nw49[(int)(5462)] = 126;
      _nw49[(int)(5463)] = 165;
      _nw49[(int)(5464)] = 61;
      _nw49[(int)(5465)] = 209;
      _nw49[(int)(5466)] = 245;
      _nw49[(int)(5467)] = 101;
      _nw49[(int)(5468)] = 124;
      _nw49[(int)(5469)] = 62;
      _nw49[(int)(5470)] = 146;
      _nw49[(int)(5471)] = 24;
      _nw49[(int)(5472)] = 164;
      _nw49[(int)(5473)] = 231;
      _nw49[(int)(5474)] = 43;
      _nw49[(int)(5475)] = 120;
      _nw49[(int)(5476)] = 148;
      _nw49[(int)(5477)] = 165;
      _nw49[(int)(5478)] = 31;
      _nw49[(int)(5479)] = 73;
      _nw49[(int)(5480)] = 97;
      _nw49[(int)(5481)] = 82;
      _nw49[(int)(5482)] = 67;
      _nw49[(int)(5483)] = 228;
      _nw49[(int)(5484)] = 34;
      _nw49[(int)(5485)] = 46;
      _nw49[(int)(5486)] = 129;
      _nw49[(int)(5487)] = 167;
      _nw49[(int)(5488)] = 29;
      _nw49[(int)(5489)] = 37;
      _nw49[(int)(5490)] = 140;
      _nw49[(int)(5491)] = 240;
      _nw49[(int)(5492)] = 191;
      _nw49[(int)(5493)] = 236;
      _nw49[(int)(5494)] = 240;
      _nw49[(int)(5495)] = 160;
      _nw49[(int)(5496)] = 163;
      _nw49[(int)(5497)] = 112;
      _nw49[(int)(5498)] = 215;
      _nw49[(int)(5499)] = 146;
      _nw49[(int)(5500)] = 47;
      _nw49[(int)(5501)] = 177;
      _nw49[(int)(5502)] = 101;
      _nw49[(int)(5503)] = 117;
      _nw49[(int)(5504)] = 228;
      _nw49[(int)(5505)] = 25;
      _nw49[(int)(5506)] = 37;
      _nw49[(int)(5507)] = 185;
      _nw49[(int)(5508)] = 56;
      _nw49[(int)(5509)] = 222;
      _nw49[(int)(5510)] = 194;
      _nw49[(int)(5511)] = 100;
      _nw49[(int)(5512)] = 100;
      _nw49[(int)(5513)] = 57;
      _nw49[(int)(5514)] = 68;
      _nw49[(int)(5515)] = 147;
      _nw49[(int)(5516)] = 192;
      _nw49[(int)(5517)] = 139;
      _nw49[(int)(5518)] = 99;
      _nw49[(int)(5519)] = 162;
      _nw49[(int)(5520)] = 215;
      _nw49[(int)(5521)] = 107;
      _nw49[(int)(5522)] = 78;
      _nw49[(int)(5523)] = 117;
      _nw49[(int)(5524)] = 247;
      _nw49[(int)(5525)] = 141;
      _nw49[(int)(5526)] = 63;
      _nw49[(int)(5527)] = 168;
      _nw49[(int)(5528)] = 71;
      _nw49[(int)(5529)] = 58;
      _nw49[(int)(5530)] = 189;
      _nw49[(int)(5531)] = 40;
      _nw49[(int)(5532)] = 200;
      _nw49[(int)(5533)] = 243;
      _nw49[(int)(5534)] = 132;
      _nw49[(int)(5535)] = 96;
      _nw49[(int)(5536)] = 169;
      _nw49[(int)(5537)] = 208;
      _nw49[(int)(5538)] = 117;
      _nw49[(int)(5539)] = 6;
      _nw49[(int)(5540)] = 62;
      _nw49[(int)(5541)] = 173;
      _nw49[(int)(5542)] = 52;
      _nw49[(int)(5543)] = 86;
      _nw49[(int)(5544)] = 202;
      _nw49[(int)(5545)] = 223;
      _nw49[(int)(5546)] = 140;
      _nw49[(int)(5547)] = 24;
      _nw49[(int)(5548)] = 45;
      _nw49[(int)(5549)] = 111;
      _nw49[(int)(5550)] = 198;
      _nw49[(int)(5551)] = 165;
      _nw49[(int)(5552)] = 139;
      _nw49[(int)(5553)] = 152;
      _nw49[(int)(5554)] = 10;
      _nw49[(int)(5555)] = 87;
      _nw49[(int)(5556)] = 126;
      _nw49[(int)(5557)] = 28;
      _nw49[(int)(5558)] = 114;
      _nw49[(int)(5559)] = 185;
      _nw49[(int)(5560)] = 254;
      _nw49[(int)(5561)] = 193;
      _nw49[(int)(5562)] = 100;
      _nw49[(int)(5563)] = 21;
      _nw49[(int)(5564)] = 144;
      _nw49[(int)(5565)] = 142;
      _nw49[(int)(5566)] = 8;
      _nw49[(int)(5567)] = 233;
      _nw49[(int)(5568)] = 193;
      _nw49[(int)(5569)] = 87;
      _nw49[(int)(5570)] = 110;
      _nw49[(int)(5571)] = 79;
      _nw49[(int)(5572)] = 60;
      _nw49[(int)(5573)] = 170;
      _nw49[(int)(5574)] = 160;
      _nw49[(int)(5575)] = 92;
      _nw49[(int)(5576)] = 212;
      _nw49[(int)(5577)] = 10;
      _nw49[(int)(5578)] = 163;
      _nw49[(int)(5579)] = 135;
      _nw49[(int)(5580)] = 34;
      _nw49[(int)(5581)] = 247;
      _nw49[(int)(5582)] = 128;
      _nw49[(int)(5583)] = 232;
      _nw49[(int)(5584)] = 212;
      _nw49[(int)(5585)] = 235;
      _nw49[(int)(5586)] = 142;
      _nw49[(int)(5587)] = 46;
      _nw49[(int)(5588)] = 14;
      _nw49[(int)(5589)] = 247;
      _nw49[(int)(5590)] = 15;
      _nw49[(int)(5591)] = 86;
      _nw49[(int)(5592)] = 69;
      _nw49[(int)(5593)] = 88;
      _nw49[(int)(5594)] = 7;
      _nw49[(int)(5595)] = 28;
      _nw49[(int)(5596)] = 88;
      _nw49[(int)(5597)] = 188;
      _nw49[(int)(5598)] = 200;
      _nw49[(int)(5599)] = 216;
      _nw49[(int)(5600)] = 209;
      _nw49[(int)(5601)] = 227;
      _nw49[(int)(5602)] = 65;
      _nw49[(int)(5603)] = 234;
      _nw49[(int)(5604)] = 39;
      _nw49[(int)(5605)] = 241;
      _nw49[(int)(5606)] = 83;
      _nw49[(int)(5607)] = 235;
      _nw49[(int)(5608)] = 154;
      _nw49[(int)(5609)] = 212;
      _nw49[(int)(5610)] = 118;
      _nw49[(int)(5611)] = 223;
      _nw49[(int)(5612)] = 13;
      _nw49[(int)(5613)] = 112;
      _nw49[(int)(5614)] = 217;
      _nw49[(int)(5615)] = 18;
      _nw49[(int)(5616)] = 240;
      _nw49[(int)(5617)] = 179;
      _nw49[(int)(5618)] = 97;
      _nw49[(int)(5619)] = 206;
      _nw49[(int)(5620)] = 249;
      _nw49[(int)(5621)] = 0;
      _nw49[(int)(5622)] = 228;
      _nw49[(int)(5623)] = 36;
      _nw49[(int)(5624)] = 30;
      _nw49[(int)(5625)] = 124;
      _nw49[(int)(5626)] = 211;
      _nw49[(int)(5627)] = 155;
      _nw49[(int)(5628)] = 228;
      _nw49[(int)(5629)] = 165;
      _nw49[(int)(5630)] = 229;
      _nw49[(int)(5631)] = 240;
      _nw49[(int)(5632)] = 93;
      _nw49[(int)(5633)] = 2;
      _nw49[(int)(5634)] = 91;
      _nw49[(int)(5635)] = 82;
      _nw49[(int)(5636)] = 223;
      _nw49[(int)(5637)] = 216;
      _nw49[(int)(5638)] = 18;
      _nw49[(int)(5639)] = 189;
      _nw49[(int)(5640)] = 236;
      _nw49[(int)(5641)] = 217;
      _nw49[(int)(5642)] = 103;
      _nw49[(int)(5643)] = 148;
      _nw49[(int)(5644)] = 182;
      _nw49[(int)(5645)] = 101;
      _nw49[(int)(5646)] = 49;
      _nw49[(int)(5647)] = 58;
      _nw49[(int)(5648)] = 190;
      _nw49[(int)(5649)] = 243;
      _nw49[(int)(5650)] = 186;
      _nw49[(int)(5651)] = 133;
      _nw49[(int)(5652)] = 198;
      _nw49[(int)(5653)] = 141;
      _nw49[(int)(5654)] = 90;
      _nw49[(int)(5655)] = 0;
      _nw49[(int)(5656)] = 62;
      _nw49[(int)(5657)] = 231;
      _nw49[(int)(5658)] = 227;
      _nw49[(int)(5659)] = 145;
      _nw49[(int)(5660)] = 96;
      _nw49[(int)(5661)] = 3;
      _nw49[(int)(5662)] = 248;
      _nw49[(int)(5663)] = 232;
      _nw49[(int)(5664)] = 120;
      _nw49[(int)(5665)] = 142;
      _nw49[(int)(5666)] = 33;
      _nw49[(int)(5667)] = 252;
      _nw49[(int)(5668)] = 94;
      _nw49[(int)(5669)] = 60;
      _nw49[(int)(5670)] = 86;
      _nw49[(int)(5671)] = 137;
      _nw49[(int)(5672)] = 214;
      _nw49[(int)(5673)] = 39;
      _nw49[(int)(5674)] = 122;
      _nw49[(int)(5675)] = 185;
      _nw49[(int)(5676)] = 185;
      _nw49[(int)(5677)] = 160;
      _nw49[(int)(5678)] = 41;
      _nw49[(int)(5679)] = 123;
      _nw49[(int)(5680)] = 147;
      _nw49[(int)(5681)] = 121;
      _nw49[(int)(5682)] = 22;
      _nw49[(int)(5683)] = 141;
      _nw49[(int)(5684)] = 227;
      _nw49[(int)(5685)] = 142;
      _nw49[(int)(5686)] = 143;
      _nw49[(int)(5687)] = 40;
      _nw49[(int)(5688)] = 177;
      _nw49[(int)(5689)] = 16;
      _nw49[(int)(5690)] = 218;
      _nw49[(int)(5691)] = 52;
      _nw49[(int)(5692)] = 185;
      _nw49[(int)(5693)] = 201;
      _nw49[(int)(5694)] = 205;
      _nw49[(int)(5695)] = 142;
      _nw49[(int)(5696)] = 102;
      _nw49[(int)(5697)] = 87;
      _nw49[(int)(5698)] = 101;
      _nw49[(int)(5699)] = 119;
      _nw49[(int)(5700)] = 45;
      _nw49[(int)(5701)] = 68;
      _nw49[(int)(5702)] = 22;
      _nw49[(int)(5703)] = 131;
      _nw49[(int)(5704)] = 160;
      _nw49[(int)(5705)] = 116;
      _nw49[(int)(5706)] = 87;
      _nw49[(int)(5707)] = 37;
      _nw49[(int)(5708)] = 96;
      _nw49[(int)(5709)] = 56;
      _nw49[(int)(5710)] = 58;
      _nw49[(int)(5711)] = 241;
      _nw49[(int)(5712)] = 159;
      _nw49[(int)(5713)] = 137;
      _nw49[(int)(5714)] = 43;
      _nw49[(int)(5715)] = 209;
      _nw49[(int)(5716)] = 22;
      _nw49[(int)(5717)] = 212;
      _nw49[(int)(5718)] = 2;
      _nw49[(int)(5719)] = 162;
      _nw49[(int)(5720)] = 117;
      _nw49[(int)(5721)] = 154;
      _nw49[(int)(5722)] = 78;
      _nw49[(int)(5723)] = 228;
      _nw49[(int)(5724)] = 76;
      _nw49[(int)(5725)] = 169;
      _nw49[(int)(5726)] = 53;
      _nw49[(int)(5727)] = 86;
      _nw49[(int)(5728)] = 235;
      _nw49[(int)(5729)] = 164;
      _nw49[(int)(5730)] = 244;
      _nw49[(int)(5731)] = 163;
      _nw49[(int)(5732)] = 44;
      _nw49[(int)(5733)] = 13;
      _nw49[(int)(5734)] = 165;
      _nw49[(int)(5735)] = 236;
      _nw49[(int)(5736)] = 88;
      _nw49[(int)(5737)] = 69;
      _nw49[(int)(5738)] = 229;
      _nw49[(int)(5739)] = 152;
      _nw49[(int)(5740)] = 187;
      _nw49[(int)(5741)] = 29;
      _nw49[(int)(5742)] = 245;
      _nw49[(int)(5743)] = 155;
      _nw49[(int)(5744)] = 166;
      _nw49[(int)(5745)] = 106;
      _nw49[(int)(5746)] = 42;
      _nw49[(int)(5747)] = 158;
      _nw49[(int)(5748)] = 21;
      _nw49[(int)(5749)] = 213;
      _nw49[(int)(5750)] = 9;
      _nw49[(int)(5751)] = 158;
      _nw49[(int)(5752)] = 86;
      _nw49[(int)(5753)] = 252;
      _nw49[(int)(5754)] = 174;
      _nw49[(int)(5755)] = 12;
      _nw49[(int)(5756)] = 77;
      _nw49[(int)(5757)] = 176;
      _nw49[(int)(5758)] = 158;
      _nw49[(int)(5759)] = 4;
      _nw49[(int)(5760)] = 28;
      _nw49[(int)(5761)] = 183;
      _nw49[(int)(5762)] = 210;
      _nw49[(int)(5763)] = 61;
      _nw49[(int)(5764)] = 232;
      _nw49[(int)(5765)] = 141;
      _nw49[(int)(5766)] = 233;
      _nw49[(int)(5767)] = 71;
      _nw49[(int)(5768)] = 3;
      _nw49[(int)(5769)] = 18;
      _nw49[(int)(5770)] = 35;
      _nw49[(int)(5771)] = 217;
      _nw49[(int)(5772)] = 171;
      _nw49[(int)(5773)] = 81;
      _nw49[(int)(5774)] = 240;
      _nw49[(int)(5775)] = 66;
      _nw49[(int)(5776)] = 202;
      _nw49[(int)(5777)] = 35;
      _nw49[(int)(5778)] = 25;
      _nw49[(int)(5779)] = 133;
      _nw49[(int)(5780)] = 192;
      _nw49[(int)(5781)] = 52;
      _nw49[(int)(5782)] = 215;
      _nw49[(int)(5783)] = 232;
      _nw49[(int)(5784)] = 11;
      _nw49[(int)(5785)] = 245;
      _nw49[(int)(5786)] = 45;
      _nw49[(int)(5787)] = 228;
      _nw49[(int)(5788)] = 205;
      _nw49[(int)(5789)] = 219;
      _nw49[(int)(5790)] = 109;
      _nw49[(int)(5791)] = 138;
      _nw49[(int)(5792)] = 103;
      _nw49[(int)(5793)] = 127;
      _nw49[(int)(5794)] = 205;
      _nw49[(int)(5795)] = 174;
      _nw49[(int)(5796)] = 88;
      _nw49[(int)(5797)] = 72;
      _nw49[(int)(5798)] = 85;
      _nw49[(int)(5799)] = 239;
      _nw49[(int)(5800)] = 53;
      _nw49[(int)(5801)] = 182;
      _nw49[(int)(5802)] = 192;
      _nw49[(int)(5803)] = 47;
      _nw49[(int)(5804)] = 92;
      _nw49[(int)(5805)] = 195;
      _nw49[(int)(5806)] = 235;
      _nw49[(int)(5807)] = 211;
      _nw49[(int)(5808)] = 174;
      _nw49[(int)(5809)] = 243;
      _nw49[(int)(5810)] = 56;
      _nw49[(int)(5811)] = 55;
      _nw49[(int)(5812)] = 71;
      _nw49[(int)(5813)] = 12;
      _nw49[(int)(5814)] = 164;
      _nw49[(int)(5815)] = 16;
      _nw49[(int)(5816)] = 178;
      _nw49[(int)(5817)] = 196;
      _nw49[(int)(5818)] = 128;
      _nw49[(int)(5819)] = 171;
      _nw49[(int)(5820)] = 147;
      _nw49[(int)(5821)] = 108;
      _nw49[(int)(5822)] = 10;
      _nw49[(int)(5823)] = 112;
      _nw49[(int)(5824)] = 172;
      _nw49[(int)(5825)] = 9;
      _nw49[(int)(5826)] = 223;
      _nw49[(int)(5827)] = 52;
      _nw49[(int)(5828)] = 199;
      _nw49[(int)(5829)] = 120;
      _nw49[(int)(5830)] = 133;
      _nw49[(int)(5831)] = 51;
      _nw49[(int)(5832)] = 174;
      _nw49[(int)(5833)] = 242;
      _nw49[(int)(5834)] = 137;
      _nw49[(int)(5835)] = 161;
      _nw49[(int)(5836)] = 243;
      _nw49[(int)(5837)] = 234;
      _nw49[(int)(5838)] = 213;
      _nw49[(int)(5839)] = 128;
      _nw49[(int)(5840)] = 80;
      _nw49[(int)(5841)] = 140;
      _nw49[(int)(5842)] = 121;
      _nw49[(int)(5843)] = 224;
      _nw49[(int)(5844)] = 146;
      _nw49[(int)(5845)] = 217;
      _nw49[(int)(5846)] = 70;
      _nw49[(int)(5847)] = 20;
      _nw49[(int)(5848)] = 203;
      _nw49[(int)(5849)] = 90;
      _nw49[(int)(5850)] = 13;
      _nw49[(int)(5851)] = 212;
      _nw49[(int)(5852)] = 219;
      _nw49[(int)(5853)] = 139;
      _nw49[(int)(5854)] = 167;
      _nw49[(int)(5855)] = 71;
      _nw49[(int)(5856)] = 3;
      _nw49[(int)(5857)] = 182;
      _nw49[(int)(5858)] = 140;
      _nw49[(int)(5859)] = 209;
      _nw49[(int)(5860)] = 145;
      _nw49[(int)(5861)] = 224;
      _nw49[(int)(5862)] = 215;
      _nw49[(int)(5863)] = 63;
      _nw49[(int)(5864)] = 115;
      _nw49[(int)(5865)] = 169;
      _nw49[(int)(5866)] = 1;
      _nw49[(int)(5867)] = 162;
      _nw49[(int)(5868)] = 225;
      _nw49[(int)(5869)] = 108;
      _nw49[(int)(5870)] = 134;
      _nw49[(int)(5871)] = 225;
      _nw49[(int)(5872)] = 197;
      _nw49[(int)(5873)] = 245;
      _nw49[(int)(5874)] = 153;
      _nw49[(int)(5875)] = 116;
      _nw49[(int)(5876)] = 153;
      _nw49[(int)(5877)] = 135;
      _nw49[(int)(5878)] = 72;
      _nw49[(int)(5879)] = 208;
      _nw49[(int)(5880)] = 235;
      _nw49[(int)(5881)] = 154;
      _nw49[(int)(5882)] = 230;
      _nw49[(int)(5883)] = 68;
      _nw49[(int)(5884)] = 212;
      _nw49[(int)(5885)] = 88;
      _nw49[(int)(5886)] = 111;
      _nw49[(int)(5887)] = 181;
      _nw49[(int)(5888)] = 43;
      _nw49[(int)(5889)] = 167;
      _nw49[(int)(5890)] = 91;
      _nw49[(int)(5891)] = 170;
      _nw49[(int)(5892)] = 203;
      _nw49[(int)(5893)] = 222;
      _nw49[(int)(5894)] = 195;
      _nw49[(int)(5895)] = 9;
      _nw49[(int)(5896)] = 184;
      _nw49[(int)(5897)] = 246;
      _nw49[(int)(5898)] = 82;
      _nw49[(int)(5899)] = 174;
      _nw49[(int)(5900)] = 247;
      _nw49[(int)(5901)] = 84;
      _nw49[(int)(5902)] = 196;
      _nw49[(int)(5903)] = 6;
      _nw49[(int)(5904)] = 46;
      _nw49[(int)(5905)] = 120;
      _nw49[(int)(5906)] = 238;
      _nw49[(int)(5907)] = 223;
      _nw49[(int)(5908)] = 148;
      _nw49[(int)(5909)] = 133;
      _nw49[(int)(5910)] = 167;
      _nw49[(int)(5911)] = 80;
      _nw49[(int)(5912)] = 7;
      _nw49[(int)(5913)] = 102;
      _nw49[(int)(5914)] = 233;
      _nw49[(int)(5915)] = 22;
      _nw49[(int)(5916)] = 133;
      _nw49[(int)(5917)] = 107;
      _nw49[(int)(5918)] = 221;
      _nw49[(int)(5919)] = 149;
      _nw49[(int)(5920)] = 195;
      _nw49[(int)(5921)] = 208;
      _nw49[(int)(5922)] = 94;
      _nw49[(int)(5923)] = 188;
      _nw49[(int)(5924)] = 185;
      _nw49[(int)(5925)] = 62;
      _nw49[(int)(5926)] = 199;
      _nw49[(int)(5927)] = 71;
      _nw49[(int)(5928)] = 41;
      _nw49[(int)(5929)] = 250;
      _nw49[(int)(5930)] = 57;
      _nw49[(int)(5931)] = 178;
      _nw49[(int)(5932)] = 203;
      _nw49[(int)(5933)] = 73;
      _nw49[(int)(5934)] = 221;
      _nw49[(int)(5935)] = 183;
      _nw49[(int)(5936)] = 203;
      _nw49[(int)(5937)] = 119;
      _nw49[(int)(5938)] = 180;
      _nw49[(int)(5939)] = 34;
      _nw49[(int)(5940)] = 207;
      _nw49[(int)(5941)] = 60;
      _nw49[(int)(5942)] = 141;
      _nw49[(int)(5943)] = 142;
      _nw49[(int)(5944)] = 28;
      _nw49[(int)(5945)] = 107;
      _nw49[(int)(5946)] = 114;
      _nw49[(int)(5947)] = 195;
      _nw49[(int)(5948)] = 161;
      _nw49[(int)(5949)] = 8;
      _nw49[(int)(5950)] = 156;
      _nw49[(int)(5951)] = 69;
      _nw49[(int)(5952)] = 123;
      _nw49[(int)(5953)] = 97;
      _nw49[(int)(5954)] = 205;
      _nw49[(int)(5955)] = 97;
      _nw49[(int)(5956)] = 95;
      _nw49[(int)(5957)] = 196;
      _nw49[(int)(5958)] = 196;
      _nw49[(int)(5959)] = 201;
      _nw49[(int)(5960)] = 249;
      _nw49[(int)(5961)] = 65;
      _nw49[(int)(5962)] = 153;
      _nw49[(int)(5963)] = 30;
      _nw49[(int)(5964)] = 84;
      _nw49[(int)(5965)] = 93;
      _nw49[(int)(5966)] = 164;
      _nw49[(int)(5967)] = 206;
      _nw49[(int)(5968)] = 83;
      _nw49[(int)(5969)] = 62;
      _nw49[(int)(5970)] = 56;
      _nw49[(int)(5971)] = 14;
      _nw49[(int)(5972)] = 167;
      _nw49[(int)(5973)] = 255;
      _nw49[(int)(5974)] = 12;
      _nw49[(int)(5975)] = 73;
      _nw49[(int)(5976)] = 123;
      _nw49[(int)(5977)] = 141;
      _nw49[(int)(5978)] = 72;
      _nw49[(int)(5979)] = 38;
      _nw49[(int)(5980)] = 186;
      _nw49[(int)(5981)] = 71;
      _nw49[(int)(5982)] = 205;
      _nw49[(int)(5983)] = 97;
      _nw49[(int)(5984)] = 240;
      _nw49[(int)(5985)] = 91;
      _nw49[(int)(5986)] = 255;
      _nw49[(int)(5987)] = 79;
      _nw49[(int)(5988)] = 119;
      _nw49[(int)(5989)] = 115;
      _nw49[(int)(5990)] = 248;
      _nw49[(int)(5991)] = 145;
      _nw49[(int)(5992)] = 163;
      _nw49[(int)(5993)] = 40;
      _nw49[(int)(5994)] = 58;
      _nw49[(int)(5995)] = 108;
      _nw49[(int)(5996)] = 185;
      _nw49[(int)(5997)] = 187;
      _nw49[(int)(5998)] = 206;
      _nw49[(int)(5999)] = 143;
      _nw49[(int)(6000)] = 46;
      _nw49[(int)(6001)] = 3;
      _nw49[(int)(6002)] = 255;
      _nw49[(int)(6003)] = 16;
      _nw49[(int)(6004)] = 4;
      _nw49[(int)(6005)] = 58;
      _nw49[(int)(6006)] = 142;
      _nw49[(int)(6007)] = 77;
      _nw49[(int)(6008)] = 212;
      _nw49[(int)(6009)] = 134;
      _nw49[(int)(6010)] = 52;
      _nw49[(int)(6011)] = 234;
      _nw49[(int)(6012)] = 142;
      _nw49[(int)(6013)] = 84;
      _nw49[(int)(6014)] = 191;
      _nw49[(int)(6015)] = 129;
      _nw49[(int)(6016)] = 226;
      _nw49[(int)(6017)] = 210;
      _nw49[(int)(6018)] = 101;
      _nw49[(int)(6019)] = 116;
      _nw49[(int)(6020)] = 155;
      _nw49[(int)(6021)] = 57;
      _nw49[(int)(6022)] = 1;
      _nw49[(int)(6023)] = 131;
      _nw49[(int)(6024)] = 208;
      _nw49[(int)(6025)] = 206;
      _nw49[(int)(6026)] = 64;
      _nw49[(int)(6027)] = 11;
      _nw49[(int)(6028)] = 149;
      _nw49[(int)(6029)] = 16;
      _nw49[(int)(6030)] = 174;
      _nw49[(int)(6031)] = 194;
      _nw49[(int)(6032)] = 107;
      _nw49[(int)(6033)] = 187;
      _nw49[(int)(6034)] = 61;
      _nw49[(int)(6035)] = 184;
      _nw49[(int)(6036)] = 206;
      _nw49[(int)(6037)] = 29;
      _nw49[(int)(6038)] = 222;
      _nw49[(int)(6039)] = 189;
      _nw49[(int)(6040)] = 120;
      _nw49[(int)(6041)] = 237;
      _nw49[(int)(6042)] = 56;
      _nw49[(int)(6043)] = 217;
      _nw49[(int)(6044)] = 207;
      _nw49[(int)(6045)] = 55;
      _nw49[(int)(6046)] = 116;
      _nw49[(int)(6047)] = 246;
      _nw49[(int)(6048)] = 122;
      _nw49[(int)(6049)] = 241;
      _nw49[(int)(6050)] = 54;
      _nw49[(int)(6051)] = 235;
      _nw49[(int)(6052)] = 214;
      _nw49[(int)(6053)] = 118;
      _nw49[(int)(6054)] = 72;
      _nw49[(int)(6055)] = 195;
      _nw49[(int)(6056)] = 157;
      _nw49[(int)(6057)] = 13;
      _nw49[(int)(6058)] = 77;
      _nw49[(int)(6059)] = 231;
      _nw49[(int)(6060)] = 92;
      _nw49[(int)(6061)] = 29;
      _nw49[(int)(6062)] = 41;
      _nw49[(int)(6063)] = 105;
      _nw49[(int)(6064)] = 93;
      _nw49[(int)(6065)] = 223;
      _nw49[(int)(6066)] = 170;
      _nw49[(int)(6067)] = 165;
      _nw49[(int)(6068)] = 51;
      _nw49[(int)(6069)] = 17;
      _nw49[(int)(6070)] = 92;
      _nw49[(int)(6071)] = 39;
      _nw49[(int)(6072)] = 179;
      _nw49[(int)(6073)] = 65;
      _nw49[(int)(6074)] = 248;
      _nw49[(int)(6075)] = 20;
      _nw49[(int)(6076)] = 136;
      _nw49[(int)(6077)] = 93;
      _nw49[(int)(6078)] = 16;
      _nw49[(int)(6079)] = 61;
      _nw49[(int)(6080)] = 118;
      _nw49[(int)(6081)] = 158;
      _nw49[(int)(6082)] = 157;
      _nw49[(int)(6083)] = 49;
      _nw49[(int)(6084)] = 131;
      _nw49[(int)(6085)] = 41;
      _nw49[(int)(6086)] = 142;
      _nw49[(int)(6087)] = 252;
      _nw49[(int)(6088)] = 87;
      _nw49[(int)(6089)] = 216;
      _nw49[(int)(6090)] = 66;
      _nw49[(int)(6091)] = 109;
      _nw49[(int)(6092)] = 186;
      _nw49[(int)(6093)] = 40;
      _nw49[(int)(6094)] = 137;
      _nw49[(int)(6095)] = 235;
      _nw49[(int)(6096)] = 248;
      _nw49[(int)(6097)] = 120;
      _nw49[(int)(6098)] = 213;
      _nw49[(int)(6099)] = 224;
      _nw49[(int)(6100)] = 20;
      _nw49[(int)(6101)] = 96;
      _nw49[(int)(6102)] = 236;
      _nw49[(int)(6103)] = 150;
      _nw49[(int)(6104)] = 29;
      _nw49[(int)(6105)] = 37;
      _nw49[(int)(6106)] = 52;
      _nw49[(int)(6107)] = 140;
      _nw49[(int)(6108)] = 168;
      _nw49[(int)(6109)] = 156;
      _nw49[(int)(6110)] = 197;
      _nw49[(int)(6111)] = 56;
      _nw49[(int)(6112)] = 227;
      _nw49[(int)(6113)] = 168;
      _nw49[(int)(6114)] = 222;
      _nw49[(int)(6115)] = 128;
      _nw49[(int)(6116)] = 43;
      _nw49[(int)(6117)] = 149;
      _nw49[(int)(6118)] = 153;
      _nw49[(int)(6119)] = 26;
      _nw49[(int)(6120)] = 95;
      _nw49[(int)(6121)] = 153;
      _nw49[(int)(6122)] = 16;
      _nw49[(int)(6123)] = 182;
      _nw49[(int)(6124)] = 23;
      _nw49[(int)(6125)] = 103;
      _nw49[(int)(6126)] = 156;
      _nw49[(int)(6127)] = 93;
      _nw49[(int)(6128)] = 30;
      _nw49[(int)(6129)] = 75;
      _nw49[(int)(6130)] = 145;
      _nw49[(int)(6131)] = 26;
      _nw49[(int)(6132)] = 116;
      _nw49[(int)(6133)] = 46;
      _nw49[(int)(6134)] = 115;
      _nw49[(int)(6135)] = 63;
      _nw49[(int)(6136)] = 213;
      _nw49[(int)(6137)] = 124;
      _nw49[(int)(6138)] = 193;
      _nw49[(int)(6139)] = 42;
      _nw49[(int)(6140)] = 175;
      _nw49[(int)(6141)] = 180;
      _nw49[(int)(6142)] = 160;
      _nw49[(int)(6143)] = 24;
      _nw49[(int)(6144)] = 220;
      _nw49[(int)(6145)] = 189;
      _nw49[(int)(6146)] = 70;
      _nw49[(int)(6147)] = 23;
      _nw49[(int)(6148)] = 141;
      _nw49[(int)(6149)] = 250;
      _nw49[(int)(6150)] = 104;
      _nw49[(int)(6151)] = 84;
      _nw49[(int)(6152)] = 41;
      _nw49[(int)(6153)] = 39;
      _nw49[(int)(6154)] = 167;
      _nw49[(int)(6155)] = 242;
      _nw49[(int)(6156)] = 63;
      _nw49[(int)(6157)] = 70;
      _nw49[(int)(6158)] = 205;
      _nw49[(int)(6159)] = 115;
      _nw49[(int)(6160)] = 64;
      _nw49[(int)(6161)] = 238;
      _nw49[(int)(6162)] = 185;
      _nw49[(int)(6163)] = 229;
      _nw49[(int)(6164)] = 193;
      _nw49[(int)(6165)] = 26;
      _nw49[(int)(6166)] = 178;
      _nw49[(int)(6167)] = 203;
      _nw49[(int)(6168)] = 213;
      _nw49[(int)(6169)] = 229;
      _nw49[(int)(6170)] = 145;
      _nw49[(int)(6171)] = 83;
      _nw49[(int)(6172)] = 40;
      _nw49[(int)(6173)] = 234;
      _nw49[(int)(6174)] = 75;
      _nw49[(int)(6175)] = 217;
      _nw49[(int)(6176)] = 115;
      _nw49[(int)(6177)] = 84;
      _nw49[(int)(6178)] = 110;
      _nw49[(int)(6179)] = 228;
      _nw49[(int)(6180)] = 114;
      _nw49[(int)(6181)] = 150;
      _nw49[(int)(6182)] = 251;
      _nw49[(int)(6183)] = 116;
      _nw49[(int)(6184)] = 69;
      _nw49[(int)(6185)] = 196;
      _nw49[(int)(6186)] = 252;
      _nw49[(int)(6187)] = 99;
      _nw49[(int)(6188)] = 18;
      _nw49[(int)(6189)] = 247;
      _nw49[(int)(6190)] = 156;
      _nw49[(int)(6191)] = 22;
      _nw49[(int)(6192)] = 104;
      _nw49[(int)(6193)] = 149;
      _nw49[(int)(6194)] = 57;
      _nw49[(int)(6195)] = 133;
      _nw49[(int)(6196)] = 255;
      _nw49[(int)(6197)] = 190;
      _nw49[(int)(6198)] = 251;
      _nw49[(int)(6199)] = 59;
      _nw49[(int)(6200)] = 32;
      _nw49[(int)(6201)] = 108;
      _nw49[(int)(6202)] = 12;
      _nw49[(int)(6203)] = 32;
      _nw49[(int)(6204)] = 211;
      _nw49[(int)(6205)] = 97;
      _nw49[(int)(6206)] = 250;
      _nw49[(int)(6207)] = 119;
      _nw49[(int)(6208)] = 90;
      _nw49[(int)(6209)] = 13;
      _nw49[(int)(6210)] = 80;
      _nw49[(int)(6211)] = 56;
      _nw49[(int)(6212)] = 164;
      _nw49[(int)(6213)] = 44;
      _nw49[(int)(6214)] = 140;
      _nw49[(int)(6215)] = 49;
      _nw49[(int)(6216)] = 239;
      _nw49[(int)(6217)] = 97;
      _nw49[(int)(6218)] = 59;
      _nw49[(int)(6219)] = 137;
      _nw49[(int)(6220)] = 66;
      _nw49[(int)(6221)] = 238;
      _nw49[(int)(6222)] = 192;
      _nw49[(int)(6223)] = 227;
      _nw49[(int)(6224)] = 173;
      _nw49[(int)(6225)] = 153;
      _nw49[(int)(6226)] = 216;
      _nw49[(int)(6227)] = 221;
      _nw49[(int)(6228)] = 172;
      _nw49[(int)(6229)] = 150;
      _nw49[(int)(6230)] = 9;
      _nw49[(int)(6231)] = 221;
      _nw49[(int)(6232)] = 30;
      _nw49[(int)(6233)] = 54;
      _nw49[(int)(6234)] = 8;
      _nw49[(int)(6235)] = 118;
      _nw49[(int)(6236)] = 96;
      _nw49[(int)(6237)] = 131;
      _nw49[(int)(6238)] = 244;
      _nw49[(int)(6239)] = 163;
      _nw49[(int)(6240)] = 56;
      _nw49[(int)(6241)] = 233;
      _nw49[(int)(6242)] = 74;
      _nw49[(int)(6243)] = 157;
      _nw49[(int)(6244)] = 10;
      _nw49[(int)(6245)] = 64;
      _nw49[(int)(6246)] = 47;
      _nw49[(int)(6247)] = 241;
      _nw49[(int)(6248)] = 182;
      _nw49[(int)(6249)] = 28;
      _nw49[(int)(6250)] = 123;
      _nw49[(int)(6251)] = 108;
      _nw49[(int)(6252)] = 203;
      _nw49[(int)(6253)] = 240;
      _nw49[(int)(6254)] = 186;
      _nw49[(int)(6255)] = 121;
      _nw49[(int)(6256)] = 82;
      _nw49[(int)(6257)] = 200;
      _nw49[(int)(6258)] = 45;
      _nw49[(int)(6259)] = 227;
      _nw49[(int)(6260)] = 62;
      _nw49[(int)(6261)] = 161;
      _nw49[(int)(6262)] = 130;
      _nw49[(int)(6263)] = 147;
      _nw49[(int)(6264)] = 3;
      _nw49[(int)(6265)] = 211;
      _nw49[(int)(6266)] = 8;
      _nw49[(int)(6267)] = 86;
      _nw49[(int)(6268)] = 2;
      _nw49[(int)(6269)] = 141;
      _nw49[(int)(6270)] = 29;
      _nw49[(int)(6271)] = 254;
      _nw49[(int)(6272)] = 136;
      _nw49[(int)(6273)] = 39;
      _nw49[(int)(6274)] = 205;
      _nw49[(int)(6275)] = 77;
      _nw49[(int)(6276)] = 51;
      _nw49[(int)(6277)] = 74;
      _nw49[(int)(6278)] = 89;
      _nw49[(int)(6279)] = 183;
      _nw49[(int)(6280)] = 137;
      _nw49[(int)(6281)] = 237;
      _nw49[(int)(6282)] = 215;
      _nw49[(int)(6283)] = 138;
      _nw49[(int)(6284)] = 157;
      _nw49[(int)(6285)] = 105;
      _nw49[(int)(6286)] = 184;
      _nw49[(int)(6287)] = 248;
      _nw49[(int)(6288)] = 146;
      _nw49[(int)(6289)] = 242;
      _nw49[(int)(6290)] = 50;
      _nw49[(int)(6291)] = 98;
      _nw49[(int)(6292)] = 46;
      _nw49[(int)(6293)] = 8;
      _nw49[(int)(6294)] = 89;
      _nw49[(int)(6295)] = 40;
      _nw49[(int)(6296)] = 62;
      _nw49[(int)(6297)] = 255;
      _nw49[(int)(6298)] = 158;
      _nw49[(int)(6299)] = 42;
      _nw49[(int)(6300)] = 253;
      _nw49[(int)(6301)] = 146;
      _nw49[(int)(6302)] = 164;
      _nw49[(int)(6303)] = 126;
      _nw49[(int)(6304)] = 98;
      _nw49[(int)(6305)] = 23;
      _nw49[(int)(6306)] = 238;
      _nw49[(int)(6307)] = 162;
      _nw49[(int)(6308)] = 163;
      _nw49[(int)(6309)] = 76;
      _nw49[(int)(6310)] = 148;
      _nw49[(int)(6311)] = 239;
      _nw49[(int)(6312)] = 98;
      _nw49[(int)(6313)] = 40;
      _nw49[(int)(6314)] = 61;
      _nw49[(int)(6315)] = 48;
      _nw49[(int)(6316)] = 164;
      _nw49[(int)(6317)] = 207;
      _nw49[(int)(6318)] = 19;
      _nw49[(int)(6319)] = 39;
      _nw49[(int)(6320)] = 238;
      _nw49[(int)(6321)] = 76;
      _nw49[(int)(6322)] = 199;
      _nw49[(int)(6323)] = 11;
      _nw49[(int)(6324)] = 114;
      _nw49[(int)(6325)] = 66;
      _nw49[(int)(6326)] = 80;
      _nw49[(int)(6327)] = 198;
      _nw49[(int)(6328)] = 110;
      _nw49[(int)(6329)] = 67;
      _nw49[(int)(6330)] = 10;
      _nw49[(int)(6331)] = 246;
      _nw49[(int)(6332)] = 159;
      _nw49[(int)(6333)] = 46;
      _nw49[(int)(6334)] = 61;
      _nw49[(int)(6335)] = 111;
      _nw49[(int)(6336)] = 185;
      _nw49[(int)(6337)] = 38;
      _nw49[(int)(6338)] = 178;
      _nw49[(int)(6339)] = 86;
      _nw49[(int)(6340)] = 153;
      _nw49[(int)(6341)] = 196;
      _nw49[(int)(6342)] = 117;
      _nw49[(int)(6343)] = 51;
      _nw49[(int)(6344)] = 96;
      _nw49[(int)(6345)] = 24;
      _nw49[(int)(6346)] = 247;
      _nw49[(int)(6347)] = 121;
      _nw49[(int)(6348)] = 71;
      _nw49[(int)(6349)] = 6;
      _nw49[(int)(6350)] = 220;
      _nw49[(int)(6351)] = 98;
      _nw49[(int)(6352)] = 226;
      _nw49[(int)(6353)] = 225;
      _nw49[(int)(6354)] = 69;
      _nw49[(int)(6355)] = 217;
      _nw49[(int)(6356)] = 166;
      _nw49[(int)(6357)] = 175;
      _nw49[(int)(6358)] = 98;
      _nw49[(int)(6359)] = 62;
      _nw49[(int)(6360)] = 50;
      _nw49[(int)(6361)] = 254;
      _nw49[(int)(6362)] = 248;
      _nw49[(int)(6363)] = 193;
      _nw49[(int)(6364)] = 177;
      _nw49[(int)(6365)] = 30;
      _nw49[(int)(6366)] = 183;
      _nw49[(int)(6367)] = 238;
      _nw49[(int)(6368)] = 95;
      _nw49[(int)(6369)] = 226;
      _nw49[(int)(6370)] = 82;
      _nw49[(int)(6371)] = 214;
      _nw49[(int)(6372)] = 128;
      _nw49[(int)(6373)] = 54;
      _nw49[(int)(6374)] = 147;
      _nw49[(int)(6375)] = 122;
      _nw49[(int)(6376)] = 120;
      _nw49[(int)(6377)] = 99;
      _nw49[(int)(6378)] = 9;
      _nw49[(int)(6379)] = 219;
      _nw49[(int)(6380)] = 113;
      _nw49[(int)(6381)] = 30;
      _nw49[(int)(6382)] = 104;
      _nw49[(int)(6383)] = 133;
      _nw49[(int)(6384)] = 12;
      _nw49[(int)(6385)] = 237;
      _nw49[(int)(6386)] = 135;
      _nw49[(int)(6387)] = 99;
      _nw49[(int)(6388)] = 31;
      _nw49[(int)(6389)] = 121;
      _nw49[(int)(6390)] = 91;
      _nw49[(int)(6391)] = 106;
      _nw49[(int)(6392)] = 0;
      _nw49[(int)(6393)] = 161;
      _nw49[(int)(6394)] = 97;
      _nw49[(int)(6395)] = 167;
      _nw49[(int)(6396)] = 238;
      _nw49[(int)(6397)] = 86;
      _nw49[(int)(6398)] = 117;
      _nw49[(int)(6399)] = 235;
      _nw49[(int)(6400)] = 87;
      _nw49[(int)(6401)] = 175;
      _nw49[(int)(6402)] = 27;
      _nw49[(int)(6403)] = 18;
      _nw49[(int)(6404)] = 174;
      _nw49[(int)(6405)] = 36;
      _nw49[(int)(6406)] = 220;
      _nw49[(int)(6407)] = 167;
      _nw49[(int)(6408)] = 135;
      _nw49[(int)(6409)] = 198;
      _nw49[(int)(6410)] = 157;
      _nw49[(int)(6411)] = 82;
      _nw49[(int)(6412)] = 63;
      _nw49[(int)(6413)] = 108;
      _nw49[(int)(6414)] = 147;
      _nw49[(int)(6415)] = 149;
      _nw49[(int)(6416)] = 197;
      _nw49[(int)(6417)] = 97;
      _nw49[(int)(6418)] = 89;
      _nw49[(int)(6419)] = 76;
      _nw49[(int)(6420)] = 26;
      _nw49[(int)(6421)] = 103;
      _nw49[(int)(6422)] = 16;
      _nw49[(int)(6423)] = 35;
      _nw49[(int)(6424)] = 188;
      _nw49[(int)(6425)] = 90;
      _nw49[(int)(6426)] = 145;
      _nw49[(int)(6427)] = 254;
      _nw49[(int)(6428)] = 230;
      _nw49[(int)(6429)] = 56;
      _nw49[(int)(6430)] = 233;
      _nw49[(int)(6431)] = 230;
      _nw49[(int)(6432)] = 74;
      _nw49[(int)(6433)] = 96;
      _nw49[(int)(6434)] = 238;
      _nw49[(int)(6435)] = 255;
      _nw49[(int)(6436)] = 26;
      _nw49[(int)(6437)] = 148;
      _nw49[(int)(6438)] = 20;
      _nw49[(int)(6439)] = 211;
      _nw49[(int)(6440)] = 50;
      _nw49[(int)(6441)] = 48;
      _nw49[(int)(6442)] = 22;
      _nw49[(int)(6443)] = 190;
      _nw49[(int)(6444)] = 79;
      _nw49[(int)(6445)] = 55;
      _nw49[(int)(6446)] = 202;
      _nw49[(int)(6447)] = 51;
      _nw49[(int)(6448)] = 220;
      _nw49[(int)(6449)] = 12;
      _nw49[(int)(6450)] = 3;
      _nw49[(int)(6451)] = 222;
      _nw49[(int)(6452)] = 91;
      _nw49[(int)(6453)] = 1;
      _nw49[(int)(6454)] = 86;
      _nw49[(int)(6455)] = 97;
      _nw49[(int)(6456)] = 216;
      _nw49[(int)(6457)] = 90;
      _nw49[(int)(6458)] = 3;
      _nw49[(int)(6459)] = 209;
      _nw49[(int)(6460)] = 88;
      _nw49[(int)(6461)] = 40;
      _nw49[(int)(6462)] = 68;
      _nw49[(int)(6463)] = 209;
      _nw49[(int)(6464)] = 71;
      _nw49[(int)(6465)] = 233;
      _nw49[(int)(6466)] = 239;
      _nw49[(int)(6467)] = 54;
      _nw49[(int)(6468)] = 21;
      _nw49[(int)(6469)] = 171;
      _nw49[(int)(6470)] = 11;
      _nw49[(int)(6471)] = 95;
      _nw49[(int)(6472)] = 2;
      _nw49[(int)(6473)] = 180;
      _nw49[(int)(6474)] = 95;
      _nw49[(int)(6475)] = 74;
      _nw49[(int)(6476)] = 13;
      _nw49[(int)(6477)] = 133;
      _nw49[(int)(6478)] = 134;
      _nw49[(int)(6479)] = 32;
      _nw49[(int)(6480)] = 227;
      _nw49[(int)(6481)] = 39;
      _nw49[(int)(6482)] = 247;
      _nw49[(int)(6483)] = 113;
      _nw49[(int)(6484)] = 46;
      _nw49[(int)(6485)] = 247;
      _nw49[(int)(6486)] = 177;
      _nw49[(int)(6487)] = 89;
      _nw49[(int)(6488)] = 46;
      _nw49[(int)(6489)] = 3;
      _nw49[(int)(6490)] = 166;
      _nw49[(int)(6491)] = 227;
      _nw49[(int)(6492)] = 23;
      _nw49[(int)(6493)] = 123;
      _nw49[(int)(6494)] = 155;
      _nw49[(int)(6495)] = 57;
      _nw49[(int)(6496)] = 44;
      _nw49[(int)(6497)] = 142;
      _nw49[(int)(6498)] = 37;
      _nw49[(int)(6499)] = 80;
      _nw49[(int)(6500)] = 3;
      _nw49[(int)(6501)] = 247;
      _nw49[(int)(6502)] = 30;
      _nw49[(int)(6503)] = 196;
      _nw49[(int)(6504)] = 127;
      _nw49[(int)(6505)] = 158;
      _nw49[(int)(6506)] = 21;
      _nw49[(int)(6507)] = 73;
      _nw49[(int)(6508)] = 177;
      _nw49[(int)(6509)] = 90;
      _nw49[(int)(6510)] = 241;
      _nw49[(int)(6511)] = 204;
      _nw49[(int)(6512)] = 1;
      _nw49[(int)(6513)] = 224;
      _nw49[(int)(6514)] = 84;
      _nw49[(int)(6515)] = 225;
      _nw49[(int)(6516)] = 193;
      _nw49[(int)(6517)] = 213;
      _nw49[(int)(6518)] = 249;
      _nw49[(int)(6519)] = 167;
      _nw49[(int)(6520)] = 238;
      _nw49[(int)(6521)] = 48;
      _nw49[(int)(6522)] = 108;
      _nw49[(int)(6523)] = 189;
      _nw49[(int)(6524)] = 248;
      _nw49[(int)(6525)] = 123;
      _nw49[(int)(6526)] = 96;
      _nw49[(int)(6527)] = 115;
      _nw49[(int)(6528)] = 232;
      _nw49[(int)(6529)] = 237;
      _nw49[(int)(6530)] = 103;
      _nw49[(int)(6531)] = 78;
      _nw49[(int)(6532)] = 167;
      _nw49[(int)(6533)] = 222;
      _nw49[(int)(6534)] = 77;
      _nw49[(int)(6535)] = 96;
      _nw49[(int)(6536)] = 10;
      _nw49[(int)(6537)] = 56;
      _nw49[(int)(6538)] = 31;
      _nw49[(int)(6539)] = 214;
      _nw49[(int)(6540)] = 159;
      _nw49[(int)(6541)] = 236;
      _nw49[(int)(6542)] = 51;
      _nw49[(int)(6543)] = 134;
      _nw49[(int)(6544)] = 53;
      _nw49[(int)(6545)] = 185;
      _nw49[(int)(6546)] = 175;
      _nw49[(int)(6547)] = 139;
      _nw49[(int)(6548)] = 177;
      _nw49[(int)(6549)] = 40;
      _nw49[(int)(6550)] = 145;
      _nw49[(int)(6551)] = 15;
      _nw49[(int)(6552)] = 196;
      _nw49[(int)(6553)] = 38;
      _nw49[(int)(6554)] = 205;
      _nw49[(int)(6555)] = 222;
      _nw49[(int)(6556)] = 242;
      _nw49[(int)(6557)] = 198;
      _nw49[(int)(6558)] = 23;
      _nw49[(int)(6559)] = 113;
      _nw49[(int)(6560)] = 62;
      _nw49[(int)(6561)] = 116;
      _nw49[(int)(6562)] = 102;
      _nw49[(int)(6563)] = 71;
      _nw49[(int)(6564)] = 166;
      _nw49[(int)(6565)] = 92;
      _nw49[(int)(6566)] = 173;
      _nw49[(int)(6567)] = 50;
      _nw49[(int)(6568)] = 64;
      _nw49[(int)(6569)] = 167;
      _nw49[(int)(6570)] = 58;
      _nw49[(int)(6571)] = 255;
      _nw49[(int)(6572)] = 39;
      _nw49[(int)(6573)] = 5;
      _nw49[(int)(6574)] = 146;
      _nw49[(int)(6575)] = 91;
      _nw49[(int)(6576)] = 58;
      _nw49[(int)(6577)] = 15;
      _nw49[(int)(6578)] = 195;
      _nw49[(int)(6579)] = 244;
      _nw49[(int)(6580)] = 51;
      _nw49[(int)(6581)] = 251;
      _nw49[(int)(6582)] = 4;
      _nw49[(int)(6583)] = 176;
      _nw49[(int)(6584)] = 10;
      _nw49[(int)(6585)] = 222;
      _nw49[(int)(6586)] = 6;
      _nw49[(int)(6587)] = 130;
      _nw49[(int)(6588)] = 1;
      _nw49[(int)(6589)] = 255;
      _nw49[(int)(6590)] = 46;
      _nw49[(int)(6591)] = 130;
      _nw49[(int)(6592)] = 4;
      _nw49[(int)(6593)] = 224;
      _nw49[(int)(6594)] = 200;
      _nw49[(int)(6595)] = 134;
      _nw49[(int)(6596)] = 227;
      _nw49[(int)(6597)] = 175;
      _nw49[(int)(6598)] = 73;
      _nw49[(int)(6599)] = 152;
      _nw49[(int)(6600)] = 80;
      _nw49[(int)(6601)] = 115;
      _nw49[(int)(6602)] = 138;
      _nw49[(int)(6603)] = 139;
      _nw49[(int)(6604)] = 152;
      _nw49[(int)(6605)] = 255;
      _nw49[(int)(6606)] = 13;
      _nw49[(int)(6607)] = 16;
      _nw49[(int)(6608)] = 34;
      _nw49[(int)(6609)] = 20;
      _nw49[(int)(6610)] = 236;
      _nw49[(int)(6611)] = 123;
      _nw49[(int)(6612)] = 180;
      _nw49[(int)(6613)] = 197;
      _nw49[(int)(6614)] = 221;
      _nw49[(int)(6615)] = 133;
      _nw49[(int)(6616)] = 52;
      _nw49[(int)(6617)] = 132;
      _nw49[(int)(6618)] = 25;
      _nw49[(int)(6619)] = 80;
      _nw49[(int)(6620)] = 251;
      _nw49[(int)(6621)] = 127;
      _nw49[(int)(6622)] = 132;
      _nw49[(int)(6623)] = 199;
      _nw49[(int)(6624)] = 146;
      _nw49[(int)(6625)] = 66;
      _nw49[(int)(6626)] = 148;
      _nw49[(int)(6627)] = 47;
      _nw49[(int)(6628)] = 24;
      _nw49[(int)(6629)] = 67;
      _nw49[(int)(6630)] = 62;
      _nw49[(int)(6631)] = 165;
      _nw49[(int)(6632)] = 186;
      _nw49[(int)(6633)] = 212;
      _nw49[(int)(6634)] = 187;
      _nw49[(int)(6635)] = 224;
      _nw49[(int)(6636)] = 62;
      _nw49[(int)(6637)] = 1;
      _nw49[(int)(6638)] = 187;
      _nw49[(int)(6639)] = 118;
      _nw49[(int)(6640)] = 229;
      _nw49[(int)(6641)] = 214;
      _nw49[(int)(6642)] = 69;
      _nw49[(int)(6643)] = 222;
      _nw49[(int)(6644)] = 223;
      _nw49[(int)(6645)] = 67;
      _nw49[(int)(6646)] = 81;
      _nw49[(int)(6647)] = 238;
      _nw49[(int)(6648)] = 143;
      _nw49[(int)(6649)] = 4;
      _nw49[(int)(6650)] = 246;
      _nw49[(int)(6651)] = 60;
      _nw49[(int)(6652)] = 65;
      _nw49[(int)(6653)] = 67;
      _nw49[(int)(6654)] = 43;
      _nw49[(int)(6655)] = 90;
      _nw49[(int)(6656)] = 184;
      _nw49[(int)(6657)] = 110;
      _nw49[(int)(6658)] = 73;
      _nw49[(int)(6659)] = 231;
      _nw49[(int)(6660)] = 255;
      _nw49[(int)(6661)] = 93;
      _nw49[(int)(6662)] = 115;
      _nw49[(int)(6663)] = 131;
      _nw49[(int)(6664)] = 87;
      _nw49[(int)(6665)] = 15;
      _nw49[(int)(6666)] = 159;
      _nw49[(int)(6667)] = 130;
      _nw49[(int)(6668)] = 220;
      _nw49[(int)(6669)] = 3;
      _nw49[(int)(6670)] = 34;
      _nw49[(int)(6671)] = 51;
      _nw49[(int)(6672)] = 101;
      _nw49[(int)(6673)] = 154;
      _nw49[(int)(6674)] = 219;
      _nw49[(int)(6675)] = 3;
      _nw49[(int)(6676)] = 250;
      _nw49[(int)(6677)] = 81;
      _nw49[(int)(6678)] = 105;
      _nw49[(int)(6679)] = 192;
      _nw49[(int)(6680)] = 10;
      _nw49[(int)(6681)] = 32;
      _nw49[(int)(6682)] = 16;
      _nw49[(int)(6683)] = 200;
      _nw49[(int)(6684)] = 208;
      _nw49[(int)(6685)] = 196;
      _nw49[(int)(6686)] = 97;
      _nw49[(int)(6687)] = 72;
      _nw49[(int)(6688)] = 189;
      _nw49[(int)(6689)] = 135;
      _nw49[(int)(6690)] = 191;
      _nw49[(int)(6691)] = 42;
      _nw49[(int)(6692)] = 25;
      _nw49[(int)(6693)] = 52;
      _nw49[(int)(6694)] = 119;
      _nw49[(int)(6695)] = 69;
      _nw49[(int)(6696)] = 15;
      _nw49[(int)(6697)] = 230;
      _nw49[(int)(6698)] = 197;
      _nw49[(int)(6699)] = 143;
      _nw49[(int)(6700)] = 51;
      _nw49[(int)(6701)] = 243;
      _nw49[(int)(6702)] = 100;
      _nw49[(int)(6703)] = 130;
      _nw49[(int)(6704)] = 171;
      _nw49[(int)(6705)] = 176;
      _nw49[(int)(6706)] = 97;
      _nw49[(int)(6707)] = 192;
      _nw49[(int)(6708)] = 125;
      _nw49[(int)(6709)] = 168;
      _nw49[(int)(6710)] = 35;
      _nw49[(int)(6711)] = 127;
      _nw49[(int)(6712)] = 180;
      _nw49[(int)(6713)] = 223;
      _nw49[(int)(6714)] = 208;
      _nw49[(int)(6715)] = 51;
      _nw49[(int)(6716)] = 127;
      _nw49[(int)(6717)] = 69;
      _nw49[(int)(6718)] = 142;
      _nw49[(int)(6719)] = 93;
      _nw49[(int)(6720)] = 188;
      _nw49[(int)(6721)] = 205;
      _nw49[(int)(6722)] = 223;
      _nw49[(int)(6723)] = 172;
      _nw49[(int)(6724)] = 96;
      _nw49[(int)(6725)] = 178;
      _nw49[(int)(6726)] = 236;
      _nw49[(int)(6727)] = 23;
      _nw49[(int)(6728)] = 59;
      _nw49[(int)(6729)] = 207;
      _nw49[(int)(6730)] = 119;
      _nw49[(int)(6731)] = 109;
      _nw49[(int)(6732)] = 162;
      _nw49[(int)(6733)] = 253;
      _nw49[(int)(6734)] = 5;
      _nw49[(int)(6735)] = 226;
      _nw49[(int)(6736)] = 152;
      _nw49[(int)(6737)] = 239;
      _nw49[(int)(6738)] = 228;
      _nw49[(int)(6739)] = 109;
      _nw49[(int)(6740)] = 146;
      _nw49[(int)(6741)] = 168;
      _nw49[(int)(6742)] = 147;
      _nw49[(int)(6743)] = 56;
      _nw49[(int)(6744)] = 7;
      _nw49[(int)(6745)] = 166;
      _nw49[(int)(6746)] = 118;
      _nw49[(int)(6747)] = 131;
      _nw49[(int)(6748)] = 130;
      _nw49[(int)(6749)] = 207;
      _nw49[(int)(6750)] = 115;
      _nw49[(int)(6751)] = 24;
      _nw49[(int)(6752)] = 206;
      _nw49[(int)(6753)] = 215;
      _nw49[(int)(6754)] = 104;
      _nw49[(int)(6755)] = 244;
      _nw49[(int)(6756)] = 109;
      _nw49[(int)(6757)] = 230;
      _nw49[(int)(6758)] = 132;
      _nw49[(int)(6759)] = 79;
      _nw49[(int)(6760)] = 188;
      _nw49[(int)(6761)] = 89;
      _nw49[(int)(6762)] = 210;
      _nw49[(int)(6763)] = 91;
      _nw49[(int)(6764)] = 210;
      _nw49[(int)(6765)] = 28;
      _nw49[(int)(6766)] = 204;
      _nw49[(int)(6767)] = 96;
      _nw49[(int)(6768)] = 173;
      _nw49[(int)(6769)] = 104;
      _nw49[(int)(6770)] = 121;
      _nw49[(int)(6771)] = 112;
      _nw49[(int)(6772)] = 116;
      _nw49[(int)(6773)] = 89;
      _nw49[(int)(6774)] = 6;
      _nw49[(int)(6775)] = 191;
      _nw49[(int)(6776)] = 172;
      _nw49[(int)(6777)] = 67;
      _nw49[(int)(6778)] = 153;
      _nw49[(int)(6779)] = 98;
      _nw49[(int)(6780)] = 236;
      _nw49[(int)(6781)] = 118;
      _nw49[(int)(6782)] = 151;
      _nw49[(int)(6783)] = 17;
      _nw49[(int)(6784)] = 154;
      _nw49[(int)(6785)] = 133;
      _nw49[(int)(6786)] = 212;
      _nw49[(int)(6787)] = 237;
      _nw49[(int)(6788)] = 246;
      _nw49[(int)(6789)] = 32;
      _nw49[(int)(6790)] = 46;
      _nw49[(int)(6791)] = 60;
      _nw49[(int)(6792)] = 146;
      _nw49[(int)(6793)] = 93;
      _nw49[(int)(6794)] = 98;
      _nw49[(int)(6795)] = 34;
      _nw49[(int)(6796)] = 68;
      _nw49[(int)(6797)] = 189;
      _nw49[(int)(6798)] = 178;
      _nw49[(int)(6799)] = 59;
      _nw49[(int)(6800)] = 100;
      _nw49[(int)(6801)] = 130;
      _nw49[(int)(6802)] = 99;
      _nw49[(int)(6803)] = 225;
      _nw49[(int)(6804)] = 57;
      _nw49[(int)(6805)] = 198;
      _nw49[(int)(6806)] = 105;
      _nw49[(int)(6807)] = 11;
      _nw49[(int)(6808)] = 100;
      _nw49[(int)(6809)] = 201;
      _nw49[(int)(6810)] = 112;
      _nw49[(int)(6811)] = 203;
      _nw49[(int)(6812)] = 2;
      _nw49[(int)(6813)] = 137;
      _nw49[(int)(6814)] = 229;
      _nw49[(int)(6815)] = 109;
      _nw49[(int)(6816)] = 177;
      _nw49[(int)(6817)] = 45;
      _nw49[(int)(6818)] = 81;
      _nw49[(int)(6819)] = 45;
      _nw49[(int)(6820)] = 221;
      _nw49[(int)(6821)] = 228;
      _nw49[(int)(6822)] = 73;
      _nw49[(int)(6823)] = 82;
      _nw49[(int)(6824)] = 189;
      _nw49[(int)(6825)] = 156;
      _nw49[(int)(6826)] = 165;
      _nw49[(int)(6827)] = 236;
      _nw49[(int)(6828)] = 162;
      _nw49[(int)(6829)] = 164;
      _nw49[(int)(6830)] = 114;
      _nw49[(int)(6831)] = 57;
      _nw49[(int)(6832)] = 142;
      _nw49[(int)(6833)] = 226;
      _nw49[(int)(6834)] = 191;
      _nw49[(int)(6835)] = 188;
      _nw49[(int)(6836)] = 71;
      _nw49[(int)(6837)] = 190;
      _nw49[(int)(6838)] = 143;
      _nw49[(int)(6839)] = 134;
      _nw49[(int)(6840)] = 138;
      _nw49[(int)(6841)] = 173;
      _nw49[(int)(6842)] = 224;
      _nw49[(int)(6843)] = 70;
      _nw49[(int)(6844)] = 87;
      _nw49[(int)(6845)] = 183;
      _nw49[(int)(6846)] = 128;
      _nw49[(int)(6847)] = 173;
      _nw49[(int)(6848)] = 142;
      _nw49[(int)(6849)] = 68;
      _nw49[(int)(6850)] = 50;
      _nw49[(int)(6851)] = 2;
      _nw49[(int)(6852)] = 127;
      _nw49[(int)(6853)] = 128;
      _nw49[(int)(6854)] = 112;
      _nw49[(int)(6855)] = 221;
      _nw49[(int)(6856)] = 254;
      _nw49[(int)(6857)] = 113;
      _nw49[(int)(6858)] = 212;
      _nw49[(int)(6859)] = 39;
      _nw49[(int)(6860)] = 62;
      _nw49[(int)(6861)] = 135;
      _nw49[(int)(6862)] = 70;
      _nw49[(int)(6863)] = 32;
      _nw49[(int)(6864)] = 68;
      _nw49[(int)(6865)] = 97;
      _nw49[(int)(6866)] = 192;
      _nw49[(int)(6867)] = 81;
      _nw49[(int)(6868)] = 25;
      _nw49[(int)(6869)] = 84;
      _nw49[(int)(6870)] = 185;
      _nw49[(int)(6871)] = 96;
      _nw49[(int)(6872)] = 86;
      _nw49[(int)(6873)] = 48;
      _nw49[(int)(6874)] = 227;
      _nw49[(int)(6875)] = 250;
      _nw49[(int)(6876)] = 3;
      _nw49[(int)(6877)] = 56;
      _nw49[(int)(6878)] = 212;
      _nw49[(int)(6879)] = 7;
      _nw49[(int)(6880)] = 195;
      _nw49[(int)(6881)] = 34;
      _nw49[(int)(6882)] = 243;
      _nw49[(int)(6883)] = 88;
      _nw49[(int)(6884)] = 142;
      _nw49[(int)(6885)] = 29;
      _nw49[(int)(6886)] = 33;
      _nw49[(int)(6887)] = 218;
      _nw49[(int)(6888)] = 79;
      _nw49[(int)(6889)] = 152;
      _nw49[(int)(6890)] = 245;
      _nw49[(int)(6891)] = 121;
      _nw49[(int)(6892)] = 227;
      _nw49[(int)(6893)] = 215;
      _nw49[(int)(6894)] = 69;
      _nw49[(int)(6895)] = 72;
      _nw49[(int)(6896)] = 17;
      _nw49[(int)(6897)] = 139;
      _nw49[(int)(6898)] = 52;
      _nw49[(int)(6899)] = 206;
      _nw49[(int)(6900)] = 204;
      _nw49[(int)(6901)] = 234;
      _nw49[(int)(6902)] = 252;
      _nw49[(int)(6903)] = 36;
      _nw49[(int)(6904)] = 251;
      _nw49[(int)(6905)] = 17;
      _nw49[(int)(6906)] = 244;
      _nw49[(int)(6907)] = 245;
      _nw49[(int)(6908)] = 250;
      _nw49[(int)(6909)] = 5;
      _nw49[(int)(6910)] = 36;
      _nw49[(int)(6911)] = 199;
      _nw49[(int)(6912)] = 93;
      _nw49[(int)(6913)] = 126;
      _nw49[(int)(6914)] = 58;
      _nw49[(int)(6915)] = 101;
      _nw49[(int)(6916)] = 69;
      _nw49[(int)(6917)] = 250;
      _nw49[(int)(6918)] = 144;
      _nw49[(int)(6919)] = 231;
      _nw49[(int)(6920)] = 190;
      _nw49[(int)(6921)] = 2;
      _nw49[(int)(6922)] = 149;
      _nw49[(int)(6923)] = 191;
      _nw49[(int)(6924)] = 204;
      _nw49[(int)(6925)] = 225;
      _nw49[(int)(6926)] = 217;
      _nw49[(int)(6927)] = 135;
      _nw49[(int)(6928)] = 66;
      _nw49[(int)(6929)] = 255;
      _nw49[(int)(6930)] = 80;
      _nw49[(int)(6931)] = 135;
      _nw49[(int)(6932)] = 95;
      _nw49[(int)(6933)] = 112;
      _nw49[(int)(6934)] = 20;
      _nw49[(int)(6935)] = 206;
      _nw49[(int)(6936)] = 190;
      _nw49[(int)(6937)] = 183;
      _nw49[(int)(6938)] = 119;
      _nw49[(int)(6939)] = 251;
      _nw49[(int)(6940)] = 195;
      _nw49[(int)(6941)] = 196;
      _nw49[(int)(6942)] = 137;
      _nw49[(int)(6943)] = 75;
      _nw49[(int)(6944)] = 218;
      _nw49[(int)(6945)] = 59;
      _nw49[(int)(6946)] = 117;
      _nw49[(int)(6947)] = 55;
      _nw49[(int)(6948)] = 182;
      _nw49[(int)(6949)] = 148;
      _nw49[(int)(6950)] = 20;
      _nw49[(int)(6951)] = 215;
      _nw49[(int)(6952)] = 31;
      _nw49[(int)(6953)] = 228;
      _nw49[(int)(6954)] = 177;
      _nw49[(int)(6955)] = 192;
      _nw49[(int)(6956)] = 69;
      _nw49[(int)(6957)] = 176;
      _nw49[(int)(6958)] = 207;
      _nw49[(int)(6959)] = 121;
      _nw49[(int)(6960)] = 47;
      _nw49[(int)(6961)] = 35;
      _nw49[(int)(6962)] = 125;
      _nw49[(int)(6963)] = 129;
      _nw49[(int)(6964)] = 249;
      _nw49[(int)(6965)] = 79;
      _nw49[(int)(6966)] = 54;
      _nw49[(int)(6967)] = 224;
      _nw49[(int)(6968)] = 70;
      _nw49[(int)(6969)] = 240;
      _nw49[(int)(6970)] = 78;
      _nw49[(int)(6971)] = 251;
      _nw49[(int)(6972)] = 250;
      _nw49[(int)(6973)] = 149;
      _nw49[(int)(6974)] = 56;
      _nw49[(int)(6975)] = 254;
      _nw49[(int)(6976)] = 247;
      _nw49[(int)(6977)] = 207;
      _nw49[(int)(6978)] = 63;
      _nw49[(int)(6979)] = 146;
      _nw49[(int)(6980)] = 192;
      _nw49[(int)(6981)] = 175;
      _nw49[(int)(6982)] = 86;
      _nw49[(int)(6983)] = 20;
      _nw49[(int)(6984)] = 49;
      _nw49[(int)(6985)] = 226;
      _nw49[(int)(6986)] = 42;
      _nw49[(int)(6987)] = 113;
      _nw49[(int)(6988)] = 98;
      _nw49[(int)(6989)] = 142;
      _nw49[(int)(6990)] = 52;
      _nw49[(int)(6991)] = 198;
      _nw49[(int)(6992)] = 8;
      _nw49[(int)(6993)] = 15;
      _nw49[(int)(6994)] = 164;
      _nw49[(int)(6995)] = 58;
      _nw49[(int)(6996)] = 3;
      _nw49[(int)(6997)] = 26;
      _nw49[(int)(6998)] = 253;
      _nw49[(int)(6999)] = 66;
      _nw49[(int)(7000)] = 168;
      _nw49[(int)(7001)] = 185;
      _nw49[(int)(7002)] = 81;
      _nw49[(int)(7003)] = 230;
      _nw49[(int)(7004)] = 143;
      _nw49[(int)(7005)] = 53;
      _nw49[(int)(7006)] = 8;
      _nw49[(int)(7007)] = 38;
      _nw49[(int)(7008)] = 61;
      _nw49[(int)(7009)] = 245;
      _nw49[(int)(7010)] = 99;
      _nw49[(int)(7011)] = 242;
      _nw49[(int)(7012)] = 24;
      _nw49[(int)(7013)] = 56;
      _nw49[(int)(7014)] = 169;
      _nw49[(int)(7015)] = 33;
      _nw49[(int)(7016)] = 108;
      _nw49[(int)(7017)] = 240;
      _nw49[(int)(7018)] = 57;
      _nw49[(int)(7019)] = 34;
      _nw49[(int)(7020)] = 141;
      _nw49[(int)(7021)] = 62;
      _nw49[(int)(7022)] = 169;
      _nw49[(int)(7023)] = 212;
      _nw49[(int)(7024)] = 135;
      _nw49[(int)(7025)] = 102;
      _nw49[(int)(7026)] = 246;
      _nw49[(int)(7027)] = 183;
      _nw49[(int)(7028)] = 114;
      _nw49[(int)(7029)] = 111;
      _nw49[(int)(7030)] = 171;
      _nw49[(int)(7031)] = 200;
      _nw49[(int)(7032)] = 10;
      _nw49[(int)(7033)] = 42;
      _nw49[(int)(7034)] = 108;
      _nw49[(int)(7035)] = 121;
      _nw49[(int)(7036)] = 91;
      _nw49[(int)(7037)] = 2;
      _nw49[(int)(7038)] = 138;
      _nw49[(int)(7039)] = 44;
      _nw49[(int)(7040)] = 181;
      _nw49[(int)(7041)] = 54;
      _nw49[(int)(7042)] = 119;
      _nw49[(int)(7043)] = 9;
      _nw49[(int)(7044)] = 183;
      _nw49[(int)(7045)] = 97;
      _nw49[(int)(7046)] = 202;
      _nw49[(int)(7047)] = 137;
      _nw49[(int)(7048)] = 88;
      _nw49[(int)(7049)] = 200;
      _nw49[(int)(7050)] = 189;
      _nw49[(int)(7051)] = 162;
      _nw49[(int)(7052)] = 33;
      _nw49[(int)(7053)] = 43;
      _nw49[(int)(7054)] = 254;
      _nw49[(int)(7055)] = 22;
      _nw49[(int)(7056)] = 12;
      _nw49[(int)(7057)] = 36;
      _nw49[(int)(7058)] = 109;
      _nw49[(int)(7059)] = 225;
      _nw49[(int)(7060)] = 112;
      _nw49[(int)(7061)] = 120;
      _nw49[(int)(7062)] = 106;
      _nw49[(int)(7063)] = 213;
      _nw49[(int)(7064)] = 98;
      _nw49[(int)(7065)] = 122;
      _nw49[(int)(7066)] = 254;
      _nw49[(int)(7067)] = 95;
      _nw49[(int)(7068)] = 99;
      _nw49[(int)(7069)] = 85;
      _nw49[(int)(7070)] = 223;
      _nw49[(int)(7071)] = 212;
      _nw49[(int)(7072)] = 209;
      _nw49[(int)(7073)] = 50;
      _nw49[(int)(7074)] = 70;
      _nw49[(int)(7075)] = 131;
      _nw49[(int)(7076)] = 156;
      _nw49[(int)(7077)] = 218;
      _nw49[(int)(7078)] = 180;
      _nw49[(int)(7079)] = 106;
      _nw49[(int)(7080)] = 113;
      _nw49[(int)(7081)] = 184;
      _nw49[(int)(7082)] = 198;
      _nw49[(int)(7083)] = 230;
      _nw49[(int)(7084)] = 206;
      _nw49[(int)(7085)] = 0;
      _nw49[(int)(7086)] = 189;
      _nw49[(int)(7087)] = 26;
      _nw49[(int)(7088)] = 0;
      _nw49[(int)(7089)] = 119;
      _nw49[(int)(7090)] = 138;
      _nw49[(int)(7091)] = 60;
      _nw49[(int)(7092)] = 88;
      _nw49[(int)(7093)] = 203;
      _nw49[(int)(7094)] = 23;
      _nw49[(int)(7095)] = 145;
      _nw49[(int)(7096)] = 233;
      _nw49[(int)(7097)] = 8;
      _nw49[(int)(7098)] = 72;
      _nw49[(int)(7099)] = 17;
      _nw49[(int)(7100)] = 94;
      _nw49[(int)(7101)] = 227;
      _nw49[(int)(7102)] = 42;
      _nw49[(int)(7103)] = 247;
      _nw49[(int)(7104)] = 251;
      _nw49[(int)(7105)] = 135;
      _nw49[(int)(7106)] = 217;
      _nw49[(int)(7107)] = 142;
      _nw49[(int)(7108)] = 232;
      _nw49[(int)(7109)] = 240;
      _nw49[(int)(7110)] = 12;
      _nw49[(int)(7111)] = 19;
      _nw49[(int)(7112)] = 219;
      _nw49[(int)(7113)] = 22;
      _nw49[(int)(7114)] = 180;
      _nw49[(int)(7115)] = 107;
      _nw49[(int)(7116)] = 174;
      _nw49[(int)(7117)] = 178;
      _nw49[(int)(7118)] = 236;
      _nw49[(int)(7119)] = 40;
      _nw49[(int)(7120)] = 94;
      _nw49[(int)(7121)] = 121;
      _nw49[(int)(7122)] = 140;
      _nw49[(int)(7123)] = 140;
      _nw49[(int)(7124)] = 191;
      _nw49[(int)(7125)] = 59;
      _nw49[(int)(7126)] = 224;
      _nw49[(int)(7127)] = 117;
      _nw49[(int)(7128)] = 156;
      _nw49[(int)(7129)] = 167;
      _nw49[(int)(7130)] = 113;
      _nw49[(int)(7131)] = 131;
      _nw49[(int)(7132)] = 70;
      _nw49[(int)(7133)] = 216;
      _nw49[(int)(7134)] = 255;
      _nw49[(int)(7135)] = 45;
      _nw49[(int)(7136)] = 36;
      _nw49[(int)(7137)] = 16;
      _nw49[(int)(7138)] = 184;
      _nw49[(int)(7139)] = 138;
      _nw49[(int)(7140)] = 30;
      _nw49[(int)(7141)] = 149;
      _nw49[(int)(7142)] = 58;
      _nw49[(int)(7143)] = 240;
      _nw49[(int)(7144)] = 220;
      _nw49[(int)(7145)] = 227;
      _nw49[(int)(7146)] = 248;
      _nw49[(int)(7147)] = 12;
      _nw49[(int)(7148)] = 167;
      _nw49[(int)(7149)] = 131;
      _nw49[(int)(7150)] = 65;
      _nw49[(int)(7151)] = 237;
      _nw49[(int)(7152)] = 78;
      _nw49[(int)(7153)] = 227;
      _nw49[(int)(7154)] = 245;
      _nw49[(int)(7155)] = 62;
      _nw49[(int)(7156)] = 7;
      _nw49[(int)(7157)] = 179;
      _nw49[(int)(7158)] = 189;
      _nw49[(int)(7159)] = 138;
      _nw49[(int)(7160)] = 219;
      _nw49[(int)(7161)] = 115;
      _nw49[(int)(7162)] = 65;
      _nw49[(int)(7163)] = 243;
      _nw49[(int)(7164)] = 180;
      _nw49[(int)(7165)] = 245;
      _nw49[(int)(7166)] = 251;
      _nw49[(int)(7167)] = 24;
      _nw49[(int)(7168)] = 67;
      _nw49[(int)(7169)] = 119;
      _nw49[(int)(7170)] = 128;
      _nw49[(int)(7171)] = 48;
      _nw49[(int)(7172)] = 11;
      _nw49[(int)(7173)] = 81;
      _nw49[(int)(7174)] = 11;
      _nw49[(int)(7175)] = 226;
      _nw49[(int)(7176)] = 241;
      _nw49[(int)(7177)] = 13;
      _nw49[(int)(7178)] = 16;
      _nw49[(int)(7179)] = 72;
      _nw49[(int)(7180)] = 171;
      _nw49[(int)(7181)] = 125;
      _nw49[(int)(7182)] = 54;
      _nw49[(int)(7183)] = 15;
      _nw49[(int)(7184)] = 152;
      _nw49[(int)(7185)] = 162;
      _nw49[(int)(7186)] = 66;
      _nw49[(int)(7187)] = 239;
      _nw49[(int)(7188)] = 206;
      _nw49[(int)(7189)] = 12;
      _nw49[(int)(7190)] = 141;
      _nw49[(int)(7191)] = 232;
      _nw49[(int)(7192)] = 167;
      _nw49[(int)(7193)] = 251;
      _nw49[(int)(7194)] = 56;
      _nw49[(int)(7195)] = 180;
      _nw49[(int)(7196)] = 132;
      _nw49[(int)(7197)] = 109;
      _nw49[(int)(7198)] = 65;
      _nw49[(int)(7199)] = 254;
      _nw49[(int)(7200)] = 177;
      _nw49[(int)(7201)] = 138;
      _nw49[(int)(7202)] = 144;
      _nw49[(int)(7203)] = 241;
      _nw49[(int)(7204)] = 72;
      _nw49[(int)(7205)] = 248;
      _nw49[(int)(7206)] = 72;
      _nw49[(int)(7207)] = 70;
      _nw49[(int)(7208)] = 154;
      _nw49[(int)(7209)] = 85;
      _nw49[(int)(7210)] = 55;
      _nw49[(int)(7211)] = 236;
      _nw49[(int)(7212)] = 61;
      _nw49[(int)(7213)] = 234;
      _nw49[(int)(7214)] = 118;
      _nw49[(int)(7215)] = 67;
      _nw49[(int)(7216)] = 175;
      _nw49[(int)(7217)] = 34;
      _nw49[(int)(7218)] = 191;
      _nw49[(int)(7219)] = 91;
      _nw49[(int)(7220)] = 43;
      _nw49[(int)(7221)] = 123;
      _nw49[(int)(7222)] = 26;
      _nw49[(int)(7223)] = 125;
      _nw49[(int)(7224)] = 206;
      _nw49[(int)(7225)] = 255;
      _nw49[(int)(7226)] = 137;
      _nw49[(int)(7227)] = 247;
      _nw49[(int)(7228)] = 188;
      _nw49[(int)(7229)] = 111;
      _nw49[(int)(7230)] = 134;
      _nw49[(int)(7231)] = 77;
      _nw49[(int)(7232)] = 174;
      _nw49[(int)(7233)] = 108;
      _nw49[(int)(7234)] = 21;
      _nw49[(int)(7235)] = 91;
      _nw49[(int)(7236)] = 3;
      _nw49[(int)(7237)] = 213;
      _nw49[(int)(7238)] = 252;
      _nw49[(int)(7239)] = 156;
      _nw49[(int)(7240)] = 133;
      _nw49[(int)(7241)] = 11;
      _nw49[(int)(7242)] = 208;
      _nw49[(int)(7243)] = 40;
      _nw49[(int)(7244)] = 180;
      _nw49[(int)(7245)] = 252;
      _nw49[(int)(7246)] = 60;
      _nw49[(int)(7247)] = 192;
      _nw49[(int)(7248)] = 150;
      _nw49[(int)(7249)] = 175;
      _nw49[(int)(7250)] = 77;
      _nw49[(int)(7251)] = 179;
      _nw49[(int)(7252)] = 124;
      _nw49[(int)(7253)] = 234;
      _nw49[(int)(7254)] = 167;
      _nw49[(int)(7255)] = 114;
      _nw49[(int)(7256)] = 84;
      _nw49[(int)(7257)] = 115;
      _nw49[(int)(7258)] = 66;
      _nw49[(int)(7259)] = 65;
      _nw49[(int)(7260)] = 170;
      _nw49[(int)(7261)] = 108;
      _nw49[(int)(7262)] = 36;
      _nw49[(int)(7263)] = 31;
      _nw49[(int)(7264)] = 192;
      _nw49[(int)(7265)] = 13;
      _nw49[(int)(7266)] = 236;
      _nw49[(int)(7267)] = 169;
      _nw49[(int)(7268)] = 176;
      _nw49[(int)(7269)] = 62;
      _nw49[(int)(7270)] = 156;
      _nw49[(int)(7271)] = 89;
      _nw49[(int)(7272)] = 59;
      _nw49[(int)(7273)] = 89;
      _nw49[(int)(7274)] = 150;
      _nw49[(int)(7275)] = 155;
      _nw49[(int)(7276)] = 133;
      _nw49[(int)(7277)] = 5;
      _nw49[(int)(7278)] = 108;
      _nw49[(int)(7279)] = 175;
      _nw49[(int)(7280)] = 254;
      _nw49[(int)(7281)] = 164;
      _nw49[(int)(7282)] = 56;
      _nw49[(int)(7283)] = 45;
      _nw49[(int)(7284)] = 201;
      _nw49[(int)(7285)] = 173;
      _nw49[(int)(7286)] = 101;
      _nw49[(int)(7287)] = 129;
      _nw49[(int)(7288)] = 73;
      _nw49[(int)(7289)] = 64;
      _nw49[(int)(7290)] = 233;
      _nw49[(int)(7291)] = 208;
      _nw49[(int)(7292)] = 64;
      _nw49[(int)(7293)] = 15;
      _nw49[(int)(7294)] = 21;
      _nw49[(int)(7295)] = 203;
      _nw49[(int)(7296)] = 104;
      _nw49[(int)(7297)] = 204;
      _nw49[(int)(7298)] = 136;
      _nw49[(int)(7299)] = 143;
      _nw49[(int)(7300)] = 175;
      _nw49[(int)(7301)] = 107;
      _nw49[(int)(7302)] = 48;
      _nw49[(int)(7303)] = 43;
      _nw49[(int)(7304)] = 41;
      _nw49[(int)(7305)] = 55;
      _nw49[(int)(7306)] = 207;
      _nw49[(int)(7307)] = 196;
      _nw49[(int)(7308)] = 78;
      _nw49[(int)(7309)] = 66;
      _nw49[(int)(7310)] = 251;
      _nw49[(int)(7311)] = 178;
      _nw49[(int)(7312)] = 97;
      _nw49[(int)(7313)] = 145;
      _nw49[(int)(7314)] = 110;
      _nw49[(int)(7315)] = 195;
      _nw49[(int)(7316)] = 43;
      _nw49[(int)(7317)] = 213;
      _nw49[(int)(7318)] = 109;
      _nw49[(int)(7319)] = 141;
      _nw49[(int)(7320)] = 126;
      _nw49[(int)(7321)] = 120;
      _nw49[(int)(7322)] = 63;
      _nw49[(int)(7323)] = 129;
      _nw49[(int)(7324)] = 212;
      _nw49[(int)(7325)] = 175;
      _nw49[(int)(7326)] = 137;
      _nw49[(int)(7327)] = 175;
      _nw49[(int)(7328)] = 47;
      _nw49[(int)(7329)] = 230;
      _nw49[(int)(7330)] = 122;
      _nw49[(int)(7331)] = 49;
      _nw49[(int)(7332)] = 73;
      _nw49[(int)(7333)] = 153;
      _nw49[(int)(7334)] = 229;
      _nw49[(int)(7335)] = 126;
      _nw49[(int)(7336)] = 76;
      _nw49[(int)(7337)] = 26;
      _nw49[(int)(7338)] = 14;
      _nw49[(int)(7339)] = 162;
      _nw49[(int)(7340)] = 26;
      _nw49[(int)(7341)] = 62;
      _nw49[(int)(7342)] = 202;
      _nw49[(int)(7343)] = 236;
      _nw49[(int)(7344)] = 77;
      _nw49[(int)(7345)] = 247;
      _nw49[(int)(7346)] = 100;
      _nw49[(int)(7347)] = 212;
      _nw49[(int)(7348)] = 69;
      _nw49[(int)(7349)] = 228;
      _nw49[(int)(7350)] = 47;
      _nw49[(int)(7351)] = 213;
      _nw49[(int)(7352)] = 244;
      _nw49[(int)(7353)] = 225;
      _nw49[(int)(7354)] = 41;
      _nw49[(int)(7355)] = 231;
      _nw49[(int)(7356)] = 116;
      _nw49[(int)(7357)] = 93;
      _nw49[(int)(7358)] = 84;
      _nw49[(int)(7359)] = 183;
      _nw49[(int)(7360)] = 62;
      _nw49[(int)(7361)] = 51;
      _nw49[(int)(7362)] = 39;
      _nw49[(int)(7363)] = 121;
      _nw49[(int)(7364)] = 235;
      _nw49[(int)(7365)] = 158;
      _nw49[(int)(7366)] = 147;
      _nw49[(int)(7367)] = 224;
      _nw49[(int)(7368)] = 126;
      _nw49[(int)(7369)] = 254;
      _nw49[(int)(7370)] = 156;
      _nw49[(int)(7371)] = 132;
      _nw49[(int)(7372)] = 191;
      _nw49[(int)(7373)] = 155;
      _nw49[(int)(7374)] = 106;
      _nw49[(int)(7375)] = 252;
      _nw49[(int)(7376)] = 164;
      _nw49[(int)(7377)] = 221;
      _nw49[(int)(7378)] = 99;
      _nw49[(int)(7379)] = 132;
      _nw49[(int)(7380)] = 234;
      _nw49[(int)(7381)] = 153;
      _nw49[(int)(7382)] = 63;
      _nw49[(int)(7383)] = 23;
      _nw49[(int)(7384)] = 216;
      _nw49[(int)(7385)] = 176;
      _nw49[(int)(7386)] = 246;
      _nw49[(int)(7387)] = 219;
      _nw49[(int)(7388)] = 22;
      _nw49[(int)(7389)] = 50;
      _nw49[(int)(7390)] = 87;
      _nw49[(int)(7391)] = 240;
      _nw49[(int)(7392)] = 125;
      _nw49[(int)(7393)] = 204;
      _nw49[(int)(7394)] = 3;
      _nw49[(int)(7395)] = 210;
      _nw49[(int)(7396)] = 7;
      _nw49[(int)(7397)] = 225;
      _nw49[(int)(7398)] = 96;
      _nw49[(int)(7399)] = 1;
      _nw49[(int)(7400)] = 241;
      _nw49[(int)(7401)] = 234;
      _nw49[(int)(7402)] = 225;
      _nw49[(int)(7403)] = 216;
      _nw49[(int)(7404)] = 10;
      _nw49[(int)(7405)] = 185;
      _nw49[(int)(7406)] = 18;
      _nw49[(int)(7407)] = 180;
      _nw49[(int)(7408)] = 220;
      _nw49[(int)(7409)] = 245;
      _nw49[(int)(7410)] = 128;
      _nw49[(int)(7411)] = 11;
      _nw49[(int)(7412)] = 137;
      _nw49[(int)(7413)] = 118;
      _nw49[(int)(7414)] = 93;
      _nw49[(int)(7415)] = 131;
      _nw49[(int)(7416)] = 209;
      _nw49[(int)(7417)] = 203;
      _nw49[(int)(7418)] = 232;
      _nw49[(int)(7419)] = 156;
      _nw49[(int)(7420)] = 213;
      _nw49[(int)(7421)] = 243;
      _nw49[(int)(7422)] = 30;
      _nw49[(int)(7423)] = 92;
      _nw49[(int)(7424)] = 126;
      _nw49[(int)(7425)] = 60;
      _nw49[(int)(7426)] = 176;
      _nw49[(int)(7427)] = 210;
      _nw49[(int)(7428)] = 227;
      _nw49[(int)(7429)] = 73;
      _nw49[(int)(7430)] = 185;
      _nw49[(int)(7431)] = 20;
      _nw49[(int)(7432)] = 165;
      _nw49[(int)(7433)] = 49;
      _nw49[(int)(7434)] = 182;
      _nw49[(int)(7435)] = 20;
      _nw49[(int)(7436)] = 104;
      _nw49[(int)(7437)] = 223;
      _nw49[(int)(7438)] = 117;
      _nw49[(int)(7439)] = 116;
      _nw49[(int)(7440)] = 158;
      _nw49[(int)(7441)] = 211;
      _nw49[(int)(7442)] = 73;
      _nw49[(int)(7443)] = 198;
      _nw49[(int)(7444)] = 46;
      _nw49[(int)(7445)] = 69;
      _nw49[(int)(7446)] = 150;
      _nw49[(int)(7447)] = 182;
      _nw49[(int)(7448)] = 174;
      _nw49[(int)(7449)] = 219;
      _nw49[(int)(7450)] = 54;
      _nw49[(int)(7451)] = 39;
      _nw49[(int)(7452)] = 223;
      _nw49[(int)(7453)] = 187;
      _nw49[(int)(7454)] = 78;
      _nw49[(int)(7455)] = 63;
      _nw49[(int)(7456)] = 20;
      _nw49[(int)(7457)] = 209;
      _nw49[(int)(7458)] = 14;
      _nw49[(int)(7459)] = 37;
      _nw49[(int)(7460)] = 209;
      _nw49[(int)(7461)] = 107;
      _nw49[(int)(7462)] = 7;
      _nw49[(int)(7463)] = 147;
      _nw49[(int)(7464)] = 195;
      _nw49[(int)(7465)] = 195;
      _nw49[(int)(7466)] = 247;
      _nw49[(int)(7467)] = 231;
      _nw49[(int)(7468)] = 122;
      _nw49[(int)(7469)] = 108;
      _nw49[(int)(7470)] = 89;
      _nw49[(int)(7471)] = 219;
      _nw49[(int)(7472)] = 205;
      _nw49[(int)(7473)] = 230;
      _nw49[(int)(7474)] = 186;
      _nw49[(int)(7475)] = 1;
      _nw49[(int)(7476)] = 8;
      _nw49[(int)(7477)] = 196;
      _nw49[(int)(7478)] = 194;
      _nw49[(int)(7479)] = 244;
      _nw49[(int)(7480)] = 206;
      _nw49[(int)(7481)] = 176;
      _nw49[(int)(7482)] = 73;
      _nw49[(int)(7483)] = 55;
      _nw49[(int)(7484)] = 163;
      _nw49[(int)(7485)] = 213;
      _nw49[(int)(7486)] = 78;
      _nw49[(int)(7487)] = 255;
      _nw49[(int)(7488)] = 232;
      _nw49[(int)(7489)] = 81;
      _nw49[(int)(7490)] = 148;
      _nw49[(int)(7491)] = 106;
      _nw49[(int)(7492)] = 50;
      _nw49[(int)(7493)] = 141;
      _nw49[(int)(7494)] = 160;
      _nw49[(int)(7495)] = 134;
      _nw49[(int)(7496)] = 27;
      _nw49[(int)(7497)] = 223;
      _nw49[(int)(7498)] = 15;
      _nw49[(int)(7499)] = 87;
      _nw49[(int)(7500)] = 66;
      _nw49[(int)(7501)] = 100;
      _nw49[(int)(7502)] = 210;
      _nw49[(int)(7503)] = 215;
      _nw49[(int)(7504)] = 43;
      _nw49[(int)(7505)] = 113;
      _nw49[(int)(7506)] = 3;
      _nw49[(int)(7507)] = 218;
      _nw49[(int)(7508)] = 182;
      _nw49[(int)(7509)] = 232;
      _nw49[(int)(7510)] = 203;
      _nw49[(int)(7511)] = 192;
      _nw49[(int)(7512)] = 225;
      _nw49[(int)(7513)] = 139;
      _nw49[(int)(7514)] = 163;
      _nw49[(int)(7515)] = 213;
      _nw49[(int)(7516)] = 49;
      _nw49[(int)(7517)] = 55;
      _nw49[(int)(7518)] = 114;
      _nw49[(int)(7519)] = 105;
      _nw49[(int)(7520)] = 236;
      _nw49[(int)(7521)] = 215;
      _nw49[(int)(7522)] = 165;
      _nw49[(int)(7523)] = 251;
      _nw49[(int)(7524)] = 150;
      _nw49[(int)(7525)] = 171;
      _nw49[(int)(7526)] = 17;
      _nw49[(int)(7527)] = 124;
      _nw49[(int)(7528)] = 143;
      _nw49[(int)(7529)] = 158;
      _nw49[(int)(7530)] = 206;
      _nw49[(int)(7531)] = 109;
      _nw49[(int)(7532)] = 150;
      _nw49[(int)(7533)] = 43;
      _nw49[(int)(7534)] = 229;
      _nw49[(int)(7535)] = 236;
      _nw49[(int)(7536)] = 35;
      _nw49[(int)(7537)] = 170;
      _nw49[(int)(7538)] = 14;
      _nw49[(int)(7539)] = 81;
      _nw49[(int)(7540)] = 10;
      _nw49[(int)(7541)] = 27;
      _nw49[(int)(7542)] = 249;
      _nw49[(int)(7543)] = 220;
      _nw49[(int)(7544)] = 134;
      _nw49[(int)(7545)] = 128;
      _nw49[(int)(7546)] = 255;
      _nw49[(int)(7547)] = 71;
      _nw49[(int)(7548)] = 12;
      _nw49[(int)(7549)] = 35;
      _nw49[(int)(7550)] = 250;
      _nw49[(int)(7551)] = 41;
      _nw49[(int)(7552)] = 72;
      _nw49[(int)(7553)] = 143;
      _nw49[(int)(7554)] = 34;
      _nw49[(int)(7555)] = 203;
      _nw49[(int)(7556)] = 0;
      _nw49[(int)(7557)] = 21;
      _nw49[(int)(7558)] = 169;
      _nw49[(int)(7559)] = 42;
      _nw49[(int)(7560)] = 210;
      _nw49[(int)(7561)] = 31;
      _nw49[(int)(7562)] = 23;
      _nw49[(int)(7563)] = 86;
      _nw49[(int)(7564)] = 48;
      _nw49[(int)(7565)] = 125;
      _nw49[(int)(7566)] = 164;
      _nw49[(int)(7567)] = 248;
      _nw49[(int)(7568)] = 77;
      _nw49[(int)(7569)] = 236;
      _nw49[(int)(7570)] = 25;
      _nw49[(int)(7571)] = 248;
      _nw49[(int)(7572)] = 233;
      _nw49[(int)(7573)] = 72;
      _nw49[(int)(7574)] = 196;
      _nw49[(int)(7575)] = 64;
      _nw49[(int)(7576)] = 20;
      _nw49[(int)(7577)] = 104;
      _nw49[(int)(7578)] = 97;
      _nw49[(int)(7579)] = 249;
      _nw49[(int)(7580)] = 75;
      _nw49[(int)(7581)] = 168;
      _nw49[(int)(7582)] = 68;
      _nw49[(int)(7583)] = 148;
      _nw49[(int)(7584)] = 102;
      _nw49[(int)(7585)] = 55;
      _nw49[(int)(7586)] = 217;
      _nw49[(int)(7587)] = 242;
      _nw49[(int)(7588)] = 63;
      _nw49[(int)(7589)] = 219;
      _nw49[(int)(7590)] = 102;
      _nw49[(int)(7591)] = 45;
      _nw49[(int)(7592)] = 90;
      _nw49[(int)(7593)] = 112;
      _nw49[(int)(7594)] = 55;
      _nw49[(int)(7595)] = 96;
      _nw49[(int)(7596)] = 230;
      _nw49[(int)(7597)] = 155;
      _nw49[(int)(7598)] = 9;
      _nw49[(int)(7599)] = 64;
      _nw49[(int)(7600)] = 96;
      _nw49[(int)(7601)] = 17;
      _nw49[(int)(7602)] = 20;
      _nw49[(int)(7603)] = 64;
      _nw49[(int)(7604)] = 129;
      _nw49[(int)(7605)] = 183;
      _nw49[(int)(7606)] = 46;
      _nw49[(int)(7607)] = 41;
      _nw49[(int)(7608)] = 2;
      _nw49[(int)(7609)] = 171;
      _nw49[(int)(7610)] = 141;
      _nw49[(int)(7611)] = 78;
      _nw49[(int)(7612)] = 91;
      _nw49[(int)(7613)] = 190;
      _nw49[(int)(7614)] = 85;
      _nw49[(int)(7615)] = 26;
      _nw49[(int)(7616)] = 254;
      _nw49[(int)(7617)] = 111;
      _nw49[(int)(7618)] = 221;
      _nw49[(int)(7619)] = 180;
      _nw49[(int)(7620)] = 11;
      _nw49[(int)(7621)] = 152;
      _nw49[(int)(7622)] = 212;
      _nw49[(int)(7623)] = 65;
      _nw49[(int)(7624)] = 166;
      _nw49[(int)(7625)] = 176;
      _nw49[(int)(7626)] = 80;
      _nw49[(int)(7627)] = 107;
      _nw49[(int)(7628)] = 58;
      _nw49[(int)(7629)] = 89;
      _nw49[(int)(7630)] = 180;
      _nw49[(int)(7631)] = 207;
      _nw49[(int)(7632)] = 123;
      _nw49[(int)(7633)] = 20;
      _nw49[(int)(7634)] = 38;
      _nw49[(int)(7635)] = 30;
      _nw49[(int)(7636)] = 14;
      _nw49[(int)(7637)] = 83;
      _nw49[(int)(7638)] = 215;
      _nw49[(int)(7639)] = 75;
      _nw49[(int)(7640)] = 41;
      _nw49[(int)(7641)] = 129;
      _nw49[(int)(7642)] = 55;
      _nw49[(int)(7643)] = 104;
      _nw49[(int)(7644)] = 187;
      _nw49[(int)(7645)] = 157;
      _nw49[(int)(7646)] = 72;
      _nw49[(int)(7647)] = 142;
      _nw49[(int)(7648)] = 167;
      _nw49[(int)(7649)] = 246;
      _nw49[(int)(7650)] = 127;
      _nw49[(int)(7651)] = 38;
      _nw49[(int)(7652)] = 153;
      _nw49[(int)(7653)] = 58;
      _nw49[(int)(7654)] = 147;
      _nw49[(int)(7655)] = 190;
      _nw49[(int)(7656)] = 59;
      _nw49[(int)(7657)] = 95;
      _nw49[(int)(7658)] = 183;
      _nw49[(int)(7659)] = 188;
      _nw49[(int)(7660)] = 246;
      _nw49[(int)(7661)] = 34;
      _nw49[(int)(7662)] = 34;
      _nw49[(int)(7663)] = 12;
      _nw49[(int)(7664)] = 5;
      _nw49[(int)(7665)] = 219;
      _nw49[(int)(7666)] = 110;
      _nw49[(int)(7667)] = 9;
      _nw49[(int)(7668)] = 14;
      _nw49[(int)(7669)] = 125;
      _nw49[(int)(7670)] = 75;
      _nw49[(int)(7671)] = 140;
      _nw49[(int)(7672)] = 46;
      _nw49[(int)(7673)] = 255;
      _nw49[(int)(7674)] = 205;
      _nw49[(int)(7675)] = 77;
      _nw49[(int)(7676)] = 91;
      _nw49[(int)(7677)] = 253;
      _nw49[(int)(7678)] = 238;
      _nw49[(int)(7679)] = 106;
      _nw49[(int)(7680)] = 198;
      _nw49[(int)(7681)] = 55;
      _nw49[(int)(7682)] = 234;
      _nw49[(int)(7683)] = 247;
      _nw49[(int)(7684)] = 192;
      _nw49[(int)(7685)] = 139;
      _nw49[(int)(7686)] = 89;
      _nw49[(int)(7687)] = 237;
      _nw49[(int)(7688)] = 193;
      _nw49[(int)(7689)] = 164;
      _nw49[(int)(7690)] = 90;
      _nw49[(int)(7691)] = 127;
      _nw49[(int)(7692)] = 195;
      _nw49[(int)(7693)] = 129;
      _nw49[(int)(7694)] = 41;
      _nw49[(int)(7695)] = 73;
      _nw49[(int)(7696)] = 123;
      _nw49[(int)(7697)] = 248;
      _nw49[(int)(7698)] = 53;
      _nw49[(int)(7699)] = 4;
      _nw49[(int)(7700)] = 84;
      _nw49[(int)(7701)] = 17;
      _nw49[(int)(7702)] = 59;
      _nw49[(int)(7703)] = 25;
      _nw49[(int)(7704)] = 24;
      _nw49[(int)(7705)] = 118;
      _nw49[(int)(7706)] = 127;
      _nw49[(int)(7707)] = 206;
      _nw49[(int)(7708)] = 6;
      _nw49[(int)(7709)] = 194;
      _nw49[(int)(7710)] = 149;
      _nw49[(int)(7711)] = 224;
      _nw49[(int)(7712)] = 46;
      _nw49[(int)(7713)] = 166;
      _nw49[(int)(7714)] = 228;
      _nw49[(int)(7715)] = 194;
      _nw49[(int)(7716)] = 87;
      _nw49[(int)(7717)] = 252;
      _nw49[(int)(7718)] = 151;
      _nw49[(int)(7719)] = 111;
      _nw49[(int)(7720)] = 182;
      _nw49[(int)(7721)] = 135;
      _nw49[(int)(7722)] = 207;
      _nw49[(int)(7723)] = 144;
      _nw49[(int)(7724)] = 37;
      _nw49[(int)(7725)] = 239;
      _nw49[(int)(7726)] = 184;
      _nw49[(int)(7727)] = 31;
      _nw49[(int)(7728)] = 198;
      _nw49[(int)(7729)] = 220;
      _nw49[(int)(7730)] = 141;
      _nw49[(int)(7731)] = 205;
      _nw49[(int)(7732)] = 33;
      _nw49[(int)(7733)] = 51;
      _nw49[(int)(7734)] = 167;
      _nw49[(int)(7735)] = 126;
      _nw49[(int)(7736)] = 163;
      _nw49[(int)(7737)] = 154;
      _nw49[(int)(7738)] = 67;
      _nw49[(int)(7739)] = 16;
      _nw49[(int)(7740)] = 56;
      _nw49[(int)(7741)] = 197;
      _nw49[(int)(7742)] = 144;
      _nw49[(int)(7743)] = 40;
      _nw49[(int)(7744)] = 214;
      _nw49[(int)(7745)] = 62;
      _nw49[(int)(7746)] = 122;
      _nw49[(int)(7747)] = 20;
      _nw49[(int)(7748)] = 206;
      _nw49[(int)(7749)] = 94;
      _nw49[(int)(7750)] = 2;
      _nw49[(int)(7751)] = 210;
      _nw49[(int)(7752)] = 127;
      _nw49[(int)(7753)] = 230;
      _nw49[(int)(7754)] = 19;
      _nw49[(int)(7755)] = 47;
      _nw49[(int)(7756)] = 251;
      _nw49[(int)(7757)] = 50;
      _nw49[(int)(7758)] = 140;
      _nw49[(int)(7759)] = 209;
      _nw49[(int)(7760)] = 236;
      _nw49[(int)(7761)] = 235;
      _nw49[(int)(7762)] = 217;
      _nw49[(int)(7763)] = 3;
      _nw49[(int)(7764)] = 34;
      _nw49[(int)(7765)] = 49;
      _nw49[(int)(7766)] = 140;
      _nw49[(int)(7767)] = 166;
      _nw49[(int)(7768)] = 204;
      _nw49[(int)(7769)] = 195;
      _nw49[(int)(7770)] = 18;
      _nw49[(int)(7771)] = 135;
      _nw49[(int)(7772)] = 18;
      _nw49[(int)(7773)] = 36;
      _nw49[(int)(7774)] = 107;
      _nw49[(int)(7775)] = 115;
      _nw49[(int)(7776)] = 121;
      _nw49[(int)(7777)] = 21;
      _nw49[(int)(7778)] = 199;
      _nw49[(int)(7779)] = 147;
      _nw49[(int)(7780)] = 4;
      _nw49[(int)(7781)] = 213;
      _nw49[(int)(7782)] = 80;
      _nw49[(int)(7783)] = 55;
      _nw49[(int)(7784)] = 139;
      _nw49[(int)(7785)] = 169;
      _nw49[(int)(7786)] = 223;
      _nw49[(int)(7787)] = 204;
      _nw49[(int)(7788)] = 33;
      _nw49[(int)(7789)] = 180;
      _nw49[(int)(7790)] = 186;
      _nw49[(int)(7791)] = 202;
      _nw49[(int)(7792)] = 209;
      _nw49[(int)(7793)] = 222;
      _nw49[(int)(7794)] = 134;
      _nw49[(int)(7795)] = 78;
      _nw49[(int)(7796)] = 29;
      _nw49[(int)(7797)] = 32;
      _nw49[(int)(7798)] = 238;
      _nw49[(int)(7799)] = 162;
      _nw49[(int)(7800)] = 27;
      _nw49[(int)(7801)] = 90;
      _nw49[(int)(7802)] = 197;
      _nw49[(int)(7803)] = 42;
      _nw49[(int)(7804)] = 124;
      _nw49[(int)(7805)] = 99;
      _nw49[(int)(7806)] = 210;
      _nw49[(int)(7807)] = 218;
      _nw49[(int)(7808)] = 186;
      _nw49[(int)(7809)] = 227;
      _nw49[(int)(7810)] = 167;
      _nw49[(int)(7811)] = 213;
      _nw49[(int)(7812)] = 55;
      _nw49[(int)(7813)] = 91;
      _nw49[(int)(7814)] = 239;
      _nw49[(int)(7815)] = 115;
      _nw49[(int)(7816)] = 200;
      _nw49[(int)(7817)] = 24;
      _nw49[(int)(7818)] = 13;
      _nw49[(int)(7819)] = 23;
      _nw49[(int)(7820)] = 239;
      _nw49[(int)(7821)] = 83;
      _nw49[(int)(7822)] = 188;
      _nw49[(int)(7823)] = 205;
      _nw49[(int)(7824)] = 50;
      _nw49[(int)(7825)] = 253;
      _nw49[(int)(7826)] = 193;
      _nw49[(int)(7827)] = 188;
      _nw49[(int)(7828)] = 167;
      _nw49[(int)(7829)] = 214;
      _nw49[(int)(7830)] = 168;
      _nw49[(int)(7831)] = 220;
      _nw49[(int)(7832)] = 184;
      _nw49[(int)(7833)] = 152;
      _nw49[(int)(7834)] = 168;
      _nw49[(int)(7835)] = 247;
      _nw49[(int)(7836)] = 110;
      _nw49[(int)(7837)] = 86;
      _nw49[(int)(7838)] = 134;
      _nw49[(int)(7839)] = 45;
      _nw49[(int)(7840)] = 38;
      _nw49[(int)(7841)] = 66;
      _nw49[(int)(7842)] = 70;
      _nw49[(int)(7843)] = 37;
      _nw49[(int)(7844)] = 22;
      _nw49[(int)(7845)] = 67;
      _nw49[(int)(7846)] = 54;
      _nw49[(int)(7847)] = 191;
      _nw49[(int)(7848)] = 252;
      _nw49[(int)(7849)] = 120;
      _nw49[(int)(7850)] = 220;
      _nw49[(int)(7851)] = 123;
      _nw49[(int)(7852)] = 53;
      _nw49[(int)(7853)] = 201;
      _nw49[(int)(7854)] = 226;
      _nw49[(int)(7855)] = 72;
      _nw49[(int)(7856)] = 53;
      _nw49[(int)(7857)] = 216;
      _nw49[(int)(7858)] = 82;
      _nw49[(int)(7859)] = 201;
      _nw49[(int)(7860)] = 117;
      _nw49[(int)(7861)] = 236;
      _nw49[(int)(7862)] = 79;
      _nw49[(int)(7863)] = 172;
      _nw49[(int)(7864)] = 147;
      _nw49[(int)(7865)] = 185;
      _nw49[(int)(7866)] = 29;
      _nw49[(int)(7867)] = 108;
      _nw49[(int)(7868)] = 222;
      _nw49[(int)(7869)] = 161;
      _nw49[(int)(7870)] = 33;
      _nw49[(int)(7871)] = 218;
      _nw49[(int)(7872)] = 15;
      _nw49[(int)(7873)] = 60;
      _nw49[(int)(7874)] = 73;
      _nw49[(int)(7875)] = 120;
      _nw49[(int)(7876)] = 128;
      _nw49[(int)(7877)] = 236;
      _nw49[(int)(7878)] = 161;
      _nw49[(int)(7879)] = 163;
      _nw49[(int)(7880)] = 65;
      _nw49[(int)(7881)] = 34;
      _nw49[(int)(7882)] = 231;
      _nw49[(int)(7883)] = 138;
      _nw49[(int)(7884)] = 206;
      _nw49[(int)(7885)] = 187;
      _nw49[(int)(7886)] = 182;
      _nw49[(int)(7887)] = 239;
      _nw49[(int)(7888)] = 98;
      _nw49[(int)(7889)] = 130;
      _nw49[(int)(7890)] = 217;
      _nw49[(int)(7891)] = 150;
      _nw49[(int)(7892)] = 102;
      _nw49[(int)(7893)] = 225;
      _nw49[(int)(7894)] = 111;
      _nw49[(int)(7895)] = 160;
      _nw49[(int)(7896)] = 7;
      _nw49[(int)(7897)] = 192;
      _nw49[(int)(7898)] = 28;
      _nw49[(int)(7899)] = 97;
      _nw49[(int)(7900)] = 212;
      _nw49[(int)(7901)] = 83;
      _nw49[(int)(7902)] = 35;
      _nw49[(int)(7903)] = 9;
      _nw49[(int)(7904)] = 212;
      _nw49[(int)(7905)] = 52;
      _nw49[(int)(7906)] = 190;
      _nw49[(int)(7907)] = 58;
      _nw49[(int)(7908)] = 169;
      _nw49[(int)(7909)] = 95;
      _nw49[(int)(7910)] = 82;
      _nw49[(int)(7911)] = 162;
      _nw49[(int)(7912)] = 125;
      _nw49[(int)(7913)] = 189;
      _nw49[(int)(7914)] = 194;
      _nw49[(int)(7915)] = 203;
      _nw49[(int)(7916)] = 113;
      _nw49[(int)(7917)] = 170;
      _nw49[(int)(7918)] = 166;
      _nw49[(int)(7919)] = 202;
      _nw49[(int)(7920)] = 26;
      _nw49[(int)(7921)] = 158;
      _nw49[(int)(7922)] = 116;
      _nw49[(int)(7923)] = 244;
      _nw49[(int)(7924)] = 132;
      _nw49[(int)(7925)] = 2;
      _nw49[(int)(7926)] = 252;
      _nw49[(int)(7927)] = 15;
      _nw49[(int)(7928)] = 176;
      _nw49[(int)(7929)] = 79;
      _nw49[(int)(7930)] = 157;
      _nw49[(int)(7931)] = 60;
      _nw49[(int)(7932)] = 53;
      _nw49[(int)(7933)] = 130;
      _nw49[(int)(7934)] = 4;
      _nw49[(int)(7935)] = 224;
      _nw49[(int)(7936)] = 136;
      _nw49[(int)(7937)] = 36;
      _nw49[(int)(7938)] = 147;
      _nw49[(int)(7939)] = 41;
      _nw49[(int)(7940)] = 150;
      _nw49[(int)(7941)] = 122;
      _nw49[(int)(7942)] = 184;
      _nw49[(int)(7943)] = 183;
      _nw49[(int)(7944)] = 233;
      _nw49[(int)(7945)] = 236;
      _nw49[(int)(7946)] = 135;
      _nw49[(int)(7947)] = 190;
      _nw49[(int)(7948)] = 117;
      _nw49[(int)(7949)] = 97;
      _nw49[(int)(7950)] = 86;
      _nw49[(int)(7951)] = 128;
      _nw49[(int)(7952)] = 221;
      _nw49[(int)(7953)] = 84;
      _nw49[(int)(7954)] = 128;
      _nw49[(int)(7955)] = 222;
      _nw49[(int)(7956)] = 64;
      _nw49[(int)(7957)] = 226;
      _nw49[(int)(7958)] = 99;
      _nw49[(int)(7959)] = 98;
      _nw49[(int)(7960)] = 75;
      _nw49[(int)(7961)] = 90;
      _nw49[(int)(7962)] = 99;
      _nw49[(int)(7963)] = 7;
      _nw49[(int)(7964)] = 119;
      _nw49[(int)(7965)] = 186;
      _nw49[(int)(7966)] = 11;
      _nw49[(int)(7967)] = 144;
      _nw49[(int)(7968)] = 119;
      _nw49[(int)(7969)] = 168;
      _nw49[(int)(7970)] = 198;
      _nw49[(int)(7971)] = 36;
      _nw49[(int)(7972)] = 141;
      _nw49[(int)(7973)] = 208;
      _nw49[(int)(7974)] = 130;
      _nw49[(int)(7975)] = 205;
      _nw49[(int)(7976)] = 236;
      _nw49[(int)(7977)] = 17;
      _nw49[(int)(7978)] = 248;
      _nw49[(int)(7979)] = 186;
      _nw49[(int)(7980)] = 214;
      _nw49[(int)(7981)] = 108;
      _nw49[(int)(7982)] = 241;
      _nw49[(int)(7983)] = 26;
      _nw49[(int)(7984)] = 144;
      _nw49[(int)(7985)] = 167;
      _nw49[(int)(7986)] = 253;
      _nw49[(int)(7987)] = 255;
      _nw49[(int)(7988)] = 97;
      _nw49[(int)(7989)] = 205;
      _nw49[(int)(7990)] = 72;
      _nw49[(int)(7991)] = 147;
      _nw49[(int)(7992)] = 131;
      _nw49[(int)(7993)] = 236;
      _nw49[(int)(7994)] = 46;
      _nw49[(int)(7995)] = 82;
      _nw49[(int)(7996)] = 63;
      _nw49[(int)(7997)] = 203;
      _nw49[(int)(7998)] = 10;
      _nw49[(int)(7999)] = 6;
      _nw49[(int)(8000)] = 254;
      _nw49[(int)(8001)] = 70;
      _nw49[(int)(8002)] = 95;
      _nw49[(int)(8003)] = 229;
      _nw49[(int)(8004)] = 136;
      _nw49[(int)(8005)] = 187;
      _nw49[(int)(8006)] = 199;
      _nw49[(int)(8007)] = 39;
      _nw49[(int)(8008)] = 22;
      _nw49[(int)(8009)] = 239;
      _nw49[(int)(8010)] = 146;
      _nw49[(int)(8011)] = 180;
      _nw49[(int)(8012)] = 30;
      _nw49[(int)(8013)] = 102;
      _nw49[(int)(8014)] = 103;
      _nw49[(int)(8015)] = 66;
      _nw49[(int)(8016)] = 225;
      _nw49[(int)(8017)] = 211;
      _nw49[(int)(8018)] = 21;
      _nw49[(int)(8019)] = 241;
      _nw49[(int)(8020)] = 88;
      _nw49[(int)(8021)] = 141;
      _nw49[(int)(8022)] = 142;
      _nw49[(int)(8023)] = 66;
      _nw49[(int)(8024)] = 219;
      _nw49[(int)(8025)] = 53;
      _nw49[(int)(8026)] = 234;
      _nw49[(int)(8027)] = 205;
      _nw49[(int)(8028)] = 64;
      _nw49[(int)(8029)] = 89;
      _nw49[(int)(8030)] = 58;
      _nw49[(int)(8031)] = 179;
      _nw49[(int)(8032)] = 154;
      _nw49[(int)(8033)] = 201;
      _nw49[(int)(8034)] = 30;
      _nw49[(int)(8035)] = 79;
      _nw49[(int)(8036)] = 89;
      _nw49[(int)(8037)] = 32;
      _nw49[(int)(8038)] = 3;
      _nw49[(int)(8039)] = 223;
      _nw49[(int)(8040)] = 237;
      _nw49[(int)(8041)] = 62;
      _nw49[(int)(8042)] = 215;
      _nw49[(int)(8043)] = 187;
      _nw49[(int)(8044)] = 15;
      _nw49[(int)(8045)] = 11;
      _nw49[(int)(8046)] = 187;
      _nw49[(int)(8047)] = 240;
      _nw49[(int)(8048)] = 162;
      _nw49[(int)(8049)] = 159;
      _nw49[(int)(8050)] = 173;
      _nw49[(int)(8051)] = 142;
      _nw49[(int)(8052)] = 100;
      _nw49[(int)(8053)] = 28;
      _nw49[(int)(8054)] = 68;
      _nw49[(int)(8055)] = 159;
      _nw49[(int)(8056)] = 19;
      _nw49[(int)(8057)] = 30;
      _nw49[(int)(8058)] = 167;
      _nw49[(int)(8059)] = 211;
      _nw49[(int)(8060)] = 140;
      _nw49[(int)(8061)] = 122;
      _nw49[(int)(8062)] = 214;
      _nw49[(int)(8063)] = 253;
      _nw49[(int)(8064)] = 159;
      _nw49[(int)(8065)] = 162;
      _nw49[(int)(8066)] = 240;
      _nw49[(int)(8067)] = 97;
      _nw49[(int)(8068)] = 254;
      _nw49[(int)(8069)] = 41;
      _nw49[(int)(8070)] = 216;
      _nw49[(int)(8071)] = 132;
      _nw49[(int)(8072)] = 86;
      _nw49[(int)(8073)] = 150;
      _nw49[(int)(8074)] = 218;
      _nw49[(int)(8075)] = 169;
      _nw49[(int)(8076)] = 130;
      _nw49[(int)(8077)] = 21;
      _nw49[(int)(8078)] = 246;
      _nw49[(int)(8079)] = 121;
      _nw49[(int)(8080)] = 248;
      _nw49[(int)(8081)] = 230;
      _nw49[(int)(8082)] = 213;
      _nw49[(int)(8083)] = 220;
      _nw49[(int)(8084)] = 224;
      _nw49[(int)(8085)] = 253;
      _nw49[(int)(8086)] = 119;
      _nw49[(int)(8087)] = 75;
      _nw49[(int)(8088)] = 26;
      _nw49[(int)(8089)] = 60;
      _nw49[(int)(8090)] = 126;
      _nw49[(int)(8091)] = 97;
      _nw49[(int)(8092)] = 62;
      _nw49[(int)(8093)] = 31;
      _nw49[(int)(8094)] = 243;
      _nw49[(int)(8095)] = 5;
      _nw49[(int)(8096)] = 252;
      _nw49[(int)(8097)] = 172;
      _nw49[(int)(8098)] = 52;
      _nw49[(int)(8099)] = 43;
      _nw49[(int)(8100)] = 240;
      _nw49[(int)(8101)] = 149;
      _nw49[(int)(8102)] = 71;
      _nw49[(int)(8103)] = 49;
      _nw49[(int)(8104)] = 99;
      _nw49[(int)(8105)] = 233;
      _nw49[(int)(8106)] = 159;
      _nw49[(int)(8107)] = 75;
      _nw49[(int)(8108)] = 157;
      _nw49[(int)(8109)] = 194;
      _nw49[(int)(8110)] = 68;
      _nw49[(int)(8111)] = 212;
      _nw49[(int)(8112)] = 195;
      _nw49[(int)(8113)] = 187;
      _nw49[(int)(8114)] = 101;
      _nw49[(int)(8115)] = 195;
      _nw49[(int)(8116)] = 159;
      _nw49[(int)(8117)] = 207;
      _nw49[(int)(8118)] = 62;
      _nw49[(int)(8119)] = 227;
      _nw49[(int)(8120)] = 153;
      _nw49[(int)(8121)] = 137;
      _nw49[(int)(8122)] = 51;
      _nw49[(int)(8123)] = 97;
      _nw49[(int)(8124)] = 70;
      _nw49[(int)(8125)] = 220;
      _nw49[(int)(8126)] = 183;
      _nw49[(int)(8127)] = 186;
      _nw49[(int)(8128)] = 118;
      _21371_tv__okm__desired = _nw49;
      Dafny.ISequence<byte> _21372_okm;
      Dafny.ISequence<byte> _out212;
      _out212 = HKDF_Compile.__default.Hkdf(@KeyDerivationAlgorithms.KeyDerivationAlgorithm.create_HKDF__WITH__SHA__256(), @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(Dafny.Helpers.SeqFromArray(_21369_tv__salt)), Dafny.Helpers.SeqFromArray(_21368_tv__ikm), Dafny.Helpers.SeqFromArray(_21370_tv__info), new BigInteger(8129));
      _21372_okm = _out212;
      if (!((Dafny.Helpers.SeqFromArray(_21371_tv__okm__desired)).Equals((_21372_okm)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/hkdf/HKDF.dfy(598,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
  }
} // end of namespace TestHKDF
namespace TestUtils {










  public abstract class SmallEncryptionContextVariation {
    public SmallEncryptionContextVariation() { }
    private static readonly SmallEncryptionContextVariation theDefault = create_Empty();
    public static SmallEncryptionContextVariation Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<TestUtils.SmallEncryptionContextVariation> _TYPE = new Dafny.TypeDescriptor<TestUtils.SmallEncryptionContextVariation>(TestUtils.SmallEncryptionContextVariation.Default());
    public static Dafny.TypeDescriptor<TestUtils.SmallEncryptionContextVariation> _TypeDescriptor() {
      return _TYPE;
    }
    public static SmallEncryptionContextVariation create_Empty() {
      return new SmallEncryptionContextVariation_Empty();
    }
    public static SmallEncryptionContextVariation create_A() {
      return new SmallEncryptionContextVariation_A();
    }
    public static SmallEncryptionContextVariation create_AB() {
      return new SmallEncryptionContextVariation_AB();
    }
    public static SmallEncryptionContextVariation create_BA() {
      return new SmallEncryptionContextVariation_BA();
    }
    public bool is_Empty { get { return this is SmallEncryptionContextVariation_Empty; } }
    public bool is_A { get { return this is SmallEncryptionContextVariation_A; } }
    public bool is_AB { get { return this is SmallEncryptionContextVariation_AB; } }
    public bool is_BA { get { return this is SmallEncryptionContextVariation_BA; } }
    public static System.Collections.Generic.IEnumerable<SmallEncryptionContextVariation> AllSingletonConstructors {
      get {
        yield return SmallEncryptionContextVariation.create_Empty();
        yield return SmallEncryptionContextVariation.create_A();
        yield return SmallEncryptionContextVariation.create_AB();
        yield return SmallEncryptionContextVariation.create_BA();
      }
    }
  }
  public class SmallEncryptionContextVariation_Empty : SmallEncryptionContextVariation {
    public SmallEncryptionContextVariation_Empty() {
    }
    public override bool Equals(object other) {
      var oth = other as TestUtils.SmallEncryptionContextVariation_Empty;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      return (int) hash;
    }
    public override string ToString() {
      string s = "TestUtils_Compile.SmallEncryptionContextVariation.Empty";
      return s;
    }
  }
  public class SmallEncryptionContextVariation_A : SmallEncryptionContextVariation {
    public SmallEncryptionContextVariation_A() {
    }
    public override bool Equals(object other) {
      var oth = other as TestUtils.SmallEncryptionContextVariation_A;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      return (int) hash;
    }
    public override string ToString() {
      string s = "TestUtils_Compile.SmallEncryptionContextVariation.A";
      return s;
    }
  }
  public class SmallEncryptionContextVariation_AB : SmallEncryptionContextVariation {
    public SmallEncryptionContextVariation_AB() {
    }
    public override bool Equals(object other) {
      var oth = other as TestUtils.SmallEncryptionContextVariation_AB;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 2;
      return (int) hash;
    }
    public override string ToString() {
      string s = "TestUtils_Compile.SmallEncryptionContextVariation.AB";
      return s;
    }
  }
  public class SmallEncryptionContextVariation_BA : SmallEncryptionContextVariation {
    public SmallEncryptionContextVariation_BA() {
    }
    public override bool Equals(object other) {
      var oth = other as TestUtils.SmallEncryptionContextVariation_BA;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 3;
      return (int) hash;
    }
    public override string ToString() {
      string s = "TestUtils_Compile.SmallEncryptionContextVariation.BA";
      return s;
    }
  }

  public partial class __default {
    public static Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> GenerateInvalidEncryptionContext()
    {
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encCtx = Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Empty;
      Dafny.ISequence<byte> _21373_validUTF8char = UTF8.ValidUTF8Bytes.Default();
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _21374_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out213;
      _out213 = UTF8.__default.Encode(Dafny.Sequence<char>.FromString("a"));
      _21374_valueOrError0 = _out213;
      if (!(!((_21374_valueOrError0).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/TestUtils.dfy(36,43): " + _21374_valueOrError0);
      }
      _21373_validUTF8char = (_21374_valueOrError0).Extract();
      Dafny.ISequence<byte> _21375_key;
      _21375_key = Dafny.Sequence<byte>.FromElements();
      while ((new BigInteger((_21375_key).Count)) < (StandardLibrary_mUInt_Compile.__default.UINT16__LIMIT)) {
        _21375_key = Dafny.Sequence<byte>.Concat(_21375_key, _21373_validUTF8char);
      }
      encCtx = Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.FromElements(new Dafny.Pair<Dafny.ISequence<byte>,Dafny.ISequence<byte>>(_21375_key,Dafny.Sequence<byte>.FromElements(0)));
      return encCtx;
    }
    public static Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> GenerateLargeValidEncryptionContext()
    {
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> r = Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Empty;
      BigInteger _21376_numMaxPairs;
      _21376_numMaxPairs = new BigInteger(9361);
      Dafny.ISequence<byte> _21377_val = UTF8.ValidUTF8Bytes.Default();
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _21378_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out214;
      _out214 = UTF8.__default.Encode(Dafny.Sequence<char>.FromString("a"));
      _21378_valueOrError0 = _out214;
      if (!(!((_21378_valueOrError0).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/TestUtils.dfy(62,12): " + _21378_valueOrError0);
      }
      _21377_val = (_21378_valueOrError0).Extract();
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _21379_encCtx;
      _21379_encCtx = Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.FromElements();
      BigInteger _21380_i;
      _21380_i = BigInteger.Zero;
      while (((new BigInteger((_21379_encCtx).Count)) < (_21376_numMaxPairs)) && ((_21380_i) < (new BigInteger(65536)))) {
        Dafny.ISequence<byte> _21381_key;
        _21381_key = StandardLibrary_mUInt_Compile.__default.UInt16ToSeq((ushort)(_21380_i));
        if (UTF8.__default.ValidUTF8Seq(_21381_key)) {
          _21379_encCtx = Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Update(_21379_encCtx,_21381_key, _21377_val);
        }
        _21380_i = (_21380_i) + (BigInteger.One);
      }
      if (!((new BigInteger((_21379_encCtx).Count)) == (_21376_numMaxPairs))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/TestUtils.dfy(79,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      r = _21379_encCtx;
      return r;
      return r;
    }
    public static void ExpectSerializableEncryptionContext(Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encCtx)
    {
      bool _21382_valid;
      bool _out215;
      _out215 = EncryptionContext.__default.CheckSerializable(encCtx);
      _21382_valid = _out215;
      if (!(_21382_valid)) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/TestUtils.dfy(97,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    public static void ExpectNonSerializableEncryptionContext(Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encCtx)
    {
      bool _21383_valid;
      bool _out216;
      _out216 = EncryptionContext.__default.CheckSerializable(encCtx);
      _21383_valid = _out216;
      if (!(!(_21383_valid))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/TestUtils.dfy(102,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    public static Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> SmallEncryptionContext(TestUtils.SmallEncryptionContextVariation v)
    {
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext = Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Empty;
      Dafny.ISequence<byte> _21384_keyA = UTF8.ValidUTF8Bytes.Default();
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _21385_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out217;
      _out217 = UTF8.__default.Encode(Dafny.Sequence<char>.FromString("keyA"));
      _21385_valueOrError0 = _out217;
      if (!(!((_21385_valueOrError0).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/TestUtils.dfy(111,13): " + _21385_valueOrError0);
      }
      _21384_keyA = (_21385_valueOrError0).Extract();
      Dafny.ISequence<byte> _21386_valA = UTF8.ValidUTF8Bytes.Default();
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _21387_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out218;
      _out218 = UTF8.__default.Encode(Dafny.Sequence<char>.FromString("valA"));
      _21387_valueOrError1 = _out218;
      if (!(!((_21387_valueOrError1).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/TestUtils.dfy(112,13): " + _21387_valueOrError1);
      }
      _21386_valA = (_21387_valueOrError1).Extract();
      Dafny.ISequence<byte> _21388_keyB = UTF8.ValidUTF8Bytes.Default();
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _21389_valueOrError2 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out219;
      _out219 = UTF8.__default.Encode(Dafny.Sequence<char>.FromString("keyB"));
      _21389_valueOrError2 = _out219;
      if (!(!((_21389_valueOrError2).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/TestUtils.dfy(113,13): " + _21389_valueOrError2);
      }
      _21388_keyB = (_21389_valueOrError2).Extract();
      Dafny.ISequence<byte> _21390_valB = UTF8.ValidUTF8Bytes.Default();
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _21391_valueOrError3 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out220;
      _out220 = UTF8.__default.Encode(Dafny.Sequence<char>.FromString("valB"));
      _21391_valueOrError3 = _out220;
      if (!(!((_21391_valueOrError3).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/TestUtils.dfy(114,13): " + _21391_valueOrError3);
      }
      _21390_valB = (_21391_valueOrError3).Extract();
      TestUtils.SmallEncryptionContextVariation _source28 = v;
      if (_source28.is_Empty) {
        {
          encryptionContext = Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.FromElements();
        }
      } else if (_source28.is_A) {
        {
          encryptionContext = Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.FromElements(new Dafny.Pair<Dafny.ISequence<byte>,Dafny.ISequence<byte>>(_21384_keyA,_21386_valA));
        }
      } else if (_source28.is_AB) {
        {
          encryptionContext = Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.FromElements(new Dafny.Pair<Dafny.ISequence<byte>,Dafny.ISequence<byte>>(_21384_keyA,_21386_valA), new Dafny.Pair<Dafny.ISequence<byte>,Dafny.ISequence<byte>>(_21388_keyB,_21390_valB));
        }
      } else {
        {
          encryptionContext = Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.FromElements(new Dafny.Pair<Dafny.ISequence<byte>,Dafny.ISequence<byte>>(_21388_keyB,_21390_valB), new Dafny.Pair<Dafny.ISequence<byte>,Dafny.ISequence<byte>>(_21384_keyA,_21386_valA));
        }
      }
      return encryptionContext;
    }
    public static Wrappers_Compile.Result<RawRSAKeyringDef.RawRSAKeyring, Dafny.ISequence<char>> MakeRSAKeyring()
    {
      Wrappers_Compile.Result<RawRSAKeyringDef.RawRSAKeyring, Dafny.ISequence<char>> res = default(Wrappers_Compile.Result<RawRSAKeyringDef.RawRSAKeyring, Dafny.ISequence<char>>);
      Dafny.ISequence<byte> _21392_namespace = UTF8.ValidUTF8Bytes.Default();
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _21393_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out221;
      _out221 = UTF8.__default.Encode(Dafny.Sequence<char>.FromString("namespace"));
      _21393_valueOrError0 = _out221;
      if ((_21393_valueOrError0).IsFailure()) {
        res = (_21393_valueOrError0).PropagateFailure<RawRSAKeyringDef.RawRSAKeyring>();
        return res;
      }
      _21392_namespace = (_21393_valueOrError0).Extract();
      Dafny.ISequence<byte> _21394_name = UTF8.ValidUTF8Bytes.Default();
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _21395_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out222;
      _out222 = UTF8.__default.Encode(Dafny.Sequence<char>.FromString("MyKeyring"));
      _21395_valueOrError1 = _out222;
      if ((_21395_valueOrError1).IsFailure()) {
        res = (_21395_valueOrError1).PropagateFailure<RawRSAKeyringDef.RawRSAKeyring>();
        return res;
      }
      _21394_name = (_21395_valueOrError1).Extract();
      RSAEncryption.PublicKey _21396_ek;
      RSAEncryption.PrivateKey _21397_dk;
      RSAEncryption.PublicKey _out223;
      RSAEncryption.PrivateKey _out224;
      RSAEncryption.__default.GenerateKeyPair(2048, @RSAEncryption.PaddingMode.create_PKCS1(), out _out223, out _out224);
      _21396_ek = _out223;
      _21397_dk = _out224;
      RawRSAKeyringDef.RawRSAKeyring _21398_keyring;
      RawRSAKeyringDef.RawRSAKeyring _nw50 = new RawRSAKeyringDef.RawRSAKeyring();
      _nw50.__ctor(_21392_namespace, _21394_name, @RSAEncryption.PaddingMode.create_PKCS1(), @Wrappers_Compile.Option<RSAEncryption.PublicKey>.create_Some(_21396_ek), @Wrappers_Compile.Option<RSAEncryption.PrivateKey>.create_Some(_21397_dk));
      _21398_keyring = _nw50;
      res = @Wrappers_Compile.Result<RawRSAKeyringDef.RawRSAKeyring, Dafny.ISequence<char>>.create_Success(_21398_keyring);
      return res;
      return res;
    }
    public static void NamespaceAndName(BigInteger n, out Dafny.ISequence<byte> @namespace, out Dafny.ISequence<byte> name)
    {
      @namespace = UTF8.ValidUTF8Bytes.Default();
      name = UTF8.ValidUTF8Bytes.Default();
      Dafny.ISequence<char> _21399_s;
      _21399_s = Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("child"), Dafny.Sequence<char>.FromElements((char)(((char)(n)) + ('0'))));
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _21400_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out225;
      _out225 = UTF8.__default.Encode(Dafny.Sequence<char>.Concat(_21399_s, Dafny.Sequence<char>.FromString(" Namespace")));
      _21400_valueOrError0 = _out225;
      if (!(!((_21400_valueOrError0).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/TestUtils.dfy(177,14): " + _21400_valueOrError0);
      }
      @namespace = (_21400_valueOrError0).Extract();
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _21401_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out226;
      _out226 = UTF8.__default.Encode(Dafny.Sequence<char>.Concat(_21399_s, Dafny.Sequence<char>.FromString(" Name")));
      _21401_valueOrError1 = _out226;
      if (!(!((_21401_valueOrError1).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/TestUtils.dfy(178,9): " + _21401_valueOrError1);
      }
      name = (_21401_valueOrError1).Extract();
    }
    public static Dafny.ISequence<char> SHARED__TEST__KEY__ARN { get {
      return Dafny.Sequence<char>.FromString("arn:aws:kms:us-west-2:658956600833:key/b3537ef1-d8dc-4780-9f5a-55776cbb2f7f");
    } }
  }
} // end of namespace TestUtils
namespace TestClient_mHelpers_Compile {









  public partial class __default {
    public static void EncryptDecryptTest(CMMDefs.CMM cmm)
    {
      Dafny.ISequence<byte> _21402_msg = UTF8.ValidUTF8Bytes.Default();
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _21403_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out227;
      _out227 = UTF8.__default.Encode(Dafny.Sequence<char>.FromString("hello"));
      _21403_valueOrError0 = _out227;
      if (!(!((_21403_valueOrError0).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Client.dfy(46,14): " + _21403_valueOrError0);
      }
      _21402_msg = (_21403_valueOrError0).Extract();
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _21404_encryptionContext;
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _out228;
      _out228 = TestUtils.__default.SmallEncryptionContext(@TestUtils.SmallEncryptionContextVariation.create_A());
      _21404_encryptionContext = _out228;
      ESDKClient.EncryptRequest _21405_encryptRequest;
      _21405_encryptRequest = (ESDKClient.EncryptRequest.WithCMM(_21402_msg, cmm)).SetEncryptionContext(_21404_encryptionContext);
      Dafny.ISequence<byte> _21406_e = Dafny.Sequence<byte>.Empty;
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _21407_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out229;
      _out229 = ESDKClient.__default.Encrypt(_21405_encryptRequest);
      _21407_valueOrError1 = _out229;
      if (!(!((_21407_valueOrError1).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Client.dfy(50,12): " + _21407_valueOrError1);
      }
      _21406_e = (_21407_valueOrError1).Extract();
      ESDKClient.DecryptRequest _21408_decryptRequest;
      _21408_decryptRequest = ESDKClient.DecryptRequest.WithCMM(_21406_e, cmm);
      Dafny.ISequence<byte> _21409_d = Dafny.Sequence<byte>.Empty;
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _21410_valueOrError2 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out230;
      _out230 = ESDKClient.__default.Decrypt(_21408_decryptRequest);
      _21410_valueOrError2 = _out230;
      if (!(!((_21410_valueOrError2).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Client.dfy(53,12): " + _21410_valueOrError2);
      }
      _21409_d = (_21410_valueOrError2).Extract();
      if (!((_21402_msg).Equals((_21409_d)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Client.dfy(55,6): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
  }
} // end of namespace TestClient_mHelpers_Compile
namespace TestClient {













  public partial class __default {
    [Xunit.Fact]
    public static void HappyPath()
    {
      Dafny.ISequence<byte> _21411_namespace;
      Dafny.ISequence<byte> _21412_name;
      Dafny.ISequence<byte> _out231;
      Dafny.ISequence<byte> _out232;
      TestUtils.__default.NamespaceAndName(BigInteger.Zero, out _out231, out _out232);
      _21411_namespace = _out231;
      _21412_name = _out232;
      RSAEncryption.PublicKey _21413_ek;
      RSAEncryption.PrivateKey _21414_dk;
      RSAEncryption.PublicKey _out233;
      RSAEncryption.PrivateKey _out234;
      RSAEncryption.__default.GenerateKeyPair(2048, @RSAEncryption.PaddingMode.create_PKCS1(), out _out233, out _out234);
      _21413_ek = _out233;
      _21414_dk = _out234;
      RawRSAKeyringDef.RawRSAKeyring _21415_keyring;
      RawRSAKeyringDef.RawRSAKeyring _nw51 = new RawRSAKeyringDef.RawRSAKeyring();
      _nw51.__ctor(_21411_namespace, _21412_name, @RSAEncryption.PaddingMode.create_PKCS1(), @Wrappers_Compile.Option<RSAEncryption.PublicKey>.create_Some(_21413_ek), @Wrappers_Compile.Option<RSAEncryption.PrivateKey>.create_Some(_21414_dk));
      _21415_keyring = _nw51;
      DefaultCMMDef.DefaultCMM _21416_cmm;
      DefaultCMMDef.DefaultCMM _nw52 = new DefaultCMMDef.DefaultCMM();
      _nw52.OfKeyring(_21415_keyring);
      _21416_cmm = _nw52;
      TestClient_mHelpers_Compile.__default.EncryptDecryptTest(_21416_cmm);
    }
    [Xunit.Fact]
    public static void EncryptCMMKeyringOverload()
    {
      RawRSAKeyringDef.RawRSAKeyring _21417_kr = default(RawRSAKeyringDef.RawRSAKeyring);
      Wrappers_Compile.Result<RawRSAKeyringDef.RawRSAKeyring, Dafny.ISequence<char>> _21418_valueOrError0 = Wrappers_Compile.Result<RawRSAKeyringDef.RawRSAKeyring, Dafny.ISequence<char>>.Default(default(RawRSAKeyringDef.RawRSAKeyring));
      Wrappers_Compile.Result<RawRSAKeyringDef.RawRSAKeyring, Dafny.ISequence<char>> _out235;
      _out235 = TestUtils.__default.MakeRSAKeyring();
      _21418_valueOrError0 = _out235;
      if (!(!((_21418_valueOrError0).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Client.dfy(69,11): " + _21418_valueOrError0);
      }
      _21417_kr = (_21418_valueOrError0).Extract();
      DefaultCMMDef.DefaultCMM _21419_cmm;
      DefaultCMMDef.DefaultCMM _nw53 = new DefaultCMMDef.DefaultCMM();
      _nw53.OfKeyring(_21417_kr);
      _21419_cmm = _nw53;
      ESDKClient.EncryptRequest _21420_badRequest;
      _21420_badRequest = Dafny.Helpers.Let<ESDKClient.EncryptRequest, ESDKClient.EncryptRequest>(ESDKClient.EncryptRequest.WithCMM(Dafny.Sequence<byte>.FromElements(0), _21419_cmm), _pat_let12_0 => Dafny.Helpers.Let<ESDKClient.EncryptRequest, ESDKClient.EncryptRequest>(_pat_let12_0, _21421_dt__update__tmp_h0 => Dafny.Helpers.Let<RawRSAKeyringDef.RawRSAKeyring, ESDKClient.EncryptRequest>(_21417_kr, _pat_let13_0 => Dafny.Helpers.Let<KeyringDefs.Keyring, ESDKClient.EncryptRequest>(_pat_let13_0, _21422_dt__update_hkeyring_h0 => @ESDKClient.EncryptRequest.create((_21421_dt__update__tmp_h0).dtor_plaintext, (_21421_dt__update__tmp_h0).dtor_cmm, _21422_dt__update_hkeyring_h0, (_21421_dt__update__tmp_h0).dtor_plaintextLength, (_21421_dt__update__tmp_h0).dtor_encryptionContext, (_21421_dt__update__tmp_h0).dtor_algorithmSuiteID, (_21421_dt__update__tmp_h0).dtor_frameLength)))));
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _21423_result;
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out236;
      _out236 = ESDKClient.__default.Encrypt(_21420_badRequest);
      _21423_result = _out236;
      if (!((_21423_result).is_Failure)) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Client.dfy(75,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!(((_21423_result).dtor_error).Equals((Dafny.Sequence<char>.FromString("EncryptRequest.keyring OR EncryptRequest.cmm must be set (not both)."))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Client.dfy(76,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void EncryptInvalidAlgID()
    {
      RawRSAKeyringDef.RawRSAKeyring _21424_kr = default(RawRSAKeyringDef.RawRSAKeyring);
      Wrappers_Compile.Result<RawRSAKeyringDef.RawRSAKeyring, Dafny.ISequence<char>> _21425_valueOrError0 = Wrappers_Compile.Result<RawRSAKeyringDef.RawRSAKeyring, Dafny.ISequence<char>>.Default(default(RawRSAKeyringDef.RawRSAKeyring));
      Wrappers_Compile.Result<RawRSAKeyringDef.RawRSAKeyring, Dafny.ISequence<char>> _out237;
      _out237 = TestUtils.__default.MakeRSAKeyring();
      _21425_valueOrError0 = _out237;
      if (!(!((_21425_valueOrError0).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Client.dfy(80,11): " + _21425_valueOrError0);
      }
      _21424_kr = (_21425_valueOrError0).Extract();
      ESDKClient.EncryptRequest _21426_badRequest;
      _21426_badRequest = (ESDKClient.EncryptRequest.WithKeyring(Dafny.Sequence<byte>.FromElements(0), _21424_kr)).SetAlgorithmSuiteID(0);
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _21427_result;
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out238;
      _out238 = ESDKClient.__default.Encrypt(_21426_badRequest);
      _21427_result = _out238;
      if (!((_21427_result).is_Failure)) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Client.dfy(85,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!(((_21427_result).dtor_error).Equals((Dafny.Sequence<char>.FromString("Invalid algorithmSuiteID."))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Client.dfy(86,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void EncryptFrameLengthZero()
    {
      RawRSAKeyringDef.RawRSAKeyring _21428_kr = default(RawRSAKeyringDef.RawRSAKeyring);
      Wrappers_Compile.Result<RawRSAKeyringDef.RawRSAKeyring, Dafny.ISequence<char>> _21429_valueOrError0 = Wrappers_Compile.Result<RawRSAKeyringDef.RawRSAKeyring, Dafny.ISequence<char>>.Default(default(RawRSAKeyringDef.RawRSAKeyring));
      Wrappers_Compile.Result<RawRSAKeyringDef.RawRSAKeyring, Dafny.ISequence<char>> _out239;
      _out239 = TestUtils.__default.MakeRSAKeyring();
      _21429_valueOrError0 = _out239;
      if (!(!((_21429_valueOrError0).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Client.dfy(90,11): " + _21429_valueOrError0);
      }
      _21428_kr = (_21429_valueOrError0).Extract();
      ESDKClient.EncryptRequest _21430_badRequest;
      _21430_badRequest = (ESDKClient.EncryptRequest.WithKeyring(Dafny.Sequence<byte>.FromElements(0), _21428_kr)).SetFrameLength(0U);
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _21431_result;
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out240;
      _out240 = ESDKClient.__default.Encrypt(_21430_badRequest);
      _21431_result = _out240;
      if (!((_21431_result).is_Failure)) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Client.dfy(95,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!(((_21431_result).dtor_error).Equals((Dafny.Sequence<char>.FromString("Request frameLength must be > 0"))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Client.dfy(96,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void DecryptCMMKeyringOverload()
    {
      RawRSAKeyringDef.RawRSAKeyring _21432_kr = default(RawRSAKeyringDef.RawRSAKeyring);
      Wrappers_Compile.Result<RawRSAKeyringDef.RawRSAKeyring, Dafny.ISequence<char>> _21433_valueOrError0 = Wrappers_Compile.Result<RawRSAKeyringDef.RawRSAKeyring, Dafny.ISequence<char>>.Default(default(RawRSAKeyringDef.RawRSAKeyring));
      Wrappers_Compile.Result<RawRSAKeyringDef.RawRSAKeyring, Dafny.ISequence<char>> _out241;
      _out241 = TestUtils.__default.MakeRSAKeyring();
      _21433_valueOrError0 = _out241;
      if (!(!((_21433_valueOrError0).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Client.dfy(100,11): " + _21433_valueOrError0);
      }
      _21432_kr = (_21433_valueOrError0).Extract();
      DefaultCMMDef.DefaultCMM _21434_cmm;
      DefaultCMMDef.DefaultCMM _nw54 = new DefaultCMMDef.DefaultCMM();
      _nw54.OfKeyring(_21432_kr);
      _21434_cmm = _nw54;
      ESDKClient.DecryptRequest _21435_badRequest;
      _21435_badRequest = Dafny.Helpers.Let<ESDKClient.DecryptRequest, ESDKClient.DecryptRequest>(ESDKClient.DecryptRequest.WithCMM(Dafny.Sequence<byte>.FromElements(0), _21434_cmm), _pat_let14_0 => Dafny.Helpers.Let<ESDKClient.DecryptRequest, ESDKClient.DecryptRequest>(_pat_let14_0, _21436_dt__update__tmp_h0 => Dafny.Helpers.Let<RawRSAKeyringDef.RawRSAKeyring, ESDKClient.DecryptRequest>(_21432_kr, _pat_let15_0 => Dafny.Helpers.Let<KeyringDefs.Keyring, ESDKClient.DecryptRequest>(_pat_let15_0, _21437_dt__update_hkeyring_h0 => @ESDKClient.DecryptRequest.create((_21436_dt__update__tmp_h0).dtor_message, (_21436_dt__update__tmp_h0).dtor_cmm, _21437_dt__update_hkeyring_h0)))));
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _21438_result;
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out242;
      _out242 = ESDKClient.__default.Decrypt(_21435_badRequest);
      _21438_result = _out242;
      if (!((_21438_result).is_Failure)) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Client.dfy(106,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!(((_21438_result).dtor_error).Equals((Dafny.Sequence<char>.FromString("DecryptRequest.keyring OR DecryptRequest.cmm must be set (not both)."))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Client.dfy(107,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
  }
} // end of namespace TestClient
namespace TestCachingCMM_mHelpers_Compile {











  public partial class TestCMM : CMMDefs.CMM {
    public TestCMM() {
      this.eCalls = BigInteger.Zero;
      this.dCalls = BigInteger.Zero;
    }
    public BigInteger eCalls;public BigInteger dCalls;public void __ctor()
    {
      BigInteger _rhs23 = BigInteger.Zero;
      BigInteger _rhs24 = BigInteger.Zero;
      TestCachingCMM_mHelpers_Compile.TestCMM _lhs8 = this;
      TestCachingCMM_mHelpers_Compile.TestCMM _lhs9 = this;
      _lhs8.eCalls = _rhs23;
      _lhs9.dCalls = _rhs24;
    }
    public Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>> GetEncryptionMaterials(Materials.EncryptionMaterialsRequest materialsRequest)
    {
      Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>> res = Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>>.Default(Materials.ValidEncryptionMaterials.Default());
      TestUtils.__default.ExpectSerializableEncryptionContext((materialsRequest).dtor_encryptionContext);
      ushort _21439_algSuiteID;
      _21439_algSuiteID = ((object.Equals((materialsRequest).dtor_algorithmSuiteID, @Wrappers_Compile.Option<ushort>.create_None())) ? (AlgorithmSuite.__default.AES__256__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384) : (((materialsRequest).dtor_algorithmSuiteID).dtor_value));
      Materials.EncryptedDataKey _21440_edk;
      _21440_edk = @Materials.EncryptedDataKey.create(Dafny.Sequence<byte>.FromElements(), Dafny.Sequence<byte>.FromElements(), Dafny.Sequence<byte>.FromElements());
      Materials.EncryptionMaterials _21441_em;
      _21441_em = @Materials.EncryptionMaterials.create((materialsRequest).dtor_encryptionContext, _21439_algSuiteID, @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(((System.Func<Dafny.ISequence<byte>>) (() => {
  BigInteger dim12 = AlgorithmSuite.ID.KDFInputKeyLength(_21439_algSuiteID);
  var arr12 = new byte[Dafny.Helpers.ToIntChecked(dim12,"C# array size must not be larger than max 32-bit int")];
  for (int i12 = 0; i12 < dim12; i12++) {
    var _21442_x = (BigInteger) i12;
    arr12[(int)(_21442_x)] = (byte)((70) + ((byte)(Dafny.Helpers.EuclideanModulus(_21442_x, new BigInteger(20)))));
  }
  return Dafny.Sequence<byte>.FromArray(arr12);
}))()), Dafny.Sequence<Materials.EncryptedDataKey>.FromElements(_21440_edk), ((object.Equals(AlgorithmSuite.ID.SignatureType(_21439_algSuiteID), @Wrappers_Compile.Option<Signature.ECDSAParams>.create_None())) ? (@Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_None()) : (@Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(Dafny.Sequence<byte>.FromElements(52, 53, 54)))));
      (this).eCalls = (this.eCalls) + (BigInteger.One);
      res = @Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>>.create_Success(_21441_em);
      return res;
      return res;
    }
    public Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>> DecryptMaterials(Materials.DecryptionMaterialsRequest materialsRequest)
    {
      Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>> res = Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>.Default(Materials.ValidDecryptionMaterials.Default());
      Materials.DecryptionMaterials _21443_dm;
      _21443_dm = @Materials.DecryptionMaterials.create((materialsRequest).dtor_algorithmSuiteID, (materialsRequest).dtor_encryptionContext, @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(((System.Func<Dafny.ISequence<byte>>) (() => {
  BigInteger dim13 = AlgorithmSuite.ID.KDFInputKeyLength((materialsRequest).dtor_algorithmSuiteID);
  var arr13 = new byte[Dafny.Helpers.ToIntChecked(dim13,"C# array size must not be larger than max 32-bit int")];
  for (int i13 = 0; i13 < dim13; i13++) {
    var _21444_x = (BigInteger) i13;
    arr13[(int)(_21444_x)] = (byte)((70) + ((byte)(Dafny.Helpers.EuclideanModulus(_21444_x, new BigInteger(20)))));
  }
  return Dafny.Sequence<byte>.FromArray(arr13);
}))()), @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(Dafny.Sequence<byte>.FromElements(49, 48, 47)));
      (this).dCalls = (this.dCalls) + (BigInteger.One);
      res = @Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>.create_Success(_21443_dm);
      return res;
      return res;
    }
  }

  public partial class __default {
    public static void CallGetEM(CachingCMMDef.CachingCMM ccmm, TestCachingCMM_mHelpers_Compile.TestCMM tcmm, Materials.EncryptionMaterialsRequest request, bool expectCacheHit)
    {
      BigInteger _21445_previousECalls;
      _21445_previousECalls = tcmm.eCalls;
      Materials.EncryptionMaterials _21446_em = Materials.ValidEncryptionMaterials.Default();
      Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>> _21447_valueOrError0 = Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>>.Default(Materials.ValidEncryptionMaterials.Default());
      Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>> _out243;
      _out243 = (ccmm).GetEncryptionMaterials(request);
      _21447_valueOrError0 = _out243;
      if (!(!((_21447_valueOrError0).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/CMM/CachingCMM.dfy(203,13): " + _21447_valueOrError0);
      }
      _21446_em = (_21447_valueOrError0).Extract();
      if (!(((tcmm.eCalls) == (_21445_previousECalls)) || ((tcmm.eCalls) == ((_21445_previousECalls) + (BigInteger.One))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/CMM/CachingCMM.dfy(204,6): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!((expectCacheHit) == ((tcmm.eCalls) == (_21445_previousECalls)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/CMM/CachingCMM.dfy(205,6): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    public static void CallDM(CachingCMMDef.CachingCMM ccmm, TestCachingCMM_mHelpers_Compile.TestCMM tcmm, Materials.DecryptionMaterialsRequest request, bool expectCacheHit)
    {
      BigInteger _21448_previousDCalls;
      _21448_previousDCalls = tcmm.dCalls;
      Materials.DecryptionMaterials _21449_dm = Materials.ValidDecryptionMaterials.Default();
      Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>> _21450_valueOrError0 = Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>.Default(Materials.ValidDecryptionMaterials.Default());
      Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>> _out244;
      _out244 = (ccmm).DecryptMaterials(request);
      _21450_valueOrError0 = _out244;
      if (!(!((_21450_valueOrError0).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/CMM/CachingCMM.dfy(215,13): " + _21450_valueOrError0);
      }
      _21449_dm = (_21450_valueOrError0).Extract();
      if (!(((tcmm.dCalls) == (_21448_previousDCalls)) || ((tcmm.dCalls) == ((_21448_previousDCalls) + (BigInteger.One))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/CMM/CachingCMM.dfy(216,6): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!((expectCacheHit) == ((tcmm.dCalls) == (_21448_previousDCalls)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/CMM/CachingCMM.dfy(217,6): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
  }
} // end of namespace TestCachingCMM_mHelpers_Compile
namespace TestCachingCMM_Compile {










  public partial class __default {
    [Xunit.Fact]
    public static void TestGetEMMessagesLimit()
    {
      TestCachingCMM_mHelpers_Compile.TestCMM _21451_tcmm;
      TestCachingCMM_mHelpers_Compile.TestCMM _nw55 = new TestCachingCMM_mHelpers_Compile.TestCMM();
      _nw55.__ctor();
      _21451_tcmm = _nw55;
      ulong _21452_messageLimit;
      _21452_messageLimit = 4UL;
      ulong _21453_byteLimit;
      _21453_byteLimit = 100UL;
      CachingCMMDef.CachingCMM _21454_ccmm;
      CachingCMMDef.CachingCMM _nw56 = new CachingCMMDef.CachingCMM();
      _nw56.WithLimits(_21451_tcmm, TestCachingCMM_Compile.__default.SECONDS__TO__LIVE__LIMIT, _21452_messageLimit, _21453_byteLimit);
      _21454_ccmm = _nw56;
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _21455_encryptionContext;
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _out245;
      _out245 = TestUtils.__default.SmallEncryptionContext(@TestUtils.SmallEncryptionContextVariation.create_AB());
      _21455_encryptionContext = _out245;
      Materials.EncryptionMaterialsRequest _21456_eRequest;
      _21456_eRequest = @Materials.EncryptionMaterialsRequest.create(_21455_encryptionContext, @Wrappers_Compile.Option<ushort>.create_Some(AlgorithmSuite.__default.AES__128__GCM__IV12__TAG16__HKDF__SHA256__ECDSA__P256), @Wrappers_Compile.Option<BigInteger>.create_Some(new BigInteger(5)));
      TestCachingCMM_mHelpers_Compile.__default.CallGetEM(_21454_ccmm, _21451_tcmm, _21456_eRequest, false);
      TestCachingCMM_mHelpers_Compile.__default.CallGetEM(_21454_ccmm, _21451_tcmm, _21456_eRequest, true);
      TestCachingCMM_mHelpers_Compile.__default.CallGetEM(_21454_ccmm, _21451_tcmm, _21456_eRequest, true);
      TestCachingCMM_mHelpers_Compile.__default.CallGetEM(_21454_ccmm, _21451_tcmm, _21456_eRequest, false);
    }
    [Xunit.Fact]
    public static void TestGetEMBytesLimit()
    {
      TestCachingCMM_mHelpers_Compile.TestCMM _21457_tcmm;
      TestCachingCMM_mHelpers_Compile.TestCMM _nw57 = new TestCachingCMM_mHelpers_Compile.TestCMM();
      _nw57.__ctor();
      _21457_tcmm = _nw57;
      ulong _21458_messageLimit;
      _21458_messageLimit = 1000000UL;
      ulong _21459_byteLimit;
      _21459_byteLimit = 100UL;
      CachingCMMDef.CachingCMM _21460_ccmm;
      CachingCMMDef.CachingCMM _nw58 = new CachingCMMDef.CachingCMM();
      _nw58.WithLimits(_21457_tcmm, TestCachingCMM_Compile.__default.SECONDS__TO__LIVE__LIMIT, _21458_messageLimit, _21459_byteLimit);
      _21460_ccmm = _nw58;
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _21461_encryptionContext;
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _out246;
      _out246 = TestUtils.__default.SmallEncryptionContext(@TestUtils.SmallEncryptionContextVariation.create_AB());
      _21461_encryptionContext = _out246;
      Materials.EncryptionMaterialsRequest _21462_eRequest;
      _21462_eRequest = @Materials.EncryptionMaterialsRequest.create(_21461_encryptionContext, @Wrappers_Compile.Option<ushort>.create_Some(AlgorithmSuite.__default.AES__128__GCM__IV12__TAG16__HKDF__SHA256__ECDSA__P256), @Wrappers_Compile.Option<BigInteger>.create_Some(new BigInteger(29)));
      TestCachingCMM_mHelpers_Compile.__default.CallGetEM(_21460_ccmm, _21457_tcmm, _21462_eRequest, false);
      TestCachingCMM_mHelpers_Compile.__default.CallGetEM(_21460_ccmm, _21457_tcmm, _21462_eRequest, true);
      TestCachingCMM_mHelpers_Compile.__default.CallGetEM(_21460_ccmm, _21457_tcmm, _21462_eRequest, true);
      TestCachingCMM_mHelpers_Compile.__default.CallGetEM(_21460_ccmm, _21457_tcmm, _21462_eRequest, false);
    }
    [Xunit.Fact]
    public static void TestGetEMTimeLimit()
    {
      TestCachingCMM_mHelpers_Compile.TestCMM _21463_tcmm;
      TestCachingCMM_mHelpers_Compile.TestCMM _nw59 = new TestCachingCMM_mHelpers_Compile.TestCMM();
      _nw59.__ctor();
      _21463_tcmm = _nw59;
      CachingCMMDef.CachingCMM _21464_ccmm;
      CachingCMMDef.CachingCMM _nw60 = new CachingCMMDef.CachingCMM();
      _nw60.ForTestingOnly__WithZeroTimeToLive(_21463_tcmm);
      _21464_ccmm = _nw60;
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _21465_encryptionContext;
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _out247;
      _out247 = TestUtils.__default.SmallEncryptionContext(@TestUtils.SmallEncryptionContextVariation.create_AB());
      _21465_encryptionContext = _out247;
      Materials.EncryptionMaterialsRequest _21466_eRequest;
      _21466_eRequest = @Materials.EncryptionMaterialsRequest.create(_21465_encryptionContext, @Wrappers_Compile.Option<ushort>.create_Some(AlgorithmSuite.__default.AES__128__GCM__IV12__TAG16__HKDF__SHA256__ECDSA__P256), @Wrappers_Compile.Option<BigInteger>.create_Some(new BigInteger(29)));
      BigInteger _21467_n;
      _21467_n = BigInteger.Zero;
      while ((_21467_n) < (new BigInteger(12))) {
        TestCachingCMM_mHelpers_Compile.__default.CallGetEM(_21464_ccmm, _21463_tcmm, _21466_eRequest, false);
        _21467_n = (_21467_n) + (BigInteger.One);
      }
    }
    [Xunit.Fact]
    public static void TestGetEMVariationsInParameters()
    {
      TestCachingCMM_mHelpers_Compile.TestCMM _21468_tcmm;
      TestCachingCMM_mHelpers_Compile.TestCMM _nw61 = new TestCachingCMM_mHelpers_Compile.TestCMM();
      _nw61.__ctor();
      _21468_tcmm = _nw61;
      CachingCMMDef.CachingCMM _21469_ccmm;
      CachingCMMDef.CachingCMM _nw62 = new CachingCMMDef.CachingCMM();
      _nw62.__ctor(_21468_tcmm, TestCachingCMM_Compile.__default.SECONDS__TO__LIVE__LIMIT);
      _21469_ccmm = _nw62;
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _21470_encryptionContext;
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _out248;
      _out248 = TestUtils.__default.SmallEncryptionContext(@TestUtils.SmallEncryptionContextVariation.create_AB());
      _21470_encryptionContext = _out248;
      Materials.EncryptionMaterialsRequest _21471_eRequest;
      _21471_eRequest = @Materials.EncryptionMaterialsRequest.create(_21470_encryptionContext, @Wrappers_Compile.Option<ushort>.create_Some(AlgorithmSuite.__default.AES__128__GCM__IV12__TAG16__HKDF__SHA256__ECDSA__P256), @Wrappers_Compile.Option<BigInteger>.create_Some(new BigInteger(5)));
      TestCachingCMM_mHelpers_Compile.__default.CallGetEM(_21469_ccmm, _21468_tcmm, _21471_eRequest, false);
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _out249;
      _out249 = TestUtils.__default.SmallEncryptionContext(@TestUtils.SmallEncryptionContextVariation.create_BA());
      _21470_encryptionContext = _out249;
      _21471_eRequest = @Materials.EncryptionMaterialsRequest.create(_21470_encryptionContext, @Wrappers_Compile.Option<ushort>.create_Some(AlgorithmSuite.__default.AES__128__GCM__IV12__TAG16__HKDF__SHA256__ECDSA__P256), @Wrappers_Compile.Option<BigInteger>.create_Some(new BigInteger(5)));
      TestCachingCMM_mHelpers_Compile.__default.CallGetEM(_21469_ccmm, _21468_tcmm, _21471_eRequest, true);
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _21472_emptyEncryptionContext;
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _out250;
      _out250 = TestUtils.__default.SmallEncryptionContext(@TestUtils.SmallEncryptionContextVariation.create_Empty());
      _21472_emptyEncryptionContext = _out250;
      _21471_eRequest = @Materials.EncryptionMaterialsRequest.create(_21472_emptyEncryptionContext, @Wrappers_Compile.Option<ushort>.create_Some(AlgorithmSuite.__default.AES__128__GCM__IV12__TAG16__HKDF__SHA256__ECDSA__P256), @Wrappers_Compile.Option<BigInteger>.create_Some(new BigInteger(5)));
      TestCachingCMM_mHelpers_Compile.__default.CallGetEM(_21469_ccmm, _21468_tcmm, _21471_eRequest, false);
      _21471_eRequest = @Materials.EncryptionMaterialsRequest.create(_21470_encryptionContext, @Wrappers_Compile.Option<ushort>.create_Some(AlgorithmSuite.__default.AES__128__GCM__IV12__TAG16__HKDF__SHA256__ECDSA__P256), @Wrappers_Compile.Option<BigInteger>.create_Some(new BigInteger(5)));
      TestCachingCMM_mHelpers_Compile.__default.CallGetEM(_21469_ccmm, _21468_tcmm, _21471_eRequest, true);
      _21471_eRequest = @Materials.EncryptionMaterialsRequest.create(_21470_encryptionContext, @Wrappers_Compile.Option<ushort>.create_Some(AlgorithmSuite.__default.AES__128__GCM__IV12__TAG16__HKDF__SHA256__ECDSA__P256), @Wrappers_Compile.Option<BigInteger>.create_Some(new BigInteger(99)));
      TestCachingCMM_mHelpers_Compile.__default.CallGetEM(_21469_ccmm, _21468_tcmm, _21471_eRequest, true);
      _21471_eRequest = @Materials.EncryptionMaterialsRequest.create(_21470_encryptionContext, @Wrappers_Compile.Option<ushort>.create_Some(AlgorithmSuite.__default.AES__256__GCM__IV12__TAG16__IDENTITY__NO__SIGNATURE__ALG), @Wrappers_Compile.Option<BigInteger>.create_Some(new BigInteger(99)));
      TestCachingCMM_mHelpers_Compile.__default.CallGetEM(_21469_ccmm, _21468_tcmm, _21471_eRequest, false);
    }
    [Xunit.Fact]
    public static void TestDMFlowLimit()
    {
      TestCachingCMM_mHelpers_Compile.TestCMM _21473_tcmm;
      TestCachingCMM_mHelpers_Compile.TestCMM _nw63 = new TestCachingCMM_mHelpers_Compile.TestCMM();
      _nw63.__ctor();
      _21473_tcmm = _nw63;
      ulong _21474_messageLimit;
      _21474_messageLimit = 2UL;
      ulong _21475_byteLimit;
      _21475_byteLimit = 100UL;
      CachingCMMDef.CachingCMM _21476_ccmm;
      CachingCMMDef.CachingCMM _nw64 = new CachingCMMDef.CachingCMM();
      _nw64.WithLimits(_21473_tcmm, TestCachingCMM_Compile.__default.SECONDS__TO__LIVE__LIMIT, _21474_messageLimit, _21475_byteLimit);
      _21476_ccmm = _nw64;
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _21477_encryptionContext;
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _out251;
      _out251 = TestUtils.__default.SmallEncryptionContext(@TestUtils.SmallEncryptionContextVariation.create_Empty());
      _21477_encryptionContext = _out251;
      Materials.EncryptedDataKey _21478_edk;
      _21478_edk = @Materials.EncryptedDataKey.create(Dafny.Sequence<byte>.FromElements(), Dafny.Sequence<byte>.FromElements(), Dafny.Sequence<byte>.FromElements());
      Materials.DecryptionMaterialsRequest _21479_dRequest;
      _21479_dRequest = @Materials.DecryptionMaterialsRequest.create(AlgorithmSuite.__default.AES__128__GCM__IV12__TAG16__HKDF__SHA256__ECDSA__P256, Dafny.Sequence<Materials.EncryptedDataKey>.FromElements(_21478_edk), _21477_encryptionContext);
      BigInteger _21480_n;
      _21480_n = BigInteger.Zero;
      while ((_21480_n) < (new BigInteger(12))) {
        TestCachingCMM_mHelpers_Compile.__default.CallDM(_21476_ccmm, _21473_tcmm, _21479_dRequest, (_21480_n).Sign != 0);
        _21480_n = (_21480_n) + (BigInteger.One);
      }
    }
    [Xunit.Fact]
    public static void TestDMTimeLimit()
    {
      TestCachingCMM_mHelpers_Compile.TestCMM _21481_tcmm;
      TestCachingCMM_mHelpers_Compile.TestCMM _nw65 = new TestCachingCMM_mHelpers_Compile.TestCMM();
      _nw65.__ctor();
      _21481_tcmm = _nw65;
      BigInteger _21482_timeToLiveLimit;
      _21482_timeToLiveLimit = BigInteger.One;
      CachingCMMDef.CachingCMM _21483_ccmm;
      CachingCMMDef.CachingCMM _nw66 = new CachingCMMDef.CachingCMM();
      _nw66.ForTestingOnly__WithZeroTimeToLive(_21481_tcmm);
      _21483_ccmm = _nw66;
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _21484_encryptionContext;
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _out252;
      _out252 = TestUtils.__default.SmallEncryptionContext(@TestUtils.SmallEncryptionContextVariation.create_AB());
      _21484_encryptionContext = _out252;
      Materials.EncryptedDataKey _21485_edk;
      _21485_edk = @Materials.EncryptedDataKey.create(Dafny.Sequence<byte>.FromElements(), Dafny.Sequence<byte>.FromElements(), Dafny.Sequence<byte>.FromElements());
      Materials.DecryptionMaterialsRequest _21486_dRequest;
      _21486_dRequest = @Materials.DecryptionMaterialsRequest.create(AlgorithmSuite.__default.AES__128__GCM__IV12__TAG16__HKDF__SHA256__ECDSA__P256, Dafny.Sequence<Materials.EncryptedDataKey>.FromElements(_21485_edk), _21484_encryptionContext);
      BigInteger _21487_n;
      _21487_n = BigInteger.Zero;
      while ((_21487_n) < (new BigInteger(12))) {
        TestCachingCMM_mHelpers_Compile.__default.CallDM(_21483_ccmm, _21481_tcmm, _21486_dRequest, false);
        _21487_n = (_21487_n) + (BigInteger.One);
      }
    }
    [Xunit.Fact]
    public static void TestDMVariationsInParameters()
    {
      TestCachingCMM_mHelpers_Compile.TestCMM _21488_tcmm;
      TestCachingCMM_mHelpers_Compile.TestCMM _nw67 = new TestCachingCMM_mHelpers_Compile.TestCMM();
      _nw67.__ctor();
      _21488_tcmm = _nw67;
      CachingCMMDef.CachingCMM _21489_ccmm;
      CachingCMMDef.CachingCMM _nw68 = new CachingCMMDef.CachingCMM();
      _nw68.__ctor(_21488_tcmm, TestCachingCMM_Compile.__default.SECONDS__TO__LIVE__LIMIT);
      _21489_ccmm = _nw68;
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _21490_encryptionContext;
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _out253;
      _out253 = TestUtils.__default.SmallEncryptionContext(@TestUtils.SmallEncryptionContextVariation.create_AB());
      _21490_encryptionContext = _out253;
      Materials.EncryptedDataKey _21491_edk;
      _21491_edk = @Materials.EncryptedDataKey.create(Dafny.Sequence<byte>.FromElements(), Dafny.Sequence<byte>.FromElements(), Dafny.Sequence<byte>.FromElements());
      Materials.DecryptionMaterialsRequest _21492_dRequest;
      _21492_dRequest = @Materials.DecryptionMaterialsRequest.create(AlgorithmSuite.__default.AES__128__GCM__IV12__TAG16__HKDF__SHA256__ECDSA__P256, Dafny.Sequence<Materials.EncryptedDataKey>.FromElements(_21491_edk), _21490_encryptionContext);
      TestCachingCMM_mHelpers_Compile.__default.CallDM(_21489_ccmm, _21488_tcmm, _21492_dRequest, false);
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _out254;
      _out254 = TestUtils.__default.SmallEncryptionContext(@TestUtils.SmallEncryptionContextVariation.create_BA());
      _21490_encryptionContext = _out254;
      _21492_dRequest = @Materials.DecryptionMaterialsRequest.create(AlgorithmSuite.__default.AES__128__GCM__IV12__TAG16__HKDF__SHA256__ECDSA__P256, Dafny.Sequence<Materials.EncryptedDataKey>.FromElements(_21491_edk), _21490_encryptionContext);
      TestCachingCMM_mHelpers_Compile.__default.CallDM(_21489_ccmm, _21488_tcmm, _21492_dRequest, true);
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _21493_emptyEncryptionContext;
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _out255;
      _out255 = TestUtils.__default.SmallEncryptionContext(@TestUtils.SmallEncryptionContextVariation.create_Empty());
      _21493_emptyEncryptionContext = _out255;
      _21492_dRequest = @Materials.DecryptionMaterialsRequest.create(AlgorithmSuite.__default.AES__128__GCM__IV12__TAG16__HKDF__SHA256__ECDSA__P256, Dafny.Sequence<Materials.EncryptedDataKey>.FromElements(_21491_edk), _21493_emptyEncryptionContext);
      TestCachingCMM_mHelpers_Compile.__default.CallDM(_21489_ccmm, _21488_tcmm, _21492_dRequest, false);
      Materials.EncryptedDataKey _21494_edk_k;
      _21494_edk_k = @Materials.EncryptedDataKey.create(Dafny.Sequence<byte>.FromElements(), Dafny.Sequence<byte>.FromElements(82, 83), Dafny.Sequence<byte>.FromElements(84, 85));
      _21492_dRequest = @Materials.DecryptionMaterialsRequest.create(AlgorithmSuite.__default.AES__128__GCM__IV12__TAG16__HKDF__SHA256__ECDSA__P256, Dafny.Sequence<Materials.EncryptedDataKey>.FromElements(_21494_edk_k), _21490_encryptionContext);
      TestCachingCMM_mHelpers_Compile.__default.CallDM(_21489_ccmm, _21488_tcmm, _21492_dRequest, false);
      _21492_dRequest = @Materials.DecryptionMaterialsRequest.create(AlgorithmSuite.__default.AES__128__GCM__IV12__TAG16__HKDF__SHA256__ECDSA__P256, Dafny.Sequence<Materials.EncryptedDataKey>.FromElements(_21491_edk), _21490_encryptionContext);
      TestCachingCMM_mHelpers_Compile.__default.CallDM(_21489_ccmm, _21488_tcmm, _21492_dRequest, true);
    }
    public static BigInteger SECONDS__TO__LIVE__LIMIT { get {
      return new BigInteger(3600);
    } }
  }
} // end of namespace TestCachingCMM_Compile
namespace DefaultCMMTests {









  public partial class __default {
    [Xunit.Fact]
    public static Wrappers_Compile.Result<_System.Tuple0, Dafny.ISequence<char>> TestDefaultCMMNoAlg()
    {
      Wrappers_Compile.Result<_System.Tuple0, Dafny.ISequence<char>> res = Wrappers_Compile.Result<_System.Tuple0, Dafny.ISequence<char>>.Default(_System.Tuple0.Default());
      RawRSAKeyringDef.RawRSAKeyring _21495_keyring = default(RawRSAKeyringDef.RawRSAKeyring);
      Wrappers_Compile.Result<RawRSAKeyringDef.RawRSAKeyring, Dafny.ISequence<char>> _21496_valueOrError0 = Wrappers_Compile.Result<RawRSAKeyringDef.RawRSAKeyring, Dafny.ISequence<char>>.Default(default(RawRSAKeyringDef.RawRSAKeyring));
      Wrappers_Compile.Result<RawRSAKeyringDef.RawRSAKeyring, Dafny.ISequence<char>> _out256;
      _out256 = TestUtils.__default.MakeRSAKeyring();
      _21496_valueOrError0 = _out256;
      if ((_21496_valueOrError0).IsFailure()) {
        res = (_21496_valueOrError0).PropagateFailure<_System.Tuple0>();
        return res;
      }
      _21495_keyring = (_21496_valueOrError0).Extract();
      DefaultCMMDef.DefaultCMM _21497_cmm;
      DefaultCMMDef.DefaultCMM _nw69 = new DefaultCMMDef.DefaultCMM();
      _nw69.OfKeyring(_21495_keyring);
      _21497_cmm = _nw69;
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _21498_encCtx;
      _21498_encCtx = Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.FromElements();
      Materials.EncryptionMaterials _21499_getEncMatOutput = Materials.ValidEncryptionMaterials.Default();
      Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>> _21500_valueOrError1 = Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>>.Default(Materials.ValidEncryptionMaterials.Default());
      Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>> _out257;
      _out257 = (_21497_cmm).GetEncryptionMaterials(@Materials.EncryptionMaterialsRequest.create(_21498_encCtx, @Wrappers_Compile.Option<ushort>.create_None(), @Wrappers_Compile.Option<BigInteger>.create_None()));
      _21500_valueOrError1 = _out257;
      if ((_21500_valueOrError1).IsFailure()) {
        res = (_21500_valueOrError1).PropagateFailure<_System.Tuple0>();
        return res;
      }
      _21499_getEncMatOutput = (_21500_valueOrError1).Extract();
      if (!(((_21499_getEncMatOutput).dtor_algorithmSuiteID) == (888))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/DefaultCMM.dfy(30,4): " + Dafny.Sequence<char>.FromString("GetEncryptionMaterials returned unexpected algorithm id"));
      }
      if (!((new BigInteger(((_21499_getEncMatOutput).dtor_encryptedDataKeys).Count)).Sign == 1)) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/DefaultCMM.dfy(31,4): " + Dafny.Sequence<char>.FromString("GetEncryptionMaterials didn't return any EDKs"));
      }
      if (!((AlgorithmSuite.ID.SignatureType((_21499_getEncMatOutput).dtor_algorithmSuiteID)).is_Some)) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/DefaultCMM.dfy(32,4): " + Dafny.Sequence<char>.FromString("GetEncryptionMaterials didn't return a signature algorithm"));
      }
      if (!(((_21499_getEncMatOutput).dtor_signingKey).is_Some)) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/DefaultCMM.dfy(33,4): " + Dafny.Sequence<char>.FromString("GetEncryptionMaterials didn't return a signing key"));
      }
      Materials.DecryptionMaterialsRequest _21501_decMatRequest;
      _21501_decMatRequest = @Materials.DecryptionMaterialsRequest.create((_21499_getEncMatOutput).dtor_algorithmSuiteID, (_21499_getEncMatOutput).dtor_encryptedDataKeys, (_21499_getEncMatOutput).dtor_encryptionContext);
      Materials.DecryptionMaterials _21502_decMatOutput = Materials.ValidDecryptionMaterials.Default();
      Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>> _21503_valueOrError2 = Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>.Default(Materials.ValidDecryptionMaterials.Default());
      Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>> _out258;
      _out258 = (_21497_cmm).DecryptMaterials(_21501_decMatRequest);
      _21503_valueOrError2 = _out258;
      if ((_21503_valueOrError2).IsFailure()) {
        res = (_21503_valueOrError2).PropagateFailure<_System.Tuple0>();
        return res;
      }
      _21502_decMatOutput = (_21503_valueOrError2).Extract();
      if (!(((_21502_decMatOutput).dtor_plaintextDataKey).is_Some)) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/DefaultCMM.dfy(38,4): " + Dafny.Sequence<char>.FromString("DecryptMaterials did not return a plaintext datakey"));
      }
      if (!(AlgorithmSuite.ID.ValidPlaintextDataKey((_21502_decMatOutput).dtor_algorithmSuiteID, ((_21502_decMatOutput).dtor_plaintextDataKey).dtor_value))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/DefaultCMM.dfy(39,4): " + Dafny.Sequence<char>.FromString("DecryptMaterials returned invalid plaintext datakey"));
      }
      if (!(((_21502_decMatOutput).dtor_verificationKey).is_Some)) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/DefaultCMM.dfy(40,4): " + Dafny.Sequence<char>.FromString("DecryptMaterials did not return a verification key"));
      }
      res = @Wrappers_Compile.Result<_System.Tuple0, Dafny.ISequence<char>>.create_Success(@_System.Tuple0.create());
      return res;
      return res;
    }
    [Xunit.Fact]
    public static Wrappers_Compile.Result<_System.Tuple0, Dafny.ISequence<char>> TestDefaultCMMWithAlg()
    {
      Wrappers_Compile.Result<_System.Tuple0, Dafny.ISequence<char>> res = Wrappers_Compile.Result<_System.Tuple0, Dafny.ISequence<char>>.Default(_System.Tuple0.Default());
      RawRSAKeyringDef.RawRSAKeyring _21504_keyring = default(RawRSAKeyringDef.RawRSAKeyring);
      Wrappers_Compile.Result<RawRSAKeyringDef.RawRSAKeyring, Dafny.ISequence<char>> _21505_valueOrError0 = Wrappers_Compile.Result<RawRSAKeyringDef.RawRSAKeyring, Dafny.ISequence<char>>.Default(default(RawRSAKeyringDef.RawRSAKeyring));
      Wrappers_Compile.Result<RawRSAKeyringDef.RawRSAKeyring, Dafny.ISequence<char>> _out259;
      _out259 = TestUtils.__default.MakeRSAKeyring();
      _21505_valueOrError0 = _out259;
      if ((_21505_valueOrError0).IsFailure()) {
        res = (_21505_valueOrError0).PropagateFailure<_System.Tuple0>();
        return res;
      }
      _21504_keyring = (_21505_valueOrError0).Extract();
      DefaultCMMDef.DefaultCMM _21506_cmm;
      DefaultCMMDef.DefaultCMM _nw70 = new DefaultCMMDef.DefaultCMM();
      _nw70.OfKeyring(_21504_keyring);
      _21506_cmm = _nw70;
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _21507_encCtx;
      _21507_encCtx = Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.FromElements();
      Materials.EncryptionMaterials _21508_getEncMatOutput = Materials.ValidEncryptionMaterials.Default();
      Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>> _21509_valueOrError1 = Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>>.Default(Materials.ValidEncryptionMaterials.Default());
      Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>> _out260;
      _out260 = (_21506_cmm).GetEncryptionMaterials(@Materials.EncryptionMaterialsRequest.create(_21507_encCtx, @Wrappers_Compile.Option<ushort>.create_Some(AlgorithmSuite.__default.AES__256__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384), @Wrappers_Compile.Option<BigInteger>.create_None()));
      _21509_valueOrError1 = _out260;
      if ((_21509_valueOrError1).IsFailure()) {
        res = (_21509_valueOrError1).PropagateFailure<_System.Tuple0>();
        return res;
      }
      _21508_getEncMatOutput = (_21509_valueOrError1).Extract();
      if (!(((_21508_getEncMatOutput).dtor_algorithmSuiteID) == (AlgorithmSuite.__default.AES__256__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/DefaultCMM.dfy(51,4): " + Dafny.Sequence<char>.FromString("GetEncryptionMaterials returned the incorrect algorithm id"));
      }
      if (!((new BigInteger(((_21508_getEncMatOutput).dtor_encryptedDataKeys).Count)).Sign == 1)) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/DefaultCMM.dfy(53,4): " + Dafny.Sequence<char>.FromString("GetEncryptionMaterials didn't return any EDKs"));
      }
      if (!((AlgorithmSuite.ID.SignatureType((_21508_getEncMatOutput).dtor_algorithmSuiteID)).is_Some)) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/DefaultCMM.dfy(54,4): " + Dafny.Sequence<char>.FromString("GetEncryptionMaterials didn't return a signature algorithm"));
      }
      if (!(((_21508_getEncMatOutput).dtor_signingKey).is_Some)) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/DefaultCMM.dfy(55,4): " + Dafny.Sequence<char>.FromString("GetEncryptionMaterials didn't return a signing key"));
      }
      Materials.DecryptionMaterialsRequest _21510_decMatRequest;
      _21510_decMatRequest = @Materials.DecryptionMaterialsRequest.create((_21508_getEncMatOutput).dtor_algorithmSuiteID, (_21508_getEncMatOutput).dtor_encryptedDataKeys, (_21508_getEncMatOutput).dtor_encryptionContext);
      Materials.DecryptionMaterials _21511_decMatOutput = Materials.ValidDecryptionMaterials.Default();
      Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>> _21512_valueOrError2 = Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>.Default(Materials.ValidDecryptionMaterials.Default());
      Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>> _out261;
      _out261 = (_21506_cmm).DecryptMaterials(_21510_decMatRequest);
      _21512_valueOrError2 = _out261;
      if ((_21512_valueOrError2).IsFailure()) {
        res = (_21512_valueOrError2).PropagateFailure<_System.Tuple0>();
        return res;
      }
      _21511_decMatOutput = (_21512_valueOrError2).Extract();
      if (!(((_21511_decMatOutput).dtor_plaintextDataKey).is_Some)) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/DefaultCMM.dfy(60,4): " + Dafny.Sequence<char>.FromString("DecryptMaterials did not return a plaintext datakey"));
      }
      if (!(AlgorithmSuite.ID.ValidPlaintextDataKey((_21511_decMatOutput).dtor_algorithmSuiteID, ((_21511_decMatOutput).dtor_plaintextDataKey).dtor_value))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/DefaultCMM.dfy(61,4): " + Dafny.Sequence<char>.FromString("DecryptMaterials returned invalid plaintext datakey"));
      }
      if (!(((_21511_decMatOutput).dtor_verificationKey).is_Some)) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/DefaultCMM.dfy(62,4): " + Dafny.Sequence<char>.FromString("DecryptMaterials did not return a verification key"));
      }
      res = @Wrappers_Compile.Result<_System.Tuple0, Dafny.ISequence<char>>.create_Success(@_System.Tuple0.create());
      return res;
      return res;
    }
    [Xunit.Fact]
    public static Wrappers_Compile.Result<_System.Tuple0, Dafny.ISequence<char>> TestDefaultCMMWithAlgNoSig()
    {
      Wrappers_Compile.Result<_System.Tuple0, Dafny.ISequence<char>> res = Wrappers_Compile.Result<_System.Tuple0, Dafny.ISequence<char>>.Default(_System.Tuple0.Default());
      RawRSAKeyringDef.RawRSAKeyring _21513_keyring = default(RawRSAKeyringDef.RawRSAKeyring);
      Wrappers_Compile.Result<RawRSAKeyringDef.RawRSAKeyring, Dafny.ISequence<char>> _21514_valueOrError0 = Wrappers_Compile.Result<RawRSAKeyringDef.RawRSAKeyring, Dafny.ISequence<char>>.Default(default(RawRSAKeyringDef.RawRSAKeyring));
      Wrappers_Compile.Result<RawRSAKeyringDef.RawRSAKeyring, Dafny.ISequence<char>> _out262;
      _out262 = TestUtils.__default.MakeRSAKeyring();
      _21514_valueOrError0 = _out262;
      if ((_21514_valueOrError0).IsFailure()) {
        res = (_21514_valueOrError0).PropagateFailure<_System.Tuple0>();
        return res;
      }
      _21513_keyring = (_21514_valueOrError0).Extract();
      DefaultCMMDef.DefaultCMM _21515_cmm;
      DefaultCMMDef.DefaultCMM _nw71 = new DefaultCMMDef.DefaultCMM();
      _nw71.OfKeyring(_21513_keyring);
      _21515_cmm = _nw71;
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _21516_encCtx;
      _21516_encCtx = Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.FromElements();
      Materials.EncryptionMaterials _21517_getEncMatOutput = Materials.ValidEncryptionMaterials.Default();
      Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>> _21518_valueOrError1 = Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>>.Default(Materials.ValidEncryptionMaterials.Default());
      Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>> _out263;
      _out263 = (_21515_cmm).GetEncryptionMaterials(@Materials.EncryptionMaterialsRequest.create(_21516_encCtx, @Wrappers_Compile.Option<ushort>.create_Some(AlgorithmSuite.__default.AES__256__GCM__IV12__TAG16__HKDF__SHA256__NO__SIGNATURE__ALG), @Wrappers_Compile.Option<BigInteger>.create_None()));
      _21518_valueOrError1 = _out263;
      if ((_21518_valueOrError1).IsFailure()) {
        res = (_21518_valueOrError1).PropagateFailure<_System.Tuple0>();
        return res;
      }
      _21517_getEncMatOutput = (_21518_valueOrError1).Extract();
      if (!(((_21517_getEncMatOutput).dtor_algorithmSuiteID) == (AlgorithmSuite.__default.AES__256__GCM__IV12__TAG16__HKDF__SHA256__NO__SIGNATURE__ALG))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/DefaultCMM.dfy(74,4): " + Dafny.Sequence<char>.FromString("GetEncryptionMaterials returned the incorrect algorithm id"));
      }
      if (!((new BigInteger(((_21517_getEncMatOutput).dtor_encryptedDataKeys).Count)).Sign == 1)) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/DefaultCMM.dfy(76,4): " + Dafny.Sequence<char>.FromString("GetEncryptionMaterials didn't return any EDKs"));
      }
      if (!((AlgorithmSuite.ID.SignatureType((_21517_getEncMatOutput).dtor_algorithmSuiteID)).is_None)) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/DefaultCMM.dfy(77,4): " + Dafny.Sequence<char>.FromString("GetEncryptionMaterials returned a signature algorithm when it shouldn't have"));
      }
      if (!(((_21517_getEncMatOutput).dtor_signingKey).is_None)) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/DefaultCMM.dfy(78,4): " + Dafny.Sequence<char>.FromString("GetEncryptionMaterials returned a signing key when it shouldn't have"));
      }
      Materials.DecryptionMaterialsRequest _21519_decMatRequest;
      _21519_decMatRequest = @Materials.DecryptionMaterialsRequest.create((_21517_getEncMatOutput).dtor_algorithmSuiteID, (_21517_getEncMatOutput).dtor_encryptedDataKeys, (_21517_getEncMatOutput).dtor_encryptionContext);
      Materials.DecryptionMaterials _21520_decMatOutput = Materials.ValidDecryptionMaterials.Default();
      Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>> _21521_valueOrError2 = Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>.Default(Materials.ValidDecryptionMaterials.Default());
      Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>> _out264;
      _out264 = (_21515_cmm).DecryptMaterials(_21519_decMatRequest);
      _21521_valueOrError2 = _out264;
      if ((_21521_valueOrError2).IsFailure()) {
        res = (_21521_valueOrError2).PropagateFailure<_System.Tuple0>();
        return res;
      }
      _21520_decMatOutput = (_21521_valueOrError2).Extract();
      if (!(((_21520_decMatOutput).dtor_plaintextDataKey).is_Some)) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/DefaultCMM.dfy(83,4): " + Dafny.Sequence<char>.FromString("DecryptMaterials did not return a plaintext datakey"));
      }
      if (!(AlgorithmSuite.ID.ValidPlaintextDataKey((_21520_decMatOutput).dtor_algorithmSuiteID, ((_21520_decMatOutput).dtor_plaintextDataKey).dtor_value))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/DefaultCMM.dfy(84,4): " + Dafny.Sequence<char>.FromString("DecryptMaterials returned invalid plaintext datakey"));
      }
      if (!(((_21520_decMatOutput).dtor_verificationKey).is_None)) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/DefaultCMM.dfy(85,4): " + Dafny.Sequence<char>.FromString("DecryptMaterials erroneously returned a verification key"));
      }
      res = @Wrappers_Compile.Result<_System.Tuple0, Dafny.ISequence<char>>.create_Success(@_System.Tuple0.create());
      return res;
      return res;
    }
    [Xunit.Fact]
    public static Wrappers_Compile.Result<_System.Tuple0, Dafny.ISequence<char>> TestDefaultCMMRejectsBadEncCtxReservedValue()
    {
      Wrappers_Compile.Result<_System.Tuple0, Dafny.ISequence<char>> res = Wrappers_Compile.Result<_System.Tuple0, Dafny.ISequence<char>>.Default(_System.Tuple0.Default());
      RawRSAKeyringDef.RawRSAKeyring _21522_keyring = default(RawRSAKeyringDef.RawRSAKeyring);
      Wrappers_Compile.Result<RawRSAKeyringDef.RawRSAKeyring, Dafny.ISequence<char>> _21523_valueOrError0 = Wrappers_Compile.Result<RawRSAKeyringDef.RawRSAKeyring, Dafny.ISequence<char>>.Default(default(RawRSAKeyringDef.RawRSAKeyring));
      Wrappers_Compile.Result<RawRSAKeyringDef.RawRSAKeyring, Dafny.ISequence<char>> _out265;
      _out265 = TestUtils.__default.MakeRSAKeyring();
      _21523_valueOrError0 = _out265;
      if ((_21523_valueOrError0).IsFailure()) {
        res = (_21523_valueOrError0).PropagateFailure<_System.Tuple0>();
        return res;
      }
      _21522_keyring = (_21523_valueOrError0).Extract();
      DefaultCMMDef.DefaultCMM _21524_cmm;
      DefaultCMMDef.DefaultCMM _nw72 = new DefaultCMMDef.DefaultCMM();
      _nw72.OfKeyring(_21522_keyring);
      _21524_cmm = _nw72;
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _21525_encCtx;
      _21525_encCtx = Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.FromElements();
      _21525_encCtx = Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Update(_21525_encCtx,Materials.__default.EC__PUBLIC__KEY__FIELD, Dafny.Sequence<byte>.FromElements(0));
      Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>> _21526_shouldBeFail;
      Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>> _out266;
      _out266 = (_21524_cmm).GetEncryptionMaterials(@Materials.EncryptionMaterialsRequest.create(_21525_encCtx, @Wrappers_Compile.Option<ushort>.create_None(), @Wrappers_Compile.Option<BigInteger>.create_None()));
      _21526_shouldBeFail = _out266;
      if (!((_21526_shouldBeFail).is_Failure)) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/DefaultCMM.dfy(97,4): " + Dafny.Sequence<char>.FromString("GetEncryptionMaterials returned Success with bad input"));
      }
      res = @Wrappers_Compile.Result<_System.Tuple0, Dafny.ISequence<char>>.create_Success(@_System.Tuple0.create());
      return res;
      return res;
    }
    [Xunit.Fact]
    public static void TestDefaultCMMRejectsBadEncCtxTooBig()
    {
      RawRSAKeyringDef.RawRSAKeyring _21527_keyring = default(RawRSAKeyringDef.RawRSAKeyring);
      Wrappers_Compile.Result<RawRSAKeyringDef.RawRSAKeyring, Dafny.ISequence<char>> _21528_valueOrError0 = Wrappers_Compile.Result<RawRSAKeyringDef.RawRSAKeyring, Dafny.ISequence<char>>.Default(default(RawRSAKeyringDef.RawRSAKeyring));
      Wrappers_Compile.Result<RawRSAKeyringDef.RawRSAKeyring, Dafny.ISequence<char>> _out267;
      _out267 = TestUtils.__default.MakeRSAKeyring();
      _21528_valueOrError0 = _out267;
      if (!(!((_21528_valueOrError0).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/DefaultCMM.dfy(102,16): " + _21528_valueOrError0);
      }
      _21527_keyring = (_21528_valueOrError0).Extract();
      DefaultCMMDef.DefaultCMM _21529_cmm;
      DefaultCMMDef.DefaultCMM _nw73 = new DefaultCMMDef.DefaultCMM();
      _nw73.OfKeyring(_21527_keyring);
      _21529_cmm = _nw73;
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _21530_encryptionContext;
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _out268;
      _out268 = TestUtils.__default.GenerateInvalidEncryptionContext();
      _21530_encryptionContext = _out268;
      Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>> _21531_shouldBeFail;
      Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>> _out269;
      _out269 = (_21529_cmm).GetEncryptionMaterials(@Materials.EncryptionMaterialsRequest.create(_21530_encryptionContext, @Wrappers_Compile.Option<ushort>.create_None(), @Wrappers_Compile.Option<BigInteger>.create_None()));
      _21531_shouldBeFail = _out269;
      if (!((_21531_shouldBeFail).is_Failure)) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/DefaultCMM.dfy(107,4): " + Dafny.Sequence<char>.FromString("GetEncryptionMaterials returned Success with bad input"));
      }
    }
  }
} // end of namespace DefaultCMMTests
namespace TestKeyrings_Compile {




  public partial class NoOpKeyring : KeyringDefs.Keyring {
    public NoOpKeyring() {
    }
    public void __ctor()
    {
    }
    public Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>> OnEncrypt(Materials.EncryptionMaterials materials)
    {
      Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>> res = Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>>.Default(Materials.ValidEncryptionMaterials.Default());
      res = @Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>>.create_Success(materials);
      return res;
      return res;
    }
    public Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>> OnDecrypt(Materials.DecryptionMaterials materials, Dafny.ISequence<Materials.EncryptedDataKey> encryptedDataKeys)
    {
      Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>> res = Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>.Default(Materials.ValidDecryptionMaterials.Default());
      if (((materials).dtor_plaintextDataKey).is_None) {
        res = @Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("No data key"));
        return res;
      }
      res = @Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>.create_Success(materials);
      return res;
      return res;
    }
  }

  public partial class AlwaysFailingKeyring : KeyringDefs.Keyring {
    public AlwaysFailingKeyring() {
    }
    public void __ctor()
    {
    }
    public Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>> OnEncrypt(Materials.EncryptionMaterials materials)
    {
      Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>> res = Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>>.Default(Materials.ValidEncryptionMaterials.Default());
      res = @Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Surprise, AlwaysFailingKeyring always fails!"));
      return res;
      return res;
    }
    public Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>> OnDecrypt(Materials.DecryptionMaterials materials, Dafny.ISequence<Materials.EncryptedDataKey> encryptedDataKeys)
    {
      Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>> res = Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>.Default(Materials.ValidDecryptionMaterials.Default());
      if (((materials).dtor_plaintextDataKey).is_Some) {
        res = @Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>.create_Success(materials);
        return res;
      }
      res = @Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Surprise, AlwaysFailingKeyring always fails!"));
      return res;
      return res;
    }
  }

} // end of namespace TestKeyrings_Compile
namespace TestMultiKeying_Compile {












  public partial class __default {
    [Xunit.Fact]
    public static void TestOnEncryptOnDecryptWithGenerator()
    {
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _21532_encryptionContext;
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _out270;
      _out270 = TestUtils.__default.SmallEncryptionContext(@TestUtils.SmallEncryptionContextVariation.create_A());
      _21532_encryptionContext = _out270;
      Dafny.ISequence<byte> _21533_child1Namespace;
      Dafny.ISequence<byte> _21534_child1Name;
      Dafny.ISequence<byte> _out271;
      Dafny.ISequence<byte> _out272;
      TestUtils.__default.NamespaceAndName(BigInteger.One, out _out271, out _out272);
      _21533_child1Namespace = _out271;
      _21534_child1Name = _out272;
      Dafny.ISequence<byte> _21535_child2namespace;
      Dafny.ISequence<byte> _21536_child2Name;
      Dafny.ISequence<byte> _out273;
      Dafny.ISequence<byte> _out274;
      TestUtils.__default.NamespaceAndName(new BigInteger(2), out _out273, out _out274);
      _21535_child2namespace = _out273;
      _21536_child2Name = _out274;
      RawAESKeyringDef.RawAESKeyring _21537_child1Keyring;
      RawAESKeyringDef.RawAESKeyring _nw74 = new RawAESKeyringDef.RawAESKeyring();
      _nw74.__ctor(_21533_child1Namespace, _21534_child1Name, ((System.Func<Dafny.ISequence<byte>>) (() => {
        BigInteger dim14 = new BigInteger(32);
        var arr14 = new byte[Dafny.Helpers.ToIntChecked(dim14,"C# array size must not be larger than max 32-bit int")];
        for (int i14 = 0; i14 < dim14; i14++) {
          var _21538_i = (BigInteger) i14;
          arr14[(int)(_21538_i)] = 0;
        }
        return Dafny.Sequence<byte>.FromArray(arr14);
      }))(), EncryptionSuites.__default.AES__GCM__256);
      _21537_child1Keyring = _nw74;
      RawAESKeyringDef.RawAESKeyring _21539_child2Keyring;
      RawAESKeyringDef.RawAESKeyring _nw75 = new RawAESKeyringDef.RawAESKeyring();
      _nw75.__ctor(_21535_child2namespace, _21536_child2Name, ((System.Func<Dafny.ISequence<byte>>) (() => {
        BigInteger dim15 = new BigInteger(32);
        var arr15 = new byte[Dafny.Helpers.ToIntChecked(dim15,"C# array size must not be larger than max 32-bit int")];
        for (int i15 = 0; i15 < dim15; i15++) {
          var _21540_i = (BigInteger) i15;
          arr15[(int)(_21540_i)] = 0;
        }
        return Dafny.Sequence<byte>.FromArray(arr15);
      }))(), EncryptionSuites.__default.AES__GCM__256);
      _21539_child2Keyring = _nw75;
      MultiKeyringDef.MultiKeyring _21541_multiKeyring;
      MultiKeyringDef.MultiKeyring _nw76 = new MultiKeyringDef.MultiKeyring();
      _nw76.__ctor(_21537_child1Keyring, Dafny.Sequence<RawAESKeyringDef.RawAESKeyring>.FromElements(_21539_child2Keyring));
      _21541_multiKeyring = _nw76;
      ushort _21542_algorithmSuiteID;
      _21542_algorithmSuiteID = AlgorithmSuite.__default.AES__256__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384;
      Dafny.ISequence<byte> _21543_signingKey;
      _21543_signingKey = ((System.Func<Dafny.ISequence<byte>>) (() => {
        BigInteger dim16 = new BigInteger(32);
        var arr16 = new byte[Dafny.Helpers.ToIntChecked(dim16,"C# array size must not be larger than max 32-bit int")];
        for (int i16 = 0; i16 < dim16; i16++) {
          var _21544_i = (BigInteger) i16;
          arr16[(int)(_21544_i)] = 0;
        }
        return Dafny.Sequence<byte>.FromArray(arr16);
      }))();
      Materials.EncryptionMaterials _21545_encryptionMaterialsIn;
      _21545_encryptionMaterialsIn = Materials.EncryptionMaterials.WithoutDataKeys(_21532_encryptionContext, _21542_algorithmSuiteID, @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(_21543_signingKey));
      Materials.EncryptionMaterials _21546_encryptionMaterialsOut = Materials.ValidEncryptionMaterials.Default();
      Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>> _21547_valueOrError0 = Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>>.Default(Materials.ValidEncryptionMaterials.Default());
      Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>> _out275;
      _out275 = (_21541_multiKeyring).OnEncrypt(_21545_encryptionMaterialsIn);
      _21547_valueOrError0 = _out275;
      if (!(!((_21547_valueOrError0).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Keyring/MultiKeyring.dfy(43,31): " + _21547_valueOrError0);
      }
      _21546_encryptionMaterialsOut = (_21547_valueOrError0).Extract();
      if (!((new BigInteger(((_21546_encryptionMaterialsOut).dtor_encryptedDataKeys).Count)) == (new BigInteger(2)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Keyring/MultiKeyring.dfy(45,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      Wrappers_Compile.Option<Dafny.ISequence<byte>> _21548_pdk;
      _21548_pdk = (_21546_encryptionMaterialsOut).dtor_plaintextDataKey;
      Materials.EncryptedDataKey _21549_edk1;
      _21549_edk1 = ((_21546_encryptionMaterialsOut).dtor_encryptedDataKeys).Select(BigInteger.Zero);
      Materials.EncryptedDataKey _21550_edk2;
      _21550_edk2 = ((_21546_encryptionMaterialsOut).dtor_encryptedDataKeys).Select(BigInteger.One);
      Dafny.ISequence<byte> _21551_verificationKey;
      _21551_verificationKey = ((System.Func<Dafny.ISequence<byte>>) (() => {
        BigInteger dim17 = new BigInteger(32);
        var arr17 = new byte[Dafny.Helpers.ToIntChecked(dim17,"C# array size must not be larger than max 32-bit int")];
        for (int i17 = 0; i17 < dim17; i17++) {
          var _21552_i = (BigInteger) i17;
          arr17[(int)(_21552_i)] = 0;
        }
        return Dafny.Sequence<byte>.FromArray(arr17);
      }))();
      Materials.DecryptionMaterials _21553_decryptionMaterialsIn;
      _21553_decryptionMaterialsIn = Materials.DecryptionMaterials.WithoutPlaintextDataKey(_21532_encryptionContext, _21542_algorithmSuiteID, @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(_21551_verificationKey));
      Materials.DecryptionMaterials _21554_decryptionMaterialsOut = Materials.ValidDecryptionMaterials.Default();
      Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>> _21555_valueOrError1 = Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>.Default(Materials.ValidDecryptionMaterials.Default());
      Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>> _out276;
      _out276 = (_21541_multiKeyring).OnDecrypt(_21553_decryptionMaterialsIn, Dafny.Sequence<Materials.EncryptedDataKey>.FromElements(_21549_edk1));
      _21555_valueOrError1 = _out276;
      if (!(!((_21555_valueOrError1).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Keyring/MultiKeyring.dfy(54,31): " + _21555_valueOrError1);
      }
      _21554_decryptionMaterialsOut = (_21555_valueOrError1).Extract();
      if (!(object.Equals((_21554_decryptionMaterialsOut).dtor_plaintextDataKey, _21548_pdk))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Keyring/MultiKeyring.dfy(56,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>> _21556_valueOrError2 = Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>.Default(Materials.ValidDecryptionMaterials.Default());
      Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>> _out277;
      _out277 = (_21541_multiKeyring).OnDecrypt(_21553_decryptionMaterialsIn, Dafny.Sequence<Materials.EncryptedDataKey>.FromElements(_21550_edk2));
      _21556_valueOrError2 = _out277;
      if (!(!((_21556_valueOrError2).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Keyring/MultiKeyring.dfy(59,27): " + _21556_valueOrError2);
      }
      _21554_decryptionMaterialsOut = (_21556_valueOrError2).Extract();
      if (!(object.Equals((_21554_decryptionMaterialsOut).dtor_plaintextDataKey, _21548_pdk))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Keyring/MultiKeyring.dfy(61,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestOnEncryptOnDecryptWithoutGenerator()
    {
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _21557_encryptionContext;
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _out278;
      _out278 = TestUtils.__default.SmallEncryptionContext(@TestUtils.SmallEncryptionContextVariation.create_A());
      _21557_encryptionContext = _out278;
      Dafny.ISequence<byte> _21558_child1Namespace;
      Dafny.ISequence<byte> _21559_child1Name;
      Dafny.ISequence<byte> _out279;
      Dafny.ISequence<byte> _out280;
      TestUtils.__default.NamespaceAndName(BigInteger.One, out _out279, out _out280);
      _21558_child1Namespace = _out279;
      _21559_child1Name = _out280;
      Dafny.ISequence<byte> _21560_child2namespace;
      Dafny.ISequence<byte> _21561_child2Name;
      Dafny.ISequence<byte> _out281;
      Dafny.ISequence<byte> _out282;
      TestUtils.__default.NamespaceAndName(new BigInteger(2), out _out281, out _out282);
      _21560_child2namespace = _out281;
      _21561_child2Name = _out282;
      RawAESKeyringDef.RawAESKeyring _21562_child1Keyring;
      RawAESKeyringDef.RawAESKeyring _nw77 = new RawAESKeyringDef.RawAESKeyring();
      _nw77.__ctor(_21558_child1Namespace, _21559_child1Name, ((System.Func<Dafny.ISequence<byte>>) (() => {
        BigInteger dim18 = new BigInteger(32);
        var arr18 = new byte[Dafny.Helpers.ToIntChecked(dim18,"C# array size must not be larger than max 32-bit int")];
        for (int i18 = 0; i18 < dim18; i18++) {
          var _21563_i = (BigInteger) i18;
          arr18[(int)(_21563_i)] = 0;
        }
        return Dafny.Sequence<byte>.FromArray(arr18);
      }))(), EncryptionSuites.__default.AES__GCM__256);
      _21562_child1Keyring = _nw77;
      RawAESKeyringDef.RawAESKeyring _21564_child2Keyring;
      RawAESKeyringDef.RawAESKeyring _nw78 = new RawAESKeyringDef.RawAESKeyring();
      _nw78.__ctor(_21560_child2namespace, _21561_child2Name, ((System.Func<Dafny.ISequence<byte>>) (() => {
        BigInteger dim19 = new BigInteger(32);
        var arr19 = new byte[Dafny.Helpers.ToIntChecked(dim19,"C# array size must not be larger than max 32-bit int")];
        for (int i19 = 0; i19 < dim19; i19++) {
          var _21565_i = (BigInteger) i19;
          arr19[(int)(_21565_i)] = 0;
        }
        return Dafny.Sequence<byte>.FromArray(arr19);
      }))(), EncryptionSuites.__default.AES__GCM__256);
      _21564_child2Keyring = _nw78;
      ushort _21566_algorithmSuiteID;
      _21566_algorithmSuiteID = AlgorithmSuite.__default.AES__256__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384;
      Dafny.ISequence<byte> _21567_signingKey;
      _21567_signingKey = ((System.Func<Dafny.ISequence<byte>>) (() => {
        BigInteger dim20 = new BigInteger(32);
        var arr20 = new byte[Dafny.Helpers.ToIntChecked(dim20,"C# array size must not be larger than max 32-bit int")];
        for (int i20 = 0; i20 < dim20; i20++) {
          var _21568_i = (BigInteger) i20;
          arr20[(int)(_21568_i)] = 0;
        }
        return Dafny.Sequence<byte>.FromArray(arr20);
      }))();
      MultiKeyringDef.MultiKeyring _21569_multiKeyring;
      MultiKeyringDef.MultiKeyring _nw79 = new MultiKeyringDef.MultiKeyring();
      _nw79.__ctor((KeyringDefs.Keyring)null, Dafny.Sequence<RawAESKeyringDef.RawAESKeyring>.FromElements(_21562_child1Keyring, _21564_child2Keyring));
      _21569_multiKeyring = _nw79;
      Dafny.ISequence<byte> _21570_pdk;
      _21570_pdk = ((System.Func<Dafny.ISequence<byte>>) (() => {
        BigInteger dim21 = new BigInteger(32);
        var arr21 = new byte[Dafny.Helpers.ToIntChecked(dim21,"C# array size must not be larger than max 32-bit int")];
        for (int i21 = 0; i21 < dim21; i21++) {
          var _21571_i = (BigInteger) i21;
          arr21[(int)(_21571_i)] = 0;
        }
        return Dafny.Sequence<byte>.FromArray(arr21);
      }))();
      Materials.EncryptionMaterials _21572_encryptionMaterialsIn;
      _21572_encryptionMaterialsIn = (Materials.EncryptionMaterials.WithoutDataKeys(_21557_encryptionContext, _21566_algorithmSuiteID, @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(_21567_signingKey))).WithKeys(@Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(_21570_pdk), Dafny.Sequence<Materials.EncryptedDataKey>.FromElements());
      Materials.EncryptionMaterials _21573_encryptionMaterialsOut = Materials.ValidEncryptionMaterials.Default();
      Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>> _21574_valueOrError0 = Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>>.Default(Materials.ValidEncryptionMaterials.Default());
      Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>> _out283;
      _out283 = (_21569_multiKeyring).OnEncrypt(_21572_encryptionMaterialsIn);
      _21574_valueOrError0 = _out283;
      if (!(!((_21574_valueOrError0).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Keyring/MultiKeyring.dfy(82,31): " + _21574_valueOrError0);
      }
      _21573_encryptionMaterialsOut = (_21574_valueOrError0).Extract();
      if (!(object.Equals((_21573_encryptionMaterialsOut).dtor_plaintextDataKey, @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(_21570_pdk)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Keyring/MultiKeyring.dfy(84,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!((new BigInteger(((_21573_encryptionMaterialsOut).dtor_encryptedDataKeys).Count)) == (new BigInteger(2)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Keyring/MultiKeyring.dfy(86,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      Materials.EncryptedDataKey _21575_edk1;
      _21575_edk1 = ((_21573_encryptionMaterialsOut).dtor_encryptedDataKeys).Select(BigInteger.Zero);
      Materials.EncryptedDataKey _21576_edk2;
      _21576_edk2 = ((_21573_encryptionMaterialsOut).dtor_encryptedDataKeys).Select(BigInteger.One);
      Dafny.ISequence<byte> _21577_verificationKey;
      _21577_verificationKey = ((System.Func<Dafny.ISequence<byte>>) (() => {
        BigInteger dim22 = new BigInteger(32);
        var arr22 = new byte[Dafny.Helpers.ToIntChecked(dim22,"C# array size must not be larger than max 32-bit int")];
        for (int i22 = 0; i22 < dim22; i22++) {
          var _21578_i = (BigInteger) i22;
          arr22[(int)(_21578_i)] = 0;
        }
        return Dafny.Sequence<byte>.FromArray(arr22);
      }))();
      Materials.DecryptionMaterials _21579_materialsIn;
      _21579_materialsIn = Materials.DecryptionMaterials.WithoutPlaintextDataKey(_21557_encryptionContext, _21566_algorithmSuiteID, @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(_21577_verificationKey));
      Materials.DecryptionMaterials _21580_materialsOut = Materials.ValidDecryptionMaterials.Default();
      Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>> _21581_valueOrError1 = Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>.Default(Materials.ValidDecryptionMaterials.Default());
      Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>> _out284;
      _out284 = (_21569_multiKeyring).OnDecrypt(_21579_materialsIn, Dafny.Sequence<Materials.EncryptedDataKey>.FromElements(_21575_edk1));
      _21581_valueOrError1 = _out284;
      if (!(!((_21581_valueOrError1).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Keyring/MultiKeyring.dfy(94,21): " + _21581_valueOrError1);
      }
      _21580_materialsOut = (_21581_valueOrError1).Extract();
      if (!(object.Equals((_21580_materialsOut).dtor_plaintextDataKey, @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(_21570_pdk)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Keyring/MultiKeyring.dfy(96,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      _21579_materialsIn = Materials.DecryptionMaterials.WithoutPlaintextDataKey(_21557_encryptionContext, _21566_algorithmSuiteID, @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(_21577_verificationKey));
      Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>> _21582_valueOrError2 = Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>.Default(Materials.ValidDecryptionMaterials.Default());
      Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>> _out285;
      _out285 = (_21569_multiKeyring).OnDecrypt(_21579_materialsIn, Dafny.Sequence<Materials.EncryptedDataKey>.FromElements(_21576_edk2));
      _21582_valueOrError2 = _out285;
      if (!(!((_21582_valueOrError2).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Keyring/MultiKeyring.dfy(100,17): " + _21582_valueOrError2);
      }
      _21580_materialsOut = (_21582_valueOrError2).Extract();
      if (!(object.Equals((_21580_materialsOut).dtor_plaintextDataKey, @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(_21570_pdk)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Keyring/MultiKeyring.dfy(102,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestOnEncryptChildKeyringFailure()
    {
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _21583_encryptionContext;
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _out286;
      _out286 = TestUtils.__default.SmallEncryptionContext(@TestUtils.SmallEncryptionContextVariation.create_A());
      _21583_encryptionContext = _out286;
      Dafny.ISequence<byte> _21584_child1Namespace;
      Dafny.ISequence<byte> _21585_child1Name;
      Dafny.ISequence<byte> _out287;
      Dafny.ISequence<byte> _out288;
      TestUtils.__default.NamespaceAndName(BigInteger.One, out _out287, out _out288);
      _21584_child1Namespace = _out287;
      _21585_child1Name = _out288;
      RawAESKeyringDef.RawAESKeyring _21586_child1Keyring;
      RawAESKeyringDef.RawAESKeyring _nw80 = new RawAESKeyringDef.RawAESKeyring();
      _nw80.__ctor(_21584_child1Namespace, _21585_child1Name, ((System.Func<Dafny.ISequence<byte>>) (() => {
        BigInteger dim23 = new BigInteger(32);
        var arr23 = new byte[Dafny.Helpers.ToIntChecked(dim23,"C# array size must not be larger than max 32-bit int")];
        for (int i23 = 0; i23 < dim23; i23++) {
          var _21587_i = (BigInteger) i23;
          arr23[(int)(_21587_i)] = 0;
        }
        return Dafny.Sequence<byte>.FromArray(arr23);
      }))(), EncryptionSuites.__default.AES__GCM__256);
      _21586_child1Keyring = _nw80;
      TestKeyrings_Compile.AlwaysFailingKeyring _21588_child2Keyring;
      TestKeyrings_Compile.AlwaysFailingKeyring _nw81 = new TestKeyrings_Compile.AlwaysFailingKeyring();
      _nw81.__ctor();
      _21588_child2Keyring = _nw81;
      MultiKeyringDef.MultiKeyring _21589_multiKeyring;
      MultiKeyringDef.MultiKeyring _nw82 = new MultiKeyringDef.MultiKeyring();
      _nw82.__ctor(_21586_child1Keyring, Dafny.Sequence<TestKeyrings_Compile.AlwaysFailingKeyring>.FromElements(_21588_child2Keyring));
      _21589_multiKeyring = _nw82;
      ushort _21590_algorithmSuiteID;
      _21590_algorithmSuiteID = AlgorithmSuite.__default.AES__256__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384;
      Dafny.ISequence<byte> _21591_signingKey;
      _21591_signingKey = ((System.Func<Dafny.ISequence<byte>>) (() => {
        BigInteger dim24 = new BigInteger(32);
        var arr24 = new byte[Dafny.Helpers.ToIntChecked(dim24,"C# array size must not be larger than max 32-bit int")];
        for (int i24 = 0; i24 < dim24; i24++) {
          var _21592_i = (BigInteger) i24;
          arr24[(int)(_21592_i)] = 0;
        }
        return Dafny.Sequence<byte>.FromArray(arr24);
      }))();
      Materials.EncryptionMaterials _21593_encryptionMaterialsIn;
      _21593_encryptionMaterialsIn = Materials.EncryptionMaterials.WithoutDataKeys(_21583_encryptionContext, _21590_algorithmSuiteID, @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(_21591_signingKey));
      Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>> _21594_encryptionMaterialsOut;
      Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>> _out289;
      _out289 = (_21589_multiKeyring).OnEncrypt(_21593_encryptionMaterialsIn);
      _21594_encryptionMaterialsOut = _out289;
      if (!((_21594_encryptionMaterialsOut).is_Failure)) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Keyring/MultiKeyring.dfy(118,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestOnDecryptNoChildDecryptsAndAtLeastOneFails()
    {
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _21595_encryptionContext;
      _21595_encryptionContext = Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.FromElements();
      ushort _21596_algorithmSuiteID;
      _21596_algorithmSuiteID = AlgorithmSuite.__default.AES__256__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384;
      Materials.EncryptedDataKey _21597_edk;
      _21597_edk = Materials.EncryptedDataKey.ValidWitness();
      Dafny.ISequence<byte> _21598_verificationKey;
      _21598_verificationKey = ((System.Func<Dafny.ISequence<byte>>) (() => {
        BigInteger dim25 = new BigInteger(32);
        var arr25 = new byte[Dafny.Helpers.ToIntChecked(dim25,"C# array size must not be larger than max 32-bit int")];
        for (int i25 = 0; i25 < dim25; i25++) {
          var _21599_i = (BigInteger) i25;
          arr25[(int)(_21599_i)] = 0;
        }
        return Dafny.Sequence<byte>.FromArray(arr25);
      }))();
      TestKeyrings_Compile.AlwaysFailingKeyring _21600_childKeyring1;
      TestKeyrings_Compile.AlwaysFailingKeyring _nw83 = new TestKeyrings_Compile.AlwaysFailingKeyring();
      _nw83.__ctor();
      _21600_childKeyring1 = _nw83;
      TestKeyrings_Compile.NoOpKeyring _21601_childKeyring2;
      TestKeyrings_Compile.NoOpKeyring _nw84 = new TestKeyrings_Compile.NoOpKeyring();
      _nw84.__ctor();
      _21601_childKeyring2 = _nw84;
      MultiKeyringDef.MultiKeyring _21602_multiKeyring;
      MultiKeyringDef.MultiKeyring _nw85 = new MultiKeyringDef.MultiKeyring();
      _nw85.__ctor(_21601_childKeyring2, Dafny.Sequence<KeyringDefs.Keyring>.FromElements(_21600_childKeyring1, _21601_childKeyring2));
      _21602_multiKeyring = _nw85;
      Materials.DecryptionMaterials _21603_decryptionMaterialsIn;
      _21603_decryptionMaterialsIn = Materials.DecryptionMaterials.WithoutPlaintextDataKey(_21595_encryptionContext, _21596_algorithmSuiteID, @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(_21598_verificationKey));
      Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>> _21604_decryptionMaterialsOut;
      Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>> _out290;
      _out290 = (_21602_multiKeyring).OnDecrypt(_21603_decryptionMaterialsIn, Dafny.Sequence<Materials.EncryptedDataKey>.FromElements(_21597_edk));
      _21604_decryptionMaterialsOut = _out290;
      if (!((_21604_decryptionMaterialsOut).is_Failure)) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Keyring/MultiKeyring.dfy(133,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestOnDecryptAllChildKeyringsDontDecrypt()
    {
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _21605_encryptionContext;
      _21605_encryptionContext = Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.FromElements();
      ushort _21606_algorithmSuiteID;
      _21606_algorithmSuiteID = AlgorithmSuite.__default.AES__256__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384;
      Materials.EncryptedDataKey _21607_edk;
      _21607_edk = Materials.EncryptedDataKey.ValidWitness();
      Dafny.ISequence<byte> _21608_verificationKey;
      _21608_verificationKey = ((System.Func<Dafny.ISequence<byte>>) (() => {
        BigInteger dim26 = new BigInteger(32);
        var arr26 = new byte[Dafny.Helpers.ToIntChecked(dim26,"C# array size must not be larger than max 32-bit int")];
        for (int i26 = 0; i26 < dim26; i26++) {
          var _21609_i = (BigInteger) i26;
          arr26[(int)(_21609_i)] = 0;
        }
        return Dafny.Sequence<byte>.FromArray(arr26);
      }))();
      TestKeyrings_Compile.NoOpKeyring _21610_childKeyring;
      TestKeyrings_Compile.NoOpKeyring _nw86 = new TestKeyrings_Compile.NoOpKeyring();
      _nw86.__ctor();
      _21610_childKeyring = _nw86;
      MultiKeyringDef.MultiKeyring _21611_multiKeyring;
      MultiKeyringDef.MultiKeyring _nw87 = new MultiKeyringDef.MultiKeyring();
      _nw87.__ctor((KeyringDefs.Keyring)null, Dafny.Sequence<TestKeyrings_Compile.NoOpKeyring>.FromElements(_21610_childKeyring, _21610_childKeyring));
      _21611_multiKeyring = _nw87;
      Materials.DecryptionMaterials _21612_decryptionMaterialsIn;
      _21612_decryptionMaterialsIn = Materials.DecryptionMaterials.WithoutPlaintextDataKey(_21605_encryptionContext, _21606_algorithmSuiteID, @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(_21608_verificationKey));
      Materials.DecryptionMaterials _21613_decryptionMaterialsOut = Materials.ValidDecryptionMaterials.Default();
      Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>> _21614_valueOrError0 = Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>.Default(Materials.ValidDecryptionMaterials.Default());
      Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>> _out291;
      _out291 = (_21611_multiKeyring).OnDecrypt(_21612_decryptionMaterialsIn, Dafny.Sequence<Materials.EncryptedDataKey>.FromElements(_21607_edk));
      _21614_valueOrError0 = _out291;
      if (!(!((_21614_valueOrError0).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Keyring/MultiKeyring.dfy(146,31): " + _21614_valueOrError0);
      }
      _21613_decryptionMaterialsOut = (_21614_valueOrError0).Extract();
      if (!(((_21613_decryptionMaterialsOut).dtor_plaintextDataKey).is_None)) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Keyring/MultiKeyring.dfy(147,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
  }
} // end of namespace TestMultiKeying_Compile
namespace TestAESKeyring_Compile {












  public partial class __default {
    [Xunit.Fact]
    public static void TestOnEncryptOnDecryptGenerateDataKey()
    {
      Dafny.ISequence<byte> _21615_namespace;
      Dafny.ISequence<byte> _21616_name;
      Dafny.ISequence<byte> _out292;
      Dafny.ISequence<byte> _out293;
      TestUtils.__default.NamespaceAndName(BigInteger.Zero, out _out292, out _out293);
      _21615_namespace = _out292;
      _21616_name = _out293;
      RawAESKeyringDef.RawAESKeyring _21617_rawAESKeyring;
      RawAESKeyringDef.RawAESKeyring _nw88 = new RawAESKeyringDef.RawAESKeyring();
      _nw88.__ctor(_21615_namespace, _21616_name, ((System.Func<Dafny.ISequence<byte>>) (() => {
        BigInteger dim27 = new BigInteger(32);
        var arr27 = new byte[Dafny.Helpers.ToIntChecked(dim27,"C# array size must not be larger than max 32-bit int")];
        for (int i27 = 0; i27 < dim27; i27++) {
          var _21618_i = (BigInteger) i27;
          arr27[(int)(_21618_i)] = 0;
        }
        return Dafny.Sequence<byte>.FromArray(arr27);
      }))(), EncryptionSuites.__default.AES__GCM__256);
      _21617_rawAESKeyring = _nw88;
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _21619_encryptionContext;
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _out294;
      _out294 = TestUtils.__default.SmallEncryptionContext(@TestUtils.SmallEncryptionContextVariation.create_A());
      _21619_encryptionContext = _out294;
      TestUtils.__default.ExpectSerializableEncryptionContext(_21619_encryptionContext);
      ushort _21620_wrappingAlgorithmID;
      _21620_wrappingAlgorithmID = AlgorithmSuite.__default.AES__256__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384;
      Dafny.ISequence<byte> _21621_signingKey;
      _21621_signingKey = ((System.Func<Dafny.ISequence<byte>>) (() => {
        BigInteger dim28 = new BigInteger(32);
        var arr28 = new byte[Dafny.Helpers.ToIntChecked(dim28,"C# array size must not be larger than max 32-bit int")];
        for (int i28 = 0; i28 < dim28; i28++) {
          var _21622_i = (BigInteger) i28;
          arr28[(int)(_21622_i)] = 0;
        }
        return Dafny.Sequence<byte>.FromArray(arr28);
      }))();
      Materials.EncryptionMaterials _21623_encryptionMaterialsIn;
      _21623_encryptionMaterialsIn = Materials.EncryptionMaterials.WithoutDataKeys(_21619_encryptionContext, _21620_wrappingAlgorithmID, @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(_21621_signingKey));
      Materials.EncryptionMaterials _21624_encryptionMaterialsOut = Materials.ValidEncryptionMaterials.Default();
      Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>> _21625_valueOrError0 = Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>>.Default(Materials.ValidEncryptionMaterials.Default());
      Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>> _out295;
      _out295 = (_21617_rawAESKeyring).OnEncrypt(_21623_encryptionMaterialsIn);
      _21625_valueOrError0 = _out295;
      if (!(!((_21625_valueOrError0).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Keyring/RawAESKeyring.dfy(39,31): " + _21625_valueOrError0);
      }
      _21624_encryptionMaterialsOut = (_21625_valueOrError0).Extract();
      if (!((new BigInteger(((_21624_encryptionMaterialsOut).dtor_encryptedDataKeys).Count)) == (BigInteger.One))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Keyring/RawAESKeyring.dfy(40,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      Wrappers_Compile.Option<Dafny.ISequence<byte>> _21626_pdk;
      _21626_pdk = (_21624_encryptionMaterialsOut).dtor_plaintextDataKey;
      Materials.EncryptedDataKey _21627_edk;
      _21627_edk = ((_21624_encryptionMaterialsOut).dtor_encryptedDataKeys).Select(BigInteger.Zero);
      Dafny.ISequence<byte> _21628_verificationKey;
      _21628_verificationKey = ((System.Func<Dafny.ISequence<byte>>) (() => {
        BigInteger dim29 = new BigInteger(32);
        var arr29 = new byte[Dafny.Helpers.ToIntChecked(dim29,"C# array size must not be larger than max 32-bit int")];
        for (int i29 = 0; i29 < dim29; i29++) {
          var _21629_i = (BigInteger) i29;
          arr29[(int)(_21629_i)] = 0;
        }
        return Dafny.Sequence<byte>.FromArray(arr29);
      }))();
      Materials.DecryptionMaterials _21630_decryptionMaterialsIn;
      _21630_decryptionMaterialsIn = Materials.DecryptionMaterials.WithoutPlaintextDataKey(_21619_encryptionContext, _21620_wrappingAlgorithmID, @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(_21628_verificationKey));
      Materials.DecryptionMaterials _21631_decryptionMaterialsOut = Materials.ValidDecryptionMaterials.Default();
      Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>> _21632_valueOrError1 = Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>.Default(Materials.ValidDecryptionMaterials.Default());
      Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>> _out296;
      _out296 = (_21617_rawAESKeyring).OnDecrypt(_21630_decryptionMaterialsIn, Dafny.Sequence<Materials.EncryptedDataKey>.FromElements(_21627_edk));
      _21632_valueOrError1 = _out296;
      if (!(!((_21632_valueOrError1).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Keyring/RawAESKeyring.dfy(47,31): " + _21632_valueOrError1);
      }
      _21631_decryptionMaterialsOut = (_21632_valueOrError1).Extract();
      if (!(object.Equals((_21624_encryptionMaterialsOut).dtor_plaintextDataKey, _21626_pdk))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Keyring/RawAESKeyring.dfy(48,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestOnEncryptOnDecryptSuppliedDataKey()
    {
      Dafny.ISequence<byte> _21633_namespace;
      Dafny.ISequence<byte> _21634_name;
      Dafny.ISequence<byte> _out297;
      Dafny.ISequence<byte> _out298;
      TestUtils.__default.NamespaceAndName(BigInteger.Zero, out _out297, out _out298);
      _21633_namespace = _out297;
      _21634_name = _out298;
      RawAESKeyringDef.RawAESKeyring _21635_rawAESKeyring;
      RawAESKeyringDef.RawAESKeyring _nw89 = new RawAESKeyringDef.RawAESKeyring();
      _nw89.__ctor(_21633_namespace, _21634_name, ((System.Func<Dafny.ISequence<byte>>) (() => {
        BigInteger dim30 = new BigInteger(32);
        var arr30 = new byte[Dafny.Helpers.ToIntChecked(dim30,"C# array size must not be larger than max 32-bit int")];
        for (int i30 = 0; i30 < dim30; i30++) {
          var _21636_i = (BigInteger) i30;
          arr30[(int)(_21636_i)] = 0;
        }
        return Dafny.Sequence<byte>.FromArray(arr30);
      }))(), EncryptionSuites.__default.AES__GCM__256);
      _21635_rawAESKeyring = _nw89;
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _21637_encryptionContext;
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _out299;
      _out299 = TestUtils.__default.SmallEncryptionContext(@TestUtils.SmallEncryptionContextVariation.create_A());
      _21637_encryptionContext = _out299;
      TestUtils.__default.ExpectSerializableEncryptionContext(_21637_encryptionContext);
      Dafny.ISequence<byte> _21638_pdk;
      _21638_pdk = ((System.Func<Dafny.ISequence<byte>>) (() => {
        BigInteger dim31 = new BigInteger(32);
        var arr31 = new byte[Dafny.Helpers.ToIntChecked(dim31,"C# array size must not be larger than max 32-bit int")];
        for (int i31 = 0; i31 < dim31; i31++) {
          var _21639_i = (BigInteger) i31;
          arr31[(int)(_21639_i)] = 0;
        }
        return Dafny.Sequence<byte>.FromArray(arr31);
      }))();
      ushort _21640_wrappingAlgorithmID;
      _21640_wrappingAlgorithmID = AlgorithmSuite.__default.AES__256__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384;
      Dafny.ISequence<byte> _21641_signingKey;
      _21641_signingKey = ((System.Func<Dafny.ISequence<byte>>) (() => {
        BigInteger dim32 = new BigInteger(32);
        var arr32 = new byte[Dafny.Helpers.ToIntChecked(dim32,"C# array size must not be larger than max 32-bit int")];
        for (int i32 = 0; i32 < dim32; i32++) {
          var _21642_i = (BigInteger) i32;
          arr32[(int)(_21642_i)] = 0;
        }
        return Dafny.Sequence<byte>.FromArray(arr32);
      }))();
      Materials.EncryptionMaterials _21643_encryptionMaterialsIn;
      _21643_encryptionMaterialsIn = (Materials.EncryptionMaterials.WithoutDataKeys(_21637_encryptionContext, _21640_wrappingAlgorithmID, @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(_21641_signingKey))).WithKeys(@Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(_21638_pdk), Dafny.Sequence<Materials.EncryptedDataKey>.FromElements());
      Materials.EncryptionMaterials _21644_encryptionMaterialsOut = Materials.ValidEncryptionMaterials.Default();
      Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>> _21645_valueOrError0 = Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>>.Default(Materials.ValidEncryptionMaterials.Default());
      Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>> _out300;
      _out300 = (_21635_rawAESKeyring).OnEncrypt(_21643_encryptionMaterialsIn);
      _21645_valueOrError0 = _out300;
      if (!(!((_21645_valueOrError0).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Keyring/RawAESKeyring.dfy(65,31): " + _21645_valueOrError0);
      }
      _21644_encryptionMaterialsOut = (_21645_valueOrError0).Extract();
      if (!((new BigInteger(((_21644_encryptionMaterialsOut).dtor_encryptedDataKeys).Count)) == (BigInteger.One))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Keyring/RawAESKeyring.dfy(66,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      Materials.EncryptedDataKey _21646_edk;
      _21646_edk = ((_21644_encryptionMaterialsOut).dtor_encryptedDataKeys).Select(BigInteger.Zero);
      Dafny.ISequence<byte> _21647_verificationKey;
      _21647_verificationKey = ((System.Func<Dafny.ISequence<byte>>) (() => {
        BigInteger dim33 = new BigInteger(32);
        var arr33 = new byte[Dafny.Helpers.ToIntChecked(dim33,"C# array size must not be larger than max 32-bit int")];
        for (int i33 = 0; i33 < dim33; i33++) {
          var _21648_i = (BigInteger) i33;
          arr33[(int)(_21648_i)] = 0;
        }
        return Dafny.Sequence<byte>.FromArray(arr33);
      }))();
      Materials.DecryptionMaterials _21649_decryptionMaterialsIn;
      _21649_decryptionMaterialsIn = Materials.DecryptionMaterials.WithoutPlaintextDataKey(_21637_encryptionContext, _21640_wrappingAlgorithmID, @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(_21647_verificationKey));
      Materials.DecryptionMaterials _21650_decryptionMaterialsOut = Materials.ValidDecryptionMaterials.Default();
      Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>> _21651_valueOrError1 = Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>.Default(Materials.ValidDecryptionMaterials.Default());
      Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>> _out301;
      _out301 = (_21635_rawAESKeyring).OnDecrypt(_21649_decryptionMaterialsIn, Dafny.Sequence<Materials.EncryptedDataKey>.FromElements(_21646_edk));
      _21651_valueOrError1 = _out301;
      if (!(!((_21651_valueOrError1).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Keyring/RawAESKeyring.dfy(72,31): " + _21651_valueOrError1);
      }
      _21650_decryptionMaterialsOut = (_21651_valueOrError1).Extract();
      if (!(object.Equals((_21650_decryptionMaterialsOut).dtor_plaintextDataKey, @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(_21638_pdk)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Keyring/RawAESKeyring.dfy(73,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestOnDecryptNoEDKs()
    {
      Dafny.ISequence<byte> _21652_namespace;
      Dafny.ISequence<byte> _21653_name;
      Dafny.ISequence<byte> _out302;
      Dafny.ISequence<byte> _out303;
      TestUtils.__default.NamespaceAndName(BigInteger.Zero, out _out302, out _out303);
      _21652_namespace = _out302;
      _21653_name = _out303;
      RawAESKeyringDef.RawAESKeyring _21654_rawAESKeyring;
      RawAESKeyringDef.RawAESKeyring _nw90 = new RawAESKeyringDef.RawAESKeyring();
      _nw90.__ctor(_21652_namespace, _21653_name, ((System.Func<Dafny.ISequence<byte>>) (() => {
        BigInteger dim34 = new BigInteger(32);
        var arr34 = new byte[Dafny.Helpers.ToIntChecked(dim34,"C# array size must not be larger than max 32-bit int")];
        for (int i34 = 0; i34 < dim34; i34++) {
          var _21655_i = (BigInteger) i34;
          arr34[(int)(_21655_i)] = 0;
        }
        return Dafny.Sequence<byte>.FromArray(arr34);
      }))(), EncryptionSuites.__default.AES__GCM__256);
      _21654_rawAESKeyring = _nw90;
      ushort _21656_wrappingAlgorithmID;
      _21656_wrappingAlgorithmID = AlgorithmSuite.__default.AES__256__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384;
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _21657_encryptionContext;
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _out304;
      _out304 = TestUtils.__default.SmallEncryptionContext(@TestUtils.SmallEncryptionContextVariation.create_A());
      _21657_encryptionContext = _out304;
      Dafny.ISequence<byte> _21658_verificationKey;
      _21658_verificationKey = ((System.Func<Dafny.ISequence<byte>>) (() => {
        BigInteger dim35 = new BigInteger(32);
        var arr35 = new byte[Dafny.Helpers.ToIntChecked(dim35,"C# array size must not be larger than max 32-bit int")];
        for (int i35 = 0; i35 < dim35; i35++) {
          var _21659_i = (BigInteger) i35;
          arr35[(int)(_21659_i)] = 0;
        }
        return Dafny.Sequence<byte>.FromArray(arr35);
      }))();
      Materials.DecryptionMaterials _21660_decryptionMaterialsIn;
      _21660_decryptionMaterialsIn = Materials.DecryptionMaterials.WithoutPlaintextDataKey(_21657_encryptionContext, _21656_wrappingAlgorithmID, @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(_21658_verificationKey));
      Materials.DecryptionMaterials _21661_decryptionMaterialsOut = Materials.ValidDecryptionMaterials.Default();
      Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>> _21662_valueOrError0 = Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>.Default(Materials.ValidDecryptionMaterials.Default());
      Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>> _out305;
      _out305 = (_21654_rawAESKeyring).OnDecrypt(_21660_decryptionMaterialsIn, Dafny.Sequence<Materials.EncryptedDataKey>.FromElements());
      _21662_valueOrError0 = _out305;
      if (!(!((_21662_valueOrError0).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Keyring/RawAESKeyring.dfy(85,31): " + _21662_valueOrError0);
      }
      _21661_decryptionMaterialsOut = (_21662_valueOrError0).Extract();
      if (!(((_21661_decryptionMaterialsOut).dtor_plaintextDataKey).is_None)) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Keyring/RawAESKeyring.dfy(86,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestOnEncryptUnserializableEC()
    {
      Dafny.ISequence<byte> _21663_namespace;
      Dafny.ISequence<byte> _21664_name;
      Dafny.ISequence<byte> _out306;
      Dafny.ISequence<byte> _out307;
      TestUtils.__default.NamespaceAndName(BigInteger.Zero, out _out306, out _out307);
      _21663_namespace = _out306;
      _21664_name = _out307;
      RawAESKeyringDef.RawAESKeyring _21665_rawAESKeyring;
      RawAESKeyringDef.RawAESKeyring _nw91 = new RawAESKeyringDef.RawAESKeyring();
      _nw91.__ctor(_21663_namespace, _21664_name, ((System.Func<Dafny.ISequence<byte>>) (() => {
        BigInteger dim36 = new BigInteger(32);
        var arr36 = new byte[Dafny.Helpers.ToIntChecked(dim36,"C# array size must not be larger than max 32-bit int")];
        for (int i36 = 0; i36 < dim36; i36++) {
          var _21666_i = (BigInteger) i36;
          arr36[(int)(_21666_i)] = 0;
        }
        return Dafny.Sequence<byte>.FromArray(arr36);
      }))(), EncryptionSuites.__default.AES__GCM__256);
      _21665_rawAESKeyring = _nw91;
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _21667_unserializableEncryptionContext;
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _out308;
      _out308 = TestAESKeyring_Compile.__default.generateUnserializableEncryptionContext();
      _21667_unserializableEncryptionContext = _out308;
      TestUtils.__default.ExpectNonSerializableEncryptionContext(_21667_unserializableEncryptionContext);
      ushort _21668_wrappingAlgorithmID;
      _21668_wrappingAlgorithmID = AlgorithmSuite.__default.AES__256__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384;
      Dafny.ISequence<byte> _21669_signingKey;
      _21669_signingKey = ((System.Func<Dafny.ISequence<byte>>) (() => {
        BigInteger dim37 = new BigInteger(32);
        var arr37 = new byte[Dafny.Helpers.ToIntChecked(dim37,"C# array size must not be larger than max 32-bit int")];
        for (int i37 = 0; i37 < dim37; i37++) {
          var _21670_i = (BigInteger) i37;
          arr37[(int)(_21670_i)] = 0;
        }
        return Dafny.Sequence<byte>.FromArray(arr37);
      }))();
      Materials.EncryptionMaterials _21671_encryptionMaterialsIn;
      _21671_encryptionMaterialsIn = Materials.EncryptionMaterials.WithoutDataKeys(_21667_unserializableEncryptionContext, _21668_wrappingAlgorithmID, @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(_21669_signingKey));
      Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>> _21672_encryptionMaterialsOut;
      Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>> _out309;
      _out309 = (_21665_rawAESKeyring).OnEncrypt(_21671_encryptionMaterialsIn);
      _21672_encryptionMaterialsOut = _out309;
      if (!((_21672_encryptionMaterialsOut).is_Failure)) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Keyring/RawAESKeyring.dfy(100,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestOnDecryptUnserializableEC()
    {
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _21673_encryptionContext;
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _out310;
      _out310 = TestUtils.__default.SmallEncryptionContext(@TestUtils.SmallEncryptionContextVariation.create_A());
      _21673_encryptionContext = _out310;
      Dafny.ISequence<byte> _21674_namespace;
      Dafny.ISequence<byte> _21675_name;
      Dafny.ISequence<byte> _out311;
      Dafny.ISequence<byte> _out312;
      TestUtils.__default.NamespaceAndName(BigInteger.Zero, out _out311, out _out312);
      _21674_namespace = _out311;
      _21675_name = _out312;
      RawAESKeyringDef.RawAESKeyring _21676_rawAESKeyring;
      RawAESKeyringDef.RawAESKeyring _nw92 = new RawAESKeyringDef.RawAESKeyring();
      _nw92.__ctor(_21674_namespace, _21675_name, ((System.Func<Dafny.ISequence<byte>>) (() => {
        BigInteger dim38 = new BigInteger(32);
        var arr38 = new byte[Dafny.Helpers.ToIntChecked(dim38,"C# array size must not be larger than max 32-bit int")];
        for (int i38 = 0; i38 < dim38; i38++) {
          var _21677_i = (BigInteger) i38;
          arr38[(int)(_21677_i)] = 0;
        }
        return Dafny.Sequence<byte>.FromArray(arr38);
      }))(), EncryptionSuites.__default.AES__GCM__256);
      _21676_rawAESKeyring = _nw92;
      ushort _21678_wrappingAlgorithmID;
      _21678_wrappingAlgorithmID = AlgorithmSuite.__default.AES__256__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384;
      Dafny.ISequence<byte> _21679_signingKey;
      _21679_signingKey = ((System.Func<Dafny.ISequence<byte>>) (() => {
        BigInteger dim39 = new BigInteger(32);
        var arr39 = new byte[Dafny.Helpers.ToIntChecked(dim39,"C# array size must not be larger than max 32-bit int")];
        for (int i39 = 0; i39 < dim39; i39++) {
          var _21680_i = (BigInteger) i39;
          arr39[(int)(_21680_i)] = 0;
        }
        return Dafny.Sequence<byte>.FromArray(arr39);
      }))();
      Materials.EncryptionMaterials _21681_encryptionMaterialsIn;
      _21681_encryptionMaterialsIn = Materials.EncryptionMaterials.WithoutDataKeys(_21673_encryptionContext, _21678_wrappingAlgorithmID, @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(_21679_signingKey));
      Materials.EncryptionMaterials _21682_encryptionMaterialsOut = Materials.ValidEncryptionMaterials.Default();
      Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>> _21683_valueOrError0 = Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>>.Default(Materials.ValidEncryptionMaterials.Default());
      Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>> _out313;
      _out313 = (_21676_rawAESKeyring).OnEncrypt(_21681_encryptionMaterialsIn);
      _21683_valueOrError0 = _out313;
      if (!(!((_21683_valueOrError0).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Keyring/RawAESKeyring.dfy(112,31): " + _21683_valueOrError0);
      }
      _21682_encryptionMaterialsOut = (_21683_valueOrError0).Extract();
      if (!(((_21682_encryptionMaterialsOut).dtor_plaintextDataKey).is_Some)) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Keyring/RawAESKeyring.dfy(113,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!((new BigInteger(((_21682_encryptionMaterialsOut).dtor_encryptedDataKeys).Count)) == (BigInteger.One))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Keyring/RawAESKeyring.dfy(114,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      Materials.EncryptedDataKey _21684_edk;
      _21684_edk = ((_21682_encryptionMaterialsOut).dtor_encryptedDataKeys).Select(BigInteger.Zero);
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _21685_unserializableEncryptionContext;
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _out314;
      _out314 = TestAESKeyring_Compile.__default.generateUnserializableEncryptionContext();
      _21685_unserializableEncryptionContext = _out314;
      TestUtils.__default.ExpectNonSerializableEncryptionContext(_21685_unserializableEncryptionContext);
      Dafny.ISequence<byte> _21686_verificationKey;
      _21686_verificationKey = ((System.Func<Dafny.ISequence<byte>>) (() => {
        BigInteger dim40 = new BigInteger(32);
        var arr40 = new byte[Dafny.Helpers.ToIntChecked(dim40,"C# array size must not be larger than max 32-bit int")];
        for (int i40 = 0; i40 < dim40; i40++) {
          var _21687_i = (BigInteger) i40;
          arr40[(int)(_21687_i)] = 0;
        }
        return Dafny.Sequence<byte>.FromArray(arr40);
      }))();
      Materials.DecryptionMaterials _21688_decryptionMaterialsIn;
      _21688_decryptionMaterialsIn = Materials.DecryptionMaterials.WithoutPlaintextDataKey(_21685_unserializableEncryptionContext, _21678_wrappingAlgorithmID, @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(_21686_verificationKey));
      Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>> _21689_decryptionMaterialsOut;
      Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>> _out315;
      _out315 = (_21676_rawAESKeyring).OnDecrypt(_21688_decryptionMaterialsIn, Dafny.Sequence<Materials.EncryptedDataKey>.FromElements(_21684_edk));
      _21689_decryptionMaterialsOut = _out315;
      if (!((_21689_decryptionMaterialsOut).is_Failure)) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Keyring/RawAESKeyring.dfy(124,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestDeserializeEDKCiphertext()
    {
      Dafny.ISequence<byte> _21690_ciphertext;
      _21690_ciphertext = Dafny.Sequence<byte>.FromElements(0, 1, 2, 3);
      Dafny.ISequence<byte> _21691_authTag;
      _21691_authTag = Dafny.Sequence<byte>.FromElements(4, 5, 6, 7);
      Dafny.ISequence<byte> _21692_serializedEDKCiphertext;
      _21692_serializedEDKCiphertext = Dafny.Sequence<byte>.Concat(_21690_ciphertext, _21691_authTag);
      AESEncryption.EncryptionOutput _21693_encOutput;
      _21693_encOutput = RawAESKeyringDef.__default.DeserializeEDKCiphertext(_21692_serializedEDKCiphertext, new BigInteger((_21691_authTag).Count));
      if (!(((_21693_encOutput).dtor_cipherText).Equals((_21690_ciphertext)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Keyring/RawAESKeyring.dfy(133,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!(((_21693_encOutput).dtor_authTag).Equals((_21691_authTag)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Keyring/RawAESKeyring.dfy(134,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestSerializeEDKCiphertext()
    {
      Dafny.ISequence<byte> _21694_ciphertext;
      _21694_ciphertext = Dafny.Sequence<byte>.FromElements(0, 1, 2, 3);
      Dafny.ISequence<byte> _21695_authTag;
      _21695_authTag = Dafny.Sequence<byte>.FromElements(4, 5, 6, 7);
      AESEncryption.EncryptionOutput _21696_encOutput;
      _21696_encOutput = @AESEncryption.EncryptionOutput.create(_21694_ciphertext, _21695_authTag);
      Dafny.ISequence<byte> _21697_serializedEDKCiphertext;
      _21697_serializedEDKCiphertext = RawAESKeyringDef.__default.SerializeEDKCiphertext(_21696_encOutput);
      if (!((_21697_serializedEDKCiphertext).Equals((Dafny.Sequence<byte>.Concat(_21694_ciphertext, _21695_authTag))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Keyring/RawAESKeyring.dfy(143,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    public static Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> generateUnserializableEncryptionContext()
    {
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encCtx = Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Empty;
      Dafny.ISequence<byte> _21698_keyA = UTF8.ValidUTF8Bytes.Default();
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _21699_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out316;
      _out316 = UTF8.__default.Encode(Dafny.Sequence<char>.FromString("keyA"));
      _21699_valueOrError0 = _out316;
      if (!(!((_21699_valueOrError0).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Keyring/RawAESKeyring.dfy(148,13): " + _21699_valueOrError0);
      }
      _21698_keyA = (_21699_valueOrError0).Extract();
      Dafny.ISequence<byte> _21700_invalidVal;
      _21700_invalidVal = ((System.Func<Dafny.ISequence<byte>>) (() => {
        BigInteger dim41 = new BigInteger(65536);
        var arr41 = new byte[Dafny.Helpers.ToIntChecked(dim41,"C# array size must not be larger than max 32-bit int")];
        for (int i41 = 0; i41 < dim41; i41++) {
          var _21701___v0 = (BigInteger) i41;
          arr41[(int)(_21701___v0)] = 0;
        }
        return Dafny.Sequence<byte>.FromArray(arr41);
      }))();
      encCtx = Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.FromElements(new Dafny.Pair<Dafny.ISequence<byte>,Dafny.ISequence<byte>>(_21698_keyA,_21700_invalidVal));
      return encCtx;
      return encCtx;
    }
  }
} // end of namespace TestAESKeyring_Compile
namespace TestRSAKeyring_Compile {









  public partial class __default {
    [Xunit.Fact]
    public static void TestOnEncryptOnDecryptGenerateDataKey()
    {
      Dafny.ISet<RSAEncryption.PaddingMode> _21702_remainingPaddingModes;
      _21702_remainingPaddingModes = TestRSAKeyring_Compile.__default.allPaddingModes;
      Dafny.ISequence<byte> _21703_namespace;
      Dafny.ISequence<byte> _21704_name;
      Dafny.ISequence<byte> _out317;
      Dafny.ISequence<byte> _out318;
      TestUtils.__default.NamespaceAndName(BigInteger.Zero, out _out317, out _out318);
      _21703_namespace = _out317;
      _21704_name = _out318;
      while (!(_21702_remainingPaddingModes).Equals((Dafny.Set<RSAEncryption.PaddingMode>.FromElements()))) {
        RSAEncryption.PaddingMode _21705_paddingMode;
        foreach (RSAEncryption.PaddingMode _assign_such_that_1 in (_21702_remainingPaddingModes).Elements) {
          _21705_paddingMode = (RSAEncryption.PaddingMode)_assign_such_that_1;
          if ((_21702_remainingPaddingModes).Contains((_21705_paddingMode))) {
            goto after__ASSIGN_SUCH_THAT_1;
          }
        }
        throw new System.Exception("assign-such-that search produced no value (line 31)");
      after__ASSIGN_SUCH_THAT_1: ;
        _21702_remainingPaddingModes = Dafny.Set<RSAEncryption.PaddingMode>.Difference(_21702_remainingPaddingModes, Dafny.Set<RSAEncryption.PaddingMode>.FromElements(_21705_paddingMode));
        RSAEncryption.PublicKey _21706_publicKey;
        RSAEncryption.PrivateKey _21707_privateKey;
        RSAEncryption.PublicKey _out319;
        RSAEncryption.PrivateKey _out320;
        RSAEncryption.__default.GenerateKeyPair(2048, _21705_paddingMode, out _out319, out _out320);
        _21706_publicKey = _out319;
        _21707_privateKey = _out320;
        RawRSAKeyringDef.RawRSAKeyring _21708_rawRSAKeyring;
        RawRSAKeyringDef.RawRSAKeyring _nw93 = new RawRSAKeyringDef.RawRSAKeyring();
        _nw93.__ctor(_21703_namespace, _21704_name, _21705_paddingMode, @Wrappers_Compile.Option<RSAEncryption.PublicKey>.create_Some(_21706_publicKey), @Wrappers_Compile.Option<RSAEncryption.PrivateKey>.create_Some(_21707_privateKey));
        _21708_rawRSAKeyring = _nw93;
        Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _21709_encryptionContext;
        Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _out321;
        _out321 = TestUtils.__default.SmallEncryptionContext(@TestUtils.SmallEncryptionContextVariation.create_A());
        _21709_encryptionContext = _out321;
        ushort _21710_algorithmSuiteID;
        _21710_algorithmSuiteID = AlgorithmSuite.__default.AES__256__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384;
        Dafny.ISequence<byte> _21711_signingKey;
        _21711_signingKey = ((System.Func<Dafny.ISequence<byte>>) (() => {
          BigInteger dim42 = new BigInteger(32);
          var arr42 = new byte[Dafny.Helpers.ToIntChecked(dim42,"C# array size must not be larger than max 32-bit int")];
          for (int i42 = 0; i42 < dim42; i42++) {
            var _21712_i = (BigInteger) i42;
            arr42[(int)(_21712_i)] = 0;
          }
          return Dafny.Sequence<byte>.FromArray(arr42);
        }))();
        Materials.EncryptionMaterials _21713_encryptionMaterialsIn;
        _21713_encryptionMaterialsIn = Materials.EncryptionMaterials.WithoutDataKeys(_21709_encryptionContext, _21710_algorithmSuiteID, @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(_21711_signingKey));
        Materials.EncryptionMaterials _21714_encryptionMaterialsOut = Materials.ValidEncryptionMaterials.Default();
        Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>> _21715_valueOrError0 = Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>>.Default(Materials.ValidEncryptionMaterials.Default());
        Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>> _out322;
        _out322 = (_21708_rawRSAKeyring).OnEncrypt(_21713_encryptionMaterialsIn);
        _21715_valueOrError0 = _out322;
        if (!(!((_21715_valueOrError0).IsFailure()))) {
          throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Keyring/RawRSAKeyring.dfy(42,33): " + _21715_valueOrError0);
        }
        _21714_encryptionMaterialsOut = (_21715_valueOrError0).Extract();
        if (!(((_21714_encryptionMaterialsOut).dtor_plaintextDataKey).is_Some)) {
          throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Keyring/RawRSAKeyring.dfy(43,6): " + Dafny.Sequence<char>.FromString("expectation violation"));
        }
        if (!((new BigInteger(((_21714_encryptionMaterialsOut).dtor_encryptedDataKeys).Count)) == (BigInteger.One))) {
          throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Keyring/RawRSAKeyring.dfy(44,6): " + Dafny.Sequence<char>.FromString("expectation violation"));
        }
        Wrappers_Compile.Option<Dafny.ISequence<byte>> _21716_plaintextDataKey;
        _21716_plaintextDataKey = (_21714_encryptionMaterialsOut).dtor_plaintextDataKey;
        Materials.EncryptedDataKey _21717_encryptedDataKey;
        _21717_encryptedDataKey = ((_21714_encryptionMaterialsOut).dtor_encryptedDataKeys).Select(BigInteger.Zero);
        Dafny.ISequence<byte> _21718_verificationKey;
        _21718_verificationKey = ((System.Func<Dafny.ISequence<byte>>) (() => {
          BigInteger dim43 = new BigInteger(32);
          var arr43 = new byte[Dafny.Helpers.ToIntChecked(dim43,"C# array size must not be larger than max 32-bit int")];
          for (int i43 = 0; i43 < dim43; i43++) {
            var _21719_i = (BigInteger) i43;
            arr43[(int)(_21719_i)] = 0;
          }
          return Dafny.Sequence<byte>.FromArray(arr43);
        }))();
        Materials.DecryptionMaterials _21720_decryptionMaterialsIn;
        _21720_decryptionMaterialsIn = Materials.DecryptionMaterials.WithoutPlaintextDataKey(_21709_encryptionContext, _21710_algorithmSuiteID, @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(_21718_verificationKey));
        Materials.DecryptionMaterials _21721_decryptionMaterialsOut = Materials.ValidDecryptionMaterials.Default();
        Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>> _21722_valueOrError1 = Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>.Default(Materials.ValidDecryptionMaterials.Default());
        Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>> _out323;
        _out323 = (_21708_rawRSAKeyring).OnDecrypt(_21720_decryptionMaterialsIn, Dafny.Sequence<Materials.EncryptedDataKey>.FromElements(_21717_encryptedDataKey));
        _21722_valueOrError1 = _out323;
        if (!(!((_21722_valueOrError1).IsFailure()))) {
          throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Keyring/RawRSAKeyring.dfy(51,33): " + _21722_valueOrError1);
        }
        _21721_decryptionMaterialsOut = (_21722_valueOrError1).Extract();
        if (!(object.Equals((_21714_encryptionMaterialsOut).dtor_plaintextDataKey, _21716_plaintextDataKey))) {
          throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Keyring/RawRSAKeyring.dfy(52,6): " + Dafny.Sequence<char>.FromString("expectation violation"));
        }
      }
    }
    [Xunit.Fact]
    public static void TestOnEncryptOnDecryptSuppliedDataKey()
    {
      Dafny.ISet<RSAEncryption.PaddingMode> _21723_remainingPaddingModes;
      _21723_remainingPaddingModes = TestRSAKeyring_Compile.__default.allPaddingModes;
      Dafny.ISequence<byte> _21724_namespace;
      Dafny.ISequence<byte> _21725_name;
      Dafny.ISequence<byte> _out324;
      Dafny.ISequence<byte> _out325;
      TestUtils.__default.NamespaceAndName(BigInteger.Zero, out _out324, out _out325);
      _21724_namespace = _out324;
      _21725_name = _out325;
      while (!(_21723_remainingPaddingModes).Equals((Dafny.Set<RSAEncryption.PaddingMode>.FromElements()))) {
        RSAEncryption.PaddingMode _21726_paddingMode;
        foreach (RSAEncryption.PaddingMode _assign_such_that_2 in (_21723_remainingPaddingModes).Elements) {
          _21726_paddingMode = (RSAEncryption.PaddingMode)_assign_such_that_2;
          if ((_21723_remainingPaddingModes).Contains((_21726_paddingMode))) {
            goto after__ASSIGN_SUCH_THAT_2;
          }
        }
        throw new System.Exception("assign-such-that search produced no value (line 63)");
      after__ASSIGN_SUCH_THAT_2: ;
        _21723_remainingPaddingModes = Dafny.Set<RSAEncryption.PaddingMode>.Difference(_21723_remainingPaddingModes, Dafny.Set<RSAEncryption.PaddingMode>.FromElements(_21726_paddingMode));
        RSAEncryption.PublicKey _21727_publicKey;
        RSAEncryption.PrivateKey _21728_privateKey;
        RSAEncryption.PublicKey _out326;
        RSAEncryption.PrivateKey _out327;
        RSAEncryption.__default.GenerateKeyPair(2048, _21726_paddingMode, out _out326, out _out327);
        _21727_publicKey = _out326;
        _21728_privateKey = _out327;
        RawRSAKeyringDef.RawRSAKeyring _21729_rawRSAKeyring;
        RawRSAKeyringDef.RawRSAKeyring _nw94 = new RawRSAKeyringDef.RawRSAKeyring();
        _nw94.__ctor(_21724_namespace, _21725_name, _21726_paddingMode, @Wrappers_Compile.Option<RSAEncryption.PublicKey>.create_Some(_21727_publicKey), @Wrappers_Compile.Option<RSAEncryption.PrivateKey>.create_Some(_21728_privateKey));
        _21729_rawRSAKeyring = _nw94;
        Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _21730_encryptionContext;
        Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _out328;
        _out328 = TestUtils.__default.SmallEncryptionContext(@TestUtils.SmallEncryptionContextVariation.create_A());
        _21730_encryptionContext = _out328;
        Dafny.ISequence<byte> _21731_plaintextDataKey;
        _21731_plaintextDataKey = ((System.Func<Dafny.ISequence<byte>>) (() => {
          BigInteger dim44 = new BigInteger(32);
          var arr44 = new byte[Dafny.Helpers.ToIntChecked(dim44,"C# array size must not be larger than max 32-bit int")];
          for (int i44 = 0; i44 < dim44; i44++) {
            var _21732_i = (BigInteger) i44;
            arr44[(int)(_21732_i)] = 0;
          }
          return Dafny.Sequence<byte>.FromArray(arr44);
        }))();
        ushort _21733_algorithmSuiteID;
        _21733_algorithmSuiteID = AlgorithmSuite.__default.AES__256__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384;
        Dafny.ISequence<byte> _21734_signingKey;
        _21734_signingKey = ((System.Func<Dafny.ISequence<byte>>) (() => {
          BigInteger dim45 = new BigInteger(32);
          var arr45 = new byte[Dafny.Helpers.ToIntChecked(dim45,"C# array size must not be larger than max 32-bit int")];
          for (int i45 = 0; i45 < dim45; i45++) {
            var _21735_i = (BigInteger) i45;
            arr45[(int)(_21735_i)] = 0;
          }
          return Dafny.Sequence<byte>.FromArray(arr45);
        }))();
        Materials.EncryptionMaterials _21736_encryptionMaterialsIn;
        _21736_encryptionMaterialsIn = (Materials.EncryptionMaterials.WithoutDataKeys(_21730_encryptionContext, _21733_algorithmSuiteID, @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(_21734_signingKey))).WithKeys(@Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(_21731_plaintextDataKey), Dafny.Sequence<Materials.EncryptedDataKey>.FromElements());
        Materials.EncryptionMaterials _21737_encryptionMaterialsOut = Materials.ValidEncryptionMaterials.Default();
        Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>> _21738_valueOrError0 = Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>>.Default(Materials.ValidEncryptionMaterials.Default());
        Wrappers_Compile.Result<Materials.EncryptionMaterials, Dafny.ISequence<char>> _out329;
        _out329 = (_21729_rawRSAKeyring).OnEncrypt(_21736_encryptionMaterialsIn);
        _21738_valueOrError0 = _out329;
        if (!(!((_21738_valueOrError0).IsFailure()))) {
          throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Keyring/RawRSAKeyring.dfy(76,33): " + _21738_valueOrError0);
        }
        _21737_encryptionMaterialsOut = (_21738_valueOrError0).Extract();
        if (!(((_21737_encryptionMaterialsOut).dtor_plaintextDataKey).is_Some)) {
          throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Keyring/RawRSAKeyring.dfy(77,6): " + Dafny.Sequence<char>.FromString("expectation violation"));
        }
        if (!((new BigInteger(((_21737_encryptionMaterialsOut).dtor_encryptedDataKeys).Count)) == (BigInteger.One))) {
          throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Keyring/RawRSAKeyring.dfy(78,6): " + Dafny.Sequence<char>.FromString("expectation violation"));
        }
        if (!((((_21737_encryptionMaterialsOut).dtor_plaintextDataKey).dtor_value).Equals((_21731_plaintextDataKey)))) {
          throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Keyring/RawRSAKeyring.dfy(79,6): " + Dafny.Sequence<char>.FromString("expectation violation"));
        }
        Materials.EncryptedDataKey _21739_encryptedDataKey;
        _21739_encryptedDataKey = ((_21737_encryptionMaterialsOut).dtor_encryptedDataKeys).Select(BigInteger.Zero);
        Dafny.ISequence<byte> _21740_verificationKey;
        _21740_verificationKey = ((System.Func<Dafny.ISequence<byte>>) (() => {
          BigInteger dim46 = new BigInteger(32);
          var arr46 = new byte[Dafny.Helpers.ToIntChecked(dim46,"C# array size must not be larger than max 32-bit int")];
          for (int i46 = 0; i46 < dim46; i46++) {
            var _21741_i = (BigInteger) i46;
            arr46[(int)(_21741_i)] = 0;
          }
          return Dafny.Sequence<byte>.FromArray(arr46);
        }))();
        Materials.DecryptionMaterials _21742_decryptionMaterialsIn;
        _21742_decryptionMaterialsIn = Materials.DecryptionMaterials.WithoutPlaintextDataKey(_21730_encryptionContext, _21733_algorithmSuiteID, @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(_21740_verificationKey));
        Materials.DecryptionMaterials _21743_decryptionMaterialsOut = Materials.ValidDecryptionMaterials.Default();
        Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>> _21744_valueOrError1 = Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>>.Default(Materials.ValidDecryptionMaterials.Default());
        Wrappers_Compile.Result<Materials.DecryptionMaterials, Dafny.ISequence<char>> _out330;
        _out330 = (_21729_rawRSAKeyring).OnDecrypt(_21742_decryptionMaterialsIn, Dafny.Sequence<Materials.EncryptedDataKey>.FromElements(_21739_encryptedDataKey));
        _21744_valueOrError1 = _out330;
        if (!(!((_21744_valueOrError1).IsFailure()))) {
          throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Keyring/RawRSAKeyring.dfy(85,33): " + _21744_valueOrError1);
        }
        _21743_decryptionMaterialsOut = (_21744_valueOrError1).Extract();
        if (!((((_21743_decryptionMaterialsOut).dtor_plaintextDataKey).is_Some) && ((((_21743_decryptionMaterialsOut).dtor_plaintextDataKey).dtor_value).Equals((_21731_plaintextDataKey))))) {
          throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Keyring/RawRSAKeyring.dfy(86,6): " + Dafny.Sequence<char>.FromString("expectation violation"));
        }
      }
    }
    public static Dafny.ISet<RSAEncryption.PaddingMode> allPaddingModes { get {
      return Dafny.Set<RSAEncryption.PaddingMode>.FromElements(@RSAEncryption.PaddingMode.create_PKCS1(), @RSAEncryption.PaddingMode.create_OAEP__SHA1(), @RSAEncryption.PaddingMode.create_OAEP__SHA256(), @RSAEncryption.PaddingMode.create_OAEP__SHA384(), @RSAEncryption.PaddingMode.create_OAEP__SHA512());
    } }
  }
} // end of namespace TestRSAKeyring_Compile
namespace TestMaterials {




  public partial class __default {
    [Xunit.Fact]
    public static void TestWithKeysSettingPlaintextDataKey()
    {
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _21745_encryptionContext;
      _21745_encryptionContext = Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.FromElements();
      ushort _21746_algorithmSuiteID;
      _21746_algorithmSuiteID = AlgorithmSuite.__default.AES__256__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384;
      Dafny.ISequence<byte> _21747_signingKey;
      _21747_signingKey = ((System.Func<Dafny.ISequence<byte>>) (() => {
        BigInteger dim47 = new BigInteger(32);
        var arr47 = new byte[Dafny.Helpers.ToIntChecked(dim47,"C# array size must not be larger than max 32-bit int")];
        for (int i47 = 0; i47 < dim47; i47++) {
          var _21748_i = (BigInteger) i47;
          arr47[(int)(_21748_i)] = 0;
        }
        return Dafny.Sequence<byte>.FromArray(arr47);
      }))();
      Materials.EncryptionMaterials _21749_encryptionMaterials1;
      _21749_encryptionMaterials1 = @Materials.EncryptionMaterials.create(_21745_encryptionContext, _21746_algorithmSuiteID, @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_None(), Dafny.Sequence<Materials.EncryptedDataKey>.FromElements(), @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(_21747_signingKey));
      Dafny.ISequence<byte> _21750_pdk;
      _21750_pdk = ((System.Func<Dafny.ISequence<byte>>) (() => {
        BigInteger dim48 = new BigInteger(32);
        var arr48 = new byte[Dafny.Helpers.ToIntChecked(dim48,"C# array size must not be larger than max 32-bit int")];
        for (int i48 = 0; i48 < dim48; i48++) {
          var _21751_i = (BigInteger) i48;
          arr48[(int)(_21751_i)] = 0;
        }
        return Dafny.Sequence<byte>.FromArray(arr48);
      }))();
      Materials.EncryptedDataKey _21752_edk;
      _21752_edk = @Materials.EncryptedDataKey.create(Dafny.Sequence<byte>.FromElements(), Dafny.Sequence<byte>.FromElements(2), Dafny.Sequence<byte>.FromElements(2));
      Materials.EncryptionMaterials _21753_encryptionMaterials2;
      _21753_encryptionMaterials2 = (_21749_encryptionMaterials1).WithKeys(@Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(_21750_pdk), Dafny.Sequence<Materials.EncryptedDataKey>.FromElements(_21752_edk));
      if (!(object.Equals(@Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(_21750_pdk), (_21753_encryptionMaterials2).dtor_plaintextDataKey))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Materials.dfy(25,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!(((_21749_encryptionMaterials1).dtor_algorithmSuiteID) == ((_21753_encryptionMaterials2).dtor_algorithmSuiteID))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Materials.dfy(26,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!((Dafny.Sequence<Materials.EncryptedDataKey>.FromElements(_21752_edk)).Equals(((_21753_encryptionMaterials2).dtor_encryptedDataKeys)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Materials.dfy(27,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestWithKeysKeepingPlaintextDataKey()
    {
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _21754_encryptionContext;
      _21754_encryptionContext = Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.FromElements();
      Materials.EncryptedDataKey _21755_edk1;
      _21755_edk1 = @Materials.EncryptedDataKey.create(Dafny.Sequence<byte>.FromElements(), Dafny.Sequence<byte>.FromElements(1), Dafny.Sequence<byte>.FromElements(1));
      Dafny.ISequence<byte> _21756_pdk;
      _21756_pdk = ((System.Func<Dafny.ISequence<byte>>) (() => {
        BigInteger dim49 = new BigInteger(32);
        var arr49 = new byte[Dafny.Helpers.ToIntChecked(dim49,"C# array size must not be larger than max 32-bit int")];
        for (int i49 = 0; i49 < dim49; i49++) {
          var _21757_i = (BigInteger) i49;
          arr49[(int)(_21757_i)] = 0;
        }
        return Dafny.Sequence<byte>.FromArray(arr49);
      }))();
      ushort _21758_algorithmSuiteID;
      _21758_algorithmSuiteID = AlgorithmSuite.__default.AES__256__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384;
      Dafny.ISequence<byte> _21759_signingKey;
      _21759_signingKey = ((System.Func<Dafny.ISequence<byte>>) (() => {
        BigInteger dim50 = new BigInteger(32);
        var arr50 = new byte[Dafny.Helpers.ToIntChecked(dim50,"C# array size must not be larger than max 32-bit int")];
        for (int i50 = 0; i50 < dim50; i50++) {
          var _21760_i = (BigInteger) i50;
          arr50[(int)(_21760_i)] = 0;
        }
        return Dafny.Sequence<byte>.FromArray(arr50);
      }))();
      Materials.EncryptionMaterials _21761_encryptionMaterials1;
      _21761_encryptionMaterials1 = @Materials.EncryptionMaterials.create(_21754_encryptionContext, _21758_algorithmSuiteID, @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(_21756_pdk), Dafny.Sequence<Materials.EncryptedDataKey>.FromElements(_21755_edk1), @Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(_21759_signingKey));
      Materials.EncryptedDataKey _21762_edk2;
      _21762_edk2 = @Materials.EncryptedDataKey.create(Dafny.Sequence<byte>.FromElements(), Dafny.Sequence<byte>.FromElements(2), Dafny.Sequence<byte>.FromElements(2));
      Materials.EncryptionMaterials _21763_encryptionMaterials2;
      _21763_encryptionMaterials2 = (_21761_encryptionMaterials1).WithKeys(@Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(_21756_pdk), Dafny.Sequence<Materials.EncryptedDataKey>.FromElements(_21762_edk2));
      if (!((object.Equals(@Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(_21756_pdk), (_21761_encryptionMaterials1).dtor_plaintextDataKey)) && (object.Equals((_21761_encryptionMaterials1).dtor_plaintextDataKey, (_21763_encryptionMaterials2).dtor_plaintextDataKey)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Materials.dfy(42,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!(((_21761_encryptionMaterials1).dtor_algorithmSuiteID) == ((_21763_encryptionMaterials2).dtor_algorithmSuiteID))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Materials.dfy(43,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!((Dafny.Sequence<Materials.EncryptedDataKey>.Concat((_21761_encryptionMaterials1).dtor_encryptedDataKeys, Dafny.Sequence<Materials.EncryptedDataKey>.FromElements(_21762_edk2))).Equals(((_21763_encryptionMaterials2).dtor_encryptedDataKeys)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Materials.dfy(44,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
  }
} // end of namespace TestMaterials
namespace TestMessageHeader_Compile {








  public partial class __default {
    [Xunit.Fact]
    public static void TestKVPairSequenceToMapEmpty()
    {
      Dafny.ISequence<_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>> _21764_kvPairs;
      _21764_kvPairs = Dafny.Sequence<_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>>.FromElements();
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _21765_output;
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _out331;
      _out331 = EncryptionContext.__default.LinearToMap(_21764_kvPairs);
      _21765_output = _out331;
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _21766_expected;
      _21766_expected = Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.FromElements();
      if (!((_21765_output).Equals((_21766_expected)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/MessageHeader.dfy(24,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestKVPairSequenceToMap()
    {
      Dafny.ISequence<byte> _21767_keyA = UTF8.ValidUTF8Bytes.Default();
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _21768_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out332;
      _out332 = UTF8.__default.Encode(Dafny.Sequence<char>.FromString("keyA"));
      _21768_valueOrError0 = _out332;
      if (!(!((_21768_valueOrError0).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/MessageHeader.dfy(28,13): " + _21768_valueOrError0);
      }
      _21767_keyA = (_21768_valueOrError0).Extract();
      Dafny.ISequence<byte> _21769_valA = UTF8.ValidUTF8Bytes.Default();
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _21770_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out333;
      _out333 = UTF8.__default.Encode(Dafny.Sequence<char>.FromString("valA"));
      _21770_valueOrError1 = _out333;
      if (!(!((_21770_valueOrError1).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/MessageHeader.dfy(29,13): " + _21770_valueOrError1);
      }
      _21769_valA = (_21770_valueOrError1).Extract();
      Dafny.ISequence<byte> _21771_keyB = UTF8.ValidUTF8Bytes.Default();
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _21772_valueOrError2 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out334;
      _out334 = UTF8.__default.Encode(Dafny.Sequence<char>.FromString("keyB"));
      _21772_valueOrError2 = _out334;
      if (!(!((_21772_valueOrError2).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/MessageHeader.dfy(30,13): " + _21772_valueOrError2);
      }
      _21771_keyB = (_21772_valueOrError2).Extract();
      Dafny.ISequence<byte> _21773_valB = UTF8.ValidUTF8Bytes.Default();
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _21774_valueOrError3 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out335;
      _out335 = UTF8.__default.Encode(Dafny.Sequence<char>.FromString("valB"));
      _21774_valueOrError3 = _out335;
      if (!(!((_21774_valueOrError3).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/MessageHeader.dfy(31,13): " + _21774_valueOrError3);
      }
      _21773_valB = (_21774_valueOrError3).Extract();
      Dafny.ISequence<_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>> _21775_kvPairs;
      _21775_kvPairs = Dafny.Sequence<_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>>.FromElements(@_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.create(_21767_keyA, _21769_valA), @_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.create(_21771_keyB, _21773_valB));
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _21776_output;
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _out336;
      _out336 = EncryptionContext.__default.LinearToMap(_21775_kvPairs);
      _21776_output = _out336;
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _21777_expected;
      _21777_expected = Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.FromElements(new Dafny.Pair<Dafny.ISequence<byte>,Dafny.ISequence<byte>>(_21767_keyA,_21769_valA), new Dafny.Pair<Dafny.ISequence<byte>,Dafny.ISequence<byte>>(_21771_keyB,_21773_valB));
      if (!((_21776_output).Equals((_21777_expected)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/MessageHeader.dfy(35,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestCheckSerializableEmpty()
    {
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _21778_encCtx;
      _21778_encCtx = Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.FromElements();
      TestUtils.__default.ExpectSerializableEncryptionContext(_21778_encCtx);
    }
    [Xunit.Fact]
    public static void TestCheckSerializableOnePair()
    {
      Dafny.ISequence<byte> _21779_keyA = UTF8.ValidUTF8Bytes.Default();
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _21780_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out337;
      _out337 = UTF8.__default.Encode(Dafny.Sequence<char>.FromString("keyA"));
      _21780_valueOrError0 = _out337;
      if (!(!((_21780_valueOrError0).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/MessageHeader.dfy(44,13): " + _21780_valueOrError0);
      }
      _21779_keyA = (_21780_valueOrError0).Extract();
      Dafny.ISequence<byte> _21781_valA = UTF8.ValidUTF8Bytes.Default();
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _21782_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out338;
      _out338 = UTF8.__default.Encode(Dafny.Sequence<char>.FromString("valA"));
      _21782_valueOrError1 = _out338;
      if (!(!((_21782_valueOrError1).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/MessageHeader.dfy(45,13): " + _21782_valueOrError1);
      }
      _21781_valA = (_21782_valueOrError1).Extract();
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _21783_encCtx;
      _21783_encCtx = Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.FromElements(new Dafny.Pair<Dafny.ISequence<byte>,Dafny.ISequence<byte>>(_21779_keyA,_21781_valA));
      TestUtils.__default.ExpectSerializableEncryptionContext(_21783_encCtx);
    }
    [Xunit.Fact]
    public static void TestCheckSerializableOnePairMaxSize()
    {
      Dafny.ISequence<byte> _21784_keyA = UTF8.ValidUTF8Bytes.Default();
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _21785_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out339;
      _out339 = UTF8.__default.Encode(Dafny.Sequence<char>.FromString("A"));
      _21785_valueOrError0 = _out339;
      if (!(!((_21785_valueOrError0).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/MessageHeader.dfy(51,13): " + _21785_valueOrError0);
      }
      _21784_keyA = (_21785_valueOrError0).Extract();
      Dafny.ISequence<byte> _21786_largeVal;
      _21786_largeVal = ((System.Func<Dafny.ISequence<byte>>) (() => {
        BigInteger dim51 = new BigInteger(65528);
        var arr51 = new byte[Dafny.Helpers.ToIntChecked(dim51,"C# array size must not be larger than max 32-bit int")];
        for (int i51 = 0; i51 < dim51; i51++) {
          var _21787___v0 = (BigInteger) i51;
          arr51[(int)(_21787___v0)] = 0;
        }
        return Dafny.Sequence<byte>.FromArray(arr51);
      }))();
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _21788_encCtx;
      _21788_encCtx = Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.FromElements(new Dafny.Pair<Dafny.ISequence<byte>,Dafny.ISequence<byte>>(_21784_keyA,_21786_largeVal));
      TestUtils.__default.ExpectSerializableEncryptionContext(_21788_encCtx);
    }
    [Xunit.Fact]
    public static void TestCheckSerializableTooLarge()
    {
      Dafny.ISequence<byte> _21789_keyA = UTF8.ValidUTF8Bytes.Default();
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _21790_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out340;
      _out340 = UTF8.__default.Encode(Dafny.Sequence<char>.FromString("keyA"));
      _21790_valueOrError0 = _out340;
      if (!(!((_21790_valueOrError0).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/MessageHeader.dfy(61,13): " + _21790_valueOrError0);
      }
      _21789_keyA = (_21790_valueOrError0).Extract();
      Dafny.ISequence<byte> _21791_keyB = UTF8.ValidUTF8Bytes.Default();
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _21792_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out341;
      _out341 = UTF8.__default.Encode(Dafny.Sequence<char>.FromString("keyB"));
      _21792_valueOrError1 = _out341;
      if (!(!((_21792_valueOrError1).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/MessageHeader.dfy(62,13): " + _21792_valueOrError1);
      }
      _21791_keyB = (_21792_valueOrError1).Extract();
      Dafny.ISequence<byte> _21793_invalidVal;
      _21793_invalidVal = ((System.Func<Dafny.ISequence<byte>>) (() => {
        BigInteger dim52 = new BigInteger(65528);
        var arr52 = new byte[Dafny.Helpers.ToIntChecked(dim52,"C# array size must not be larger than max 32-bit int")];
        for (int i52 = 0; i52 < dim52; i52++) {
          var _21794___v1 = (BigInteger) i52;
          arr52[(int)(_21794___v1)] = 0;
        }
        return Dafny.Sequence<byte>.FromArray(arr52);
      }))();
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _21795_encCtx;
      _21795_encCtx = Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.FromElements(new Dafny.Pair<Dafny.ISequence<byte>,Dafny.ISequence<byte>>(_21789_keyA,_21793_invalidVal), new Dafny.Pair<Dafny.ISequence<byte>,Dafny.ISequence<byte>>(_21791_keyB,_21793_invalidVal));
      TestUtils.__default.ExpectNonSerializableEncryptionContext(_21795_encCtx);
    }
    [Xunit.Fact]
    public static void TestCheckSerializablePairTooBig()
    {
      Dafny.ISequence<byte> _21796_key = UTF8.ValidUTF8Bytes.Default();
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _21797_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out342;
      _out342 = UTF8.__default.Encode(Dafny.Sequence<char>.FromString("keyA"));
      _21797_valueOrError0 = _out342;
      if (!(!((_21797_valueOrError0).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/MessageHeader.dfy(71,12): " + _21797_valueOrError0);
      }
      _21796_key = (_21797_valueOrError0).Extract();
      Dafny.ISequence<byte> _21798_invalidVal;
      _21798_invalidVal = ((System.Func<Dafny.ISequence<byte>>) (() => {
        BigInteger dim53 = new BigInteger(65536);
        var arr53 = new byte[Dafny.Helpers.ToIntChecked(dim53,"C# array size must not be larger than max 32-bit int")];
        for (int i53 = 0; i53 < dim53; i53++) {
          var _21799___v2 = (BigInteger) i53;
          arr53[(int)(_21799___v2)] = 0;
        }
        return Dafny.Sequence<byte>.FromArray(arr53);
      }))();
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _21800_encCtx;
      _21800_encCtx = Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.FromElements(new Dafny.Pair<Dafny.ISequence<byte>,Dafny.ISequence<byte>>(_21796_key,_21798_invalidVal));
      TestUtils.__default.ExpectNonSerializableEncryptionContext(_21800_encCtx);
    }
    [Xunit.Fact]
    public static void TestComputeKVPairsLengthEmpty()
    {
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _21801_encCtx;
      _21801_encCtx = Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.FromElements();
      BigInteger _21802_len;
      BigInteger _out343;
      _out343 = EncryptionContext.__default.ComputeLength(_21801_encCtx);
      _21802_len = _out343;
      if (!((_21802_len).Sign == 0)) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/MessageHeader.dfy(82,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestComputeKVPairsLengthOnePair()
    {
      Dafny.ISequence<byte> _21803_keyA = UTF8.ValidUTF8Bytes.Default();
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _21804_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out344;
      _out344 = UTF8.__default.Encode(Dafny.Sequence<char>.FromString("keyA"));
      _21804_valueOrError0 = _out344;
      if (!(!((_21804_valueOrError0).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/MessageHeader.dfy(86,13): " + _21804_valueOrError0);
      }
      _21803_keyA = (_21804_valueOrError0).Extract();
      Dafny.ISequence<byte> _21805_valA = UTF8.ValidUTF8Bytes.Default();
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _21806_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out345;
      _out345 = UTF8.__default.Encode(Dafny.Sequence<char>.FromString("valA"));
      _21806_valueOrError1 = _out345;
      if (!(!((_21806_valueOrError1).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/MessageHeader.dfy(87,13): " + _21806_valueOrError1);
      }
      _21805_valA = (_21806_valueOrError1).Extract();
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _21807_encCtx;
      _21807_encCtx = Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.FromElements(new Dafny.Pair<Dafny.ISequence<byte>,Dafny.ISequence<byte>>(_21803_keyA,_21805_valA));
      Dafny.ISequence<BigInteger> _21808_expectedSerialization;
      _21808_expectedSerialization = Dafny.Sequence<BigInteger>.FromElements(BigInteger.Zero, BigInteger.One, BigInteger.Zero, new BigInteger(4), new BigInteger(107), new BigInteger(101), new BigInteger(121), new BigInteger(65), BigInteger.Zero, new BigInteger(4), new BigInteger(118), new BigInteger(97), new BigInteger(108), new BigInteger(65));
      BigInteger _21809_len;
      BigInteger _out346;
      _out346 = EncryptionContext.__default.ComputeLength(_21807_encCtx);
      _21809_len = _out346;
      if (!((_21809_len) == (new BigInteger((_21808_expectedSerialization).Count)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/MessageHeader.dfy(92,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestComputeKVPairsLengthLong()
    {
      Dafny.ISequence<byte> _21810_keyA = UTF8.ValidUTF8Bytes.Default();
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _21811_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out347;
      _out347 = UTF8.__default.Encode(Dafny.Sequence<char>.FromString("A"));
      _21811_valueOrError0 = _out347;
      if (!(!((_21811_valueOrError0).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/MessageHeader.dfy(96,13): " + _21811_valueOrError0);
      }
      _21810_keyA = (_21811_valueOrError0).Extract();
      Dafny.ISequence<byte> _21812_largeVal;
      _21812_largeVal = ((System.Func<Dafny.ISequence<byte>>) (() => {
        BigInteger dim54 = new BigInteger(65536);
        var arr54 = new byte[Dafny.Helpers.ToIntChecked(dim54,"C# array size must not be larger than max 32-bit int")];
        for (int i54 = 0; i54 < dim54; i54++) {
          var _21813___v3 = (BigInteger) i54;
          arr54[(int)(_21813___v3)] = 0;
        }
        return Dafny.Sequence<byte>.FromArray(arr54);
      }))();
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _21814_encCtx;
      _21814_encCtx = Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.FromElements(new Dafny.Pair<Dafny.ISequence<byte>,Dafny.ISequence<byte>>(_21810_keyA,_21812_largeVal));
      BigInteger _21815_len;
      BigInteger _out348;
      _out348 = EncryptionContext.__default.ComputeLength(_21814_encCtx);
      _21815_len = _out348;
      if (!((_21815_len) == ((new BigInteger(7)) + (new BigInteger((_21812_largeVal).Count))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/MessageHeader.dfy(102,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestComputeOpoerationsOnLargeValidEC()
    {
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _21816_encCtx;
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _out349;
      _out349 = TestUtils.__default.GenerateLargeValidEncryptionContext();
      _21816_encCtx = _out349;
      BigInteger _21817_len;
      BigInteger _out350;
      _out350 = EncryptionContext.__default.ComputeLength(_21816_encCtx);
      _21817_len = _out350;
      if (!((_21817_len) == ((new BigInteger(2)) + ((new BigInteger((_21816_encCtx).Count)) * (new BigInteger(7)))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/MessageHeader.dfy(109,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      TestUtils.__default.ExpectSerializableEncryptionContext(_21816_encCtx);
    }
  }
} // end of namespace TestMessageHeader_Compile
namespace TestSerialize_Compile {







  public partial class __default {
    [Xunit.Fact]
    public static void TestSerializeAAD()
    {
      Streams_Compile.ByteWriter _21818_wr;
      Streams_Compile.ByteWriter _nw95 = new Streams_Compile.ByteWriter();
      _nw95.__ctor();
      _21818_wr = _nw95;
      Dafny.ISequence<byte> _21819_keyA = UTF8.ValidUTF8Bytes.Default();
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _21820_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out351;
      _out351 = UTF8.__default.Encode(Dafny.Sequence<char>.FromString("keyA"));
      _21820_valueOrError0 = _out351;
      if (!(!((_21820_valueOrError0).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Serialize.dfy(19,13): " + _21820_valueOrError0);
      }
      _21819_keyA = (_21820_valueOrError0).Extract();
      Dafny.ISequence<byte> _21821_valA = UTF8.ValidUTF8Bytes.Default();
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _21822_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out352;
      _out352 = UTF8.__default.Encode(Dafny.Sequence<char>.FromString("valA"));
      _21822_valueOrError1 = _out352;
      if (!(!((_21822_valueOrError1).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Serialize.dfy(20,13): " + _21822_valueOrError1);
      }
      _21821_valA = (_21822_valueOrError1).Extract();
      Dafny.ISequence<byte> _21823_keyB = UTF8.ValidUTF8Bytes.Default();
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _21824_valueOrError2 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out353;
      _out353 = UTF8.__default.Encode(Dafny.Sequence<char>.FromString("keyB"));
      _21824_valueOrError2 = _out353;
      if (!(!((_21824_valueOrError2).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Serialize.dfy(21,13): " + _21824_valueOrError2);
      }
      _21823_keyB = (_21824_valueOrError2).Extract();
      Dafny.ISequence<byte> _21825_valB = UTF8.ValidUTF8Bytes.Default();
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _21826_valueOrError3 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out354;
      _out354 = UTF8.__default.Encode(Dafny.Sequence<char>.FromString("valB"));
      _21826_valueOrError3 = _out354;
      if (!(!((_21826_valueOrError3).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Serialize.dfy(22,13): " + _21826_valueOrError3);
      }
      _21825_valB = (_21826_valueOrError3).Extract();
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _21827_encryptionContext;
      _21827_encryptionContext = Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.FromElements(new Dafny.Pair<Dafny.ISequence<byte>,Dafny.ISequence<byte>>(_21823_keyB,_21825_valB), new Dafny.Pair<Dafny.ISequence<byte>,Dafny.ISequence<byte>>(_21819_keyA,_21821_valA));
      Dafny.ISequence<byte> _21828_expectedSerializedAAD;
      _21828_expectedSerializedAAD = Dafny.Sequence<byte>.FromElements(0, 26, 0, 2, 0, 4, 107, 101, 121, 65, 0, 4, 118, 97, 108, 65, 0, 4, 107, 101, 121, 66, 0, 4, 118, 97, 108, 66);
      BigInteger _21829_len = BigInteger.Zero;
      Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>> _21830_valueOrError4 = Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>>.Default(BigInteger.Zero);
      Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>> _out355;
      _out355 = Serialize_Compile.__default.SerializeAAD(_21818_wr, _21827_encryptionContext);
      _21830_valueOrError4 = _out355;
      if (!(!((_21830_valueOrError4).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Serialize.dfy(28,12): " + _21830_valueOrError4);
      }
      _21829_len = (_21830_valueOrError4).Extract();
      if (!(((_21818_wr).GetDataWritten()).Equals((_21828_expectedSerializedAAD)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Serialize.dfy(29,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestSerializeAADEmpty()
    {
      Streams_Compile.ByteWriter _21831_wr;
      Streams_Compile.ByteWriter _nw96 = new Streams_Compile.ByteWriter();
      _nw96.__ctor();
      _21831_wr = _nw96;
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _21832_encryptionContext;
      _21832_encryptionContext = Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.FromElements();
      Dafny.ISequence<byte> _21833_expectedSerializedAAD;
      _21833_expectedSerializedAAD = Dafny.Sequence<byte>.FromElements(0, 0);
      BigInteger _21834_len = BigInteger.Zero;
      Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>> _21835_valueOrError0 = Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>>.Default(BigInteger.Zero);
      Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>> _out356;
      _out356 = Serialize_Compile.__default.SerializeAAD(_21831_wr, _21832_encryptionContext);
      _21835_valueOrError0 = _out356;
      if (!(!((_21835_valueOrError0).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Serialize.dfy(39,12): " + _21835_valueOrError0);
      }
      _21834_len = (_21835_valueOrError0).Extract();
      if (!(((_21831_wr).GetDataWritten()).Equals((_21833_expectedSerializedAAD)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Serialize.dfy(40,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestSerializeLargeValidEC()
    {
      Streams_Compile.ByteWriter _21836_wr;
      Streams_Compile.ByteWriter _nw97 = new Streams_Compile.ByteWriter();
      _nw97.__ctor();
      _21836_wr = _nw97;
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _21837_encCtx;
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _out357;
      _out357 = TestUtils.__default.GenerateLargeValidEncryptionContext();
      _21837_encCtx = _out357;
      BigInteger _21838_len = BigInteger.Zero;
      Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>> _21839_valueOrError0 = Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>>.Default(BigInteger.Zero);
      Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>> _out358;
      _out358 = Serialize_Compile.__default.SerializeAAD(_21836_wr, _21837_encCtx);
      _21839_valueOrError0 = _out358;
      if (!(!((_21839_valueOrError0).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Serialize.dfy(47,12): " + _21839_valueOrError0);
      }
      _21838_len = (_21839_valueOrError0).Extract();
      if (!((_21838_len) == ((new BigInteger(4)) + ((new BigInteger((_21837_encCtx).Count)) * (new BigInteger(7)))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Serialize.dfy(48,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestSerializeKVPairs()
    {
      Streams_Compile.ByteWriter _21840_wr;
      Streams_Compile.ByteWriter _nw98 = new Streams_Compile.ByteWriter();
      _nw98.__ctor();
      _21840_wr = _nw98;
      Dafny.ISequence<byte> _21841_keyA = UTF8.ValidUTF8Bytes.Default();
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _21842_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out359;
      _out359 = UTF8.__default.Encode(Dafny.Sequence<char>.FromString("keyA"));
      _21842_valueOrError0 = _out359;
      if (!(!((_21842_valueOrError0).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Serialize.dfy(53,13): " + _21842_valueOrError0);
      }
      _21841_keyA = (_21842_valueOrError0).Extract();
      Dafny.ISequence<byte> _21843_valA = UTF8.ValidUTF8Bytes.Default();
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _21844_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out360;
      _out360 = UTF8.__default.Encode(Dafny.Sequence<char>.FromString("valA"));
      _21844_valueOrError1 = _out360;
      if (!(!((_21844_valueOrError1).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Serialize.dfy(54,13): " + _21844_valueOrError1);
      }
      _21843_valA = (_21844_valueOrError1).Extract();
      Dafny.ISequence<byte> _21845_keyB = UTF8.ValidUTF8Bytes.Default();
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _21846_valueOrError2 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out361;
      _out361 = UTF8.__default.Encode(Dafny.Sequence<char>.FromString("keyB"));
      _21846_valueOrError2 = _out361;
      if (!(!((_21846_valueOrError2).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Serialize.dfy(55,13): " + _21846_valueOrError2);
      }
      _21845_keyB = (_21846_valueOrError2).Extract();
      Dafny.ISequence<byte> _21847_valB = UTF8.ValidUTF8Bytes.Default();
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _21848_valueOrError3 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out362;
      _out362 = UTF8.__default.Encode(Dafny.Sequence<char>.FromString("valB"));
      _21848_valueOrError3 = _out362;
      if (!(!((_21848_valueOrError3).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Serialize.dfy(56,13): " + _21848_valueOrError3);
      }
      _21847_valB = (_21848_valueOrError3).Extract();
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _21849_encryptionContext;
      _21849_encryptionContext = Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.FromElements(new Dafny.Pair<Dafny.ISequence<byte>,Dafny.ISequence<byte>>(_21845_keyB,_21847_valB), new Dafny.Pair<Dafny.ISequence<byte>,Dafny.ISequence<byte>>(_21841_keyA,_21843_valA));
      Dafny.ISequence<byte> _21850_expectedSerializedAAD;
      _21850_expectedSerializedAAD = Dafny.Sequence<byte>.FromElements(0, 2, 0, 4, 107, 101, 121, 65, 0, 4, 118, 97, 108, 65, 0, 4, 107, 101, 121, 66, 0, 4, 118, 97, 108, 66);
      BigInteger _21851_len = BigInteger.Zero;
      Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>> _21852_valueOrError4 = Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>>.Default(BigInteger.Zero);
      Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>> _out363;
      _out363 = Serialize_Compile.__default.SerializeKVPairs(_21840_wr, _21849_encryptionContext);
      _21852_valueOrError4 = _out363;
      if (!(!((_21852_valueOrError4).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Serialize.dfy(62,12): " + _21852_valueOrError4);
      }
      _21851_len = (_21852_valueOrError4).Extract();
      if (!(((_21840_wr).GetDataWritten()).Equals((_21850_expectedSerializedAAD)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Serialize.dfy(63,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestSerializeKVPairsEmpty()
    {
      Streams_Compile.ByteWriter _21853_wr;
      Streams_Compile.ByteWriter _nw99 = new Streams_Compile.ByteWriter();
      _nw99.__ctor();
      _21853_wr = _nw99;
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _21854_encryptionContext;
      _21854_encryptionContext = Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.FromElements();
      Dafny.ISequence<byte> _21855_expectedSerializedAAD;
      _21855_expectedSerializedAAD = Dafny.Sequence<byte>.FromElements();
      BigInteger _21856_len = BigInteger.Zero;
      Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>> _21857_valueOrError0 = Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>>.Default(BigInteger.Zero);
      Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>> _out364;
      _out364 = Serialize_Compile.__default.SerializeKVPairs(_21853_wr, _21854_encryptionContext);
      _21857_valueOrError0 = _out364;
      if (!(!((_21857_valueOrError0).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Serialize.dfy(73,12): " + _21857_valueOrError0);
      }
      _21856_len = (_21857_valueOrError0).Extract();
      if (!(((_21853_wr).GetDataWritten()).Equals((_21855_expectedSerializedAAD)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/SDK/Serialize.dfy(74,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
  }
} // end of namespace TestSerialize_Compile
namespace TestBase64_Compile {




  public partial class __default {
    [Xunit.Fact]
    public static void TestIsBase64CharSuccess()
    {
      if (!(Dafny.Helpers.Quantifier<char>((TestBase64_Compile.__default.BASE64__CHARS).UniqueElements, true, (((_21858_c) => {
        return !((TestBase64_Compile.__default.BASE64__CHARS).Contains((_21858_c))) || (Base64_Compile.__default.IsBase64Char(_21858_c));
      }))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/Base64.dfy(30,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestIsBase64CharFailure()
    {
      if (!(Dafny.Helpers.Quantifier<char>(Dafny.Helpers.AllChars(), true, (((_21859_c) => {
        return !(!(TestBase64_Compile.__default.BASE64__CHARS).Contains((_21859_c))) || (!(Base64_Compile.__default.IsBase64Char(_21859_c)));
      }))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/Base64.dfy(34,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestIsUnpaddedBase64StringSuccess()
    {
      if (!(Base64_Compile.__default.IsUnpaddedBase64String(Dafny.Sequence<char>.FromString("VGVz")))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/Base64.dfy(38,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestIsUnpaddedBase64StringTooShort()
    {
      if (!(!(Base64_Compile.__default.IsUnpaddedBase64String(Dafny.Sequence<char>.FromString("VGV"))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/Base64.dfy(42,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestIsUnpaddedBase64StringNotBase64()
    {
      if (!(!(Base64_Compile.__default.IsUnpaddedBase64String(Dafny.Sequence<char>.FromString("VGV$"))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/Base64.dfy(46,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestIndexToChar63()
    {
      if (!((Base64_Compile.__default.IndexToChar(63)) == ('/'))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/Base64.dfy(50,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestIndexToChar62()
    {
      if (!((Base64_Compile.__default.IndexToChar(62)) == ('+'))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/Base64.dfy(54,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestIndexToCharDigits()
    {
      Dafny.ISequence<char> _21860_digits;
      _21860_digits = Dafny.Sequence<char>.FromString("0123456789");
      if (!(Dafny.Helpers.Id<Func<Dafny.ISequence<char>, bool>>((_21861_digits) => Dafny.Helpers.Quantifier<byte>(Base64_Compile.index.IntegerRange(BigInteger.Zero, new BigInteger(64)), true, (((_21862_i) => {
        return !(((52) <= (_21862_i)) && ((_21862_i) <= (61))) || ((_21861_digits).Contains((Base64_Compile.__default.IndexToChar(_21862_i))));
      }))))(_21860_digits))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/Base64.dfy(59,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestIndexToCharLowercase()
    {
      Dafny.ISequence<char> _21863_lowercase;
      _21863_lowercase = Dafny.Sequence<char>.FromString("abcdefghijklmnopqrstuvwxyz");
      if (!(Dafny.Helpers.Id<Func<Dafny.ISequence<char>, bool>>((_21864_lowercase) => Dafny.Helpers.Quantifier<byte>(Base64_Compile.index.IntegerRange(BigInteger.Zero, new BigInteger(64)), true, (((_21865_i) => {
        return !(((26) <= (_21865_i)) && ((_21865_i) <= (51))) || ((_21864_lowercase).Contains((Base64_Compile.__default.IndexToChar(_21865_i))));
      }))))(_21863_lowercase))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/Base64.dfy(64,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestIndexToCharUppercase()
    {
      Dafny.ISequence<char> _21866_uppercase;
      _21866_uppercase = Dafny.Sequence<char>.FromString("ABCDEFGHIJKLMNOPQRSTUVWXYZ");
      if (!(Dafny.Helpers.Id<Func<Dafny.ISequence<char>, bool>>((_21867_uppercase) => Dafny.Helpers.Quantifier<byte>(Base64_Compile.index.IntegerRange(BigInteger.Zero, new BigInteger(64)), true, (((_21868_i) => {
        return !(((0) <= (_21868_i)) && ((_21868_i) <= (25))) || ((_21867_uppercase).Contains((Base64_Compile.__default.IndexToChar(_21868_i))));
      }))))(_21866_uppercase))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/Base64.dfy(69,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestCharToIndex63()
    {
      if (!((Base64_Compile.__default.CharToIndex('/')) == (63))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/Base64.dfy(73,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestCharToIndex62()
    {
      if (!((Base64_Compile.__default.CharToIndex('+')) == (62))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/Base64.dfy(77,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestCharToIndexDigits()
    {
      Dafny.ISequence<char> _21869_digits;
      _21869_digits = Dafny.Sequence<char>.FromString("0123456789");
      if (!(Dafny.Helpers.Id<Func<Dafny.ISequence<char>, bool>>((_21870_digits) => Dafny.Helpers.Quantifier<BigInteger>(Dafny.Helpers.IntegerRange(BigInteger.Zero, new BigInteger((_21870_digits).Count)), true, (((_21871_i) => {
        return !(((_21871_i).Sign != -1) && ((_21871_i) < (new BigInteger((_21870_digits).Count)))) || ((Base64_Compile.__default.CharToIndex((_21870_digits).Select(_21871_i))) == ((byte)((_21871_i) + (new BigInteger(52)))));
      }))))(_21869_digits))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/Base64.dfy(82,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestCharToIndexLowercase()
    {
      Dafny.ISequence<char> _21872_lowercase;
      _21872_lowercase = Dafny.Sequence<char>.FromString("abcdefghijklmnopqrstuvwxyz");
      if (!(Dafny.Helpers.Id<Func<Dafny.ISequence<char>, bool>>((_21873_lowercase) => Dafny.Helpers.Quantifier<BigInteger>(Dafny.Helpers.IntegerRange(BigInteger.Zero, new BigInteger((_21873_lowercase).Count)), true, (((_21874_i) => {
        return !(((_21874_i).Sign != -1) && ((_21874_i) < (new BigInteger((_21873_lowercase).Count)))) || ((Base64_Compile.__default.CharToIndex((_21873_lowercase).Select(_21874_i))) == ((byte)((_21874_i) + (new BigInteger(26)))));
      }))))(_21872_lowercase))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/Base64.dfy(87,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestCharToIndexUppercase()
    {
      Dafny.ISequence<char> _21875_uppercase;
      _21875_uppercase = Dafny.Sequence<char>.FromString("ABCDEFGHIJKLMNOPQRSTUVWXYZ");
      if (!(Dafny.Helpers.Id<Func<Dafny.ISequence<char>, bool>>((_21876_uppercase) => Dafny.Helpers.Quantifier<BigInteger>(Dafny.Helpers.IntegerRange(BigInteger.Zero, new BigInteger((_21876_uppercase).Count)), true, (((_21877_i) => {
        return !(((_21877_i).Sign != -1) && ((_21877_i) < (new BigInteger((_21876_uppercase).Count)))) || ((Base64_Compile.__default.CharToIndex((_21876_uppercase).Select(_21877_i))) == ((byte)(_21877_i)));
      }))))(_21875_uppercase))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/Base64.dfy(92,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestUInt24ToSeq()
    {
      uint _21878_input;
      _21878_input = 1048833U;
      Dafny.ISequence<byte> _21879_output;
      _21879_output = Dafny.Sequence<byte>.FromElements(16, 1, 1);
      if (!((_21879_output).Equals((Base64_Compile.__default.UInt24ToSeq(_21878_input))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/Base64.dfy(98,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestSeqToUInt24()
    {
      Dafny.ISequence<byte> _21880_input;
      _21880_input = Dafny.Sequence<byte>.FromElements(16, 1, 1);
      uint _21881_output;
      _21881_output = 1048833U;
      if (!((_21881_output) == (Base64_Compile.__default.SeqToUInt24(_21880_input)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/Base64.dfy(104,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestUInt24ToIndexSeq()
    {
      uint _21882_input;
      _21882_input = 1048833U;
      Dafny.ISequence<byte> _21883_output;
      _21883_output = Dafny.Sequence<byte>.FromElements(4, 0, 4, 1);
      if (!((_21883_output).Equals((Base64_Compile.__default.UInt24ToIndexSeq(_21882_input))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/Base64.dfy(110,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestIndexSeqToUInt24()
    {
      Dafny.ISequence<byte> _21884_input;
      _21884_input = Dafny.Sequence<byte>.FromElements(4, 0, 4, 1);
      uint _21885_output;
      _21885_output = 1048833U;
      if (!((_21885_output) == (Base64_Compile.__default.IndexSeqToUInt24(_21884_input)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/Base64.dfy(116,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestDecodeBlock()
    {
      Dafny.ISequence<byte> _21886_input;
      _21886_input = Dafny.Sequence<byte>.FromElements(4, 0, 4, 1);
      Dafny.ISequence<byte> _21887_output;
      _21887_output = Dafny.Sequence<byte>.FromElements(16, 1, 1);
      if (!((_21887_output).Equals((Base64_Compile.__default.DecodeBlock(_21886_input))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/Base64.dfy(122,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestEncodeBlock()
    {
      Dafny.ISequence<byte> _21888_input;
      _21888_input = Dafny.Sequence<byte>.FromElements(16, 1, 1);
      Dafny.ISequence<byte> _21889_output;
      _21889_output = Dafny.Sequence<byte>.FromElements(4, 0, 4, 1);
      if (!((_21889_output).Equals((Base64_Compile.__default.EncodeBlock(_21888_input))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/Base64.dfy(128,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestDecodeRecursively()
    {
      Dafny.ISequence<byte> _21890_input;
      _21890_input = Dafny.Sequence<byte>.FromElements(4, 0, 4, 1, 4, 0, 4, 1);
      Dafny.ISequence<byte> _21891_output;
      _21891_output = Dafny.Sequence<byte>.FromElements(16, 1, 1, 16, 1, 1);
      if (!((_21891_output).Equals((Base64_Compile.__default.DecodeRecursively(_21890_input))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/Base64.dfy(134,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestEncodeRecursively()
    {
      Dafny.ISequence<byte> _21892_input;
      _21892_input = Dafny.Sequence<byte>.FromElements(16, 1, 1, 16, 1, 1);
      Dafny.ISequence<byte> _21893_output;
      _21893_output = Dafny.Sequence<byte>.FromElements(4, 0, 4, 1, 4, 0, 4, 1);
      if (!((_21893_output).Equals((Base64_Compile.__default.EncodeRecursively(_21892_input))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/Base64.dfy(140,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestFromCharsToIndices()
    {
      Dafny.ISequence<char> _21894_input;
      _21894_input = Dafny.Sequence<char>.FromString("aA1+/");
      Dafny.ISequence<byte> _21895_output;
      _21895_output = Dafny.Sequence<byte>.FromElements(26, 0, 53, 62, 63);
      if (!((_21895_output).Equals((Base64_Compile.__default.FromCharsToIndices(_21894_input))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/Base64.dfy(146,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestFromIndicesToChars()
    {
      Dafny.ISequence<byte> _21896_input;
      _21896_input = Dafny.Sequence<byte>.FromElements(26, 0, 53, 62, 63);
      Dafny.ISequence<char> _21897_output;
      _21897_output = Dafny.Sequence<char>.FromString("aA1+/");
      if (!((_21897_output).Equals((Base64_Compile.__default.FromIndicesToChars(_21896_input))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/Base64.dfy(152,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestDecodeUnpadded()
    {
      Dafny.ISequence<char> _21898_input;
      _21898_input = Dafny.Sequence<char>.FromString("VGVzdGluZysx");
      Dafny.ISequence<byte> _21899_output;
      _21899_output = Dafny.Sequence<byte>.FromElements(84, 101, 115, 116, 105, 110, 103, 43, 49);
      if (!((_21899_output).Equals((Base64_Compile.__default.DecodeUnpadded(_21898_input))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/Base64.dfy(158,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestEncodeUnpadded()
    {
      Dafny.ISequence<byte> _21900_input;
      _21900_input = Dafny.Sequence<byte>.FromElements(84, 101, 115, 116, 105, 110, 103, 43, 49);
      Dafny.ISequence<char> _21901_output;
      _21901_output = Dafny.Sequence<char>.FromString("VGVzdGluZysx");
      if (!((_21901_output).Equals((Base64_Compile.__default.EncodeUnpadded(_21900_input))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/Base64.dfy(164,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestDecodeUnpaddedEmpty()
    {
      if (!((Dafny.Sequence<byte>.FromElements()).Equals((Base64_Compile.__default.DecodeUnpadded(Dafny.Sequence<char>.FromElements()))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/Base64.dfy(168,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestEncodeUnpaddedEmpty()
    {
      if (!((Dafny.Sequence<char>.FromElements()).Equals((Base64_Compile.__default.EncodeUnpadded(Dafny.Sequence<byte>.FromElements()))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/Base64.dfy(172,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestIs1PaddingSuccess()
    {
      if (!(Base64_Compile.__default.Is1Padding(Dafny.Sequence<char>.FromString("VGU=")))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/Base64.dfy(176,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestIs1PaddingTooShort()
    {
      if (!(!(Base64_Compile.__default.Is1Padding(Dafny.Sequence<char>.FromString("VG="))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/Base64.dfy(180,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestIs1PaddingTooLong()
    {
      if (!(!(Base64_Compile.__default.Is1Padding(Dafny.Sequence<char>.FromString("VGUU="))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/Base64.dfy(184,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestIs1PaddingInvalidChar0()
    {
      if (!(!(Base64_Compile.__default.Is1Padding(Dafny.Sequence<char>.FromString("$GU="))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/Base64.dfy(188,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestIs1PaddingInvalidChar1()
    {
      if (!(!(Base64_Compile.__default.Is1Padding(Dafny.Sequence<char>.FromString("V$U="))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/Base64.dfy(192,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestIs1PaddingInvalidChar2()
    {
      if (!(!(Base64_Compile.__default.Is1Padding(Dafny.Sequence<char>.FromString("VG$="))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/Base64.dfy(196,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestIs1PaddingInvalidChar3()
    {
      if (!(!(Base64_Compile.__default.Is1Padding(Dafny.Sequence<char>.FromString("VGVz"))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/Base64.dfy(200,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestIs1PaddingInvalidChar2Modulus()
    {
      if (!(!(Base64_Compile.__default.Is1Padding(Dafny.Sequence<char>.FromString("VGV="))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/Base64.dfy(204,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestDecode1Padding()
    {
      Dafny.ISequence<char> _21902_input;
      _21902_input = Dafny.Sequence<char>.FromString("VGU=");
      Dafny.ISequence<byte> _21903_output;
      _21903_output = Dafny.Sequence<byte>.FromElements(84, 101);
      if (!((_21903_output).Equals((Base64_Compile.__default.Decode1Padding(_21902_input))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/Base64.dfy(210,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestEncode1Padding()
    {
      Dafny.ISequence<byte> _21904_input;
      _21904_input = Dafny.Sequence<byte>.FromElements(84, 101);
      Dafny.ISequence<char> _21905_output;
      _21905_output = Dafny.Sequence<char>.FromString("VGU=");
      if (!((_21905_output).Equals((Base64_Compile.__default.Encode1Padding(_21904_input))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/Base64.dfy(216,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestIs2PaddingSuccess()
    {
      if (!(Base64_Compile.__default.Is2Padding(Dafny.Sequence<char>.FromString("VA==")))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/Base64.dfy(220,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestIs2PaddingTooShort()
    {
      if (!(!(Base64_Compile.__default.Is2Padding(Dafny.Sequence<char>.FromString("VA="))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/Base64.dfy(224,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestIs2PaddingTooLong()
    {
      if (!(!(Base64_Compile.__default.Is2Padding(Dafny.Sequence<char>.FromString("VAA=="))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/Base64.dfy(228,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestIs2PaddingInvalidChar0()
    {
      if (!(!(Base64_Compile.__default.Is2Padding(Dafny.Sequence<char>.FromString("$A=="))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/Base64.dfy(232,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestIs2PaddingInvalidChar1()
    {
      if (!(!(Base64_Compile.__default.Is2Padding(Dafny.Sequence<char>.FromString("V$=="))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/Base64.dfy(236,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestIs2PaddingInvalidChar2()
    {
      if (!(!(Base64_Compile.__default.Is2Padding(Dafny.Sequence<char>.FromString("VAA="))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/Base64.dfy(240,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestIs2PaddingInvalidChar3()
    {
      if (!(!(Base64_Compile.__default.Is2Padding(Dafny.Sequence<char>.FromString("VA=A"))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/Base64.dfy(244,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestIs2PaddingInvalidChar1Modulus()
    {
      if (!(!(Base64_Compile.__default.Is2Padding(Dafny.Sequence<char>.FromString("VB=="))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/Base64.dfy(248,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestDecode2Padding()
    {
      Dafny.ISequence<char> _21906_input;
      _21906_input = Dafny.Sequence<char>.FromString("VA==");
      Dafny.ISequence<byte> _21907_output;
      _21907_output = Dafny.Sequence<byte>.FromElements(84);
      if (!((_21907_output).Equals((Base64_Compile.__default.Decode2Padding(_21906_input))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/Base64.dfy(254,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestEncode2Padding()
    {
      Dafny.ISequence<byte> _21908_input;
      _21908_input = Dafny.Sequence<byte>.FromElements(84);
      Dafny.ISequence<char> _21909_output;
      _21909_output = Dafny.Sequence<char>.FromString("VA==");
      if (!((_21909_output).Equals((Base64_Compile.__default.Encode2Padding(_21908_input))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/Base64.dfy(260,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestIsBase64StringTestVectors()
    {
      if (!(Dafny.Helpers.Quantifier<Dafny.ISequence<char>>((TestBase64_Compile.__default.BASE64__TEST__VECTORS__ENCODED).UniqueElements, true, (((_21910_i) => {
        return !((TestBase64_Compile.__default.BASE64__TEST__VECTORS__ENCODED).Contains((_21910_i))) || ((Base64_Compile.__default.IsBase64String(_21910_i)) == (true));
      }))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/Base64.dfy(264,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestIsBase64StringBadLength()
    {
      if (!(!(Base64_Compile.__default.IsBase64String(Dafny.Sequence<char>.FromString("VG="))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/Base64.dfy(268,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestIsBase64StringBadString()
    {
      if (!(!(Base64_Compile.__default.IsBase64String(Dafny.Sequence<char>.FromString("VC=="))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/Base64.dfy(272,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestSanityCheckDecodedTestVectors()
    {
      BigInteger _21911_testVectorIndex;
      _21911_testVectorIndex = BigInteger.Zero;
      while ((_21911_testVectorIndex) < (new BigInteger((TestBase64_Compile.__default.BASE64__TEST__VECTORS__DECODED).Count))) {
        Dafny.ISequence<byte> _21912_uint8Message;
        _21912_uint8Message = Dafny.Sequence<byte>.FromElements();
        Dafny.ISequence<char> _21913_strMessage;
        _21913_strMessage = (TestBase64_Compile.__default.BASE64__TEST__VECTORS__DECODED).Select(_21911_testVectorIndex);
        BigInteger _21914_msgIndex;
        _21914_msgIndex = BigInteger.Zero;
        while ((_21914_msgIndex) < (new BigInteger((_21913_strMessage).Count))) {
          _21912_uint8Message = Dafny.Sequence<byte>.Concat(_21912_uint8Message, Dafny.Sequence<byte>.FromElements((byte)((_21913_strMessage).Select(_21914_msgIndex))));
          _21914_msgIndex = (_21914_msgIndex) + (BigInteger.One);
        }
        if (!(((TestBase64_Compile.__default.BASE64__TEST__VECTORS__DECODED__UINT8).Select(_21911_testVectorIndex)).Equals((_21912_uint8Message)))) {
          throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/Base64.dfy(290,6): " + Dafny.Sequence<char>.FromString("expectation violation"));
        }
        _21911_testVectorIndex = (_21911_testVectorIndex) + (BigInteger.One);
      }
    }
    [Xunit.Fact]
    public static void TestDecodeValidTestVectors()
    {
      if (!(Dafny.Helpers.Quantifier<BigInteger>(Dafny.Helpers.IntegerRange(BigInteger.Zero, new BigInteger((TestBase64_Compile.__default.BASE64__TEST__VECTORS__ENCODED).Count)), true, (((_21915_i) => {
        return !(((_21915_i).Sign != -1) && ((_21915_i) < (new BigInteger((TestBase64_Compile.__default.BASE64__TEST__VECTORS__ENCODED).Count)))) || ((Base64_Compile.__default.DecodeValid((TestBase64_Compile.__default.BASE64__TEST__VECTORS__ENCODED).Select(_21915_i))).Equals(((TestBase64_Compile.__default.BASE64__TEST__VECTORS__DECODED__UINT8).Select(_21915_i))));
      }))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/Base64.dfy(296,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestDecodeTestVectors()
    {
      if (!(Dafny.Helpers.Quantifier<BigInteger>(Dafny.Helpers.IntegerRange(BigInteger.Zero, new BigInteger((TestBase64_Compile.__default.BASE64__TEST__VECTORS__ENCODED).Count)), true, (((_21916_i) => {
        return !(((_21916_i).Sign != -1) && ((_21916_i) < (new BigInteger((TestBase64_Compile.__default.BASE64__TEST__VECTORS__ENCODED).Count)))) || (object.Equals(Base64_Compile.__default.Decode((TestBase64_Compile.__default.BASE64__TEST__VECTORS__ENCODED).Select(_21916_i)), @Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.create_Success((TestBase64_Compile.__default.BASE64__TEST__VECTORS__DECODED__UINT8).Select(_21916_i))));
      }))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/Base64.dfy(301,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestDecodeFailure()
    {
      if (!(object.Equals(@Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("The encoding is malformed")), Base64_Compile.__default.Decode(Dafny.Sequence<char>.FromString("$"))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/Base64.dfy(306,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestEncode()
    {
      if (!(Dafny.Helpers.Quantifier<BigInteger>(Dafny.Helpers.IntegerRange(BigInteger.Zero, new BigInteger((TestBase64_Compile.__default.BASE64__TEST__VECTORS__DECODED__UINT8).Count)), true, (((_21917_i) => {
        return !(((_21917_i).Sign != -1) && ((_21917_i) < (new BigInteger((TestBase64_Compile.__default.BASE64__TEST__VECTORS__DECODED__UINT8).Count)))) || ((Base64_Compile.__default.Encode((TestBase64_Compile.__default.BASE64__TEST__VECTORS__DECODED__UINT8).Select(_21917_i))).Equals(((TestBase64_Compile.__default.BASE64__TEST__VECTORS__ENCODED).Select(_21917_i))));
      }))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/Base64.dfy(310,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestEncodeDecode()
    {
      if (!(Dafny.Helpers.Quantifier<BigInteger>(Dafny.Helpers.IntegerRange(BigInteger.Zero, new BigInteger((TestBase64_Compile.__default.BASE64__TEST__VECTORS__DECODED__UINT8).Count)), true, (((_21918_i) => {
        return !(((_21918_i).Sign != -1) && ((_21918_i) < (new BigInteger((TestBase64_Compile.__default.BASE64__TEST__VECTORS__DECODED__UINT8).Count)))) || (object.Equals(Base64_Compile.__default.Decode(Base64_Compile.__default.Encode((TestBase64_Compile.__default.BASE64__TEST__VECTORS__DECODED__UINT8).Select(_21918_i))), @Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.create_Success((TestBase64_Compile.__default.BASE64__TEST__VECTORS__DECODED__UINT8).Select(_21918_i))));
      }))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/Base64.dfy(315,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestDecodeEncode()
    {
      if (!(Dafny.Helpers.Quantifier<BigInteger>(Dafny.Helpers.IntegerRange(BigInteger.Zero, new BigInteger((TestBase64_Compile.__default.BASE64__TEST__VECTORS__ENCODED).Count)), true, (((_21919_i) => {
        return !(((_21919_i).Sign != -1) && ((_21919_i) < (new BigInteger((TestBase64_Compile.__default.BASE64__TEST__VECTORS__ENCODED).Count)))) || (((Base64_Compile.__default.Decode((TestBase64_Compile.__default.BASE64__TEST__VECTORS__ENCODED).Select(_21919_i))).is_Success) && ((Base64_Compile.__default.Encode((Base64_Compile.__default.Decode((TestBase64_Compile.__default.BASE64__TEST__VECTORS__ENCODED).Select(_21919_i))).dtor_value)).Equals(((TestBase64_Compile.__default.BASE64__TEST__VECTORS__ENCODED).Select(_21919_i)))));
      }))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/Base64.dfy(320,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    public static Dafny.ISequence<Dafny.ISequence<byte>> BASE64__TEST__VECTORS__DECODED__UINT8 { get {
      return Dafny.Sequence<Dafny.ISequence<byte>>.FromElements(Dafny.Sequence<byte>.FromElements(), Dafny.Sequence<byte>.FromElements(84), Dafny.Sequence<byte>.FromElements(84, 101), Dafny.Sequence<byte>.FromElements(84, 101, 115), Dafny.Sequence<byte>.FromElements(84, 101, 115, 116), Dafny.Sequence<byte>.FromElements(84, 101, 115, 116, 105), Dafny.Sequence<byte>.FromElements(84, 101, 115, 116, 105, 110), Dafny.Sequence<byte>.FromElements(84, 101, 115, 116, 105, 110, 103), Dafny.Sequence<byte>.FromElements(84, 101, 115, 116, 105, 110, 103, 43), Dafny.Sequence<byte>.FromElements(84, 101, 115, 116, 105, 110, 103, 43, 49));
    } }
    public static Dafny.ISequence<Dafny.ISequence<char>> BASE64__TEST__VECTORS__ENCODED { get {
      return Dafny.Sequence<Dafny.ISequence<char>>.FromElements(Dafny.Sequence<char>.FromString(""), Dafny.Sequence<char>.FromString("VA=="), Dafny.Sequence<char>.FromString("VGU="), Dafny.Sequence<char>.FromString("VGVz"), Dafny.Sequence<char>.FromString("VGVzdA=="), Dafny.Sequence<char>.FromString("VGVzdGk="), Dafny.Sequence<char>.FromString("VGVzdGlu"), Dafny.Sequence<char>.FromString("VGVzdGluZw=="), Dafny.Sequence<char>.FromString("VGVzdGluZys="), Dafny.Sequence<char>.FromString("VGVzdGluZysx"));
    } }
    public static Dafny.ISequence<Dafny.ISequence<char>> BASE64__TEST__VECTORS__DECODED { get {
      return Dafny.Sequence<Dafny.ISequence<char>>.FromElements(Dafny.Sequence<char>.FromString(""), Dafny.Sequence<char>.FromString("T"), Dafny.Sequence<char>.FromString("Te"), Dafny.Sequence<char>.FromString("Tes"), Dafny.Sequence<char>.FromString("Test"), Dafny.Sequence<char>.FromString("Testi"), Dafny.Sequence<char>.FromString("Testin"), Dafny.Sequence<char>.FromString("Testing"), Dafny.Sequence<char>.FromString("Testing+"), Dafny.Sequence<char>.FromString("Testing+1"));
    } }
    public static Dafny.ISequence<char> BASE64__CHARS { get {
      return Dafny.Sequence<char>.FromString("+/0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz");
    } }
  }
} // end of namespace TestBase64_Compile
namespace TestStandardLibrary_Compile {



  public partial class __default {
    [Xunit.Fact]
    public static void TestJoinMultiElementSeq()
    {
      Dafny.ISequence<Dafny.ISequence<char>> _21920_input;
      _21920_input = Dafny.Sequence<Dafny.ISequence<char>>.FromElements(Dafny.Sequence<char>.FromString("comma"), Dafny.Sequence<char>.FromString("separated"), Dafny.Sequence<char>.FromString("list"));
      Dafny.ISequence<char> _21921_output;
      _21921_output = StandardLibrary_Compile.__default.Join<char>(_21920_input, Dafny.Sequence<char>.FromString(","));
      if (!((Dafny.Sequence<char>.FromString("comma,separated,list")).Equals((_21921_output)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/StandardLibrary.dfy(13,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestJoinSingleElementSeq()
    {
      Dafny.ISequence<Dafny.ISequence<char>> _21922_input;
      _21922_input = Dafny.Sequence<Dafny.ISequence<char>>.FromElements(Dafny.Sequence<char>.FromString("one"));
      Dafny.ISequence<char> _21923_output;
      _21923_output = StandardLibrary_Compile.__default.Join<char>(_21922_input, Dafny.Sequence<char>.FromString(","));
      if (!((Dafny.Sequence<char>.FromString("one")).Equals((_21923_output)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/StandardLibrary.dfy(19,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestJoinSplit()
    {
      Dafny.ISequence<char> _21924_input;
      _21924_input = Dafny.Sequence<char>.FromString("comma,separated,list");
      Dafny.ISequence<char> _21925_output;
      _21925_output = StandardLibrary_Compile.__default.Join<char>(StandardLibrary_Compile.__default.Split<char>(_21924_input, ','), Dafny.Sequence<char>.FromString(","));
      if (!((_21924_input).Equals((_21925_output)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/StandardLibrary.dfy(25,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestSplitJoin()
    {
      Dafny.ISequence<Dafny.ISequence<char>> _21926_input;
      _21926_input = Dafny.Sequence<Dafny.ISequence<char>>.FromElements(Dafny.Sequence<char>.FromString("comma"), Dafny.Sequence<char>.FromString("separated"), Dafny.Sequence<char>.FromString("list"));
      Dafny.ISequence<Dafny.ISequence<char>> _21927_output;
      _21927_output = StandardLibrary_Compile.__default.Split<char>(StandardLibrary_Compile.__default.Join<char>(_21926_input, Dafny.Sequence<char>.FromString(",")), ',');
      if (!((_21926_input).Equals((_21927_output)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/StandardLibrary.dfy(31,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestSplitByteSeq()
    {
      Dafny.ISequence<char> _21928_input;
      _21928_input = Dafny.Sequence<char>.FromString("comma,separated,list");
      Dafny.ISequence<Dafny.ISequence<char>> _21929_output;
      _21929_output = StandardLibrary_Compile.__default.Split<char>(_21928_input, ',');
      if (!((Dafny.Sequence<Dafny.ISequence<char>>.FromElements(Dafny.Sequence<char>.FromString("comma"), Dafny.Sequence<char>.FromString("separated"), Dafny.Sequence<char>.FromString("list"))).Equals((_21929_output)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/StandardLibrary.dfy(37,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestSplitNumSeq()
    {
      Dafny.ISequence<BigInteger> _21930_input;
      _21930_input = Dafny.Sequence<BigInteger>.FromElements(BigInteger.One, new BigInteger(2), new BigInteger(3), BigInteger.Zero, BigInteger.One, new BigInteger(2), new BigInteger(3));
      Dafny.ISequence<Dafny.ISequence<BigInteger>> _21931_output;
      _21931_output = StandardLibrary_Compile.__default.Split<BigInteger>(_21930_input, BigInteger.Zero);
      if (!((Dafny.Sequence<Dafny.ISequence<BigInteger>>.FromElements(Dafny.Sequence<BigInteger>.FromElements(BigInteger.One, new BigInteger(2), new BigInteger(3)), Dafny.Sequence<BigInteger>.FromElements(BigInteger.One, new BigInteger(2), new BigInteger(3)))).Equals((_21931_output)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/StandardLibrary.dfy(43,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestSplitFinalElementDelim()
    {
      Dafny.ISequence<char> _21932_input;
      _21932_input = Dafny.Sequence<char>.FromString("one,");
      Dafny.ISequence<Dafny.ISequence<char>> _21933_output;
      _21933_output = StandardLibrary_Compile.__default.Split<char>(_21932_input, ',');
      if (!((Dafny.Sequence<Dafny.ISequence<char>>.FromElements(Dafny.Sequence<char>.FromString("one"), Dafny.Sequence<char>.FromString(""))).Equals((_21933_output)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/StandardLibrary.dfy(49,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestSplitNoDelim()
    {
      Dafny.ISequence<char> _21934_input;
      _21934_input = Dafny.Sequence<char>.FromString("no comma");
      Dafny.ISequence<Dafny.ISequence<char>> _21935_output;
      _21935_output = StandardLibrary_Compile.__default.Split<char>(_21934_input, ',');
      if (!((Dafny.Sequence<Dafny.ISequence<char>>.FromElements(Dafny.Sequence<char>.FromString("no comma"))).Equals((_21935_output)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/StandardLibrary.dfy(55,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestSplitOnlyElemIsDelim()
    {
      Dafny.ISequence<char> _21936_input;
      _21936_input = Dafny.Sequence<char>.FromString(",");
      Dafny.ISequence<Dafny.ISequence<char>> _21937_output;
      _21937_output = StandardLibrary_Compile.__default.Split<char>(_21936_input, ',');
      if (!((Dafny.Sequence<Dafny.ISequence<char>>.FromElements(Dafny.Sequence<char>.FromString(""), Dafny.Sequence<char>.FromString(""))).Equals((_21937_output)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/StandardLibrary.dfy(61,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestSplitEmpty()
    {
      Dafny.ISequence<char> _21938_input;
      _21938_input = Dafny.Sequence<char>.FromString("");
      Dafny.ISequence<Dafny.ISequence<char>> _21939_output;
      _21939_output = StandardLibrary_Compile.__default.Split<char>(_21938_input, ',');
      if (!((Dafny.Sequence<Dafny.ISequence<char>>.FromElements(Dafny.Sequence<char>.FromString(""))).Equals((_21939_output)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/StandardLibrary.dfy(67,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestFindIndexMatchingSimple()
    {
      Dafny.ISequence<char> _21940_input;
      _21940_input = Dafny.Sequence<char>.FromString("abcd");
      Wrappers_Compile.Option<BigInteger> _21941_output;
      _21941_output = StandardLibrary_Compile.__default.FindIndexMatching<char>(_21940_input, 'c', BigInteger.Zero);
      if (!(object.Equals(@Wrappers_Compile.Option<BigInteger>.create_Some(new BigInteger(2)), _21941_output))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/StandardLibrary.dfy(73,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestFindIndexMatchingDuplicates()
    {
      Dafny.ISequence<char> _21942_input;
      _21942_input = Dafny.Sequence<char>.FromString("abcdc");
      Wrappers_Compile.Option<BigInteger> _21943_output;
      _21943_output = StandardLibrary_Compile.__default.FindIndexMatching<char>(_21942_input, 'c', BigInteger.Zero);
      if (!(object.Equals(@Wrappers_Compile.Option<BigInteger>.create_Some(new BigInteger(2)), _21943_output))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/StandardLibrary.dfy(79,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestFindIndexMatchingNone()
    {
      Dafny.ISequence<char> _21944_input;
      _21944_input = Dafny.Sequence<char>.FromString("abcd");
      Wrappers_Compile.Option<BigInteger> _21945_output;
      _21945_output = StandardLibrary_Compile.__default.FindIndexMatching<char>(_21944_input, 'e', BigInteger.Zero);
      if (!(object.Equals(@Wrappers_Compile.Option<BigInteger>.create_None(), _21945_output))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/StandardLibrary.dfy(85,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestFindIndexSimple()
    {
      Dafny.ISequence<char> _21946_input;
      _21946_input = Dafny.Sequence<char>.FromString("abcd");
      Wrappers_Compile.Option<BigInteger> _21947_output;
      _21947_output = StandardLibrary_Compile.__default.FindIndex<char>(_21946_input, ((System.Func<char, bool>)((_21948_x) => {
        return (_21948_x) == ('c');
      })), BigInteger.Zero);
      if (!(object.Equals(@Wrappers_Compile.Option<BigInteger>.create_Some(new BigInteger(2)), _21947_output))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/StandardLibrary.dfy(92,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestFindIndexComplex()
    {
      Dafny.ISequence<char> _21949_input;
      _21949_input = Dafny.Sequence<char>.FromString("abcd");
      Wrappers_Compile.Option<BigInteger> _21950_output;
      _21950_output = StandardLibrary_Compile.__default.FindIndex<char>(_21949_input, ((System.Func<char, bool>)((_21951_x) => {
        return (Dafny.Sequence<char>.FromString("crepe")).Contains((_21951_x));
      })), BigInteger.Zero);
      if (!(object.Equals(@Wrappers_Compile.Option<BigInteger>.create_Some(new BigInteger(2)), _21950_output))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/StandardLibrary.dfy(99,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestFindIndexDuplicates()
    {
      Dafny.ISequence<char> _21952_input;
      _21952_input = Dafny.Sequence<char>.FromString("abcdc");
      Wrappers_Compile.Option<BigInteger> _21953_output;
      _21953_output = StandardLibrary_Compile.__default.FindIndex<char>(_21952_input, ((System.Func<char, bool>)((_21954_x) => {
        return (_21954_x) == ('c');
      })), BigInteger.Zero);
      if (!(object.Equals(@Wrappers_Compile.Option<BigInteger>.create_Some(new BigInteger(2)), _21953_output))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/StandardLibrary.dfy(106,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestFindIndexNone()
    {
      Dafny.ISequence<char> _21955_input;
      _21955_input = Dafny.Sequence<char>.FromString("abcd");
      Wrappers_Compile.Option<BigInteger> _21956_output;
      _21956_output = StandardLibrary_Compile.__default.FindIndex<char>(_21955_input, ((System.Func<char, bool>)((_21957_x) => {
        return false;
      })), BigInteger.Zero);
      if (!(object.Equals(@Wrappers_Compile.Option<BigInteger>.create_None(), _21956_output))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/StandardLibrary.dfy(113,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    public static bool TestFilterPredicate(Dafny.ISequence<char> entry) {
      return (Dafny.Sequence<Dafny.ISequence<char>>.FromElements(Dafny.Sequence<char>.FromString("a"))).Contains((entry));
    }
    [Xunit.Fact]
    public static void TestFilterSomeValid()
    {
      Dafny.ISequence<Dafny.ISequence<char>> _21958_input;
      _21958_input = Dafny.Sequence<Dafny.ISequence<char>>.FromElements(Dafny.Sequence<char>.FromString("a"), Dafny.Sequence<char>.FromString("b"), Dafny.Sequence<char>.FromString("a"));
      Dafny.ISequence<Dafny.ISequence<char>> _21959_output;
      _21959_output = StandardLibrary_Compile.__default.Filter<Dafny.ISequence<char>>(_21958_input, TestStandardLibrary_Compile.__default.TestFilterPredicate);
      if (!((Dafny.Sequence<Dafny.ISequence<char>>.FromElements(Dafny.Sequence<char>.FromString("a"), Dafny.Sequence<char>.FromString("a"))).Equals((_21959_output)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/StandardLibrary.dfy(123,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestFilterNoneValid()
    {
      Dafny.ISequence<Dafny.ISequence<char>> _21960_input;
      _21960_input = Dafny.Sequence<Dafny.ISequence<char>>.FromElements(Dafny.Sequence<char>.FromString("c"), Dafny.Sequence<char>.FromString("b"), Dafny.Sequence<char>.FromString("c"));
      Dafny.ISequence<Dafny.ISequence<char>> _21961_output;
      _21961_output = StandardLibrary_Compile.__default.Filter<Dafny.ISequence<char>>(_21960_input, TestStandardLibrary_Compile.__default.TestFilterPredicate);
      if (!((Dafny.Sequence<Dafny.ISequence<char>>.FromElements()).Equals((_21961_output)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/StandardLibrary.dfy(129,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestFilterNothing()
    {
      Dafny.ISequence<Dafny.ISequence<char>> _21962_input;
      _21962_input = Dafny.Sequence<Dafny.ISequence<char>>.FromElements();
      Dafny.ISequence<Dafny.ISequence<char>> _21963_output;
      _21963_output = StandardLibrary_Compile.__default.Filter<Dafny.ISequence<char>>(_21962_input, TestStandardLibrary_Compile.__default.TestFilterPredicate);
      if (!((Dafny.Sequence<Dafny.ISequence<char>>.FromElements()).Equals((_21963_output)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/StandardLibrary.dfy(135,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestFillZero()
    {
      Dafny.ISequence<BigInteger> _21964_output;
      _21964_output = StandardLibrary_Compile.__default.Fill<BigInteger>(BigInteger.Zero, new BigInteger(50));
      if (!((((System.Func<Dafny.ISequence<BigInteger>>) (() => {
        BigInteger dim55 = new BigInteger(50);
        var arr55 = new BigInteger[Dafny.Helpers.ToIntChecked(dim55,"C# array size must not be larger than max 32-bit int")];
        for (int i55 = 0; i55 < dim55; i55++) {
          var _21965___v0 = (BigInteger) i55;
          arr55[(int)(_21965___v0)] = BigInteger.Zero;
        }
        return Dafny.Sequence<BigInteger>.FromArray(arr55);
      }))()).Equals((_21964_output)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/StandardLibrary.dfy(140,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestFillChars()
    {
      Dafny.ISequence<Dafny.ISequence<char>> _21966_output;
      _21966_output = StandardLibrary_Compile.__default.Fill<Dafny.ISequence<char>>(Dafny.Sequence<char>.FromString("a"), new BigInteger(25));
      if (!((((System.Func<Dafny.ISequence<Dafny.ISequence<char>>>) (() => {
        BigInteger dim56 = new BigInteger(25);
        var arr56 = new Dafny.ISequence<char>[Dafny.Helpers.ToIntChecked(dim56,"C# array size must not be larger than max 32-bit int")];
        for (int i56 = 0; i56 < dim56; i56++) {
          var _21967___v1 = (BigInteger) i56;
          arr56[(int)(_21967___v1)] = Dafny.Sequence<char>.FromString("a");
        }
        return Dafny.Sequence<Dafny.ISequence<char>>.FromArray(arr56);
      }))()).Equals((_21966_output)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/StandardLibrary.dfy(145,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestMinPositives()
    {
      if (!((BigInteger.One) == (StandardLibrary_Compile.__default.Min(BigInteger.One, new BigInteger(2))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/StandardLibrary.dfy(149,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestMinNegatives()
    {
      if (!((new BigInteger(-2)) == (StandardLibrary_Compile.__default.Min(new BigInteger(-1), new BigInteger(-2))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/StandardLibrary.dfy(153,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestMinPositivesNegatives()
    {
      if (!((new BigInteger(-1)) == (StandardLibrary_Compile.__default.Min(new BigInteger(-1), BigInteger.One)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/StandardLibrary.dfy(157,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestMinDuplicateNumber()
    {
      if (!((StandardLibrary_Compile.__default.Min(BigInteger.Zero, BigInteger.Zero)).Sign == 0)) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/StandardLibrary.dfy(161,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestSeqToArray()
    {
      Dafny.ISequence<BigInteger> _21968_input;
      _21968_input = Dafny.Sequence<BigInteger>.FromElements(BigInteger.One, new BigInteger(2), new BigInteger(3));
      BigInteger[] _21969_output;
      BigInteger[] _out365;
      _out365 = StandardLibrary_Compile.__default.SeqToArray<BigInteger>(_21968_input);
      _21969_output = _out365;
      BigInteger[] _21970_expected;
      BigInteger[] _nw100 = new BigInteger[Dafny.Helpers.ToIntChecked(Dafny.Helpers.ToIntChecked(new BigInteger(3), "C# arrays may not be larger than the max 32-bit integer"),"C# array size must not be larger than max 32-bit int")];
      Func<BigInteger, BigInteger> _arrayinit3 = ((System.Func<BigInteger, BigInteger>)((_21971_i) => {
        return (_21971_i) + (BigInteger.One);
      }));
      for (var _arrayinit_03 = 0; _arrayinit_03 < new BigInteger(_nw100.Length); _arrayinit_03++) {
        _nw100[(int)(_arrayinit_03)] = _arrayinit3(_arrayinit_03);
      }
      _21970_expected = _nw100;
      if (!((new BigInteger((_21970_expected).Length)) == (new BigInteger((_21969_output).Length)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/StandardLibrary.dfy(172,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!(((_21970_expected)[(int)(BigInteger.Zero)]) == ((_21969_output)[(int)(BigInteger.Zero)]))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/StandardLibrary.dfy(173,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!(((_21970_expected)[(int)(BigInteger.One)]) == ((_21969_output)[(int)(BigInteger.One)]))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/StandardLibrary.dfy(174,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!(((_21970_expected)[(int)(new BigInteger(2))]) == ((_21969_output)[(int)(new BigInteger(2))]))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/StandardLibrary.dfy(175,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestSeqToArrayEmpty()
    {
      Dafny.ISequence<char> _21972_input;
      _21972_input = Dafny.Sequence<char>.FromElements();
      char[] _21973_output;
      char[] _out366;
      _out366 = StandardLibrary_Compile.__default.SeqToArray<char>(_21972_input);
      _21973_output = _out366;
      if (!((new BigInteger((_21973_output).Length)).Sign == 0)) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/StandardLibrary.dfy(181,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    public static bool TestStandardLibraryLessPredicate(BigInteger a, BigInteger b)
    {
      return (a) < (b);
    }
    [Xunit.Fact]
    public static void TestLexicographicLessOrEqualTrue()
    {
      Dafny.ISequence<BigInteger> _21974_a;
      _21974_a = Dafny.Sequence<BigInteger>.FromElements(BigInteger.One, new BigInteger(2), new BigInteger(3));
      Dafny.ISequence<BigInteger> _21975_b;
      _21975_b = Dafny.Sequence<BigInteger>.FromElements(BigInteger.One, new BigInteger(2), new BigInteger(4));
      if (!(StandardLibrary_Compile.__default.LexicographicLessOrEqual<BigInteger>(_21974_a, _21975_b, TestStandardLibrary_Compile.__default.TestStandardLibraryLessPredicate))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/StandardLibrary.dfy(189,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestLexicographicLessOrEqualFalse()
    {
      Dafny.ISequence<BigInteger> _21976_a;
      _21976_a = Dafny.Sequence<BigInteger>.FromElements(BigInteger.One, new BigInteger(2), new BigInteger(3));
      Dafny.ISequence<BigInteger> _21977_b;
      _21977_b = Dafny.Sequence<BigInteger>.FromElements(BigInteger.One, new BigInteger(2), new BigInteger(4));
      if (!(!(StandardLibrary_Compile.__default.LexicographicLessOrEqual<BigInteger>(_21977_b, _21976_a, TestStandardLibrary_Compile.__default.TestStandardLibraryLessPredicate)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/StandardLibrary.dfy(195,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestLexicographicLessOrEqualAllEqual()
    {
      Dafny.ISequence<BigInteger> _21978_a;
      _21978_a = Dafny.Sequence<BigInteger>.FromElements(BigInteger.One, new BigInteger(2), new BigInteger(3));
      Dafny.ISequence<BigInteger> _21979_b;
      _21979_b = Dafny.Sequence<BigInteger>.FromElements(BigInteger.One, new BigInteger(2), new BigInteger(3));
      if (!(StandardLibrary_Compile.__default.LexicographicLessOrEqual<BigInteger>(_21978_a, _21979_b, TestStandardLibrary_Compile.__default.TestStandardLibraryLessPredicate))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/StandardLibrary.dfy(201,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestLexicographicLessOrEqualNoneEqual()
    {
      Dafny.ISequence<BigInteger> _21980_a;
      _21980_a = Dafny.Sequence<BigInteger>.FromElements(BigInteger.One);
      Dafny.ISequence<BigInteger> _21981_b;
      _21981_b = Dafny.Sequence<BigInteger>.FromElements(new BigInteger(2));
      if (!(StandardLibrary_Compile.__default.LexicographicLessOrEqual<BigInteger>(_21980_a, _21981_b, TestStandardLibrary_Compile.__default.TestStandardLibraryLessPredicate))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/StandardLibrary.dfy(207,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestLexicographicLessOrEqualEmpty()
    {
      Dafny.ISequence<BigInteger> _21982_a;
      _21982_a = Dafny.Sequence<BigInteger>.FromElements();
      Dafny.ISequence<BigInteger> _21983_b;
      _21983_b = Dafny.Sequence<BigInteger>.FromElements();
      if (!(StandardLibrary_Compile.__default.LexicographicLessOrEqual<BigInteger>(_21982_a, _21983_b, TestStandardLibrary_Compile.__default.TestStandardLibraryLessPredicate))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/StandardLibrary.dfy(213,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
  }
} // end of namespace TestStandardLibrary_Compile
namespace TestUInt_Compile {


  public partial class __default {
    [Xunit.Fact]
    public static void TestUInt16ToSeq()
    {
      ushort _21984_x;
      _21984_x = 290;
      if (!((Dafny.Sequence<byte>.FromElements(1, 34)).Equals((StandardLibrary_mUInt_Compile.__default.UInt16ToSeq(_21984_x))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/UInt.dfy(12,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestSeqToUInt16()
    {
      Dafny.ISequence<byte> _21985_s;
      _21985_s = Dafny.Sequence<byte>.FromElements(1, 34);
      if (!(((ushort)(290)) == (StandardLibrary_mUInt_Compile.__default.SeqToUInt16(_21985_s)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/UInt.dfy(17,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestUInt32ToSeq()
    {
      uint _21986_x;
      _21986_x = 16920644U;
      if (!((Dafny.Sequence<byte>.FromElements(1, 2, 48, 68)).Equals((StandardLibrary_mUInt_Compile.__default.UInt32ToSeq(_21986_x))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/UInt.dfy(22,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestSeqToUInt32()
    {
      Dafny.ISequence<byte> _21987_s;
      _21987_s = Dafny.Sequence<byte>.FromElements(1, 2, 48, 68);
      if (!(((uint)(16920644U)) == (StandardLibrary_mUInt_Compile.__default.SeqToUInt32(_21987_s)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/UInt.dfy(27,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestUInt64ToSeq()
    {
      ulong _21988_x;
      _21988_x = 72673614040037256UL;
      if (!((Dafny.Sequence<byte>.FromElements(1, 2, 48, 68, 85, 102, 119, 136)).Equals((StandardLibrary_mUInt_Compile.__default.UInt64ToSeq(_21988_x))))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/UInt.dfy(32,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestSeqToUInt64()
    {
      Dafny.ISequence<byte> _21989_s;
      _21989_s = Dafny.Sequence<byte>.FromElements(1, 2, 48, 68, 85, 102, 119, 136);
      if (!(((ulong)(72673614040037256UL)) == (StandardLibrary_mUInt_Compile.__default.SeqToUInt64(_21989_s)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/StandardLibrary/UInt.dfy(37,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
  }
} // end of namespace TestUInt_Compile
namespace TestSeqReaderReadElements_Compile {




  public partial class __default {
    [Xunit.Fact]
    public static void TestSetToOrderedSequenceEmpty()
    {
      Dafny.ISequence<Dafny.ISequence<byte>> _21990_output;
      Dafny.ISequence<Dafny.ISequence<byte>> _out367;
      _out367 = Sets.__default.SetToOrderedSequence<byte>(Dafny.Set<Dafny.ISequence<byte>>.FromElements(), StandardLibrary_mUInt_Compile.__default.UInt8Less);
      _21990_output = _out367;
      Dafny.ISequence<Dafny.ISequence<byte>> _21991_expected;
      _21991_expected = Dafny.Sequence<Dafny.ISequence<byte>>.FromElements();
      if (!((_21990_output).Equals((_21991_expected)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/Sets.dfy(15,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestSetToOrderedSequenceOneItem()
    {
      Dafny.ISet<Dafny.ISequence<byte>> _21992_a;
      _21992_a = Dafny.Set<Dafny.ISequence<byte>>.FromElements(Dafny.Sequence<byte>.FromElements(0));
      Dafny.ISequence<Dafny.ISequence<byte>> _21993_output;
      Dafny.ISequence<Dafny.ISequence<byte>> _out368;
      _out368 = Sets.__default.SetToOrderedSequence<byte>(_21992_a, StandardLibrary_mUInt_Compile.__default.UInt8Less);
      _21993_output = _out368;
      Dafny.ISequence<Dafny.ISequence<byte>> _21994_expected;
      _21994_expected = Dafny.Sequence<Dafny.ISequence<byte>>.FromElements(Dafny.Sequence<byte>.FromElements(0));
      if (!((_21993_output).Equals((_21994_expected)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/Sets.dfy(22,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestSetToOrderedSequenceSimple()
    {
      Dafny.ISet<Dafny.ISequence<byte>> _21995_a;
      _21995_a = Dafny.Set<Dafny.ISequence<byte>>.FromElements(Dafny.Sequence<byte>.FromElements(0, 2), Dafny.Sequence<byte>.FromElements(0, 1));
      Dafny.ISequence<Dafny.ISequence<byte>> _21996_output;
      Dafny.ISequence<Dafny.ISequence<byte>> _out369;
      _out369 = Sets.__default.SetToOrderedSequence<byte>(_21995_a, StandardLibrary_mUInt_Compile.__default.UInt8Less);
      _21996_output = _out369;
      Dafny.ISequence<Dafny.ISequence<byte>> _21997_expected;
      _21997_expected = Dafny.Sequence<Dafny.ISequence<byte>>.FromElements(Dafny.Sequence<byte>.FromElements(0, 1), Dafny.Sequence<byte>.FromElements(0, 2));
      if (!((_21996_output).Equals((_21997_expected)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/Sets.dfy(29,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestSetToOrderedSequencePrefix()
    {
      Dafny.ISet<Dafny.ISequence<byte>> _21998_a;
      _21998_a = Dafny.Set<Dafny.ISequence<byte>>.FromElements(Dafny.Sequence<byte>.FromElements(0, 1, 2), Dafny.Sequence<byte>.FromElements(0, 1));
      Dafny.ISequence<Dafny.ISequence<byte>> _21999_output;
      Dafny.ISequence<Dafny.ISequence<byte>> _out370;
      _out370 = Sets.__default.SetToOrderedSequence<byte>(_21998_a, StandardLibrary_mUInt_Compile.__default.UInt8Less);
      _21999_output = _out370;
      Dafny.ISequence<Dafny.ISequence<byte>> _22000_expected;
      _22000_expected = Dafny.Sequence<Dafny.ISequence<byte>>.FromElements(Dafny.Sequence<byte>.FromElements(0, 1), Dafny.Sequence<byte>.FromElements(0, 1, 2));
      if (!((_21999_output).Equals((_22000_expected)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/Sets.dfy(36,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestSetToOrderedSequenceComplex()
    {
      Dafny.ISet<Dafny.ISequence<byte>> _22001_a;
      _22001_a = Dafny.Set<Dafny.ISequence<byte>>.FromElements(Dafny.Sequence<byte>.FromElements(0, 1, 2), Dafny.Sequence<byte>.FromElements(1, 1, 2), Dafny.Sequence<byte>.FromElements(0, 1));
      Dafny.ISequence<Dafny.ISequence<byte>> _22002_output;
      Dafny.ISequence<Dafny.ISequence<byte>> _out371;
      _out371 = Sets.__default.SetToOrderedSequence<byte>(_22001_a, StandardLibrary_mUInt_Compile.__default.UInt8Less);
      _22002_output = _out371;
      Dafny.ISequence<Dafny.ISequence<byte>> _22003_expected;
      _22003_expected = Dafny.Sequence<Dafny.ISequence<byte>>.FromElements(Dafny.Sequence<byte>.FromElements(0, 1), Dafny.Sequence<byte>.FromElements(0, 1, 2), Dafny.Sequence<byte>.FromElements(1, 1, 2));
      if (!((_22002_output).Equals((_22003_expected)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/Sets.dfy(43,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestSetToOrderedSequenceManyItems()
    {
      Dafny.ISet<Dafny.ISequence<byte>> _22004_a;
      _22004_a = ((System.Func<Dafny.ISet<Dafny.ISequence<byte>>>)(() => {
        var _coll4 = new System.Collections.Generic.List<Dafny.ISequence<byte>>();
        foreach (ushort _compr_4 in StandardLibrary_mUInt_Compile.uint16.IntegerRange(BigInteger.Zero, new BigInteger(65536))) {
          ushort _22005_x = (ushort)_compr_4;
          if (((0) <= (_22005_x)) && ((_22005_x) < (65535))) {
            _coll4.Add(StandardLibrary_mUInt_Compile.__default.UInt16ToSeq(_22005_x));
          }
        }
        return Dafny.Set<Dafny.ISequence<byte>>.FromCollection(_coll4);
      }))();
      Dafny.ISequence<Dafny.ISequence<byte>> _22006_output;
      Dafny.ISequence<Dafny.ISequence<byte>> _out372;
      _out372 = Sets.__default.SetToOrderedSequence<byte>(_22004_a, StandardLibrary_mUInt_Compile.__default.UInt8Less);
      _22006_output = _out372;
      Dafny.ISequence<Dafny.ISequence<byte>> _22007_expected;
      _22007_expected = ((System.Func<Dafny.ISequence<Dafny.ISequence<byte>>>) (() => {
        BigInteger dim57 = new BigInteger(65535);
        var arr57 = new Dafny.ISequence<byte>[Dafny.Helpers.ToIntChecked(dim57,"C# array size must not be larger than max 32-bit int")];
        for (int i57 = 0; i57 < dim57; i57++) {
          var _22008_i = (BigInteger) i57;
          arr57[(int)(_22008_i)] = StandardLibrary_mUInt_Compile.__default.UInt16ToSeq((ushort)(_22008_i));
        }
        return Dafny.Sequence<Dafny.ISequence<byte>>.FromArray(arr57);
      }))();
      if (!((_22006_output).Equals((_22007_expected)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/Sets.dfy(50,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
  }
} // end of namespace TestSeqReaderReadElements_Compile
namespace TestStreams_Compile {



  public partial class __default {
    [Xunit.Fact]
    public static void TestSeqReaderReadElements()
    {
      Dafny.ISequence<BigInteger> _22009_s;
      _22009_s = Dafny.Sequence<BigInteger>.FromElements(BigInteger.Zero, new BigInteger(100), new BigInteger(200), new BigInteger(300), new BigInteger(400));
      Streams_Compile.SeqReader<BigInteger> _22010_reader;
      Streams_Compile.SeqReader<BigInteger> _nw101 = new Streams_Compile.SeqReader<BigInteger>();
      _nw101.__ctor(_22009_s);
      _22010_reader = _nw101;
      Dafny.ISequence<BigInteger> _22011_res;
      Dafny.ISequence<BigInteger> _out373;
      _out373 = (_22010_reader).ReadElements(new BigInteger(3));
      _22011_res = _out373;
      if (!((Dafny.Sequence<BigInteger>.FromElements(BigInteger.Zero, new BigInteger(100), new BigInteger(200))).Equals((_22011_res)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/Streams.dfy(16,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      Dafny.ISequence<BigInteger> _out374;
      _out374 = (_22010_reader).ReadElements(BigInteger.Zero);
      _22011_res = _out374;
      if (!((Dafny.Sequence<BigInteger>.FromElements()).Equals((_22011_res)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/Streams.dfy(19,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      Dafny.ISequence<BigInteger> _out375;
      _out375 = (_22010_reader).ReadElements(new BigInteger(2));
      _22011_res = _out375;
      if (!((Dafny.Sequence<BigInteger>.FromElements(new BigInteger(300), new BigInteger(400))).Equals((_22011_res)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/Streams.dfy(22,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestSeqReaderReadExact()
    {
      Dafny.ISequence<BigInteger> _22012_s;
      _22012_s = Dafny.Sequence<BigInteger>.FromElements(BigInteger.Zero, new BigInteger(100), new BigInteger(200), new BigInteger(300), new BigInteger(400));
      Streams_Compile.SeqReader<BigInteger> _22013_reader;
      Streams_Compile.SeqReader<BigInteger> _nw102 = new Streams_Compile.SeqReader<BigInteger>();
      _nw102.__ctor(_22012_s);
      _22013_reader = _nw102;
      Dafny.ISequence<BigInteger> _22014_res = Dafny.Sequence<BigInteger>.Empty;
      Wrappers_Compile.Result<Dafny.ISequence<BigInteger>, Dafny.ISequence<char>> _22015_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<BigInteger>, Dafny.ISequence<char>>.Default(Dafny.Sequence<BigInteger>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<BigInteger>, Dafny.ISequence<char>> _out376;
      _out376 = (_22013_reader).ReadExact(new BigInteger(3));
      _22015_valueOrError0 = _out376;
      if (!(!((_22015_valueOrError0).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/Streams.dfy(29,12): " + _22015_valueOrError0);
      }
      _22014_res = (_22015_valueOrError0).Extract();
      if (!((Dafny.Sequence<BigInteger>.FromElements(BigInteger.Zero, new BigInteger(100), new BigInteger(200))).Equals((_22014_res)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/Streams.dfy(30,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      Wrappers_Compile.Result<Dafny.ISequence<BigInteger>, Dafny.ISequence<char>> _22016_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<BigInteger>, Dafny.ISequence<char>>.Default(Dafny.Sequence<BigInteger>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<BigInteger>, Dafny.ISequence<char>> _out377;
      _out377 = (_22013_reader).ReadExact(BigInteger.Zero);
      _22016_valueOrError1 = _out377;
      if (!(!((_22016_valueOrError1).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/Streams.dfy(32,8): " + _22016_valueOrError1);
      }
      _22014_res = (_22016_valueOrError1).Extract();
      if (!((Dafny.Sequence<BigInteger>.FromElements()).Equals((_22014_res)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/Streams.dfy(33,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      Wrappers_Compile.Result<Dafny.ISequence<BigInteger>, Dafny.ISequence<char>> _22017_valueOrError2 = Wrappers_Compile.Result<Dafny.ISequence<BigInteger>, Dafny.ISequence<char>>.Default(Dafny.Sequence<BigInteger>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<BigInteger>, Dafny.ISequence<char>> _out378;
      _out378 = (_22013_reader).ReadExact(new BigInteger(2));
      _22017_valueOrError2 = _out378;
      if (!(!((_22017_valueOrError2).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/Streams.dfy(35,8): " + _22017_valueOrError2);
      }
      _22014_res = (_22017_valueOrError2).Extract();
      if (!((Dafny.Sequence<BigInteger>.FromElements(new BigInteger(300), new BigInteger(400))).Equals((_22014_res)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/Streams.dfy(36,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      Wrappers_Compile.Result<Dafny.ISequence<BigInteger>, Dafny.ISequence<char>> _22018_isFailure;
      Wrappers_Compile.Result<Dafny.ISequence<BigInteger>, Dafny.ISequence<char>> _out379;
      _out379 = (_22013_reader).ReadExact(BigInteger.One);
      _22018_isFailure = _out379;
      if (!((_22018_isFailure).is_Failure)) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/Streams.dfy(39,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestByteReader()
    {
      Dafny.ISequence<byte> _22019_s;
      _22019_s = Dafny.Sequence<byte>.FromElements(0, 3, 10, 20, 50, 100, 150, 200, 250, 255);
      Streams_Compile.ByteReader _22020_reader;
      Streams_Compile.ByteReader _nw103 = new Streams_Compile.ByteReader();
      _nw103.__ctor(_22019_s);
      _22020_reader = _nw103;
      byte _22021_uint8Res = 0;
      Wrappers_Compile.Result<byte, Dafny.ISequence<char>> _22022_valueOrError0 = Wrappers_Compile.Result<byte, Dafny.ISequence<char>>.Default(0);
      Wrappers_Compile.Result<byte, Dafny.ISequence<char>> _out380;
      _out380 = (_22020_reader).ReadByte();
      _22022_valueOrError0 = _out380;
      if (!(!((_22022_valueOrError0).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/Streams.dfy(46,17): " + _22022_valueOrError0);
      }
      _22021_uint8Res = (_22022_valueOrError0).Extract();
      BigInteger _22023_sizeRead;
      BigInteger _out381;
      _out381 = (_22020_reader).GetSizeRead();
      _22023_sizeRead = _out381;
      bool _22024_isDoneReading;
      bool _out382;
      _out382 = (_22020_reader).IsDoneReading();
      _22024_isDoneReading = _out382;
      if (!((0) == (_22021_uint8Res))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/Streams.dfy(49,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!((BigInteger.One) == (_22023_sizeRead))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/Streams.dfy(50,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!(!(_22024_isDoneReading))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/Streams.dfy(51,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      Dafny.ISequence<byte> _22025_sRes = Dafny.Sequence<byte>.Empty;
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _22026_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out383;
      _out383 = (_22020_reader).ReadBytes(BigInteger.Zero);
      _22026_valueOrError1 = _out383;
      if (!(!((_22026_valueOrError1).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/Streams.dfy(53,13): " + _22026_valueOrError1);
      }
      _22025_sRes = (_22026_valueOrError1).Extract();
      BigInteger _out384;
      _out384 = (_22020_reader).GetSizeRead();
      _22023_sizeRead = _out384;
      bool _out385;
      _out385 = (_22020_reader).IsDoneReading();
      _22024_isDoneReading = _out385;
      if (!((Dafny.Sequence<byte>.FromElements()).Equals((_22025_sRes)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/Streams.dfy(56,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!((BigInteger.One) == (_22023_sizeRead))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/Streams.dfy(57,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!(!(_22024_isDoneReading))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/Streams.dfy(58,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _22027_valueOrError2 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(Dafny.Sequence<byte>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out386;
      _out386 = (_22020_reader).ReadBytes(new BigInteger(3));
      _22027_valueOrError2 = _out386;
      if (!(!((_22027_valueOrError2).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/Streams.dfy(60,9): " + _22027_valueOrError2);
      }
      _22025_sRes = (_22027_valueOrError2).Extract();
      BigInteger _out387;
      _out387 = (_22020_reader).GetSizeRead();
      _22023_sizeRead = _out387;
      bool _out388;
      _out388 = (_22020_reader).IsDoneReading();
      _22024_isDoneReading = _out388;
      if (!((Dafny.Sequence<byte>.FromElements(3, 10, 20)).Equals((_22025_sRes)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/Streams.dfy(63,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!((new BigInteger(4)) == (_22023_sizeRead))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/Streams.dfy(64,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!(!(_22024_isDoneReading))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/Streams.dfy(65,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      ushort _22028_uint16 = 0;
      Wrappers_Compile.Result<ushort, Dafny.ISequence<char>> _22029_valueOrError3 = Wrappers_Compile.Result<ushort, Dafny.ISequence<char>>.Default(0);
      Wrappers_Compile.Result<ushort, Dafny.ISequence<char>> _out389;
      _out389 = (_22020_reader).ReadUInt16();
      _22029_valueOrError3 = _out389;
      if (!(!((_22029_valueOrError3).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/Streams.dfy(67,15): " + _22029_valueOrError3);
      }
      _22028_uint16 = (_22029_valueOrError3).Extract();
      ushort _22030_expectedUint16;
      _22030_expectedUint16 = StandardLibrary_mUInt_Compile.__default.SeqToUInt16(Dafny.Sequence<byte>.FromElements(50, 100));
      BigInteger _out390;
      _out390 = (_22020_reader).GetSizeRead();
      _22023_sizeRead = _out390;
      bool _out391;
      _out391 = (_22020_reader).IsDoneReading();
      _22024_isDoneReading = _out391;
      if (!((_22030_expectedUint16) == (_22028_uint16))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/Streams.dfy(71,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!((new BigInteger(6)) == (_22023_sizeRead))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/Streams.dfy(72,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!(!(_22024_isDoneReading))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/Streams.dfy(73,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      uint _22031_uint32 = 0;
      Wrappers_Compile.Result<uint, Dafny.ISequence<char>> _22032_valueOrError4 = Wrappers_Compile.Result<uint, Dafny.ISequence<char>>.Default(0);
      Wrappers_Compile.Result<uint, Dafny.ISequence<char>> _out392;
      _out392 = (_22020_reader).ReadUInt32();
      _22032_valueOrError4 = _out392;
      if (!(!((_22032_valueOrError4).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/Streams.dfy(75,15): " + _22032_valueOrError4);
      }
      _22031_uint32 = (_22032_valueOrError4).Extract();
      uint _22033_expectedUint32;
      _22033_expectedUint32 = StandardLibrary_mUInt_Compile.__default.SeqToUInt32(Dafny.Sequence<byte>.FromElements(150, 200, 250, 255));
      BigInteger _out393;
      _out393 = (_22020_reader).GetSizeRead();
      _22023_sizeRead = _out393;
      bool _out394;
      _out394 = (_22020_reader).IsDoneReading();
      _22024_isDoneReading = _out394;
      if (!((_22033_expectedUint32) == (_22031_uint32))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/Streams.dfy(79,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!((new BigInteger(10)) == (_22023_sizeRead))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/Streams.dfy(80,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!(_22024_isDoneReading)) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/Streams.dfy(81,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      Wrappers_Compile.Result<byte, Dafny.ISequence<char>> _22034_isByteFailure;
      Wrappers_Compile.Result<byte, Dafny.ISequence<char>> _out395;
      _out395 = (_22020_reader).ReadByte();
      _22034_isByteFailure = _out395;
      BigInteger _out396;
      _out396 = (_22020_reader).GetSizeRead();
      _22023_sizeRead = _out396;
      bool _out397;
      _out397 = (_22020_reader).IsDoneReading();
      _22024_isDoneReading = _out397;
      if (!((_22034_isByteFailure).is_Failure)) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/Streams.dfy(86,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!((new BigInteger(10)) == (_22023_sizeRead))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/Streams.dfy(87,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!(_22024_isDoneReading)) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/Streams.dfy(88,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _22035_isBytesFailure;
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out398;
      _out398 = (_22020_reader).ReadBytes(BigInteger.One);
      _22035_isBytesFailure = _out398;
      BigInteger _out399;
      _out399 = (_22020_reader).GetSizeRead();
      _22023_sizeRead = _out399;
      bool _out400;
      _out400 = (_22020_reader).IsDoneReading();
      _22024_isDoneReading = _out400;
      if (!((_22035_isBytesFailure).is_Failure)) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/Streams.dfy(93,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!((new BigInteger(10)) == (_22023_sizeRead))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/Streams.dfy(94,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!(_22024_isDoneReading)) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/Streams.dfy(95,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      Wrappers_Compile.Result<ushort, Dafny.ISequence<char>> _22036_isUint16Failure;
      Wrappers_Compile.Result<ushort, Dafny.ISequence<char>> _out401;
      _out401 = (_22020_reader).ReadUInt16();
      _22036_isUint16Failure = _out401;
      BigInteger _out402;
      _out402 = (_22020_reader).GetSizeRead();
      _22023_sizeRead = _out402;
      bool _out403;
      _out403 = (_22020_reader).IsDoneReading();
      _22024_isDoneReading = _out403;
      if (!((_22036_isUint16Failure).is_Failure)) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/Streams.dfy(100,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!((new BigInteger(10)) == (_22023_sizeRead))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/Streams.dfy(101,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!(_22024_isDoneReading)) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/Streams.dfy(102,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      Wrappers_Compile.Result<uint, Dafny.ISequence<char>> _22037_isUint32Failure;
      Wrappers_Compile.Result<uint, Dafny.ISequence<char>> _out404;
      _out404 = (_22020_reader).ReadUInt32();
      _22037_isUint32Failure = _out404;
      BigInteger _out405;
      _out405 = (_22020_reader).GetSizeRead();
      _22023_sizeRead = _out405;
      bool _out406;
      _out406 = (_22020_reader).IsDoneReading();
      _22024_isDoneReading = _out406;
      if (!((_22037_isUint32Failure).is_Failure)) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/Streams.dfy(107,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!((new BigInteger(10)) == (_22023_sizeRead))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/Streams.dfy(108,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!(_22024_isDoneReading)) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/Streams.dfy(109,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestSeqWriter()
    {
      Streams_Compile.SeqWriter<BigInteger> _22038_writer;
      Streams_Compile.SeqWriter<BigInteger> _nw104 = new Streams_Compile.SeqWriter<BigInteger>();
      _nw104.__ctor();
      _22038_writer = _nw104;
      if (!((Dafny.Sequence<BigInteger>.FromElements()).Equals((_22038_writer.data)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/Streams.dfy(114,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      BigInteger _22039_elemSize;
      BigInteger _out407;
      _out407 = (_22038_writer).WriteElements(Dafny.Sequence<BigInteger>.FromElements());
      _22039_elemSize = _out407;
      if (!((_22039_elemSize).Sign == 0)) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/Streams.dfy(117,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!((Dafny.Sequence<BigInteger>.FromElements()).Equals((_22038_writer.data)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/Streams.dfy(118,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      BigInteger _out408;
      _out408 = (_22038_writer).WriteElements(Dafny.Sequence<BigInteger>.FromElements(BigInteger.Zero, new BigInteger(100), new BigInteger(200)));
      _22039_elemSize = _out408;
      if (!((new BigInteger(3)) == (_22039_elemSize))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/Streams.dfy(121,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!((Dafny.Sequence<BigInteger>.FromElements(BigInteger.Zero, new BigInteger(100), new BigInteger(200))).Equals((_22038_writer.data)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/Streams.dfy(122,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      BigInteger _out409;
      _out409 = (_22038_writer).WriteElements(Dafny.Sequence<BigInteger>.FromElements(new BigInteger(300), new BigInteger(400), new BigInteger(500), new BigInteger(600)));
      _22039_elemSize = _out409;
      if (!((new BigInteger(4)) == (_22039_elemSize))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/Streams.dfy(125,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!((Dafny.Sequence<BigInteger>.FromElements(BigInteger.Zero, new BigInteger(100), new BigInteger(200), new BigInteger(300), new BigInteger(400), new BigInteger(500), new BigInteger(600))).Equals((_22038_writer.data)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/Streams.dfy(126,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestByteWriter()
    {
      Streams_Compile.ByteWriter _22040_writer;
      Streams_Compile.ByteWriter _nw105 = new Streams_Compile.ByteWriter();
      _nw105.__ctor();
      _22040_writer = _nw105;
      Dafny.ISequence<byte> _22041_dataWritten;
      _22041_dataWritten = (_22040_writer).GetDataWritten();
      if (!((Dafny.Sequence<byte>.FromElements()).Equals((_22041_dataWritten)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/Streams.dfy(132,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      BigInteger _22042_sizeWritten;
      _22042_sizeWritten = (_22040_writer).GetSizeWritten();
      if (!((_22042_sizeWritten).Sign == 0)) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/Streams.dfy(134,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      BigInteger _22043_res;
      BigInteger _out410;
      _out410 = (_22040_writer).WriteByte(0);
      _22043_res = _out410;
      if (!((BigInteger.One) == (_22043_res))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/Streams.dfy(137,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      _22041_dataWritten = (_22040_writer).GetDataWritten();
      if (!((Dafny.Sequence<byte>.FromElements(0)).Equals((_22041_dataWritten)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/Streams.dfy(139,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      _22042_sizeWritten = (_22040_writer).GetSizeWritten();
      if (!((BigInteger.One) == (_22042_sizeWritten))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/Streams.dfy(141,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      BigInteger _out411;
      _out411 = (_22040_writer).WriteBytes(Dafny.Sequence<byte>.FromElements());
      _22043_res = _out411;
      if (!((_22043_res).Sign == 0)) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/Streams.dfy(144,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      _22041_dataWritten = (_22040_writer).GetDataWritten();
      if (!((Dafny.Sequence<byte>.FromElements(0)).Equals((_22041_dataWritten)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/Streams.dfy(146,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      _22042_sizeWritten = (_22040_writer).GetSizeWritten();
      if (!((BigInteger.One) == (_22042_sizeWritten))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/Streams.dfy(148,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      BigInteger _out412;
      _out412 = (_22040_writer).WriteBytes(Dafny.Sequence<byte>.FromElements(5, 50, 100));
      _22043_res = _out412;
      if (!((new BigInteger(3)) == (_22043_res))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/Streams.dfy(151,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      _22041_dataWritten = (_22040_writer).GetDataWritten();
      if (!((Dafny.Sequence<byte>.FromElements(0, 5, 50, 100)).Equals((_22041_dataWritten)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/Streams.dfy(153,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      _22042_sizeWritten = (_22040_writer).GetSizeWritten();
      if (!((new BigInteger(4)) == (_22042_sizeWritten))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/Streams.dfy(155,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      ushort _22044_uint16Written;
      _22044_uint16Written = StandardLibrary_mUInt_Compile.__default.SeqToUInt16(Dafny.Sequence<byte>.FromElements(150, 200));
      BigInteger _out413;
      _out413 = (_22040_writer).WriteUInt16(_22044_uint16Written);
      _22043_res = _out413;
      if (!((new BigInteger(2)) == (_22043_res))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/Streams.dfy(159,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      _22041_dataWritten = (_22040_writer).GetDataWritten();
      if (!((Dafny.Sequence<byte>.FromElements(0, 5, 50, 100, 150, 200)).Equals((_22041_dataWritten)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/Streams.dfy(161,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      _22042_sizeWritten = (_22040_writer).GetSizeWritten();
      if (!((new BigInteger(6)) == (_22042_sizeWritten))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/Streams.dfy(163,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      uint _22045_uint32Written;
      _22045_uint32Written = StandardLibrary_mUInt_Compile.__default.SeqToUInt32(Dafny.Sequence<byte>.FromElements(50, 150, 200, 255));
      BigInteger _out414;
      _out414 = (_22040_writer).WriteUInt32(_22045_uint32Written);
      _22043_res = _out414;
      if (!((new BigInteger(4)) == (_22043_res))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/Streams.dfy(167,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      _22041_dataWritten = (_22040_writer).GetDataWritten();
      if (!((Dafny.Sequence<byte>.FromElements(0, 5, 50, 100, 150, 200, 50, 150, 200, 255)).Equals((_22041_dataWritten)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/Streams.dfy(169,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      _22042_sizeWritten = (_22040_writer).GetSizeWritten();
      if (!((new BigInteger(10)) == (_22042_sizeWritten))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/Streams.dfy(171,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
  }
} // end of namespace TestStreams_Compile
namespace TestUTF8_Compile {



  public partial class __default {
    [Xunit.Fact]
    public static void TestEncodeHappyCase()
    {
      Dafny.ISequence<char> _22046_unicodeString;
      _22046_unicodeString = Dafny.Sequence<char>.FromString("abc\u0306\u01FD\u03B2");
      Dafny.ISequence<byte> _22047_expectedBytes;
      _22047_expectedBytes = Dafny.Sequence<byte>.FromElements(97, 98, 99, 204, 134, 199, 189, 206, 178);
      Dafny.ISequence<byte> _22048_encoded = UTF8.ValidUTF8Bytes.Default();
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _22049_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out415;
      _out415 = UTF8.__default.Encode(_22046_unicodeString);
      _22049_valueOrError0 = _out415;
      if (!(!((_22049_valueOrError0).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(14,16): " + _22049_valueOrError0);
      }
      _22048_encoded = (_22049_valueOrError0).Extract();
      if (!((_22047_expectedBytes).Equals((_22048_encoded)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(15,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestEncodeInvalidUnicode()
    {
      Dafny.ISequence<char> _22050_invalidUnicode;
      _22050_invalidUnicode = Dafny.Sequence<char>.FromString("abc\uD800");
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _22051_encoded;
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out416;
      _out416 = UTF8.__default.Encode(_22050_invalidUnicode);
      _22051_encoded = _out416;
      if (!((_22051_encoded).is_Failure)) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(22,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestDecodeHappyCase()
    {
      Dafny.ISequence<byte> _22052_unicodeBytes;
      _22052_unicodeBytes = Dafny.Sequence<byte>.FromElements(97, 98, 99, 204, 134, 199, 189, 206, 178);
      Dafny.ISequence<char> _22053_expectedString;
      _22053_expectedString = Dafny.Sequence<char>.FromString("abc\u0306\u01FD\u03B2");
      Dafny.ISequence<char> _22054_decoded = Dafny.Sequence<char>.Empty;
      Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>> _22055_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.Default(Dafny.Sequence<char>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>> _out417;
      _out417 = UTF8.__default.Decode(_22052_unicodeBytes);
      _22055_valueOrError0 = _out417;
      if (!(!((_22055_valueOrError0).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(30,16): " + _22055_valueOrError0);
      }
      _22054_decoded = (_22055_valueOrError0).Extract();
      if (!((_22053_expectedString).Equals((_22054_decoded)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(31,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void TestDecodeInvalidUnicode()
    {
      Dafny.ISequence<byte> _22056_invalidUnicode;
      _22056_invalidUnicode = Dafny.Sequence<byte>.FromElements(97, 98, 99, 237, 160, 128);
      if (!(!(UTF8.__default.ValidUTF8Seq(_22056_invalidUnicode)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(37,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void Test1Byte()
    {
      Dafny.ISequence<char> _22057_decoded;
      _22057_decoded = Dafny.Sequence<char>.FromString("\u0000");
      Dafny.ISequence<byte> _22058_encoded = UTF8.ValidUTF8Bytes.Default();
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _22059_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out418;
      _out418 = UTF8.__default.Encode(_22057_decoded);
      _22059_valueOrError0 = _out418;
      if (!(!((_22059_valueOrError0).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(43,16): " + _22059_valueOrError0);
      }
      _22058_encoded = (_22059_valueOrError0).Extract();
      if (!((Dafny.Sequence<byte>.FromElements(0)).Equals((_22058_encoded)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(44,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!(UTF8.__default.Uses1Byte(_22058_encoded))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(45,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      Dafny.ISequence<char> _22060_redecoded = Dafny.Sequence<char>.Empty;
      Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>> _22061_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.Default(Dafny.Sequence<char>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>> _out419;
      _out419 = UTF8.__default.Decode(_22058_encoded);
      _22061_valueOrError1 = _out419;
      if (!(!((_22061_valueOrError1).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(46,18): " + _22061_valueOrError1);
      }
      _22060_redecoded = (_22061_valueOrError1).Extract();
      if (!((_22057_decoded).Equals((_22060_redecoded)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(47,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      _22057_decoded = Dafny.Sequence<char>.FromString("\u0020");
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _22062_valueOrError2 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out420;
      _out420 = UTF8.__default.Encode(_22057_decoded);
      _22062_valueOrError2 = _out420;
      if (!(!((_22062_valueOrError2).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(51,12): " + _22062_valueOrError2);
      }
      _22058_encoded = (_22062_valueOrError2).Extract();
      if (!((Dafny.Sequence<byte>.FromElements(32)).Equals((_22058_encoded)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(52,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!(UTF8.__default.Uses1Byte(_22058_encoded))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(53,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>> _22063_valueOrError3 = Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.Default(Dafny.Sequence<char>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>> _out421;
      _out421 = UTF8.__default.Decode(_22058_encoded);
      _22063_valueOrError3 = _out421;
      if (!(!((_22063_valueOrError3).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(54,14): " + _22063_valueOrError3);
      }
      _22060_redecoded = (_22063_valueOrError3).Extract();
      if (!((_22057_decoded).Equals((_22060_redecoded)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(55,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      _22057_decoded = Dafny.Sequence<char>.FromString("$");
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _22064_valueOrError4 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out422;
      _out422 = UTF8.__default.Encode(_22057_decoded);
      _22064_valueOrError4 = _out422;
      if (!(!((_22064_valueOrError4).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(58,12): " + _22064_valueOrError4);
      }
      _22058_encoded = (_22064_valueOrError4).Extract();
      if (!((Dafny.Sequence<byte>.FromElements(36)).Equals((_22058_encoded)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(59,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!(UTF8.__default.Uses1Byte(_22058_encoded))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(60,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>> _22065_valueOrError5 = Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.Default(Dafny.Sequence<char>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>> _out423;
      _out423 = UTF8.__default.Decode(_22058_encoded);
      _22065_valueOrError5 = _out423;
      if (!(!((_22065_valueOrError5).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(61,14): " + _22065_valueOrError5);
      }
      _22060_redecoded = (_22065_valueOrError5).Extract();
      if (!((_22057_decoded).Equals((_22060_redecoded)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(62,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      _22057_decoded = Dafny.Sequence<char>.FromString("0");
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _22066_valueOrError6 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out424;
      _out424 = UTF8.__default.Encode(_22057_decoded);
      _22066_valueOrError6 = _out424;
      if (!(!((_22066_valueOrError6).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(65,12): " + _22066_valueOrError6);
      }
      _22058_encoded = (_22066_valueOrError6).Extract();
      if (!((Dafny.Sequence<byte>.FromElements(48)).Equals((_22058_encoded)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(66,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!(UTF8.__default.Uses1Byte(_22058_encoded))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(67,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>> _22067_valueOrError7 = Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.Default(Dafny.Sequence<char>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>> _out425;
      _out425 = UTF8.__default.Decode(_22058_encoded);
      _22067_valueOrError7 = _out425;
      if (!(!((_22067_valueOrError7).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(68,14): " + _22067_valueOrError7);
      }
      _22060_redecoded = (_22067_valueOrError7).Extract();
      if (!((_22057_decoded).Equals((_22060_redecoded)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(69,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      _22057_decoded = Dafny.Sequence<char>.FromString("A");
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _22068_valueOrError8 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out426;
      _out426 = UTF8.__default.Encode(_22057_decoded);
      _22068_valueOrError8 = _out426;
      if (!(!((_22068_valueOrError8).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(72,12): " + _22068_valueOrError8);
      }
      _22058_encoded = (_22068_valueOrError8).Extract();
      if (!((Dafny.Sequence<byte>.FromElements(65)).Equals((_22058_encoded)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(73,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!(UTF8.__default.Uses1Byte(_22058_encoded))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(74,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>> _22069_valueOrError9 = Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.Default(Dafny.Sequence<char>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>> _out427;
      _out427 = UTF8.__default.Decode(_22058_encoded);
      _22069_valueOrError9 = _out427;
      if (!(!((_22069_valueOrError9).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(75,14): " + _22069_valueOrError9);
      }
      _22060_redecoded = (_22069_valueOrError9).Extract();
      if (!((_22057_decoded).Equals((_22060_redecoded)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(76,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      _22057_decoded = Dafny.Sequence<char>.FromString("a");
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _22070_valueOrError10 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out428;
      _out428 = UTF8.__default.Encode(_22057_decoded);
      _22070_valueOrError10 = _out428;
      if (!(!((_22070_valueOrError10).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(79,12): " + _22070_valueOrError10);
      }
      _22058_encoded = (_22070_valueOrError10).Extract();
      if (!((Dafny.Sequence<byte>.FromElements(97)).Equals((_22058_encoded)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(80,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!(UTF8.__default.Uses1Byte(_22058_encoded))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(81,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>> _22071_valueOrError11 = Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.Default(Dafny.Sequence<char>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>> _out429;
      _out429 = UTF8.__default.Decode(_22058_encoded);
      _22071_valueOrError11 = _out429;
      if (!(!((_22071_valueOrError11).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(82,14): " + _22071_valueOrError11);
      }
      _22060_redecoded = (_22071_valueOrError11).Extract();
      if (!((_22057_decoded).Equals((_22060_redecoded)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(83,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void Test2Bytes()
    {
      Dafny.ISequence<char> _22072_decoded;
      _22072_decoded = Dafny.Sequence<char>.FromString("\u00A3");
      Dafny.ISequence<byte> _22073_encoded = UTF8.ValidUTF8Bytes.Default();
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _22074_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out430;
      _out430 = UTF8.__default.Encode(_22072_decoded);
      _22074_valueOrError0 = _out430;
      if (!(!((_22074_valueOrError0).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(89,16): " + _22074_valueOrError0);
      }
      _22073_encoded = (_22074_valueOrError0).Extract();
      if (!((Dafny.Sequence<byte>.FromElements(194, 163)).Equals((_22073_encoded)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(90,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!(UTF8.__default.Uses2Bytes(_22073_encoded))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(91,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      Dafny.ISequence<char> _22075_redecoded = Dafny.Sequence<char>.Empty;
      Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>> _22076_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.Default(Dafny.Sequence<char>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>> _out431;
      _out431 = UTF8.__default.Decode(_22073_encoded);
      _22076_valueOrError1 = _out431;
      if (!(!((_22076_valueOrError1).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(92,18): " + _22076_valueOrError1);
      }
      _22075_redecoded = (_22076_valueOrError1).Extract();
      if (!((_22072_decoded).Equals((_22075_redecoded)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(93,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      _22072_decoded = Dafny.Sequence<char>.FromString("\u00A9");
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _22077_valueOrError2 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out432;
      _out432 = UTF8.__default.Encode(_22072_decoded);
      _22077_valueOrError2 = _out432;
      if (!(!((_22077_valueOrError2).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(97,12): " + _22077_valueOrError2);
      }
      _22073_encoded = (_22077_valueOrError2).Extract();
      if (!((Dafny.Sequence<byte>.FromElements(194, 169)).Equals((_22073_encoded)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(98,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!(UTF8.__default.Uses2Bytes(_22073_encoded))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(99,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>> _22078_valueOrError3 = Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.Default(Dafny.Sequence<char>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>> _out433;
      _out433 = UTF8.__default.Decode(_22073_encoded);
      _22078_valueOrError3 = _out433;
      if (!(!((_22078_valueOrError3).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(100,14): " + _22078_valueOrError3);
      }
      _22075_redecoded = (_22078_valueOrError3).Extract();
      if (!((_22072_decoded).Equals((_22075_redecoded)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(101,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      _22072_decoded = Dafny.Sequence<char>.FromString("\u00AE");
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _22079_valueOrError4 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out434;
      _out434 = UTF8.__default.Encode(_22072_decoded);
      _22079_valueOrError4 = _out434;
      if (!(!((_22079_valueOrError4).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(105,12): " + _22079_valueOrError4);
      }
      _22073_encoded = (_22079_valueOrError4).Extract();
      if (!((Dafny.Sequence<byte>.FromElements(194, 174)).Equals((_22073_encoded)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(106,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!(UTF8.__default.Uses2Bytes(_22073_encoded))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(107,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>> _22080_valueOrError5 = Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.Default(Dafny.Sequence<char>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>> _out435;
      _out435 = UTF8.__default.Decode(_22073_encoded);
      _22080_valueOrError5 = _out435;
      if (!(!((_22080_valueOrError5).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(108,14): " + _22080_valueOrError5);
      }
      _22075_redecoded = (_22080_valueOrError5).Extract();
      if (!((_22072_decoded).Equals((_22075_redecoded)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(109,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      _22072_decoded = Dafny.Sequence<char>.FromString("\u03C0");
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _22081_valueOrError6 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out436;
      _out436 = UTF8.__default.Encode(_22072_decoded);
      _22081_valueOrError6 = _out436;
      if (!(!((_22081_valueOrError6).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(113,12): " + _22081_valueOrError6);
      }
      _22073_encoded = (_22081_valueOrError6).Extract();
      if (!((Dafny.Sequence<byte>.FromElements(207, 128)).Equals((_22073_encoded)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(114,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!(UTF8.__default.Uses2Bytes(_22073_encoded))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(115,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>> _22082_valueOrError7 = Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.Default(Dafny.Sequence<char>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>> _out437;
      _out437 = UTF8.__default.Decode(_22073_encoded);
      _22082_valueOrError7 = _out437;
      if (!(!((_22082_valueOrError7).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(116,14): " + _22082_valueOrError7);
      }
      _22075_redecoded = (_22082_valueOrError7).Extract();
      if (!((_22072_decoded).Equals((_22075_redecoded)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(117,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void Test3Bytes()
    {
      Dafny.ISequence<char> _22083_decoded;
      _22083_decoded = Dafny.Sequence<char>.FromString("\u2386");
      Dafny.ISequence<byte> _22084_encoded = UTF8.ValidUTF8Bytes.Default();
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _22085_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out438;
      _out438 = UTF8.__default.Encode(_22083_decoded);
      _22085_valueOrError0 = _out438;
      if (!(!((_22085_valueOrError0).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(123,16): " + _22085_valueOrError0);
      }
      _22084_encoded = (_22085_valueOrError0).Extract();
      if (!((Dafny.Sequence<byte>.FromElements(226, 142, 134)).Equals((_22084_encoded)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(124,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!(UTF8.__default.Uses3Bytes(_22084_encoded))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(125,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      Dafny.ISequence<char> _22086_redecoded = Dafny.Sequence<char>.Empty;
      Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>> _22087_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.Default(Dafny.Sequence<char>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>> _out439;
      _out439 = UTF8.__default.Decode(_22084_encoded);
      _22087_valueOrError1 = _out439;
      if (!(!((_22087_valueOrError1).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(126,18): " + _22087_valueOrError1);
      }
      _22086_redecoded = (_22087_valueOrError1).Extract();
      if (!((_22083_decoded).Equals((_22086_redecoded)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(127,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      _22083_decoded = Dafny.Sequence<char>.FromString("\u2387");
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _22088_valueOrError2 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out440;
      _out440 = UTF8.__default.Encode(_22083_decoded);
      _22088_valueOrError2 = _out440;
      if (!(!((_22088_valueOrError2).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(131,12): " + _22088_valueOrError2);
      }
      _22084_encoded = (_22088_valueOrError2).Extract();
      if (!((Dafny.Sequence<byte>.FromElements(226, 142, 135)).Equals((_22084_encoded)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(132,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!(UTF8.__default.Uses3Bytes(_22084_encoded))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(133,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>> _22089_valueOrError3 = Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.Default(Dafny.Sequence<char>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>> _out441;
      _out441 = UTF8.__default.Decode(_22084_encoded);
      _22089_valueOrError3 = _out441;
      if (!(!((_22089_valueOrError3).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(134,14): " + _22089_valueOrError3);
      }
      _22086_redecoded = (_22089_valueOrError3).Extract();
      if (!((_22083_decoded).Equals((_22086_redecoded)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(135,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      _22083_decoded = Dafny.Sequence<char>.FromString("\u231B");
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _22090_valueOrError4 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out442;
      _out442 = UTF8.__default.Encode(_22083_decoded);
      _22090_valueOrError4 = _out442;
      if (!(!((_22090_valueOrError4).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(139,12): " + _22090_valueOrError4);
      }
      _22084_encoded = (_22090_valueOrError4).Extract();
      if (!((Dafny.Sequence<byte>.FromElements(226, 140, 155)).Equals((_22084_encoded)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(140,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!(UTF8.__default.Uses3Bytes(_22084_encoded))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(141,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>> _22091_valueOrError5 = Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.Default(Dafny.Sequence<char>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>> _out443;
      _out443 = UTF8.__default.Decode(_22084_encoded);
      _22091_valueOrError5 = _out443;
      if (!(!((_22091_valueOrError5).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(142,14): " + _22091_valueOrError5);
      }
      _22086_redecoded = (_22091_valueOrError5).Extract();
      if (!((_22083_decoded).Equals((_22086_redecoded)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(143,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      _22083_decoded = Dafny.Sequence<char>.FromString("\u1D78");
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _22092_valueOrError6 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out444;
      _out444 = UTF8.__default.Encode(_22083_decoded);
      _22092_valueOrError6 = _out444;
      if (!(!((_22092_valueOrError6).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(147,12): " + _22092_valueOrError6);
      }
      _22084_encoded = (_22092_valueOrError6).Extract();
      if (!((Dafny.Sequence<byte>.FromElements(225, 181, 184)).Equals((_22084_encoded)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(148,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!(UTF8.__default.Uses3Bytes(_22084_encoded))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(149,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>> _22093_valueOrError7 = Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.Default(Dafny.Sequence<char>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>> _out445;
      _out445 = UTF8.__default.Decode(_22084_encoded);
      _22093_valueOrError7 = _out445;
      if (!(!((_22093_valueOrError7).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(150,14): " + _22093_valueOrError7);
      }
      _22086_redecoded = (_22093_valueOrError7).Extract();
      if (!((_22083_decoded).Equals((_22086_redecoded)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(151,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      _22083_decoded = Dafny.Sequence<char>.FromString("\u732B");
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _22094_valueOrError8 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out446;
      _out446 = UTF8.__default.Encode(_22083_decoded);
      _22094_valueOrError8 = _out446;
      if (!(!((_22094_valueOrError8).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(155,12): " + _22094_valueOrError8);
      }
      _22084_encoded = (_22094_valueOrError8).Extract();
      if (!((Dafny.Sequence<byte>.FromElements(231, 140, 171)).Equals((_22084_encoded)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(156,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!(UTF8.__default.Uses3Bytes(_22084_encoded))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(157,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>> _22095_valueOrError9 = Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.Default(Dafny.Sequence<char>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>> _out447;
      _out447 = UTF8.__default.Decode(_22084_encoded);
      _22095_valueOrError9 = _out447;
      if (!(!((_22095_valueOrError9).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(158,14): " + _22095_valueOrError9);
      }
      _22086_redecoded = (_22095_valueOrError9).Extract();
      if (!((_22083_decoded).Equals((_22086_redecoded)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(159,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
    [Xunit.Fact]
    public static void Test4Bytes()
    {
      Dafny.ISequence<char> _22096_decoded;
      _22096_decoded = Dafny.Sequence<char>.FromString("\uD808\uDC00");
      Dafny.ISequence<byte> _22097_encoded = UTF8.ValidUTF8Bytes.Default();
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _22098_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out448;
      _out448 = UTF8.__default.Encode(_22096_decoded);
      _22098_valueOrError0 = _out448;
      if (!(!((_22098_valueOrError0).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(165,16): " + _22098_valueOrError0);
      }
      _22097_encoded = (_22098_valueOrError0).Extract();
      if (!((Dafny.Sequence<byte>.FromElements(240, 146, 128, 128)).Equals((_22097_encoded)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(166,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!(UTF8.__default.Uses4Bytes(_22097_encoded))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(167,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      Dafny.ISequence<char> _22099_redecoded = Dafny.Sequence<char>.Empty;
      Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>> _22100_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.Default(Dafny.Sequence<char>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>> _out449;
      _out449 = UTF8.__default.Decode(_22097_encoded);
      _22100_valueOrError1 = _out449;
      if (!(!((_22100_valueOrError1).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(168,18): " + _22100_valueOrError1);
      }
      _22099_redecoded = (_22100_valueOrError1).Extract();
      if (!((_22096_decoded).Equals((_22099_redecoded)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(169,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      _22096_decoded = Dafny.Sequence<char>.FromString("\uD835\uDFC1");
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _22101_valueOrError2 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.Default(UTF8.ValidUTF8Bytes.Default());
      Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>> _out450;
      _out450 = UTF8.__default.Encode(_22096_decoded);
      _22101_valueOrError2 = _out450;
      if (!(!((_22101_valueOrError2).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(173,12): " + _22101_valueOrError2);
      }
      _22097_encoded = (_22101_valueOrError2).Extract();
      if (!((Dafny.Sequence<byte>.FromElements(240, 157, 159, 129)).Equals((_22097_encoded)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(174,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      if (!(UTF8.__default.Uses4Bytes(_22097_encoded))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(175,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
      Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>> _22102_valueOrError3 = Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.Default(Dafny.Sequence<char>.Empty);
      Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>> _out451;
      _out451 = UTF8.__default.Decode(_22097_encoded);
      _22102_valueOrError3 = _out451;
      if (!(!((_22102_valueOrError3).IsFailure()))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(176,14): " + _22102_valueOrError3);
      }
      _22099_redecoded = (_22102_valueOrError3).Extract();
      if (!((_22096_decoded).Equals((_22099_redecoded)))) {
        throw new Dafny.HaltException("/Users/farleyb/workspace/esdk/dafny/aws-encryption-sdk-net-formally-verified/Dafny/test/Util/UTF8.dfy(177,4): " + Dafny.Sequence<char>.FromString("expectation violation"));
      }
    }
  }
} // end of namespace TestUTF8_Compile
namespace _module {



































































} // end of namespace _module
