// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

include "../../Model/AwsCryptographyMaterialProvidersTypes.dfy"
include "../Materials.dfy"

// Traits and related data types to help keyring encapsulate
// wrap/unwrap/generate logic for use with the helper methods
// in EdkWrapping.dfy.
module MaterialWrapping {
  import opened StandardLibrary
  import opened UInt = StandardLibrary.UInt
  import opened Actions
  import opened Wrappers
  import Types = AwsCryptographyMaterialProvidersTypes
  import Aws.Cryptography.Primitives
  import Materials
  import AlgorithmSuites

  datatype GenerateAndWrapInput = GenerateAndWrapInput(
    nameonly algorithmSuite: Types.AlgorithmSuiteInfo,
    nameonly encryptionContext: Types.EncryptionContext
  )

  datatype GenerateAndWrapOutput<T> = GenerateAndWrapOutput(
    nameonly plaintextMaterial: seq<uint8>,
    nameonly wrappedMaterial: seq<uint8>,
    nameonly wrapInfo: T
  )

  datatype WrapInput = WrapInput(
    nameonly plaintextMaterial: seq<uint8>,
    nameonly algorithmSuite: Types.AlgorithmSuiteInfo,
    nameonly encryptionContext: Types.EncryptionContext
  )

  datatype WrapOutput<T> = WrapOutput(
    nameonly wrappedMaterial: seq<uint8>,
    nameonly wrapInfo: T
  )

  datatype UnwrapInput = UnwrapInput(
    nameonly wrappedMaterial: seq<uint8>,
    nameonly algorithmSuite: Types.AlgorithmSuiteInfo,
    nameonly encryptionContext: Types.EncryptionContext
  )

  datatype UnwrapOutput<T> = UnwrapOutput(
    nameonly unwrappedMaterial: seq<uint8>,
    nameonly unwrapInfo: T
  )

  // There are three Actions that must be implemented in order for Keyrings to make use of
  // the helpers in EdkWrapping.dfy.
  //
  // `WrapMaterial` and `GenerateAndWrapMaterial` may be used during `WrapEdkMaterial` for the purpose
  // of creating necessary key material and performing the Keyring's method of wrapping such material.
  // Note that the material being generated by `GenerateAndWrapMaterial` may either be the plaintext data key
  // or the intermediate data key, depending on the EDK Wrapping Algorithm in use.
  // We explictly seperate `WrapMaterial` and `GenerateAndWrap` as seperate Actions because:
  //   1. The Keyring may want to utilize a specific method for generating random bytes,
  //      such as the AWS KMS Keyring via KMS::GenerateDataKey.
  //      Keyrings that do not have such optimizations SHOULD implement this by
  //      generating cryptographically secure bytes of the correct length and delegating to `WrapMaterial`
  //   2. By seperating these Actions, we can have EdkWrapping implement the logic
  //      to decide whether it is necessary to generate new material in the right contexts,
  //      as opposed to requiring each Keyring to ensure they implement the
  //      switch on the existencing of an input pdk correctly.
  //
  // `UnwrapMaterial` is used during `UnwrapEdkMaterial` for the purpose of unwrapping
  // a set of material originally wrapped by `WrapMaterial`.
  trait {:termination false} GenerateAndWrapMaterial<T>
    extends ActionWithResult<GenerateAndWrapInput, GenerateAndWrapOutput<T>, Types.Error>
  {
    method Invoke(input: GenerateAndWrapInput, ghost attemptsState: seq<ActionInvoke<GenerateAndWrapInput, Result<GenerateAndWrapOutput<T>, Types.Error>>>)
      returns (r: Result<GenerateAndWrapOutput<T>, Types.Error>)
      requires Invariant()
      modifies Modifies
      decreases Modifies
      ensures Invariant()
      ensures Ensures(input, r, attemptsState)
      ensures r.Success? ==> |r.value.plaintextMaterial| == AlgorithmSuites.GetEncryptKeyLength(input.algorithmSuite) as nat
  }

  trait {:termination false} WrapMaterial<T>
    extends ActionWithResult<WrapInput, WrapOutput<T>, Types.Error>
  {
    method Invoke(input: WrapInput, ghost attemptsState: seq<ActionInvoke<WrapInput, Result<WrapOutput<T>, Types.Error>>>)
      returns (r: Result<WrapOutput<T>, Types.Error>)
      requires Invariant()
      modifies Modifies
      decreases Modifies
      ensures Invariant()
      ensures Ensures(input, r, attemptsState)
  }

  trait {:termination false} UnwrapMaterial<T>
    extends ActionWithResult<UnwrapInput, UnwrapOutput<T>, Types.Error>
  {
    method Invoke(input: UnwrapInput, ghost attemptsState: seq<ActionInvoke<UnwrapInput, Result<UnwrapOutput<T>, Types.Error>>>)
      returns (r: Result<UnwrapOutput<T>, Types.Error>)
      requires Invariant()
      modifies Modifies
      decreases Modifies
      ensures Invariant()
      ensures Ensures(input, r, attemptsState)
      ensures r.Success? ==> |r.value.unwrappedMaterial| == AlgorithmSuites.GetEncryptKeyLength(input.algorithmSuite) as nat
  }
}
